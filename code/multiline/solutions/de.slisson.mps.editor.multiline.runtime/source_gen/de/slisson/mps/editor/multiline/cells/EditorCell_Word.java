package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.style.Style;
import com.intellij.openapi.actionSystem.DataContext;
import com.intellij.ide.DataManager;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.actionSystem.CommonDataKeys;
import de.slisson.mps.editor.multiline.runtime.plugin.MultilineSettingsPage;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.KeyMap;
import jetbrains.mps.editor.runtime.cells.KeyMapImpl;
import jetbrains.mps.openapi.editor.cells.CellAction;
import javax.swing.SwingUtilities;
import java.awt.event.KeyEvent;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;
import jetbrains.mps.nodeEditor.cells.TextLine;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import de.slisson.mps.editor.multiline.runtime.CellUtils;
import java.awt.event.MouseEvent;
import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;

public class EditorCell_Word extends EditorCell_Property {
  private static final Logger LOG_2133742043 = Logger.getLogger(EditorCell_Word.class);
  private int myWordNum;
  private int lastMLCaretPosition;
  private boolean myShiftSelectionDisabled = false;

  private boolean myDisableInsertOverride;
  private boolean myModelAccessorRequested = false;

  public EditorCell_Word(EditorContext context, ModelAccessor modelAccessor, SNode node, int wordNum) {
    super(context, modelAccessor, node);
    myWordNum = wordNum;
    setEditable(true);
    setDefaultText("");
    setSRole(new SContainmentLink() {

      /**
       * Important for {@link jetbrains.mps.nodeEditor.ChildrenCollectionFinder }#isMultipleCollectionCell
       * 
       * @deprecated 
       */
      @Deprecated
      @Override
      public boolean isMultiple() {
        return true;
      }

      @NotNull
      @Override
      public SAbstractConcept getTargetConcept() {
        throw new UnsupportedOperationException();
      }

      @NotNull
      @Override
      public String getName() {
        return "wordCellDummyRole";
      }

      @Override
      public boolean isValid() {
        throw new UnsupportedOperationException();
      }

      @Deprecated
      @Override
      public String getRole() {
        return getName();
      }

      @Override
      public boolean isOptional() {
        return true;
      }

      @NotNull
      @Override
      public SAbstractConcept getOwner() {
        throw new UnsupportedOperationException();
      }

      @Deprecated
      @Override
      public boolean isReference() {
        return false;
      }

      @Deprecated
      @Nullable
      @Override
      public SNode getDeclarationNode() {
        throw new UnsupportedOperationException();
      }

      @Deprecated
      @Override
      public String getRoleName() {
        return getName();
      }

      @Override
      public boolean isUnordered() {
        throw new UnsupportedOperationException();
      }

    });
    Style style = this.getStyle();
    DataContext dataContext = DataManager.getInstance().getDataContext((EditorComponent) context.getEditorComponent());
    Project ideaProject = dataContext.getData(CommonDataKeys.PROJECT);
    if (ideaProject != null) {
      boolean isSpellCheckerEnabled = MultilineSettingsPage.isSpellCheckingEnabledInPreferences(ideaProject);
      style.set(StyleAttributes.SPELLCHECK, isSpellCheckerEnabled);
    }

    setAction(CellActionType.INSERT, new NewLineAction(this));
    setAction(CellActionType.INSERT_BEFORE, new NewLineAction(true, this));
    setAction(CellActionType.SELECT_LEFT, new SelectLeftRightAction(true, this));
    setAction(CellActionType.SELECT_RIGHT, new SelectLeftRightAction(false, this));
    setAction(CellActionType.SELECT_UP, new SelectUpDownAction(this, true));
    setAction(CellActionType.SELECT_PREVIOUS, new SelectUpDownAction(this, true));
    setAction(CellActionType.SELECT_DOWN, new SelectUpDownAction(this, false));
    setAction(CellActionType.SELECT_NEXT, new SelectUpDownAction(this, false));
    setAction(CellActionType.PASTE, new WordPasteAction(this));
    KeyMap km = new KeyMapImpl();
    addKeyMap(km);
  }
  @Override
  public CellAction getAction(CellActionType type) {
    if (type == CellActionType.INSERT) {
      myDisableInsertOverride = true;
      SwingUtilities.invokeLater(() -> myDisableInsertOverride = false);
    }
    return super.getAction(type);
  }
  public CellAction getActionNoHacks(CellActionType type) {
    return super.getAction(type);
  }
  public void setIndentLayoutNewLine(boolean value) {
    getStyle().set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, value);
  }
  @Override
  protected boolean doProcessKeyTyped(KeyEvent event, boolean b) {
    lastMLCaretPosition = -1;
    boolean result = super.doProcessKeyTyped(event, b);
    if (lastMLCaretPosition != -1 && lastMLCaretPosition != getParent().getCaretPosition()) {
      getParent().setCaretPosition(lastMLCaretPosition);
    }
    return result;
  }
  public void setNewLine(boolean newLine) {
    setIndentLayoutNewLine(newLine);
  }
  public boolean followedByNewLine() {
    Boolean result = getStyle().get(StyleAttributes.INDENT_LAYOUT_NEW_LINE);
    result = (result == null ? false : result);
    return result;
  }
  @Override
  public String getText() {
    String text = super.getText();
    return (text == null ? "" : text);
  }
  public String getTextIncludingSeparator() {
    return getText() + ((followedByNewLine() ? "\n" : " "));
  }
  public int getTextLengthIncludingSeparator() {
    return getText().length() + 1;
  }
  @Override
  public boolean canPasteText() {
    return isEditable();
  }
  @Override
  protected boolean toShowCaret() {
    if (super.toShowCaret()) {
      return true;
    }

    // TODO: Looks like default logic should work in this case
    // Caret blinking when multiline selection is active
    Selection deepest = getEditor().getSelectionManager().getDeepestSelection();
    if (deepest instanceof EditorCellLabelSelection) {
      return ((EditorCellLabelSelection) deepest).getEditorCellLabel() == this && myCaretState.isVisible();
    }

    return false;
  }
  public TextLine getRenderedTextLine() {
    TextLine textLine;
    if (myNoTextSet && myTextLine.getText().length() == 0) {
      textLine = myNullTextLine;
    } else {
      textLine = myTextLine;
    }
    return textLine;
  }
  @Override
  public void setCaretX(int x) {
    EditorCell rightLeaf = CellTraversalUtil.getNextLeaf(this, (EditorCell cell) -> cell.isSelectable() && !(GeometryUtil.isAbove(EditorCell_Word.this, cell)) && !(GeometryUtil.isAbove(cell, EditorCell_Word.this)) && GeometryUtil.isLeftToRight(EditorCell_Word.this, cell));
    if (rightLeaf instanceof EditorCell_Word) {
      EditorCell_Word rightWord = ((EditorCell_Word) rightLeaf);
      if (rightWord.getX() - x < x - (getX() + getEffectiveWidth())) {
        getEditor().getSelectionManager().setSelection(rightWord, 0);
        return;
      }
    }
    super.setCaretX(x);
  }
  public Rectangle getCharacterBounds(int charNum) {
    if (charNum < 0 || charNum > myTextLine.getText().length()) {
      throw new IllegalArgumentException("charNum = " + charNum + ", text = " + myTextLine.getText());
    }
    int prevPos = myTextLine.getCaretPosition();
    myTextLine.setCaretPosition(charNum);
    int x1 = myTextLine.getCaretX(myX + myGapLeft);
    myTextLine.setCaretPosition(charNum + 1);
    int x2 = myTextLine.getCaretX(myX + myGapLeft);
    Rectangle rect = new Rectangle();
    rect.setBounds(x1, getY(), x2 - x1, getHeight());

    // space/newline at end of word
    if (charNum == myTextLine.getText().length()) {
      rect.width = myTextLine.getFontMetrics().charWidth(' ');
    }

    myTextLine.setCaretPosition(prevPos);
    return rect;
  }
  @Override
  public void setText(String text) {
    super.setText(text);
  }
  @Override
  public boolean executeTextAction(CellActionType type, boolean allowErrors) {
    if (type == CellActionType.BACKSPACE) {
      if (getCaretPosition() == 0) {
        if (isCursorAtMultilineStart()) {
          EditorCell prevLeaf = CellTraversalUtil.getPrevLeaf(this);
          if (prevLeaf != null) {
            if (prevLeaf instanceof EditorCell_Label) {
              EditorCell_Label labelCell = ((EditorCell_Label) prevLeaf);
              labelCell.setCaretPositionIfPossible(check_xru0dp_a0a1a0a1a0a0a0a32(labelCell.getText()));
              CellUtils.setSelection(labelCell, getContext());
              getEditor().getActionHandler().executeAction(labelCell, type);
              return true;
            }
          }
        } else {
          deletePrecedingCharacter();
          return true;
        }
        return false;
      }
    } else if (type == CellActionType.INSERT) {
      insertText("\n");
    } else if (type == CellActionType.DELETE) {
      if (getCaretPosition() == getText().length()) {
        if (isCursorAtMultilineEnd()) {
          EditorCell nextLeaf = CellTraversalUtil.getNextLeaf(this);
          if (nextLeaf != null) {
            if (nextLeaf instanceof EditorCell_Label) {
              EditorCell_Label labelCell = ((EditorCell_Label) nextLeaf);
              labelCell.setCaretPositionIfPossible(0);
              CellUtils.setSelection(labelCell, getContext());
              getEditor().getActionHandler().executeAction(labelCell, type);
              return true;
            }
          }
        } else {
          deleteFollowingCharacter();
          return true;
        }
        return false;
      }
    }
    boolean result = super.executeTextAction(type, allowErrors);
    return result;
  }
  public void deleteFollowingCharacter() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell != null) {
      int caretPos = mlCell.getCaretPosition();
      String text = mlCell.getTextAfterCaret();
      if (text.length() >= 1) {
        text = text.substring(1);
      }
      text = mlCell.getTextBeforeCaret() + text;
      mlCell.setText(text);
      mlCell.setCaretPosition(caretPos, true);
    }
  }
  public boolean isCursorAtMultilineStart() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell == null) {
      return false;
    }
    int caretPos = mlCell.getCaretPosition();
    return caretPos == 0;
  }
  public boolean isCursorAtMultilineEnd() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell == null) {
      return false;
    }
    int caretPos = mlCell.getCaretPosition();
    return caretPos == check_xru0dp_a0d0ab(mlCell.getText());
  }
  private void deletePrecedingCharacter() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell != null) {
      int caretPos = mlCell.getCaretPosition();
      if (caretPos > 0) {
        String text = mlCell.getTextBeforeCaret();
        if (text.length() > 0) {
          text = text.substring(0, text.length() - 1);
        }
        text += mlCell.getTextAfterCaret();
        mlCell.setText(text);
        mlCell.setCaretPosition(caretPos - 1, true);
      }
    }
  }
  public void deleteWord() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell != null) {
      int caretPos = mlCell.getCaretPosition();
      if (caretPos >= 0) {
        String text = "";
        boolean isBeginningOfLine = true;
        {
          String textBefore = mlCell.getTextBeforeCaret();
          int lastSpace = textBefore.lastIndexOf(" ");
          int lastNewLine = textBefore.lastIndexOf("\n");
          int lastWhiteSpace = Math.max(lastSpace, lastNewLine);
          isBeginningOfLine = lastSpace <= lastNewLine || textBefore.isEmpty();
          if (lastWhiteSpace != -1) {
            if (isBeginningOfLine) {
              text += textBefore.substring(0, lastNewLine + 1);
            } else {
              text += textBefore.substring(0, lastSpace);
            }
          }
        }

        caretPos = text.length();

        {
          String textAfter = mlCell.getTextAfterCaret();
          int firstSpace = textAfter.indexOf(" ");
          int firstNewLine = textAfter.indexOf("\n");
          int firstWhiteSpace = firstSpace;
          if (firstNewLine != -1 && firstNewLine < firstWhiteSpace) {
            firstWhiteSpace = firstNewLine;
          }
          if (firstWhiteSpace != -1) {
            if ((firstSpace < firstNewLine || firstNewLine == -1) && firstSpace != -1 && isBeginningOfLine) {
              text += textAfter.substring(firstWhiteSpace + 1);
            } else {
              text += textAfter.substring(firstWhiteSpace);
            }
          }
        }

        mlCell.setText(text);
        mlCell.setCaretPosition(caretPos, true);
      }
    }
  }
  public void insertText(String text) {
    EditorCell_Multiline mlCell = getParent();
    if (mlCell != null) {
      int newCaretPos = mlCell.getCaretPosition() + text.length();
      super.insertText(text);
      mlCell.setCaretPosition(newCaretPos);
    }
  }

  public void insertTextBefore(String text) {
    EditorCell_Multiline mlCell = getParent();
    if (mlCell != null) {
      int newCaretPos = mlCell.getCaretPosition() - text.length() + 1;
      super.insertText(text);
      mlCell.setCaretPosition(newCaretPos);
    }
  }

  @Override
  public String getCellId() {
    return check_xru0dp_a0a0a33(getParent(), this) + "_word" + myWordNum;
  }
  @Override
  public EditorCell_Multiline getParent() {
    if (myDisableInsertOverride) {
      myDisableInsertOverride = false;
      if (isInTree()) {
        return null;
      }
    }
    return (EditorCell_Multiline) super.getParent();
  }
  @Override
  public void setCaretPositionIfPossible(int i) {
    if (i == getText().length() + 1) {
      int pos = getParent().getTextBefore(this, getText().length()).length() + 1;
      getParent().setCaretPosition(pos);
    } else {
      super.setCaretPositionIfPossible(i);
    }
    lastMLCaretPosition = getParent().getCaretPosition();
  }
  public String getTextBefore(int pos) {
    String result = getText();
    result = result.substring(0, Math.min(pos, result.length()));
    return result;
  }
  @Override
  public String getRole() {
    // This is required for processing the INSERT action (the user presses ENTER).
    // Otherwise the action is passed to the next children collection cell.
    return "";
  }
  @Override
  public void synchronizeViewWithModel() {
    check_xru0dp_a0a83(getParent(), this);
  }
  @Override
  public boolean processMousePressed(MouseEvent event) {
    super.processMousePressed(event);
    if (!(myShiftSelectionDisabled) && event.isShiftDown()) {
      int caretPos = getParent().getCaretPosition();
      getEditor().getSelectionManager().pushSelection(new MultilineSelection(getEditor(), getParent(), getParent().getRecentCursorPosition(0), caretPos));
      if (LOG_2133742043.isInfoLevel()) {
        LOG_2133742043.info("mousePressed", new Exception());
      }
    } else {
      getParent().rememberCursorPosition();
    }
    return true;
  }
  private static void addPropertyDependenciesToEditor(NodeReadAccessInEditorListener listener, EditorCell_Word result) {
    for (Pair<SNodeReference, String> pair : listener.popCleanlyReadAccessedProperties()) {
      result.getEditor().getUpdater().getCurrentUpdateSession().registerCleanDependency(result, pair);
    }
  }
  public static EditorCell_Word create(EditorContext editorContext, ModelAccessor modelAccessor, SNode node, int wordNum) {
    NodeReadAccessInEditorListener listener = NodeReadAccessCasterInEditor.getReadAccessListener();
    if (modelAccessor instanceof PropertyAccessor) {
      if (listener != null) {
        listener.clearCleanlyReadAccessProperties();
      }
    }
    EditorCell_Word result = new EditorCell_Word(editorContext, modelAccessor, node, wordNum);
    if (listener != null) {
      EditorCell_Word.addPropertyDependenciesToEditor(listener, result);
    }
    return result;
  }
  public Rectangle getBounds() {
    return new Rectangle(getX(), getY(), getWidth(), getHeight());
  }
  public void disableShiftSelection(boolean disable) {
    myShiftSelectionDisabled = disable;
  }

  @Override
  public void requestRelayout() {
    super.requestRelayout();
    for (EditorCell c = getParent(); c != null; c = c.getParent()) {
      c.requestRelayout();
    }
  }

  public int getWordNum() {
    return myWordNum;
  }

  @Override
  public ModelAccessor getModelAccessor() {
    myModelAccessorRequested = true;
    return super.getModelAccessor();
  }

  public boolean wasModelAccessorRequested() {
    boolean result = myModelAccessorRequested;
    myModelAccessorRequested = false;
    return result;
  }


  public int getCaretFromAbsolutePosition(int absolutePos) {
    return absolutePos - this.getParent().getTextBefore(this, 0).length();
  }
  private static int check_xru0dp_a0a1a0a1a0a0a0a32(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }
  private static int check_xru0dp_a0d0ab(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }
  private static String check_xru0dp_a0a0a33(EditorCell_Multiline checkedDotOperand, EditorCell_Word checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getCellId();
    }
    return null;
  }
  private static void check_xru0dp_a0a83(EditorCell_Multiline checkedDotOperand, EditorCell_Word checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      checkedDotOperand.synchronizeViewWithModel();
    }

  }
}

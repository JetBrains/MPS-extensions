package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Iterator;
import de.q60.mps.logging.runtime.ShadowLogging;
import java.util.Objects;
import org.modelix.model.api.IConcept;
import org.jetbrains.annotations.Nullable;
import de.q60.mps.shadowmodels.runtime.util.pmap.CustomPMap;
import de.q60.mps.shadowmodels.runtime.util.pmap.SmallPMap;
import org.modelix.model.api.INode;
import org.modelix.model.api.IChildLink;

public class TransformationResult implements ITransformationResult {
  private int elementIdSequence = 0;
  private final List<Child> roots = ListSequence.fromList(new ArrayList<Child>(1));
  private final Map<String, ResultElement> allElements = MapSequence.fromMap(new HashMap<String, ResultElement>());
  private final Map<String, ResultElement> labeledElements = MapSequence.fromMap(new HashMap<String, ResultElement>());
  private final ITransformationEngine engine;
  private ContainmentTargetRootNodes<TransformationCall> resultRef;
  private final List<IWeaving> weavings = ListSequence.fromList(new ArrayList<IWeaving>());
  private final MappingLabels mappingLabels = new MappingLabels();
  private final List<ScopeImport> subgraphDependencies = ListSequence.fromList(new ArrayList<ScopeImport>());
  private boolean transformationsApplied = true;
  private String traceInfo;
  private boolean frozen = false;

  public TransformationResult(@NotNull ContainmentTargetRootNodes<TransformationCall> call, ITransformationEngine engine) {
    this.resultRef = call;
    this.engine = engine;
  }

  public boolean hasTransformationsApplied() {
    return transformationsApplied;
  }

  public void setTransformationsApplied(boolean transformationsApplied) {
    this.transformationsApplied = transformationsApplied;
  }

  public void freeze() {
    if (frozen) {
      return;
    }
    frozen = true;
    mappingLabels.freeze();
  }

  public boolean isFrozen() {
    return frozen;
  }

  public void checkNotFrozen() {
    if (frozen) {
      throw new IllegalStateException("Transformation result computation is already completed.");
    }
  }

  public MappingLabels mappingLabels() {
    return mappingLabels;
  }

  @Override
  public IStageReference getStageRef() {
    return resultRef.getStageRef();
  }

  public ISubgraphStage getStage() {
    return engine.resolveStage(getStageRef());
  }

  public IScope getScope() {
    return resultRef.getContainmentTarget().getScope();
  }

  @Override
  public Iterable<Tuples._2<IUniqueContainmentTarget, IContainment>> getChildCalls() {
    return ListSequence.fromList(roots).ofType(TransformationResultChild.class).select(new _FunctionTypes._return_P1_E0<Tuples._2<IUniqueContainmentTarget, IContainment>, TransformationResultChild>() {
      public Tuples._2<IUniqueContainmentTarget, IContainment> invoke(TransformationResultChild it) {
        return MultiTuple.<IUniqueContainmentTarget,IContainment>from(it.call, (IContainment) null);
      }
    }).concat(Sequence.fromIterable(MapSequence.fromMap(allElements).values()).translate(new _FunctionTypes._return_P1_E0<Iterable<Tuples._2<IUniqueContainmentTarget, IContainment>>, ResultElement>() {
      public Iterable<Tuples._2<IUniqueContainmentTarget, IContainment>> invoke(final ResultElement parent) {
        return ListSequence.fromList(parent.children).ofType(TransformationResultChild.class).select(new _FunctionTypes._return_P1_E0<Tuples._2<IUniqueContainmentTarget, IContainment>, TransformationResultChild>() {
          public Tuples._2<IUniqueContainmentTarget, IContainment> invoke(TransformationResultChild child) {
            IContainment containment = KnownContainment.create(parent.getCanonicalReference(), child.role.getName());
            return MultiTuple.<IUniqueContainmentTarget,IContainment>from(child.call, containment);
          }
        });
      }
    }));
  }

  public ITransformationEngine getEngine() {
    return engine;
  }

  public void addWeaving(IWeaving weaving) {
    checkNotFrozen();
    ListSequence.fromList(weavings).addElement(weaving);
  }

  @Override
  public Iterable<IWeaving> getWeavings() {
    return weavings;
  }

  public void addDependency(ScopeImport subgraph) {
    checkNotFrozen();
    ListSequence.fromList(subgraphDependencies).addElement(subgraph);
  }

  /**
   * 
   * @deprecated  Use scopes with imports
   */
  @Deprecated
  public Iterable<ScopeImport> getDependencies() {
    return subgraphDependencies;
  }

  public ResultElement getElementById(String id) {
    return MapSequence.fromMap(allElements).get(id);
  }

  public Iterable<IResultElement> getElements() {
    return Sequence.fromIterable(MapSequence.fromMap(allElements).values()).select((it) -> {
      IResultElement element = it;
      return element;
    });
  }

  public ContainmentTargetRootNodes<TransformationCall> getResultReference() {
    return resultRef;
  }

  public String getTraceInfo() {
    return traceInfo;
  }

  public void setTraceInfo(String info) {
    checkNotFrozen();
    traceInfo = info;
  }

  @Override
  public Iterable<IOutputNodeReference> getRootNodes() {
    return ListSequence.fromList(roots).translate((it) -> it.resolve(engine));
  }

  public IOutputNodeReference getRoot() {
    Iterable<IOutputNodeReference> resolvedRoots = getRootNodes();
    if (Sequence.fromIterable(resolvedRoots).count() > 1) {
      throw new RuntimeException("Result has multiple roots");
    }
    return Sequence.fromIterable(resolvedRoots).first();
  }

  @Override
  public IOutputNodeReference getRootNode(int index) {
    Iterable<IOutputNodeReference> elements = getRootNodes(index);
    Iterator<IOutputNodeReference> itr = Sequence.fromIterable(elements).iterator();
    if (!(itr.hasNext())) {
      String msg = "No root elements found at index " + index;
      ShadowLogging.logError(msg, resultRef);
      throw new RuntimeException(msg);
    }
    IOutputNodeReference element = itr.next();
    if (itr.hasNext()) {
      String msg = "Multiple root elements found at index " + index;
      ShadowLogging.logError(msg, resultRef, "Found elements: ", Sequence.fromIterable(elements).select((it) -> OutputNodeReferenceAsNode.create(engine, it)).toList());
      throw new RuntimeException(msg);
    }
    return element;
  }

  @Override
  public IResultElement getFirstRootElement(int index) {
    final RootRole role = RootRole.forIndex(index);
    return ListSequence.fromList(roots).where((it) -> Objects.equals(it.role, role)).ofType(ResultElementChild.class).select((it) -> it.child).first();
  }

  @Override
  public Iterable<IOutputNodeReference> getRootNodes(int index) {
    final RootRole role = RootRole.forIndex(index);
    return ListSequence.fromList(roots).where((it) -> Objects.equals(it.role, role)).translate((it) -> it.resolve(engine));
  }

  public ResultElement getLabeledElement(String label) {
    ResultElement element = tryGetLabeledElement(label);
    if (element == null) {
      RuntimeException ex = new RuntimeException("Element with label '" + label + "' doesn't exist");
      ShadowLogging.logError(ex, resultRef);
      throw ex;
    }
    return element;
  }

  public ResultElement tryGetLabeledElement(String label) {
    return MapSequence.fromMap(labeledElements).get(label);
  }

  public ResultElement createNode(int index, String id, IConcept concept, IScope scope) {
    checkNotFrozen();
    ResultElement root = new ResultElement(id, concept, null, null, scope);
    ListSequence.fromList(roots).addElement(new ResultElementChild(RootRole.forIndex(index), root));
    return root;
  }

  public <T extends IContainmentTarget> IUniqueContainmentTarget<T> createNode(int index, T call, @Nullable IScope scope) {
    checkNotFrozen();
    IUniqueContainmentTarget<T> registered = getStage().makeUnique((scope == null ? getScope() : scope), call);
    ListSequence.fromList(roots).addElement(new TransformationResultChild(RootRole.forIndex(index), registered));
    return registered;
  }

  public class ResultElement implements IResultElement {
    private String id;
    private IConcept concept;
    @Nullable
    private ResultElement parent;
    @Nullable
    private String roleInParent;
    private List<Child> children = ListSequence.fromList(new ArrayList<Child>());
    private CustomPMap<String, _FunctionTypes._return_P0_E0<? extends String>> propertyValues = SmallPMap.empty();
    private CustomPMap<String, IReferenceTarget> referenceTargets = SmallPMap.empty();
    private CustomPMap<String, IPropertyWriteHandler> propertyWriteHandlers = SmallPMap.empty();
    private CustomPMap<String, IOperation> operations = SmallPMap.empty();
    private CustomPMap<String, IReferenceWriteHandler> referenceWriteHandlers = SmallPMap.empty();
    private CustomPMap<String, IChildCreateHandler> childAddHandlers = SmallPMap.empty();
    private String elementTraceInfo;
    @Nullable
    private IScope scope;

    public ResultElement(String id, IConcept concept, @Nullable ResultElement parent, @Nullable String roleInParent, @Nullable IScope scope) {
      checkNotFrozen();
      this.concept = concept;
      this.parent = parent;
      this.roleInParent = roleInParent;
      this.scope = scope;
      if (id == null) {
        id = "$" + ++elementIdSequence;
      }
      if (MapSequence.fromMap(allElements).containsKey(id)) {
        RuntimeException ex = new RuntimeException("Duplicate element id: " + id);
        ShadowLogging.logError(ex, resultRef);
        throw ex;
      }
      MapSequence.fromMap(allElements).put(id, this);
      this.id = id;
    }

    public Iterable<TransformationResultChild> getChildCalls() {
      return ListSequence.fromList(children).ofType(TransformationResultChild.class);
    }

    @Override
    public ResultElementOutputNodeReference_Id getCanonicalReference() {
      return new ResultElementOutputNodeReference_Id(getResultReference(), getId());
    }

    @Override
    public IScope getScope() {
      return (scope != null ? scope : TransformationResult.this.getScope());
    }

    @Override
    public String getTraceInfo() {
      return elementTraceInfo;
    }

    public void setTraceInfo(String info) {
      checkNotFrozen();
      elementTraceInfo = info;
    }

    @Nullable
    public ResultElement getParent() {
      return parent;
    }

    @Nullable
    public String getRoleInParent() {
      return roleInParent;
    }

    public IReferenceTarget getReferenceTarget(String role) {
      return referenceTargets.get(role);
    }

    public String getPropertyValue(String role) {
      final _FunctionTypes._return_P0_E0<? extends String> p = propertyValues.get(role);
      if (p == null) {
        return null;
      }

      return TransformationEngine.CONTEXT_ENGINE.computeWith((TransformationEngine) engine, () -> engine.currentContext().computeWith(getStageRef(), () -> p.invoke()));
    }

    public Iterable<Child> getAllChildren() {
      return children;
    }

    public Iterable<Child> getChildren(final String role) {
      return ListSequence.fromList(children).where((it) -> Objects.equals(it.role.getName(), role));
    }

    public String getId() {
      return id;
    }

    public IConcept getConcept() {
      return concept;
    }

    public TransformationResult getTransformationResult() {
      return TransformationResult.this;
    }

    @Override
    public void addLabel(String label) {
      checkNotFrozen();
      if (MapSequence.fromMap(labeledElements).containsKey(label)) {
        RuntimeException ex = new RuntimeException("Duplicate label: " + label);
        ShadowLogging.logError(ex, resultRef);
        throw ex;
      }
      MapSequence.fromMap(labeledElements).put(label, this);
    }

    public void addLabel(String label, INode inputNode) {
      checkNotFrozen();
      if (MapSequence.fromMap(labeledElements).containsKey(label)) {
        RuntimeException ex = new RuntimeException("Duplicate label: " + label);
        ShadowLogging.logError(ex, resultRef);
        throw ex;
      }
      MapSequence.fromMap(labeledElements).put(label, this);
    }

    @Override
    public ResultElement createChild(String role, String id, IConcept childConcept, IScope scope) {
      checkNotFrozen();
      checkChildLinkEmpty(role);
      ResultElement node = new ResultElement(id, childConcept, this, role, scope);
      ListSequence.fromList(children).addElement(new ResultElementChild(concept.getChildLink(role), node));
      return node;
    }

    @Override
    public void clearChildren(final String role) {
      checkNotFrozen();
      ListSequence.fromList(children).removeWhere((it) -> Objects.equals(it.role.getName(), role));
    }

    @Override
    public <T extends IContainmentTarget> IUniqueContainmentTarget<T> addChild(String role, T child, IScope scope) {
      checkNotFrozen();
      checkChildLinkEmpty(role);
      DependencyTrackingNode.checkHasTracking(child);

      IUniqueContainmentTarget<T> registeredChild = getStage().makeUnique((scope == null ? getScope() : scope), child);
      ListSequence.fromList(children).addElement(new TransformationResultChild(concept.getChildLink(role), registeredChild));
      return registeredChild;
    }

    protected void checkChildLinkEmpty(String role) {
      IChildLink link = concept.getChildLink(role);
      if (link == null) {
        RuntimeException ex = new RuntimeException("Unknown child link '" + role + "' in concept '" + concept + "'");
        ShadowLogging.logError(ex, resultRef);
        throw ex;
      }
      if (!(link.isMultiple()) && Sequence.fromIterable(getChildren(role)).isNotEmpty()) {
        RuntimeException ex = new RuntimeException(link + " doesn't allow multiple nodes");
        ShadowLogging.logError(ex, resultRef);
        throw ex;
      }
    }

    public void setReferenceTarget(String role, String label) {
      setReferenceTarget(role, new LocalLabelReferenceTarget(resultRef, label));
    }

    public void setReferenceTarget(String role, ResultElement target) {
      setReferenceTarget(role, target.getCanonicalReference());
    }

    public void setReferenceTarget(String role, IOutputNodeReference target) {
      setReferenceTarget(role, new OutputNodeAsReferenceTarget(target));
    }

    public void setReferenceTarget(String role, INode target) {
      setReferenceTarget(role, NodeAsOutputNodeReference.create(DependencyTrackingNode.unwrap(target)));
    }

    public void setReferenceTarget(String role, IReferenceTarget target) {
      checkNotFrozen();
      referenceTargets = referenceTargets.put(role, target);
    }

    public void setProperty(String role, final String value) {
      setProperty(role, () -> value);
    }

    public void setProperty(String role, final _FunctionTypes._return_P0_E0<? extends String> value) {
      checkNotFrozen();
      propertyValues = propertyValues.put(role, value);
    }

    public void setProperty(String role, int value) {
      checkNotFrozen();
      setProperty(role, Integer.toString(value));
    }

    public void setProperty(String role, double value) {
      checkNotFrozen();
      setProperty(role, Double.toString(value));
    }

    public void setProperty(String role, boolean value) {
      checkNotFrozen();
      setProperty(role, Boolean.toString(value));
    }

    public void setPropertyWriteHandler(String role, IPropertyWriteHandler handler) {
      checkNotFrozen();
      propertyWriteHandlers = propertyWriteHandlers.put(role, handler);
    }

    public IPropertyWriteHandler getPropertyWriteHandler(String role) {
      return propertyWriteHandlers.get(role);
    }

    public void setOperation(String id, IOperation op) {
      checkNotFrozen();
      if (operations.containsKey(id)) {
        RuntimeException ex = new RuntimeException("Operation " + id + " already exists");
        ShadowLogging.logError(ex, resultRef);
        throw ex;
      }
      operations = operations.put(id, op);
    }

    @Nullable
    public IOperation getOperation(String id) {
      return operations.get(id);
    }

    public void setReferenceWriteHandler(String role, IReferenceWriteHandler handler) {
      checkNotFrozen();
      referenceWriteHandlers = referenceWriteHandlers.put(role, handler);
    }

    public IReferenceWriteHandler getReferenceWriteHandler(String role) {
      return referenceWriteHandlers.get(role);
    }

    public void setChildAddHandler(String role, IChildCreateHandler handler) {
      checkNotFrozen();
      childAddHandlers = childAddHandlers.put(role, handler);
    }

    public IChildCreateHandler getChildAddHandler(String role) {
      return childAddHandlers.get(role);
    }

    public INode toNode() {
      return OutputNodeReferenceAsNode.create(engine, getCanonicalReference());
    }
  }

  public static abstract class Child {
    protected IChildLink role;
    public Child(IChildLink role1) {
      role = role1;
    }

    public abstract Iterable<IOutputNodeReference> resolve(ITransformationEngine engine);
  }

  public static class ResultElementChild extends Child {
    private TransformationResult.ResultElement child;
    public ResultElementChild(IChildLink role1, TransformationResult.ResultElement child1) {
      super(role1);
      child = child1;
    }

    @Override
    public Iterable<IOutputNodeReference> resolve(ITransformationEngine engine) {
      return Sequence.<IOutputNodeReference>singleton(child.getCanonicalReference());
    }
  }

  public class TransformationResultChild extends Child {
    private IUniqueContainmentTarget call;

    public TransformationResultChild(IChildLink role1, IUniqueContainmentTarget call) {
      super(role1);
      this.call = call;
    }

    @Override
    public Iterable<IOutputNodeReference> resolve(ITransformationEngine engine) {
      return engine.resolveRootNodes(new ContainmentTargetRootNodes(getStageRef(), call));
    }
  }

  public static class RootRole implements IChildLink {
    private static final RootRole INDEX0 = new RootRole(0);

    public static RootRole forIndex(int index) {
      if (index == 0) {
        return INDEX0;
      }
      return new RootRole(index);
    }
    private final int index;
    private RootRole(int index) {
      this.index = index;
    }
    @NotNull
    @Override
    public IConcept getTargetConcept() {
      throw new UnsupportedOperationException();
    }
    @NotNull
    @Override
    public IConcept getConcept() {
      throw new UnsupportedOperationException();
    }
    @Override
    public String getSimpleName() {
      throw new UnsupportedOperationException();
    }
    @Override
    public boolean isMultiple() {
      throw new UnsupportedOperationException();
    }
    @Override
    public boolean isOptional() {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }
      RootRole that = (RootRole) o;
      return index == that.index;
    }
    @Override
    public int hashCode() {
      return index;
    }
    @NotNull
    @Override
    public IConcept getChildConcept() {
      throw new UnsupportedOperationException();
    }
    @NotNull
    @Override
    public String getUID() {
      throw new UnsupportedOperationException();
    }
  }
}

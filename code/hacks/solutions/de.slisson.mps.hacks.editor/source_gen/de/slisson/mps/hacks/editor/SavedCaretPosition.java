package de.slisson.mps.hacks.editor;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Label;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.cells.CellInfo;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class SavedCaretPosition {

  private List<SavedCell> myCellsBefore = ListSequence.fromList(new ArrayList<SavedCell>());
  private List<SavedCell> myCellsAfter = ListSequence.fromList(new ArrayList<SavedCell>());
  private SavedCell mySelectedCell;
  private int myCaretPosition;
  private EditorContext myEditorContext;

  public SavedCaretPosition(EditorContext editorContext) {
    this.myEditorContext = editorContext;
  }

  public void clear() {
    myCellsBefore = ListSequence.fromList(new ArrayList<SavedCell>());
    myCellsAfter = ListSequence.fromList(new ArrayList<SavedCell>());
    mySelectedCell = null;
    myCaretPosition = 0;
  }

  public void save() {
    clear();
    EditorCell selectedCell = myEditorContext.getSelectedCell();
    if (selectedCell == null) {
      return;
    }
    mySelectedCell = getCellInfo(selectedCell);
    if (selectedCell instanceof EditorCell_Label) {
      myCaretPosition = ((EditorCell_Label) selectedCell).getCaretPosition();
    }

    myCellsBefore = ListSequence.fromList(getLeafs(selectedCell, false)).select((it) -> getCellInfo(it)).toList();
    myCellsAfter = ListSequence.fromList(getLeafs(selectedCell, true)).select((it) -> getCellInfo(it)).toList();
  }

  public void restore() {
    restore(true);
  }

  public void restore(boolean preferLeft) {
    EditorCell cellToSelect = mySelectedCell.findCell();
    if (cellToSelect != null) {
      if (cellToSelect instanceof EditorCell_Label) {
        myEditorContext.getSelectionManager().setSelection(((EditorCell_Label) cellToSelect), myCaretPosition);
      } else {
        myEditorContext.getSelectionManager().setSelection(cellToSelect);
      }
      return;
    }

    selectBestCandidate(preferLeft);
  }

  protected void selectBestCandidate(boolean preferLeft) {
    List<EditorCell> oldCellsBefore = ListSequence.fromList(myCellsBefore).select((it) -> it.findCell()).toList();
    List<EditorCell> oldCellsAfter = ListSequence.fromList(myCellsAfter).select((it) -> it.findCell()).toList();
    final Set<EditorCell> allFoundCells = SetSequence.fromSet(new HashSet<EditorCell>());
    SetSequence.fromSet(allFoundCells).addSequence(ListSequence.fromList(oldCellsBefore).where((it) -> it != null));
    SetSequence.fromSet(allFoundCells).addSequence(ListSequence.fromList(oldCellsAfter).where((it) -> it != null));

    List<EditorCell> allLeafs = getAllLeafs();
    Set<EditorCell> allLeafsSet = SetSequence.fromSetWithValues(new HashSet<EditorCell>(), allLeafs);

    // try to find new instances of the same cell
    for (int i = 0; i < ListSequence.fromList(oldCellsBefore).count(); i++) {
      if (ListSequence.fromList(oldCellsBefore).getElement(i) != null) {
        continue;
      }

      EditorCell cellLeft = ListSequence.fromList(oldCellsBefore).headListSequence(i).findLast((it) -> it != null);
      EditorCell cellRight = ListSequence.fromList(oldCellsBefore).tailListSequence(i + 1).findFirst((it) -> it != null);
      int indexLeft = (cellLeft == null ? -1 : ListSequence.fromList(allLeafs).indexOf(cellLeft));
      int indexRight = (cellRight == null ? -1 : ListSequence.fromList(allLeafs).indexOf(cellRight));
      List<EditorCell> candidates;
      if (indexLeft != -1 && indexRight != -1) {
        if (indexLeft + 1 < indexRight) {
          candidates = ListSequence.fromList(allLeafs).subListSequence(indexLeft + 1, indexRight);
        } else {
          candidates = ListSequence.fromList(new ArrayList<EditorCell>());
        }
      } else if (indexLeft != -1) {
        candidates = ListSequence.fromList(allLeafs).tailListSequence(indexLeft + 1);
      } else if (indexRight != -1) {
        candidates = ListSequence.fromList(allLeafs).headListSequence(indexRight);
      } else {
        candidates = allLeafs;
      }

      final String cellText = ListSequence.fromList(myCellsBefore).getElement(i).myText;
      EditorCell foundCell = ListSequence.fromList(candidates).findFirst((it) -> it != null && !(SetSequence.fromSet(allFoundCells).contains(it)) && Objects.equals(check_c79w0i_a0a0a0a0a01a01a71(as_c79w0i_a0a0a0a0a0a01a01a71(it, EditorCell_Label.class)), cellText));
      if (foundCell != null) {
        ListSequence.fromList(oldCellsBefore).setElement(i, foundCell);
        SetSequence.fromSet(allFoundCells).addElement(foundCell);
      }
    }
    for (int i = 0; i < ListSequence.fromList(oldCellsAfter).count(); i++) {
      if (ListSequence.fromList(oldCellsAfter).getElement(i) != null) {
        continue;
      }

      EditorCell cellLeft = ListSequence.fromList(oldCellsAfter).headListSequence(i).findLast((it) -> it != null);
      EditorCell cellRight = ListSequence.fromList(oldCellsAfter).tailListSequence(i + 1).findFirst((it) -> it != null);
      int indexLeft = (cellLeft == null ? -1 : ListSequence.fromList(allLeafs).indexOf(cellLeft));
      int indexRight = (cellRight == null ? -1 : ListSequence.fromList(allLeafs).indexOf(cellRight));
      List<EditorCell> candidates;
      if (indexLeft != -1 && indexRight != -1) {
        candidates = ListSequence.fromList(allLeafs).subListSequence(indexLeft + 1, indexRight);
      } else if (indexLeft != -1) {
        candidates = ListSequence.fromList(allLeafs).tailListSequence(indexLeft + 1);
      } else if (indexRight != -1) {
        candidates = ListSequence.fromList(allLeafs).headListSequence(indexRight);
      } else {
        candidates = ListSequence.fromList(new ArrayList<EditorCell>());
      }

      final String cellText = ListSequence.fromList(myCellsAfter).getElement(i).myText;
      EditorCell foundCell = ListSequence.fromList(candidates).findLast((it) -> it != null && !(SetSequence.fromSet(allFoundCells).contains(it)) && Objects.equals(check_c79w0i_a0a0a0a0a01a11a71(as_c79w0i_a0a0a0a0a0a01a11a71(it, EditorCell_Label.class)), cellText));
      if (foundCell != null) {
        ListSequence.fromList(oldCellsAfter).setElement(i, foundCell);
        SetSequence.fromSet(allFoundCells).addElement(foundCell);
      }
    }

    oldCellsBefore = ListSequence.fromList(oldCellsBefore).where((it) -> it != null).toList();
    oldCellsAfter = ListSequence.fromList(oldCellsAfter).where((it) -> it != null).toList();
    Set<EditorCell> oldCellsBeforeSet = SetSequence.fromSetWithValues(new HashSet<EditorCell>(), oldCellsBefore);
    Set<EditorCell> oldCellsAfterSet = SetSequence.fromSetWithValues(new HashSet<EditorCell>(), oldCellsAfter);

    // find best match by comparing the text (useful in case of literal splitting)
    if (mySelectedCell.getTextWithoutSpaces().length() >= 2) {
      List<EditorCell> newCells = ListSequence.fromList(new ArrayList<EditorCell>());
      for (EditorCell current = getLeaf(ListSequence.fromList(oldCellsBefore).last(), true); current != null && current != ListSequence.fromList(oldCellsAfter).first(); current = getLeaf(current, true)) {
        ListSequence.fromList(newCells).addElement(current);
      }

      String newCellsText = IterableUtils.join(ListSequence.fromList(newCells).select((it) -> {
        String text = check_c79w0i_a0a0a0a0a0d0t0r(as_c79w0i_a0a0a0a0a0a0d0t0r(it, EditorCell_Label.class));
        return (text == null ? "" : text);
      }), " ").replace(" ", "");
      if (newCellsText.contains(mySelectedCell.getTextWithoutSpaces())) {
        String textBeforeCaret = mySelectedCell.getTextBefore(myCaretPosition).replace(" ", "");
        String textAfterCaret = mySelectedCell.getTextAfter(myCaretPosition).replace(" ", "");

        int pos = 0;
        Tuples._4<String, String, EditorCell, Integer> textBeforeAfter = getTextBeforeAfter(newCells, pos);
        while (textBeforeAfter != null) {
          String textBefore = textBeforeAfter._0();
          String textAfter = textBeforeAfter._1();

          if (textBefore.endsWith(textBeforeCaret) && textAfter.startsWith(textAfterCaret)) {
            selectCell(textBeforeAfter._2(), (int) textBeforeAfter._3());
            return;
          }

          pos++;
          textBeforeAfter = getTextBeforeAfter(newCells, pos);
        }
      }
    }

    EditorCell candidate = getLeaf(ListSequence.fromList(oldCellsBefore).last(), true);
    if (candidate != null && !(SetSequence.fromSet(oldCellsAfterSet).contains(candidate))) {
      if (Objects.equals(getText(candidate), mySelectedCell.myText)) {
        selectCell(candidate, myCaretPosition);
      } else {
        selectCell(candidate, true);
      }
      return;
    }

    if (preferLeft && ListSequence.fromList(oldCellsBefore).isNotEmpty()) {
      selectCell(ListSequence.fromList(oldCellsBefore).last(), true);
      return;
    } else {
      selectCell(ListSequence.fromList(oldCellsAfter).first(), false);
      return;
    }
  }

  protected void selectCell(EditorCell cell, boolean end) {
    selectCell(cell, (end ? -1 : 0));
  }
  protected void selectCell(EditorCell cell, int position) {
    String cellId = cell.getCellId();
    if (cellId != null) {
      SelectionUtil.selectLabelCellAnSetCaret(myEditorContext, cell.getSNode(), cellId, position);
    }
  }

  protected List<EditorCell> getLeafs(EditorCell cell, boolean after) {
    List<EditorCell> result = ListSequence.fromList(new ArrayList<EditorCell>());
    EditorCell leaf = getLeaf(cell, after);
    while (leaf != null) {
      if (leaf instanceof EditorCell_Label) {
        ListSequence.fromList(result).addElement(((EditorCell_Label) leaf));
      }
      leaf = getLeaf(leaf, after);
    }
    return (after ? result : ListSequence.fromList(result).reversedList());
  }

  protected List<EditorCell> getAllLeafs() {
    List<EditorCell> result = ListSequence.fromList(new ArrayList<EditorCell>());
    EditorCell leaf = CellTraversalUtil.getFirstLeaf(myEditorContext.getEditorComponent().getRootCell());
    while (leaf != null) {
      if (leaf instanceof EditorCell_Label) {
        ListSequence.fromList(result).addElement(((EditorCell_Label) leaf));
      }
      leaf = getLeaf(leaf, true);
    }
    return result;
  }

  @Nullable
  protected EditorCell getLeaf(@Nullable EditorCell cell, boolean next) {
    if (cell == null) {
      return null;
    }
    EditorCell result = (next ? CellTraversalUtil.getNextLeaf(cell) : CellTraversalUtil.getPrevLeaf(cell));
    if (result == cell) {
      // This would cause an endless loop. It actually happens when the cell is a bracket cell,
      // because of a bug in MPS.
      return null;
    }
    return result;
  }

  protected SavedCell getCellInfo(EditorCell cell) {
    return new SavedCell(cell);
  }

  protected EditorCell findCell(CellInfo cellInfo) {
    return cellInfo.findCell(((EditorComponent) myEditorContext.getEditorComponent()));
  }

  protected Tuples._4<String, String, EditorCell, Integer> getTextBeforeAfter(List<EditorCell> cells, int pos) {
    StringBuilder before = new StringBuilder();
    StringBuilder after = new StringBuilder();
    EditorCell cellAtPos = ListSequence.fromList(cells).first();
    int caretPosAtPos = 0;

    int currentPos = 0;
    for (EditorCell cell : ListSequence.fromList(cells)) {
      String text = getText(cell);
      int posInCell = 1;
      for (char c : text.toCharArray()) {
        if (c != ' ') {
          if (currentPos < pos) {
            before.append(c);
            cellAtPos = cell;
            caretPosAtPos = posInCell;
          } else {
            after.append(c);
          }
          currentPos++;
        }

        posInCell++;
      }
    }
    if (pos > currentPos) {
      // we are at the end of iterating over all positions
      return null;
    }

    return MultiTuple.<String,String,EditorCell,Integer>from(before.toString(), after.toString(), cellAtPos, caretPosAtPos);
  }

  protected String getText(EditorCell cell) {
    if (cell == null) {
      return "";
    }
    String text = check_c79w0i_a0b0ib(as_c79w0i_a0a0b0ib(cell, EditorCell_Label.class));
    if (text == null) {
      return "";
    }
    return text;
  }

  protected class SavedCell {
    private CellInfo myCellInfo;
    private String myText;

    public SavedCell(EditorCell cell) {
      myCellInfo = cell.getCellInfo();
      myText = check_c79w0i_a0b0d63(as_c79w0i_a0a0b0d63(cell, EditorCell_Label.class));
    }

    public EditorCell findCell() {
      return findCell(myEditorContext.getEditorComponent());
    }

    public EditorCell findCell(jetbrains.mps.openapi.editor.EditorComponent editorComponent) {
      return myCellInfo.findCell(editorComponent);
    }

    protected String getTextWithoutSpaces() {
      String t = (myText == null ? "" : myText);
      return t.replace(" ", "");
    }

    protected String getTextBefore(int pos) {
      if (myText == null) {
        return "";
      }
      if (pos < 0) {
        return "";
      }
      if (pos > myText.length()) {
        return myText;
      }
      return myText.substring(0, pos);
    }

    protected String getTextAfter(int pos) {
      if (myText == null) {
        return "";
      }
      if (pos < 0) {
        return myText;
      }
      if (pos > myText.length()) {
        return "";
      }
      return myText.substring(pos);
    }
  }
  private static String check_c79w0i_a0a0a0a0a01a01a71(EditorCell_Label checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getText();
    }
    return null;
  }
  private static String check_c79w0i_a0a0a0a0a01a11a71(EditorCell_Label checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getText();
    }
    return null;
  }
  private static String check_c79w0i_a0a0a0a0a0d0t0r(EditorCell_Label checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getText();
    }
    return null;
  }
  private static String check_c79w0i_a0b0ib(EditorCell_Label checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getText();
    }
    return null;
  }
  private static String check_c79w0i_a0b0d63(EditorCell_Label checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getText();
    }
    return null;
  }
  private static <T> T as_c79w0i_a0a0a0a0a0a01a01a71(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_c79w0i_a0a0a0a0a0a01a11a71(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_c79w0i_a0a0a0a0a0a0d0t0r(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_c79w0i_a0a0b0ib(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_c79w0i_a0a0b0d63(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

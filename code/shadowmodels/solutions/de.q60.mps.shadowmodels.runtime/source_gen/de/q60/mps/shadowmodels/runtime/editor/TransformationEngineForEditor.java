package de.q60.mps.shadowmodels.runtime.editor;

/*Generated by MPS */

import de.q60.mps.shadowmodels.runtime.smodel.STransformationEngine;
import java.util.Map;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import de.q60.mps.shadowmodels.runtime.engine.TransformationEngine;
import de.q60.mps.polymorphicfunctions.runtime.DefaultPFContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import de.q60.mps.polymorphicfunctions.runtime.IImplementationProvider;
import de.q60.mps.shadowmodels.runtime.smodel.SM_TransformationsFromAspect;
import jetbrains.mps.module.ReloadableModule;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.extapi.model.SModelDescriptorStub;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.q60.mps.polymorphicfunctions.runtime.IPFContext;
import org.jetbrains.annotations.NotNull;

public class TransformationEngineForEditor extends STransformationEngine {

  private static Map<EditorComponent, TransformationEngineForEditor> instances = MapSequence.fromMap(new HashMap<EditorComponent, TransformationEngineForEditor>());

  public static TransformationEngine getUpdater(final EditorComponent editor) {
    TransformationEngineForEditor instance = MapSequence.fromMap(TransformationEngineForEditor.instances).get(editor);
    if (instance == null) {
      instance = new TransformationEngineForEditor(editor, new DefaultPFContext(ListSequence.fromListAndArray(new ArrayList<IImplementationProvider>(), new SM_TransformationsFromAspect() {
        @Override
        protected Iterable<ReloadableModule> getSModules() {
          Set<SLanguage> languages = SetSequence.fromSetWithValues(new HashSet<SLanguage>(), ((SModelDescriptorStub) editor.getEditorContext().getModel()).importedLanguageIds());
          return SetSequence.fromSet(languages).select((it) -> (ReloadableModule) it.getSourceModule());
        }
      })));
      MapSequence.fromMap(TransformationEngineForEditor.instances).put(editor, instance);
    }
    return instance;
  }

  public static void disposeAll() {
    Sequence.fromIterable(MapSequence.fromMap(instances).values()).visitAll((it) -> it.dispose());
    instances = null;
  }

  private EditorComponent editor;

  public TransformationEngineForEditor(EditorComponent editor, IPFContext transformationFunctions) {
    super(transformationFunctions);
    this.editor = editor;
    ((jetbrains.mps.nodeEditor.EditorComponent) editor).addDisposeListener(new jetbrains.mps.nodeEditor.EditorComponent.EditorDisposeListener() {
      public void editorWillBeDisposed(@NotNull jetbrains.mps.nodeEditor.EditorComponent e) {
        MapSequence.fromMap(instances).removeKey(e);
        dispose();
      }
    });
  }

  public void dispose() {
    MapSequence.fromMap(instances).removeKey(editor);
    editor = null;
  }
}

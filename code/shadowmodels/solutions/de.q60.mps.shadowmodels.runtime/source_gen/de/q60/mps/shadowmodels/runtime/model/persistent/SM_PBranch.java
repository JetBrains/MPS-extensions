package de.q60.mps.shadowmodels.runtime.model.persistent;

/*Generated by MPS */

import org.modelix.model.api.IBranch;
import jetbrains.mps.logging.Logger;
import org.modelix.model.api.ITree;
import de.q60.mps.incremental.util.ContextValue;
import org.modelix.model.api.IBranchListener;
import org.jetbrains.annotations.Nullable;
import java.util.UUID;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import kotlin.jvm.functions.Function0;
import kotlin.Unit;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import de.q60.mps.shadowmodels.runtime.util.pmap.COWArrays;
import org.jetbrains.annotations.NotNull;
import kotlin.jvm.functions.Function1;
import org.modelix.model.api.IReadTransaction;
import org.modelix.model.api.IWriteTransaction;

public class SM_PBranch implements IBranch {
  private static final Logger LOG = Logger.getLogger(SM_PBranch.class);
  private volatile ITree tree;

  private final Object writeLock = new Object();
  private final ContextValue<SM_Transaction> contextTransactions = new ContextValue<SM_Transaction>();
  private IBranchListener[] listeners = new IBranchListener[0];
  @Nullable
  private final SM_INodeLoader nodeLoader;
  private SM_IIdGenerator idGenerator;
  private final String id = UUID.randomUUID().toString();

  public SM_PBranch() {
    this(SM_PTree.EMPTY, null, SM_DefaultIdGenerator.getInstance());
  }

  public SM_PBranch(ITree initialTree) {
    this(initialTree, null, SM_DefaultIdGenerator.getInstance());
  }

  public SM_PBranch(ITree initialTree, SM_IIdGenerator idGenerator) {
    this(initialTree, null, idGenerator);
  }

  public SM_PBranch(SM_INodeLoader nodeLoader) {
    this(SM_PTree.EMPTY, nodeLoader, SM_DefaultIdGenerator.getInstance());
  }

  public SM_PBranch(ITree initialTree, SM_INodeLoader nodeLoader) {
    this(initialTree, nodeLoader, SM_DefaultIdGenerator.getInstance());
  }

  public SM_PBranch(ITree initialTree, SM_INodeLoader nodeLoader, SM_IIdGenerator idGenerator) {
    this.tree = initialTree;
    this.nodeLoader = nodeLoader;
    this.idGenerator = idGenerator;
  }

  @Nullable
  @Override
  public String getId() {
    return id;
  }

  public SM_INodeLoader getNodeLoader() {
    return nodeLoader;
  }

  public void runWithTransaction(SM_ITransaction transaction, _FunctionTypes._void_P0_E0 runnable) {
    contextTransactions.runWithFunctionType((SM_Transaction) transaction, runnable);
  }

  @Override
  public void runRead(final Function0<Unit> runnable) {
    SM_Transaction prevTransaction = contextTransactions.getValue();
    if (prevTransaction instanceof SM_IReadTransaction) {
      runnable.invoke();
    } else {
      int timeout = 100;
      while (true) {
        if (timeout-- == 0) {
          throw new RuntimeException("Too many lazy nodes");
        }
        ITree currentTree = (prevTransaction == null ? this.tree : prevTransaction.getTree());
        SM_ReadTransaction t = new SM_ReadTransaction(currentTree, this);
        try {
          contextTransactions.computeWith(t, () -> runnable.invoke());
        } catch (RuntimeException ex) {
          if (Sequence.fromIterable(t.getMissingNodes()).isEmpty()) {
            throw ex;
          } else {
            // Exception may be caused by missing nodes and may go away after loading them. Ignore it.
            if (LOG.isDebugLevel()) {
              LOG.debug("Exception possibly caused by an incomplete model", ex);
            }
          }
        }
        if (Sequence.fromIterable(t.getMissingNodes()).isEmpty()) {
          break;
        } else {
          if (nodeLoader == null) {
            throw new RuntimeException("Tree contains lazy nodes but no node loader is specified");
          } else {
            for (final SM_IMissingNode missingNode : Sequence.fromIterable(t.getMissingNodes())) {
              nodeLoader.runRead(() -> runWrite(() -> {
                nodeLoader.loadNode(missingNode, getWriteTransaction());
                return Unit.INSTANCE;
              }));
            }
          }
        }
      }
    }
  }

  @Override
  public void runWrite(final Function0<Unit> runnable) {
    synchronized (writeLock) {
      SM_Transaction prevTransaction = contextTransactions.getValue();
      if (prevTransaction instanceof SM_ReadTransaction) {
        throw new IllegalStateException("Cannot run write from read");
      }

      SM_WriteTransaction prevWrite = (SM_WriteTransaction) prevTransaction;

      final ITree oldTree = (prevWrite == null ? tree : prevWrite.getTree());
      SM_WriteTransaction newWrite = (nodeLoader == null ? new SM_WriteTransaction(oldTree, this, idGenerator) : new SM_LazyLoadingWriteTransaction(oldTree, this, idGenerator));
      try {
        try {
          contextTransactions.computeWith(newWrite, () -> runnable.invoke());
        } catch (SM_NodeNotLoadedException ex) {
          throw new RuntimeException("Should not happen. NodeLoader: " + nodeLoader, ex);
        }
        newWrite.close();
        ITree newTree = newWrite.getTree();
        if (prevWrite == null) {
          tree = newTree;
          notifyTreeChange(oldTree, newTree);
        } else {
          prevWrite.setTree(newTree);
        }
      } finally {
        newWrite.close();
      }
    }
  }

  @Override
  public <T> T computeRead(final Function0<? extends T> computable) {
    final Wrappers._T<T> result = new Wrappers._T<T>(null);
    runRead(() -> {
      result.value = computable.invoke();
      return Unit.INSTANCE;
    });
    return result.value;
  }

  @Override
  public <T> T computeWrite(final Function0<? extends T> computable) {
    final Wrappers._T<T> result = new Wrappers._T<T>(null);
    runWrite(() -> {
      result.value = computable.invoke();
      return Unit.INSTANCE;
    });
    return result.value;
  }

  @Override
  public boolean canRead() {
    return contextTransactions.getValue() instanceof SM_ITransaction;
  }

  @Override
  public boolean canWrite() {
    return contextTransactions.getValue() instanceof SM_IWriteTransaction;
  }

  public SM_Transaction getTransaction() {
    SM_Transaction t = contextTransactions.getValue();
    if (t == null) {
      throw new IllegalStateException("Not in a transaction");
    }
    return t;
  }

  public SM_ReadTransaction getReadTransaction() {
    SM_Transaction transaction = getTransaction();
    if (!(transaction instanceof SM_ReadTransaction)) {
      throw new IllegalStateException("Not in a read transaction");
    }
    return (SM_ReadTransaction) transaction;
  }

  public SM_WriteTransaction getWriteTransaction() {
    SM_Transaction transaction = getTransaction();
    if (!(transaction instanceof SM_WriteTransaction)) {
      throw new IllegalStateException("Not in a write transaction");
    }
    return (SM_WriteTransaction) transaction;
  }

  @Override
  public void addListener(IBranchListener l) {
    listeners = COWArrays.addIfAbsent(listeners, l);
  }

  @Override
  public void removeListener(IBranchListener l) {
    listeners = COWArrays.remove(listeners, l);
  }

  protected void notifyTreeChange(ITree oldTree, ITree newTree) {
    if (oldTree == newTree) {
      return;
    }
    for (IBranchListener l : listeners) {
      try {
        l.treeChanged(oldTree, newTree);
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("Exception in branch listener", ex);
        }
      }
    }
  }

  @Override
  public <T> T computeReadT(@NotNull Function1<? super IReadTransaction, ? extends T> f) {
    return IBranch.DefaultImpls.computeReadT(this, f);
  }

  @Override
  public <T> T computeWriteT(@NotNull Function1<? super IWriteTransaction, ? extends T> f) {
    return IBranch.DefaultImpls.computeWriteT(this, f);
  }
  @Override
  public void runReadT(@NotNull Function1<? super IReadTransaction, Unit> f) {
    IBranch.DefaultImpls.runReadT(this, f);
  }
  @Override
  public void runWriteT(@NotNull Function1<? super IWriteTransaction, Unit> f) {
    IBranch.DefaultImpls.runWriteT(this, f);
  }
}

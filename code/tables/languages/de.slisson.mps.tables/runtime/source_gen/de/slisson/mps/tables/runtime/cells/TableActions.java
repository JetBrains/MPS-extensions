package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.datatransfer.PasteNodeData;
import jetbrains.mps.ide.datatransfer.CopyPasteUtil;
import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class TableActions {

  public enum TableActionType {
    ROW(),
    COLUMN()
  }

  public static abstract class AbstractTableCellAction extends AbstractCellAction {

    private EditorCell cell;
    private boolean triggeredFromMPSAction = false;

    public AbstractTableCellAction(EditorCell cell) {
      this(cell, false);
    }

    public AbstractTableCellAction(EditorCell cell, boolean triggeredFromMPSAction) {
      this.cell = cell;
      this.triggeredFromMPSAction = triggeredFromMPSAction;
    }

    public abstract TableActions.TableActionType getActionType();

    public EditorCell_GridCell getGridCell() {
      return (EditorCell_GridCell) TableTraversalUtil.getParent(cell, TableTraversalUtil.GRID_CELL);
    }

    public TableEditor getTableEditor() {
      return (TableEditor) TableTraversalUtil.getParent(cell, TableTraversalUtil.TABLE_EDITOR);
    }


    public SNode getNodeOfRow() {
      return TableUtils.getNodeOfRowNode(getGridCell());
    }

    public EditorCell getEditorCell() {
      return cell;
    }


    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell_GridCell gridCell = getGridCell();
      TableEditor tableEditor = getTableEditor();
      if (tableEditor == null) {
        return false;
      }

      boolean cond = gridCell != null && TableUtils.getNodeOfRowNode(gridCell) != null;

      if (triggeredFromMPSAction) {
        cond &= (getActionType() == TableActions.TableActionType.COLUMN ? tableEditor.columnUIActionsAllowed() : tableEditor.rowUIActionsAllowed());
      }
      return cond;
    }
  }

  public static class InsertColumnAction extends AbstractTableCellAction {

    private boolean before;

    public InsertColumnAction(EditorCell cell, boolean before) {
      this(cell, before, false);
    }

    public InsertColumnAction(EditorCell cell, boolean before, boolean triggeredFromMPSAction) {
      super(cell, triggeredFromMPSAction);
      this.before = before;
    }

    @Override
    public TableActions.TableActionType getActionType() {
      return TableActions.TableActionType.COLUMN;
    }

    @Override
    public boolean canExecute(EditorContext context) {
      CellAction action = null;
      EditorCell currentCell = this.getEditorCell();
      while (currentCell != null && action == null) {
        action = currentCell.getAction((before ? CellActionType.INSERT_BEFORE : CellActionType.INSERT));
        currentCell = currentCell.getParent();
      }
      // FIXME: how can we better detect that we are in the header?
      return action != null && action.getClass().getName().contains("HeaderGridFactory");
    }

    @Override
    public void execute(EditorContext context) {
      CellAction action = null;
      EditorCell currentCell = this.getEditorCell();
      while (currentCell != null && action == null) {
        action = currentCell.getAction((before ? CellActionType.INSERT_BEFORE : CellActionType.INSERT));
        currentCell = currentCell.getParent();
      }
      if (action != null) {
        action.execute(context);
      }
    }

  }

  public static class InsertRowAction extends AbstractTableCellAction {

    private boolean before;

    public InsertRowAction(EditorCell cell, boolean before) {
      this(cell, before, false);
    }

    public InsertRowAction(EditorCell cell, boolean before, boolean triggeredFromMPSAction) {
      super(cell, triggeredFromMPSAction);
      this.before = before;
    }

    @Override
    public TableActions.TableActionType getActionType() {
      return TableActions.TableActionType.ROW;
    }

    public void execute(EditorContext context) {
      SNode nodeOfRow = TableUtils.getNodeOfRowNode(getGridCell());
      if (before) {
        SNodeOperations.insertPrevSiblingChild(nodeOfRow, SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(SNodeOperations.getConcept(nodeOfRow))));
      } else {
        SNodeOperations.insertNextSiblingChild(nodeOfRow, SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(SNodeOperations.getConcept(nodeOfRow))));
      }
    }
  }

  public static class SelectRowNodeAction extends AbstractTableCellAction {
    public SelectRowNodeAction(EditorCell cell) {
      this(cell, false);
    }

    public SelectRowNodeAction(EditorCell cell, boolean triggeredFromMPSAction) {
      super(cell, triggeredFromMPSAction);
    }

    @Override
    public TableActions.TableActionType getActionType() {
      return TableActions.TableActionType.ROW;
    }

    @Override
    public boolean canExecute(EditorContext context) {
      return getNodeOfRow() != null;
    }
    public void execute(EditorContext context) {
      context.getSelectionManager().setSelection(getNodeOfRow());
    }
  }

  public static class PasteAction extends AbstractTableCellAction {

    private boolean leftSide;

    public PasteAction(EditorCell cell, boolean leftSide) {
      this(cell, leftSide, false);
    }

    public PasteAction(EditorCell cell, boolean leftSide, boolean triggeredFromMPSAction) {
      super(cell, triggeredFromMPSAction);
      this.leftSide = leftSide;
    }

    @Override
    public TableActions.TableActionType getActionType() {
      return TableActions.TableActionType.ROW;
    }

    @Override
    public boolean canExecute(EditorContext context) {
      SNode nodeOfRow = getNodeOfRow();
      if (nodeOfRow == null) {
        return false;
      }
      if (!(SNodeOperations.getContainingLink(nodeOfRow).isMultiple())) {
        return false;
      }

      PasteNodeData pasteNodeData = CopyPasteUtil.getPasteNodeData();
      List<SNode> nodesToPaste = pasteNodeData.getNodes();
      SAbstractConcept targetConcept = SNodeOperations.getContainingLink(nodeOfRow).getTargetConcept();
      for (SNode nodeToPaste : ListSequence.fromList(nodesToPaste)) {
        if (!(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(nodeToPaste)), SNodeOperations.asSConcept(targetConcept)))) {
          return false;
        }
      }
      return true;
    }
    public void execute(EditorContext context) {
      SNode nodeOfRow = TableUtils.getNodeOfRowNode(getGridCell());
      if (nodeOfRow == null) {
        return;
      }

      PasteNodeData pasteNodeData = CopyPasteUtil.getPasteNodeData();
      List<SNode> nodesToPaste = pasteNodeData.getNodes();
      if (!(leftSide)) {
        nodesToPaste = ListSequence.fromList(nodesToPaste).reversedList();
      }
      for (SNode nodeToPaste : ListSequence.fromList(nodesToPaste)) {
        if (leftSide) {
          SNodeOperations.insertPrevSiblingChild(nodeOfRow, nodeToPaste);
        } else {
          SNodeOperations.insertNextSiblingChild(nodeOfRow, nodeToPaste);
        }
      }
    }
  }

  public static class DeleteRowAction extends AbstractTableCellAction {

    public enum DeleteType {
      BACKSPACE(),
      DELETE()
    }

    private DeleteType deleteType;
    private boolean fromLeftSide;

    public DeleteRowAction(EditorCell cell) {
      this(cell, false, DeleteType.BACKSPACE, false);
    }

    public DeleteRowAction(EditorCell cell, boolean triggeredFromMPSAction, DeleteType deleteType, boolean fromLeftSide) {
      super(cell, triggeredFromMPSAction);
      this.deleteType = deleteType;
      this.fromLeftSide = fromLeftSide;
    }

    @Override
    public TableActions.TableActionType getActionType() {
      return TableActions.TableActionType.ROW;
    }

    public void execute(EditorContext context) {
      SNode nodeToDelete = getNodeOfRow();

      if (deleteType == DeleteType.BACKSPACE && fromLeftSide && SNodeOperations.getPrevSibling(nodeToDelete) != null) {
        nodeToDelete = SNodeOperations.getPrevSibling(nodeToDelete);
      } else if (deleteType == DeleteType.DELETE && !(fromLeftSide) && SNodeOperations.getNextSibling(nodeToDelete) != null) {
        nodeToDelete = SNodeOperations.getNextSibling(nodeToDelete);
      }

      SNodeOperations.deleteNode(nodeToDelete);
    }
  }

  public static class DeleteColumnAction extends AbstractTableCellAction {

    public DeleteColumnAction(EditorCell cell) {
      this(cell, false);
    }

    public DeleteColumnAction(EditorCell cell, boolean triggeredFromMPSAction) {
      super(cell, triggeredFromMPSAction);
    }

    @Override
    public TableActions.TableActionType getActionType() {
      return TableActions.TableActionType.COLUMN;
    }

    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell_GridCell gridCell = getGridCell();
      if (gridCell == null) {
        return false;
      }
      CellAction action = gridCell.getAction(CellActionType.DELETE);
      // FIXME: how can we better detect that we are in the header?
      return action != null && action.getClass().getName().contains("HeaderGridFactory");
    }


    public void execute(EditorContext context) {
      context.getSelectionManager().setSelection(getGridCell());
      context.getSelectionManager().getSelection().executeAction(CellActionType.DELETE);
    }
  }

}

package de.slisson.mps.tables.runtime.gridmodel;

/*Generated by MPS */

import de.slisson.mps.tables.runtime.simplegrid.ElementFactory;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.slisson.mps.tables.runtime.cells.TableDebug;
import java.util.List;
import de.slisson.mps.tables.runtime.simplegrid.GridPosition;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class GridFlattener {

  public static final ElementFactory<ExpandedPosition> EXPANDED_POSITION_FACTORY = new ElementFactory<ExpandedPosition>() {
    public ExpandedPosition createNewElement() {
      return new ExpandedPosition();
    }
  };

  public static void flatten(Grid grid) {
    new GridFlattener(grid).flatten();
  }

  public static void flattenOneLevel(Grid grid) {
    new GridFlattener(grid).flattenOneLevel();
  }

  private Grid myGrid;
  private Map<Grid, GridHeadersUtil> myHeaderUtils = new HashMap<Grid, GridHeadersUtil>();

  public GridFlattener(Grid grid) {
    myGrid = grid;
  }

  private GridHeadersUtil getGridHeadersUtil(Grid grid) {
    GridHeadersUtil util = myHeaderUtils.get(grid);
    if (util == null) {
      util = new GridHeadersUtil(grid);
      myHeaderUtils.put(grid, util);
    }
    return util;
  }

  protected Tuples._2<Integer, Integer> getRequiredFlatteningSpaceX(int x) {
    int max = 0;
    int additional = 0;
    for (int y = 0; y < myGrid.getSizeY(); y++) {
      IGridElement element = myGrid.getElement(x, y);
      if (element != null && !(element instanceof SpannedPosition) && !(element instanceof UnusedPosition)) {
        max = Math.max(max, 1);
      }
      IGrid childGrid = as_9wl9px_a0a2a2a41(element, IGrid.class);
      if (childGrid != null) {
        max = Math.max(max, Math.max(childGrid.getSizeX(), childGrid.getSpanX()));
        additional = Math.max(additional, childGrid.getSizeX() - childGrid.getSpanX());
      }
    }
    return MultiTuple.<Integer,Integer>from(max, additional);
  }

  protected Tuples._2<Integer, Integer> getRequiredFlatteningSpaceY(int y) {
    int max = 0;
    int additional = 0;
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      IGridElement element = myGrid.getElement(x, y);
      if (element != null && !(element instanceof SpannedPosition) && !(element instanceof UnusedPosition)) {
        max = Math.max(max, 1);
      }
      IGrid childGrid = as_9wl9px_a0a2a2a61(element, IGrid.class);
      if (childGrid != null) {
        max = Math.max(max, Math.max(childGrid.getSizeY(), childGrid.getSpanY()));
        additional = Math.max(additional, childGrid.getSizeY() - childGrid.getSpanY());
      }
    }
    return MultiTuple.<Integer,Integer>from(max, additional);
  }

  protected void combineBeforeFlattening(IGrid grid) {
    for (IGridElement child : Sequence.fromIterable(grid)) {
      if (child != null) {
        child.combineWithParent(grid);
      }
    }
  }

  public void flatten() {
    if (TableDebug.isDebugEnabled()) {
      for (int k = 0; k < 20; k++) {
        TableDebug.sout("########################################################################");
      }
    }

    int i = 0;

    if (TableDebug.isDebugEnabled()) {
      TableDebug.sout("Before flatten " + ": " + myGrid);
    }
    while (!(isFlat())) {
      flatten_();
      if (TableDebug.isDebugEnabled()) {
        TableDebug.sout("After flatten " + i + ": " + myGrid);
      }
      myGrid.checkSpanningConsistencyThrow();
      if (++i >= 1000) {
        throw new RuntimeException("Failed to flatten the grid");
      }
    }
  }

  private boolean isFlat() {
    for (IGridElement element : Sequence.fromIterable(myGrid)) {
      if (element instanceof IGrid) {
        return false;
      }
    }
    return true;
  }

  public Tuples._2<Integer, Integer> calcRequiredAdditionalSpace(int elementX, int elementY) {
    int requiredX = 0;
    int requiredY = 0;
    IGridElement element = myGrid.getElement(elementX, elementY);
    IGrid childGrid = as_9wl9px_a0a3a42(element, IGrid.class);

    if (childGrid != null && childGrid.getSizeX() > childGrid.getSpanX()) {
      int availableX = 0;
      for (int x = 1; x < childGrid.getSizeX(); x++) {
        int targetX = x + elementX;
        int targetY = elementY;
        if (targetX < myGrid.getSizeX()) {
          IGridElement exisiting = myGrid.getElement(targetX, targetY);
          if (exisiting instanceof SpannedPosition || exisiting instanceof ExpandedPosition) {
            availableX++;
            continue;
          }
        }
        break;
      }
      requiredX = childGrid.getSizeX() - availableX - 1 + childGrid.getAlignmentShiftLeft();
    }

    if (childGrid != null && childGrid.getSizeY() > childGrid.getSpanY()) {
      int availableY = 0;
      for (int y = 1; y < childGrid.getSizeY(); y++) {
        int targetX = elementX;
        int targetY = elementY + y;
        if (targetY < myGrid.getSizeY()) {
          IGridElement exisiting = myGrid.getElement(targetX, targetY);
          if (exisiting instanceof SpannedPosition || exisiting instanceof ExpandedPosition) {
            availableY++;
            continue;
          }
        }
        break;
      }
      requiredY = childGrid.getSizeY() - availableY - 1 + childGrid.getAlignmentShiftUp();
    }

    return MultiTuple.<Integer,Integer>from(requiredX, requiredY);
  }

  public void flattenOneLevel() {
    flatten_();
    myGrid.checkSpanningConsistencyThrow();
  }

  private void flatten_() {
    // depth first


    // shift alignment
    int[] maxShiftLeft = createIntArray(myGrid.getSizeX(), 0);
    int[] maxShiftUp = createIntArray(myGrid.getSizeY(), 0);
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        maxShiftLeft[x] = Math.max(maxShiftLeft[x], check_9wl9px_b0a0a0a6a82(as_9wl9px_a0b0a0a0a6a82(myGrid.getElement(x, y), IGrid.class)));
        maxShiftUp[y] = Math.max(maxShiftUp[y], check_9wl9px_b0a1a0a6a82(as_9wl9px_a0b0a1a0a6a82(myGrid.getElement(x, y), IGrid.class)));
      }
    }
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        Grid childGrid = as_9wl9px_a0a0a0a7a82(myGrid.getElement(x, y), Grid.class);
        if (childGrid == null) {
          continue;
        }
        while (childGrid.getAlignmentShiftLeft() < maxShiftLeft[x]) {
          childGrid.insertColumn(0);
          childGrid.setAlignmentShiftLeft(childGrid.getAlignmentShiftLeft() + 1);
        }
        while (childGrid.getAlignmentShiftUp() < maxShiftUp[y]) {
          childGrid.insertRow(0);
          childGrid.setAlignmentShiftUp(childGrid.getAlignmentShiftUp() + 1);
        }
        childGrid.setAlignmentShiftLeft(0);
        childGrid.setAlignmentShiftUp(0);
      }
    }

    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        IGridElement element = myGrid.getElement(x, y);
        if (element instanceof Grid) {

          GridHeaderAligner.alignColumnsAndRows(myGrid, x, y, (Grid) element);
        }
      }
    }

    // First, we insert empty columns/rows into the grid and then expand the child grids into the empty space

    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        Grid childGrid = as_9wl9px_a0a0a0a31a82(myGrid.getElement(x, y), Grid.class);

        if (childGrid != null) {
          int i = 0;
          while (childGrid.getSizeX() > childGrid.getSpanX()) {
            myGrid.insertColumnAndSpan(x + 1);
            if (i++ > 100000) {
              throw new RuntimeException("endless loop");
            }
          }
          i = 0;
          while (childGrid.getSizeY() > childGrid.getSpanY()) {
            myGrid.insertRowAndSpan(y + 1);
            if (i++ > 100000) {
              throw new RuntimeException("endless loop");
            }
          }
        }
      }
    }


    int[] maxSizeX = createIntArray(myGrid.getSizeX(), 1);
    int[] maxSizeY = createIntArray(myGrid.getSizeY(), 1);
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        maxSizeX[x] = Math.max(maxSizeX[x], check_9wl9px_b0a0a0a81a82(as_9wl9px_a0b0a0a0a81a82(myGrid.getElement(x, y), IGrid.class)));
        maxSizeY[y] = Math.max(maxSizeY[y], check_9wl9px_b0a1a0a81a82(as_9wl9px_a0b0a1a0a81a82(myGrid.getElement(x, y), IGrid.class)));
      }
    }


    List<GridPosition> positionsToExpand = ListSequence.fromList(new ArrayList<GridPosition>());
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        IGridElement element = myGrid.getElement(x, y);
        if (!(element instanceof IMetaGridElement)) {
          ListSequence.fromList(positionsToExpand).addElement(new GridPosition(x, y));
        }
      }
    }


    for (GridPosition pos : ListSequence.fromList(positionsToExpand)) {
      expandElement(pos.getX(), pos.getY(), maxSizeX[pos.getX()], maxSizeY[pos.getY()], 0, 0);
      myGrid.checkSpanningConsistencyThrow();
    }

    repairSpanning();

    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        if (myGrid.getElement(x, y) instanceof ExpandedPosition) {
          myGrid.setElement(x, y, new UnusedPosition());
        }
      }
    }
  }

  public void expandElement(int x, int y, int maxSizeX, int maxSizeY, int maxShiftLeft, int maxShiftUp) {
    IGridElement element = myGrid.getElement(x, y);
    int shiftX = maxShiftLeft - check_9wl9px_a0a1a03(as_9wl9px_a0a0a1a03(element, IGrid.class));
    int shiftY = maxShiftUp - check_9wl9px_a0a2a03(as_9wl9px_a0a0a2a03(element, IGrid.class));
    if (element instanceof Grid) {
      Grid childGrid = (Grid) element;
      combineBeforeFlattening(childGrid);

      // make grid the size of its spanning
      while (childGrid.getSizeX() < childGrid.getSpanX()) {
        childGrid.insertColumnAndSpan(childGrid.getSizeX());
      }
      while (childGrid.getSizeY() < childGrid.getSpanY()) {
        childGrid.insertRowAndSpan(childGrid.getSizeY());
      }


      myGrid.replaceElements(x, y, childGrid);
      updateSpanning(x, y, x + Math.max(1, childGrid.getSizeX()) - 1, y + Math.max(1, childGrid.getSizeY()) - 1);
    } else {
    }

    for (int x2 = 0; x2 <= shiftX; x2++) {
      for (int y2 = 0; y2 <= shiftY; y2++) {
        if (x2 == shiftX && y2 == shiftY) {
          continue;
        }
        myGrid.setElement(x + x2, y + y2, new UnusedPosition());
      }
    }
  }

  public void repairSpanning() {
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        IGridElement element = myGrid.getElement(x, y);
        if (element.getSpanX() > 1 || element.getSpanY() > 1) {
          for (int i = 0; i < element.getSpanX(); i++) {
            for (int k = 0; k < element.getSpanY(); k++) {
              if (i == 0 && k == 0) {
                continue;
              }
              SpannedPosition newInfo = new SpannedPosition(element, new GridPosition(x, y));
              myGrid.setElement(x + i, y + k, newInfo);
            }
          }
        }
      }
    }
  }

  private void updateSpanning(int fromX, int fromY, int toX, int toY) {
    int newSpanX = toX - fromX + 1;
    int newSpanY = toY - fromY + 1;
    for (int x = toX + 1; x < myGrid.getSizeX(); x++) {
      if (myGrid.getElement(x, fromY) instanceof ExpandedPosition) {
        newSpanX++;
      } else {
        break;
      }
    }
    for (int y = toY + 1; y < myGrid.getSizeY(); y++) {
      if (myGrid.getElement(fromX, y) instanceof ExpandedPosition) {
        newSpanY++;
      } else {
        break;
      }
    }
    updateSpanning(fromX, fromY, toX, toY, fromX + newSpanX - 1, fromY + newSpanY - 1);
  }

  private void updateSpanning(int fromX, int fromY, int toX, int toY, int spanToX, int spanToY) {
    if (fromX > toX) {
      System.out.println("grid: " + myGrid);
      throw new IllegalArgumentException();
    }
    if (fromY > toY) {
      System.out.println("grid: " + myGrid);
      throw new IllegalArgumentException();
    }
    if (spanToX < toX) {
      System.out.println("grid: " + myGrid);
      throw new IllegalArgumentException();
    }
    if (spanToY < toY) {
      System.out.println("grid: " + myGrid);
      throw new IllegalArgumentException();
    }
    for (int y = fromY; y <= spanToY; y++) {
      for (int x = fromX; x <= spanToX; x++) {
        if (x <= toX && y <= toY) {
          IGridElement element = myGrid.getElement(x, y);
          if (element instanceof SpannedPosition) {
            SpannedPosition spanInfo = (SpannedPosition) element;
            GridPosition oldStart = spanInfo.getSpanningStart();
            GridPosition newStart = new GridPosition(fromX + oldStart.getX(), fromY + oldStart.getY());
            spanInfo.setSpaningStart(newStart);
          }
        } else {
          if (myGrid.getElement(fromX, fromY) == null) {
            TableDebug.sout("grid with null element at [" + fromX + "," + fromY + "]: " + myGrid);
          }
          SpannedPosition spanInfo = new SpannedPosition(myGrid.getElement(fromX, fromY), new GridPosition(fromX, fromY));
          IGridElement spanningElement = spanInfo.getSpanningElement();
          TableDebug.sout("setSpanX " + Math.max(spanningElement.getSpanX(), x - spanInfo.getSpanningStart().getX()));
          TableDebug.sout("setSpanY " + Math.max(spanningElement.getSpanY(), y - spanInfo.getSpanningStart().getY()));
          spanningElement.setSpanX(Math.max(spanningElement.getSpanX(), x - spanInfo.getSpanningStart().getX()));
          spanningElement.setSpanY(Math.max(spanningElement.getSpanY(), y - spanInfo.getSpanningStart().getY()));
          myGrid.setElement(x, y, spanInfo);
        }
      }
    }
  }

  public static int[] createIntArray(int size, int defaultValue) {
    int[] result = new int[size];
    for (int i = 0; i < size; i++) {
      result[i] = defaultValue;
    }
    return result;
  }

  private static int check_9wl9px_b0a0a0a6a82(IGrid checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAlignmentShiftLeft();
    }
    return 0;
  }
  private static int check_9wl9px_b0a1a0a6a82(IGrid checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAlignmentShiftUp();
    }
    return 0;
  }
  private static int check_9wl9px_b0a0a0a81a82(IGrid checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSizeX();
    }
    return 0;
  }
  private static int check_9wl9px_b0a1a0a81a82(IGrid checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSizeY();
    }
    return 0;
  }
  private static int check_9wl9px_a0a1a03(IGrid checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAlignmentShiftLeft();
    }
    return 0;
  }
  private static int check_9wl9px_a0a2a03(IGrid checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAlignmentShiftUp();
    }
    return 0;
  }
  private static <T> T as_9wl9px_a0a2a2a41(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0a2a2a61(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0a3a42(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0b0a0a0a6a82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0b0a1a0a6a82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0a0a0a7a82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0a0a0a31a82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0b0a0a0a81a82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0b0a1a0a81a82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0a0a1a03(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_9wl9px_a0a0a2a03(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.slisson.mps.tables.runtime.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import java.util.NoSuchElementException;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.slisson.mps.tables.runtime.selection.TableRangeSelection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SNodeMatcher;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;

public class TableTransformationManager {

  public static SNode dataToNode(final SNode tableNode, String data, final EditorContext editorContext) {
    List<DataTransformer> transformers = Sequence.fromIterable(new ExtensionPoint<DataTransformer>("de.slisson.mps.tables.runtime.DataTransformation").getObjects()).where((it) -> it.isApplicable(tableNode, editorContext)).sort((it) -> it.getPriority(), false).toList();
    if (transformers == null) {
      throw new NoSuchElementException("No table data transformer found");
    }

    for (DataTransformer transformer : ListSequence.fromList(transformers)) {
      transformer.setTable(tableNode);
      SNode parsedNode = transformer.fromString(data);
      if ((parsedNode != null)) {
        return parsedNode;
      }
    }

    return null;
  }

  public static String nodeToData(TableRangeSelection selection, final SNode node, final EditorContext editorContext) {
    final SNode tableNode = selection.getTable().getSNode();
    DataTransformer transformer = Sequence.fromIterable(new ExtensionPoint<DataTransformer>("de.slisson.mps.tables.runtime.DataTransformation").getObjects()).where((it) -> it.isApplicable(tableNode, editorContext)).sort((it) -> it.getPriority(), false).last();
    if (transformer == null) {
      if ((node == null)) {
        return "";
      }

      EditorCell nodeCell = ListSequence.fromList(selection.getSelectedGridCells()).findFirst((it) -> {
        SNode gridNode = it.getSNode();
        return ListSequence.fromList(SNodeOperations.getNodeDescendants(gridNode, null, true, new SAbstractConcept[]{})).any(new _FunctionTypes._return_P1_E0<Boolean, SNode>() {
          public Boolean invoke(SNode it) {
            return new SNodeMatcher().match(it, node);
          }
        });
      });
      if (nodeCell == null) {
        // fall back to string representation
        return BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(node);
      }

      String text = nodeCell.renderText().getText();
      return text;
    }

    transformer.setTable(tableNode);
    return transformer.asString(selection, node, editorContext);
  }

  public static TableData<SNode> stringDataToNodeData(final SNode table, TableData<String> tableData, final EditorContext editorContext) {
    return tableData.map((data) -> dataToNode(table, data, editorContext));
  }

  public static TableData<String> nodeDataToStringData(final TableRangeSelection selection, TableData<SNode> tableData, final EditorContext editorContext) {
    return tableData.map((data) -> nodeToData(selection, data, editorContext));
  }
}

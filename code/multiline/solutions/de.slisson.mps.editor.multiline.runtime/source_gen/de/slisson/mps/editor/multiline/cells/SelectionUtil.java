package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;

public class SelectionUtil {
  public static EditorCell getUpper(EditorCell cell) {
    return new NextAboveCellFinder(cell).getNextVerticalCell();
  }

  public static EditorCell getLower(EditorCell cell) {
    return new NextBelowCellFinder(cell).getNextVerticalCell();
  }

  private static abstract class NextVerticalCellFinder {
    private EditorCell myStartCell;

    private NextVerticalCellFinder(EditorCell startCell) {
      myStartCell = startCell;
    }
    /*package*/ EditorCell getNextVerticalCell() {
      EditorCell bestMatch = null;
      Condition<EditorCell> condition = (EditorCell c) -> c.isSelectable() && isOnTheNextLine(myStartCell, c);

      for (EditorCell nextCandidate = getNextCandidate(myStartCell, condition); nextCandidate != null; nextCandidate = getNextCandidate(nextCandidate, condition)) {
        if (bestMatch != null && isOnTheNextLine(bestMatch, nextCandidate)) {
          break;
        }
        if (bestMatch == null || GeometryUtil.getHorizontalDistance(bestMatch, myStartCell.getCaretX()) > GeometryUtil.getHorizontalDistance(nextCandidate, myStartCell.getCaretX())) {
          bestMatch = nextCandidate;
        }
      }
      return bestMatch;
    }
    protected abstract EditorCell getNextCandidate(EditorCell currentCandidate, Condition<EditorCell> condition);

    protected abstract boolean isOnTheNextLine(EditorCell originalCell, EditorCell candidate);
  }

  private static class NextAboveCellFinder extends NextVerticalCellFinder {

    private NextAboveCellFinder(EditorCell startCell) {
      super(startCell);
    }
    @Override
    protected EditorCell getNextCandidate(EditorCell currentCandidate, Condition<EditorCell> condition) {
      return CellTraversalUtil.getPrevLeaf(currentCandidate, condition);
    }
    @Override
    protected boolean isOnTheNextLine(EditorCell originalCell, EditorCell candidate) {
      return GeometryUtil.isAbove(candidate, originalCell);
    }
  }

  private static class NextBelowCellFinder extends NextVerticalCellFinder {

    private NextBelowCellFinder(EditorCell startCell) {
      super(startCell);
    }
    @Override
    protected EditorCell getNextCandidate(EditorCell currentCandidate, Condition<EditorCell> condition) {
      return CellTraversalUtil.getNextLeaf(currentCandidate, condition);
    }
    @Override
    protected boolean isOnTheNextLine(EditorCell originalCell, EditorCell candidate) {
      return GeometryUtil.isAbove(originalCell, candidate);
    }
  }
}

package org.modelix.model.mpsadapters.mps;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.logging.Logger;
import org.modelix.model.api.ContextValue;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.modelix.model.api.INode;
import org.jetbrains.mps.openapi.module.SRepository;
import com.google.common.collect.MapMaker;
import kotlin.Unit;
import jetbrains.mps.util.Computable;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModel;
import org.modelix.model.api.NodeUtilKt;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.language.SConcept;
import org.modelix.model.api.IConcept;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.modelix.model.api.INodeKt;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.model.ResolveInfo;
import org.jetbrains.mps.openapi.language.SProperty;
import java.util.Objects;
import java.util.Collections;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.util.IterableUtil;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class NodeToSNodeAdapter implements SNode {
  private static final Logger LOG = Logger.getLogger(NodeToSNodeAdapter.class);

  private static ContextValue<InstancesCache> currentCache = new ContextValue<InstancesCache>();
  public static class InstancesCache {
    public InstancesCache() {
    }
    private final Map<Tuples._2<INode, SRepository>, NodeToSNodeAdapter> instances = new MapMaker().weakValues().makeMap();

  }

  public static void runWithCache(InstancesCache cache, final Runnable runnable) {
    currentCache.computeWith(cache, () -> {
      runnable.run();
      return Unit.INSTANCE;
    });
  }

  public static <T> T computeWithCache(InstancesCache cache, final Computable<T> computable) {
    return currentCache.computeWith(cache, () -> computable.compute());
  }

  private static NodeToSNodeAdapter getInstance(INode node, SRepository repository) {
    InstancesCache cache = currentCache.getValue();
    if (cache == null) {
      return new NodeToSNodeAdapter(node, repository);
    }

    Tuples._2<INode, SRepository> key = MultiTuple.<INode,SRepository>from(node, repository);
    NodeToSNodeAdapter instance = cache.instances.get(key);
    if (instance == null) {
      instance = new NodeToSNodeAdapter(node, repository);
      cache.instances.put(key, instance);
    }
    return instance;
  }

  public static void clearInstancesCache() {
    InstancesCache cache = currentCache.getValue();
    if (cache != null) {
      cache.instances.clear();
    }
  }

  public static SNode wrap(INode nodeToWrap) {
    return wrap(nodeToWrap, null);
  }

  public static SNode wrap(INode nodeToWrap, SRepository repository) {
    if (nodeToWrap == null) {
      return null;
    }
    if (nodeToWrap instanceof SNodeToNodeAdapter) {
      return ((SNodeToNodeAdapter) nodeToWrap).getWrapped();
    }
    return getInstance(nodeToWrap, repository);
  }

  public static SNode wrap(SNode nodeToWrap) {
    // Makes code generation easier. wrap can always be applied to ensure a value is an SNode.
    return nodeToWrap;
  }

  private INode node;
  private SRepository repository;
  private Object[] userObjects = null;
  private NodeReference nodeReference = new NodeReference();
  private NodeId nodeId = new NodeId();
  private EModelMode modelMode = EModelMode.NULL;

  protected NodeToSNodeAdapter(INode node1, SRepository repository) {
    if (node1.getConcept() == null) {
      throw new RuntimeException("Node has no concept: " + node1);
    }
    node = node1;
    this.repository = repository;
  }

  public void setModelMode(@NotNull EModelMode mode) {
    this.modelMode = mode;
  }

  protected SNode wrap_(INode nodeToWrap) {
    SNode wrapped = wrap(nodeToWrap, repository);
    if (wrapped instanceof NodeToSNodeAdapter) {
      ((NodeToSNodeAdapter) wrapped).setModelMode(modelMode);
    }
    return wrapped;
  }

  public INode getWrapped() {
    return node;
  }

  @Nullable
  @Override
  public SModel getModel() {
    switch (modelMode) {
      case NULL:
        return null;
      case ADAPTER:
        INode modelNode = NodeUtilKt.getAncestor(this.node, SConceptAdapter.wrap(CONCEPTS.Model$2P), false);
        if (modelNode == null) {
          return null;
        }
        return NodeToSModelAdapter.wrap(modelNode, repository);
      default:
        throw new RuntimeException("Unknown mode: " + modelMode);
    }
  }
  @Override
  public SNodeId getNodeId() {
    return nodeId;
  }
  @NotNull
  @Override
  public SNodeReference getReference() {
    return nodeReference;
  }
  @NotNull
  @Override
  public SConcept getConcept() {
    IConcept concept = node.getConcept();
    if (concept instanceof SConceptAdapter) {
      return (SConcept) ((SConceptAdapter) concept).getAdapted();
    }
    SAbstractConcept sConcept = BootstrapConceptMappings.INSTANCE.getSConcept(concept);
    if (sConcept instanceof SConcept) {
      return (SConcept) sConcept;
    }
    return CONCEPTS.BaseConcept$gP;
  }
  @Override
  public boolean isInstanceOfConcept(@NotNull SAbstractConcept concept) {
    return getConcept().isSubConceptOf(concept);
  }
  @Override
  public String getPresentation() {
    SNode snode = this;
    String presentation = null;
    try {
      presentation = BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(snode);
    } catch (Exception ex) {
      if (LOG.isDebugLevel()) {
        LOG.debug("", ex);
      }
    }
    try {
      if (presentation == null && this.isInstanceOfConcept(CONCEPTS.INamedConcept$Kd)) {
        presentation = getProperty(PROPS.name$MnvL);
      }
    } catch (Exception ex) {
      if (LOG.isDebugLevel()) {
        LOG.debug("", ex);
      }
    }
    if (presentation == null) {
      presentation = toString();
    }
    return presentation;
  }
  @Nullable
  @Override
  public String getName() {
    return node.getPropertyValue("name");
  }
  @Override
  public void addChild(@NotNull SContainmentLink link, @NotNull SNode child) {
    INodeKt.moveChild(node, new SContainmentLinkAdapter(link), -1, SNodeToNodeAdapter.wrap(child));
  }
  @Override
  public void insertChildBefore(@NotNull SContainmentLink link, @NotNull SNode child, @Nullable SNode anchor) {
    if (anchor == null) {
      addChild(link, child);
      return;
    }
    Iterable<SNode> children = (Iterable<SNode>) getChildren(link);
    int index = Sequence.fromIterable(children).indexOf(anchor);
    INodeKt.moveChild(this.node, new SContainmentLinkAdapter(link), index, SNodeToNodeAdapter.wrap(child));
  }
  @Override
  public void insertChildAfter(@NotNull SContainmentLink link, @NotNull SNode child, @Nullable SNode anchor) {
    if (anchor == null) {
      addChild(link, child);
      return;
    }
    Iterable<SNode> children = (Iterable<SNode>) getChildren(link);
    int index = Sequence.fromIterable(children).indexOf(anchor);
    INodeKt.moveChild(this.node, new SContainmentLinkAdapter(link), index + 1, SNodeToNodeAdapter.wrap(child));

  }
  @Override
  public void removeChild(@NotNull SNode node) {
    this.node.removeChild(SNodeToNodeAdapter.wrap(node));
  }
  @Override
  public void delete() {
    node.getParent().removeChild(node);
  }
  @Nullable
  @Override
  public SNode getParent() {
    INode parent = node.getParent();
    if (parent == null) {
      return null;
    }
    if (parent.getConcept() == null) {
      return null;
    }
    SNode result = wrap_(parent);
    return result;
  }
  @NotNull
  @Override
  public SNode getContainingRoot() {
    INode n1;
    INode n2 = node;
    do {
      n1 = n2;
      n2 = n1.getParent();
    } while (n2 != null);
    return wrap_(n1);
  }
  @Nullable
  @Override
  public SContainmentLink getContainmentLink() {
    SContainmentLinkAdapter link = as_r4r1yj_a0a0a84(INodeKt.getContainmentLink(this.node), SContainmentLinkAdapter.class);
    return (link == null ? null : link.getLink());
  }
  @Nullable
  @Override
  public SNode getFirstChild() {
    Iterable<INode> allChildren = node.getAllChildren();
    return wrap_(Sequence.fromIterable(allChildren).first());
  }
  @Nullable
  @Override
  public SNode getLastChild() {
    Iterable<INode> allChildren = node.getAllChildren();
    return wrap_(Sequence.fromIterable(allChildren).last());
  }
  @Nullable
  @Override
  public SNode getPrevSibling() {
    INode parent = node.getParent();
    if (parent == null) {
      return null;
    }
    INode sibling1 = null;
    INode sibling2 = null;
    for (INode sibling : Sequence.fromIterable(parent.getAllChildren())) {
      sibling1 = sibling2;
      sibling2 = sibling;
      if (node.equals(sibling2)) {
        SNode result = wrap_(sibling1);
        return result;
      }
    }
    return null;
  }
  @Nullable
  @Override
  public SNode getNextSibling() {
    INode parent = node.getParent();
    if (parent == null) {
      return null;
    }
    INode sibling1 = null;
    INode sibling2 = null;
    for (INode sibling : Sequence.fromIterable(parent.getAllChildren())) {
      sibling1 = sibling2;
      sibling2 = sibling;
      if (node.equals(sibling1)) {
        SNode result = wrap_(sibling2);
        return result;
      }
    }
    return null;
  }
  @NotNull
  @Override
  public Iterable<? extends SNode> getChildren(SContainmentLink link) {
    Iterable<INode> children = INodeKt.getChildren(this.node, new SContainmentLinkAdapter(link));
    return Sequence.fromIterable(children).select((it) -> wrap_(it));
  }
  @NotNull
  @Override
  public Iterable<? extends SNode> getChildren() {
    Iterable<INode> allChildren = node.getAllChildren();
    return Sequence.fromIterable(allChildren).select((it) -> wrap_(it));

  }
  @Override
  public void setReferenceTarget(@NotNull SReferenceLink link, @Nullable SNode target) {
    INodeKt.setReferenceTarget(this.node, new SReferenceLinkAdapter(link), SNodeToNodeAdapter.wrap(target));
  }
  @Nullable
  @Override
  public SNode getReferenceTarget(@NotNull SReferenceLink link) {
    return wrap_(INodeKt.getReferenceTarget(this.node, new SReferenceLinkAdapter(link)));
  }
  @Nullable
  @Override
  public SReference getReference(@NotNull final SReferenceLink link) {
    return new Reference(link);
  }
  @Override
  public void setReference(@NotNull SReferenceLink link, @Nullable SReference reference) {
    throw new UnsupportedOperationException("Not implemented");
  }
  @Override
  public void setReference(@NotNull SReferenceLink link, ResolveInfo info) {
    throw new UnsupportedOperationException("Not implemented");
  }
  @Override
  public void setReference(@NotNull SReferenceLink link, @NotNull SNodeReference reference) {
    throw new UnsupportedOperationException("Not implemented");
  }
  @Override
  public void dropReference(@NotNull SReferenceLink link) {
    throw new UnsupportedOperationException("Not implemented");
  }
  @NotNull
  @Override
  public Iterable<? extends SReference> getReferences() {
    Iterable<SReferenceLink> links = SConceptAdapter.unwrap(node.getConcept()).getReferenceLinks();
    return Sequence.fromIterable(links).where((it) -> getReferenceTarget(it) != null).select((it) -> new Reference(it));
  }
  @NotNull
  @Override
  public Iterable<SProperty> getProperties() {
    Iterable<SProperty> allProperties = SConceptAdapter.unwrap(node.getConcept()).getProperties();
    return Sequence.fromIterable(allProperties).where((it) -> getProperty(it) != null);
  }
  @Override
  public boolean hasProperty(@NotNull SProperty property) {
    return getProperty(property) != null;
  }
  @Nullable
  @Override
  public String getProperty(@NotNull SProperty property) {
    return INodeKt.getPropertyValue(this.node, new SPropertyAdapter(property));
  }
  @Override
  public void setProperty(@NotNull SProperty property, @Nullable String value) {
    INodeKt.setPropertyValue(this.node, new SPropertyAdapter(property), value);
  }
  @Override
  public Object getUserObject(Object key) {
    if (userObjects != null) {
      for (int i = 0; i < userObjects.length; i += 2) {
        if (Objects.equals(userObjects[i], key)) {
          return userObjects[i + 1];
        }
      }
    }
    return null;
  }
  @Override
  public void putUserObject(Object key, @Nullable Object value) {
    if (userObjects != null) {
      for (int i = 0; i < userObjects.length; i += 2) {
        if (Objects.equals(userObjects[i], key)) {
          userObjects[i + 1] = value;
          return;
        }
      }

      Object[] newArray = new Object[userObjects.length + 2];
      System.arraycopy(userObjects, 0, newArray, 0, userObjects.length);
      newArray[newArray.length - 2] = key;
      newArray[newArray.length - 1] = value;
      userObjects = newArray;
    } else {
      userObjects = new Object[]{key, value};
    }
  }
  @Override
  public Iterable<Object> getUserObjectKeys() {
    if (userObjects == null) {
      return Collections.emptyList();
    }
    List<Object> result = ListSequence.fromList(new ArrayList<Object>(userObjects.length / 2));
    for (int i = 0; i < userObjects.length; i += 2) {
      ListSequence.fromList(result).addElement(userObjects[i]);
    }
    return result;
  }
  @Deprecated
  @Override
  public String getRoleInParent() {
    return check_r4r1yj_a0a96(getContainmentLink(), this);
  }
  @Deprecated
  @Override
  public boolean hasProperty(String name) {
    return hasProperty(findProperty(name));
  }
  @Deprecated
  @Override
  public String getProperty(String string) {
    return getProperty(findProperty(string));
  }
  @Deprecated
  @Override
  public void setProperty(String string, String string1) {
    setProperty(findProperty(string), string1);
  }
  @Deprecated
  @Override
  public Iterable<String> getPropertyNames() {
    Iterable<SProperty> properties = getProperties();
    return Sequence.fromIterable(properties).select((it) -> it.getName());
  }
  @Deprecated
  @Override
  public void setReferenceTarget(String string, @Nullable SNode node) {
    setReferenceTarget(findReferenceLink(string), node);
  }
  @Deprecated
  @Override
  public SNode getReferenceTarget(String role) {
    return getReferenceTarget(findReferenceLink(role));
  }
  protected SReferenceLink findReferenceLink(final String name) {
    Iterable<SReferenceLink> links = getConcept().getReferenceLinks();
    SReferenceLink link = Sequence.fromIterable(links).findFirst((it) -> Objects.equals(it.getName(), name));
    if (link == null) {
      throw new RuntimeException(getConcept().getName() + " doesn't have a reference link '" + name + "'");
    }
    return link;
  }
  protected SContainmentLink findChildLink(final String name) {
    Iterable<SContainmentLink> links = getConcept().getContainmentLinks();
    SContainmentLink link = Sequence.fromIterable(links).findFirst((it) -> Objects.equals(it.getName(), name));
    if (link == null) {
      throw new RuntimeException(getConcept().getName() + " doesn't have a child link '" + name + "'");
    }
    return link;
  }
  protected SProperty findProperty(final String name) {
    Iterable<SProperty> properties = getConcept().getProperties();
    SProperty property = Sequence.fromIterable(properties).findFirst((it) -> Objects.equals(it.getName(), name));
    if (property == null) {
      throw new RuntimeException(getConcept().getName() + " doesn't have a property '" + name + "'");
    }
    return property;
  }
  @Deprecated
  @Override
  public SReference getReference(String role) {
    return getReference(findReferenceLink(role));
  }
  @Deprecated
  @Override
  public void setReference(String string, @Nullable SReference reference) {
    setReference(findReferenceLink(string), reference);
  }
  @Deprecated
  @Override
  public void insertChildBefore(String role, SNode newChild, @Nullable SNode anchor) {
    SContainmentLink link = findChildLink(role);
    Iterable<INode> children = IterableUtil.asIterable(node.getChildren(role).iterator());
    int index = -1;
    if (anchor != null) {
      index = Sequence.fromIterable(children).indexOf(SNodeToNodeAdapter.wrap(anchor));
      if (index == -1) {
        throw new RuntimeException(anchor + " is not a child of " + node);
      }
    }
    INodeKt.addNewChild(this.node, new SContainmentLinkAdapter(link), index, SConceptAdapter.wrap(newChild.getConcept()));
  }
  @Deprecated
  @Override
  public void addChild(String string, SNode node) {
    addChild(findChildLink(string), node);
  }
  @Deprecated
  @Override
  @NotNull
  public List<jetbrains.mps.smodel.SNode> getChildren(String string) {
    Iterable<jetbrains.mps.smodel.SNode> children = (Iterable<jetbrains.mps.smodel.SNode>) getChildren(findChildLink(string));
    return Sequence.fromIterable(children).toList();
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    NodeToSNodeAdapter that = (NodeToSNodeAdapter) o;
    if ((node != null ? !(node.equals(that.node)) : that.node != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((node != null ? ((Object) node).hashCode() : 0));
    return result;
  }

  @Override
  public String toString() {
    return "NodeToSNodeAdapter[" + this.node + "]";
  }

  public class NodeReference implements SNodeReference {
    @Nullable
    @Override
    public SNode resolve(SRepository repository) {
      return NodeToSNodeAdapter.this;
    }

    @Nullable
    @Override
    public SModelReference getModelReference() {
      return null;
    }

    @Override
    public SNodeId getNodeId() {
      return nodeId;
    }
    @Override
    public String toString() {
      return ":" + node.getReference().toString();
    }
    @Override
    public int hashCode() {
      return NodeToSNodeAdapter.this.hashCode();
    }
    @Override
    public boolean equals(Object otherObject) {
      if (otherObject instanceof NodeReference) {
        NodeReference otherRef = ((NodeReference) otherObject);
        return getNode().equals(otherRef.getNode());
      } else {
        return false;
      }
    }
    public NodeToSNodeAdapter getNode() {
      return NodeToSNodeAdapter.this;
    }
  }

  public class NodeId implements SNodeId {
    @Override
    public String getType() {
      return "shadowmodelsAdapter";
    }
    @Override
    public String toString() {
      return ":" + node.getReference().toString();
    }
  }

  public class Reference implements SReference {
    private SReferenceLink link;
    public Reference(SReferenceLink link) {
      this.link = link;
    }
    @Deprecated
    public String getRole() {
      return getLink().getName();
    }
    public SReferenceLink getLink() {
      return link;
    }
    public SNode getSourceNode() {
      return NodeToSNodeAdapter.this;
    }
    public SNode getTargetNode() {
      return getReferenceTarget(link);
    }
    public SNodeReference getTargetNodeReference() {
      SNode targetNode = getTargetNode();
      return check_r4r1yj_a1a6rd(targetNode);
    }
    @Nullable
    public SModelReference getTargetSModelReference() {
      SNode targetNode = getTargetNode();
      SModel model = check_r4r1yj_a0b0h59(targetNode);
      return (model == null ? null : model.getReference());
    }
    @Nullable
    public SNodeId getTargetNodeId() {
      return getTargetNode().getNodeId();
    }

  }

  private static String check_r4r1yj_a0a96(SContainmentLink checkedDotOperand, NodeToSNodeAdapter checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static SNodeReference check_r4r1yj_a1a6rd(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getReference();
    }
    return null;
  }
  private static SModel check_r4r1yj_a0b0h59(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModel();
    }
    return null;
  }
  private static <T> T as_r4r1yj_a0a0a84(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Model$2P = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, "org.modelix.model.repositoryconcepts.structure.Model");
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}

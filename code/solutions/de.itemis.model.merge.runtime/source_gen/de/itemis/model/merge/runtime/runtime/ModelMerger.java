package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.collect.ImmutableMap;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.google.common.collect.BiMap;
import java.util.Map;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import java.util.List;
import com.google.common.collect.Iterables;
import java.util.Collections;
import java.util.LinkedList;
import com.google.common.collect.Lists;
import java.util.Set;
import com.google.common.collect.Sets;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import com.google.common.collect.Multimap;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.Collection;
import org.jetbrains.mps.openapi.language.SConcept;
import com.google.common.collect.ImmutableMultimap;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.HashSet;
import com.google.common.collect.ImmutableBiMap;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import java.util.Optional;
import com.google.common.collect.HashBiMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import org.jetbrains.annotations.Nullable;
import java.util.stream.Stream;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

/**
 * Given a ModelMergePolicy it will merge a list of two root nodes accordingly
 */
public class ModelMerger {
  private static final String EMPTY_STR = "";
  private static final String MERGEDID_KEY = "MERGEID";
  public static final String ORIGINAL_KEY = "ORIGINAL";
  private boolean debug = true;
  private int indent = 0;

  public SModel outputModel;
  private MergerResolverImpl resolvedMergingPolicy;
  private SNode policy;
  private ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction;

  private BiMap<String, SNode> idToLeftNodes;
  private BiMap<String, SNode> idToRightNodes;
  private Map<String, SNode> idToResultNodes;
  private Map<String, MergedNode> idToMergedNodes;

  public static ModelMerger create(SNode mergingPolicy) {
    MergerResolverImpl modelMergeResult = PolicyMergerResolver.run(mergingPolicy, new ContentHolderFactoryExtension(mergingPolicy));

    return new ModelMerger(modelMergeResult, mergingPolicy);
  }

  public ModelMerger(MergerResolverImpl resolvedPolicy, SNode mergingPolicy) {
    this.policy = mergingPolicy;
    if (SLinkOperations.getTarget(policy, LINKS.rootPolicies$AdrT) == null) {
      SLinkOperations.setTarget(this.policy, LINKS.rootPolicies$AdrT, defaultRootPolicies());
    }

    this.resolvedMergingPolicy = resolvedPolicy;
    ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction = resolvedPolicy.conceptToIdFunction();
    ImmutableMap.Builder<SAbstractConcept, Identity> builder = ImmutableMap.<SAbstractConcept,Identity>builder();
    for (Map.Entry<SAbstractConcept, Identity> e : SetSequence.fromSet(conceptToIdFunction.entrySet())) {
      final SAbstractConcept concept = e.getKey();
      final Identity identity = e.getValue();
      builder.put(concept, (SNode n) -> identity.get(n) + concept);
    }
    this.conceptToIdFunction = builder.build();
  }

  private SNode defaultRootPolicies() {
    SNode rmp = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(CONCEPTS.RootMergingPolicy$9P));
    SLinkOperations.setTarget(SLinkOperations.getTarget(rmp, LINKS.existingInBothSides$HAOr), LINKS.action$nr8l, SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(CONCEPTS.Auto$g6)));
    SLinkOperations.setTarget(SLinkOperations.getTarget(rmp, LINKS.existingOnlyLeft$O_fB), LINKS.action$nr8l, SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(CONCEPTS.Drop$fB)));
    SLinkOperations.setTarget(SLinkOperations.getTarget(rmp, LINKS.existingOnlyRight$mCmD), LINKS.action$nr8l, SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(CONCEPTS.Add$Cr)));
    return rmp;
  }

  public Iterable<MergedNode> merge(Iterable<SNode> leftRoots, Iterable<SNode> rightRoots) {
    idToLeftNodes = idToNodes(leftRoots);
    idToRightNodes = idToNodes(rightRoots);
    idToMergedNodes = MapSequence.fromMap(new HashMap<String, MergedNode>());
    mergeInternal(leftRoots, rightRoots);

    mergeAllReferences();


    if (outputModel != null && ListSequence.fromList(SModelOperations.roots(outputModel, null)).isEmpty()) {
      addRootsIntoOutputModel();
      return Sequence.fromIterable(MapSequence.fromMap(idToMergedNodes).values()).where((it) -> isRoot(it.node));
    }

    if (outputModel != null && ListSequence.fromList(SModelOperations.roots(outputModel, null)).isNotEmpty()) {
      idToResultNodes = pickSideForResults(leftRoots, rightRoots, idToLeftNodes, idToRightNodes);

      removeNodesFromOutputModel();

      updateNodesInOutputModel();

      addRootsIntoOutputModel();
    }

    return Sequence.fromIterable(MapSequence.fromMap(idToMergedNodes).values()).where((it) -> isRoot(it.node));
  }

  private void removeNodesFromOutputModel() {
    MapSequence.fromMap(idToResultNodes).where((it) -> isRoot(it.value())).visitAll((it) -> {
      if (!(MapSequence.fromMap(idToMergedNodes).containsKey(it.key()))) {
        SNodeOperations.deleteNode(it.value());
      }
    });
  }

  private void updateNodesInOutputModel() {
    MapSequence.fromMap(idToResultNodes).visitAll((idToRoot) -> {
      if (MapSequence.fromMap(idToMergedNodes).containsKey(idToRoot.key())) {
        jetbrains.mps.smodel.SNode mergedNode = (jetbrains.mps.smodel.SNode) MapSequence.fromMap(idToMergedNodes).get(idToRoot.key()).node;
        mergedNode.setId(((jetbrains.mps.smodel.SNode) idToRoot.value()).getNodeId());
        if (isRoot(idToRoot.value())) {
          SNodeOperations.replaceWithAnother(idToRoot.value(), mergedNode);
        }
      }
    });
  }

  private void addRootsIntoOutputModel() {
    MapSequence.fromMap(idToMergedNodes).where((it) -> isRoot(it.value().node)).visitAll((it) -> {
      if (!(MapSequence.fromMap(idToResultNodes).containsKey(it.key()))) {
        SModelOperations.addRootNode(outputModel, it.value().node);
      }
    });
  }


  private BiMap<String, SNode> pickSideForResults(Iterable<SNode> leftRoots, Iterable<SNode> rightRoots, BiMap<String, SNode> idToLeftNodes, BiMap<String, SNode> idToRightNodes) {
    if (Sequence.fromIterable(leftRoots).isNotEmpty() && SNodeOperations.getModel(Sequence.fromIterable(leftRoots).first()) == outputModel) {
      return idToLeftNodes;
    } else if (Sequence.fromIterable(rightRoots).isNotEmpty() && SNodeOperations.getModel(Sequence.fromIterable(rightRoots).first()) == outputModel) {
      return (SNodeOperations.getModel(Sequence.fromIterable(leftRoots).first()) == outputModel ? idToLeftNodes : idToRightNodes);
    } else {
      return idToNodes(SModelOperations.roots(outputModel, null));
    }
  }

  private boolean isRoot(SNode localNode) {
    return Objects.equals(localNode, SNodeOperations.getContainingRoot(localNode));
  }


  private Iterable<MergedNode> mergeInternal(final Iterable<SNode> leftRoots, final Iterable<SNode> rightRoots) {
    List<SNode> leftOnly = Sequence.fromIterable(leftRoots).where((it) -> findMatchingRoot(idOf(it), rightRoots) == null).toList();
    List<SNode> rightOnly = Sequence.fromIterable(rightRoots).where((it) -> findMatchingRoot(idOf(it), leftRoots) == null).toList();

    Iterable<MergedNode> mergedFromLeft = mergeRootsFromLeft(leftOnly);

    Iterable<MergedNode> mergedFromRight = mergeRootsFromRight(rightOnly);

    Iterable<MergedNode> mergedBothSides = mergeRootsFromBothSides(leftRootsInBothSides(leftRoots, leftOnly), rightRootsInBothSides(rightRoots, rightOnly));


    return Iterables.concat(mergedBothSides, mergedFromLeft, mergedFromRight);
  }

  private Iterable<SNode> rightRootsInBothSides(Iterable<SNode> rightRootNodes, Iterable<SNode> rightOnlyRoots) {
    return Sequence.fromIterable(rightRootNodes).subtract(Sequence.fromIterable(rightOnlyRoots));
  }

  private Iterable<SNode> leftRootsInBothSides(Iterable<SNode> leftRootNodes, Iterable<SNode> leftOnlyRoots) {
    return Sequence.fromIterable(leftRootNodes).subtract(Sequence.fromIterable(leftOnlyRoots));
  }

  private Iterable<MergedNode> mergeRootsFromLeft(Iterable<SNode> rootsLeft) {
    SNode action = SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(policy, LINKS.rootPolicies$AdrT), LINKS.existingOnlyLeft$O_fB), LINKS.action$nr8l);
    return mergeOneSideOnly(rootsLeft, action);
  }

  private Iterable<MergedNode> mergeRootsFromRight(Iterable<SNode> rootsRight) {
    SNode action = SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(policy, LINKS.rootPolicies$AdrT), LINKS.existingOnlyRight$mCmD), LINKS.action$nr8l);
    return mergeOneSideOnly(rootsRight, action);
  }

  private Iterable<MergedNode> mergeRootsFromBothSides(Iterable<SNode> leftRootsInBothSides, Iterable<SNode> rightRootsInBothSides) {
    if (Sequence.fromIterable(leftRootsInBothSides).isNotEmpty()) {
      Iterable<MergedNode> mergedBothSides = Sequence.fromIterable(Collections.<MergedNode>emptyList());
      SNode action = SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(policy, LINKS.rootPolicies$AdrT), LINKS.existingInBothSides$HAOr), LINKS.action$nr8l);

      {
        final SNode mergeBoth = action;
        if (SNodeOperations.isInstanceOf(mergeBoth, CONCEPTS.Auto$g6)) {
          mergedBothSides = mergeWithoutReferences(leftRootsInBothSides, rightRootsInBothSides);
        }
      }

      {
        final SNode copyLeft = action;
        if (SNodeOperations.isInstanceOf(copyLeft, CONCEPTS.Left$9M)) {
          mergedBothSides = mergeOneSideOnly(leftRootsInBothSides, copyLeft);
        }
      }

      {
        final SNode copyRight = action;
        if (SNodeOperations.isInstanceOf(copyRight, CONCEPTS.Right$Y2)) {
          mergedBothSides = mergeOneSideOnly(rightRootsInBothSides, copyRight);
        }
      }
      return mergedBothSides;
    }
    return Sequence.fromIterable(Collections.emptyList());
  }

  private Iterable<MergedNode> mergeOneSideOnly(Iterable<SNode> elements, SNode action) {
    List<MergedNode> mergedNodes = ListSequence.fromList(new LinkedList<>());

    for (SNode element : Sequence.fromIterable(elements)) {
      if (!(SNodeOperations.isInstanceOf(action, CONCEPTS.Drop$fB))) {
        SNode newInstance = CopyMaker.deepCopy(element);
        ListSequence.fromList(mergedNodes).addElement(createMergedNode(newInstance));
        ListSequence.fromList(mergedNodes).addSequence(ListSequence.fromList(createMergedNodeForDescendants(newInstance)));
      }
    }
    return mergedNodes;
  }

  private Iterable<MergedNode> mergeWithoutReferences(Iterable<SNode> leftRootNodes, final Iterable<SNode> rightRootNodes) {
    List<MergedNode> leftMergedRoots = Sequence.fromIterable(leftRootNodes).select((leftRoot) -> transitiveMerge(rightRootNodes, leftRoot)).toList();

    Iterable<SNode> umergedRightRoots = computeUnmergedRightRoots(leftRootNodes, rightRootNodes);

    List<MergedNode> rightMergedRoot = Sequence.fromIterable(umergedRightRoots).select((rightRoot) -> transitiveMerge(Lists.<SNode>newLinkedList(), rightRoot)).toList();

    return ListSequence.fromList(rightMergedRoot).union(ListSequence.fromList(leftMergedRoots)).select((it) -> as_gat80h_a0a0a0a6a05(it, MergedNode.class));
  }

  private Iterable<SNode> computeUnmergedRightRoots(Iterable<SNode> leftRoots, Iterable<SNode> rightRoots) {
    final Set<String> leftIds = Sets.newHashSet(Sequence.fromIterable(leftRoots).select((it) -> idOf(it)).where(new NotNullWhereFilter()));
    Iterable<SNode> remaingRightRoots = Sequence.fromIterable(rightRoots).where((rightRoot) -> !(SetSequence.fromSet(leftIds).contains(idOf(rightRoot)))).toList();
    return remaingRightRoots;
  }

  private MergedNode transitiveMerge(Iterable<SNode> rightRoots, SNode leftRoot) {

    SNode rightMatch = findMatchingRoot(idOf(leftRoot), rightRoots);
    assert rightMatch == null || leftRoot.getConcept().equals(rightMatch.getConcept()) : "Concepts of Matched Nodes differ " + leftRoot.getConcept() + " != " + rightMatch.getConcept();

    return autoMergeNode(leftRoot, rightMatch);
  }

  private SNode findMatchingRoot(final String id, Iterable<SNode> nodes) {
    return Sequence.fromIterable(nodes).findFirst((it) -> Objects.equals(id, idOf(it)));
  }

  private MergedNode autoMergeNode(SNode leftNode, SNode rightNode) {
    SNode newInstance = CopyMaker.newInstanceOf(leftNode);
    List<SNode> leftSmodelAttributes = SLinkOperations.getChildren(((SNode) leftNode), LINKS.smodelAttribute$KJ43);
    List<SNode> rightSmodelAttributes = SLinkOperations.getChildren(((SNode) rightNode), LINKS.smodelAttribute$KJ43);

    mergeAttributes(leftSmodelAttributes, rightSmodelAttributes, newInstance);

    mergeProperties(leftNode, rightNode, newInstance);

    MergedNode merged = new MergedNode(leftNode.getContainmentLink(), newInstance, pickAnyIdfrom(leftNode, rightNode));
    if (merged.originalId != null) {
      MapSequence.fromMap(idToMergedNodes).put(merged.originalId, merged);
    }

    mergeChildren(leftNode, rightNode, newInstance);

    return merged;
  }

  private void mergeAttributes(List<SNode> leftAttributes, List<SNode> rightAttributes, SNode newInstance) {
    List<SNode> mergedAttributes = Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(this.mergeInternal(leftAttributes, rightAttributes)).select((it) -> it.node), CONCEPTS.Attribute$g1)).toList();
    ListSequence.fromList(SLinkOperations.getChildren(newInstance, LINKS.smodelAttribute$KJ43)).addSequence(ListSequence.fromList(mergedAttributes));
  }

  private void mergeChildren(SNode leftNode, SNode rightNode, SNode newInstance) {
    assert leftNode.getConcept().equals(rightNode.getConcept()) : "Concepts of left and right node must not differ " + leftNode.getConcept() + " != " + rightNode.getConcept();
    Multimap<SContainmentLink, SNode> linkToLeftNodes = this.makeLinkToChildren(leftNode);
    Multimap<SContainmentLink, SNode> linkToRightNodes = this.makeLinkToChildren(rightNode);

    for (SContainmentLink link : SetSequence.fromSet(Sets.union(linkToLeftNodes.keySet(), linkToRightNodes.keySet()))) {
      Collection<SNode> leftNodesForLink = linkToLeftNodes.get(link);
      Collection<SNode> rightNodesForLink = linkToRightNodes.get(link);
      SConcept concept = leftNode.getConcept();
      mergeChildrenOfLink(concept, link, leftNode, rightNode, leftNodesForLink, rightNodesForLink, newInstance);
    }
  }

  private void mergeChildrenOfLink(SConcept concept, SContainmentLink link, SNode leftNode, SNode rightNode, Collection<SNode> leftNodesForLink, Collection<SNode> rightNodesForLink, SNode newInstance) {
    ConceptChildMerger childMerger = resolvedMergingPolicy.childMergerFor(concept, link);
    assert childMerger != null : "ConceptChildMerger for Concept " + concept + " and link " + link + " not found!";

    List<SNode> mergedChildren = childMerger.merge(leftNode, rightNode, leftNodesForLink, rightNodesForLink, (SNode leftChild, SNode rightChild) -> ModelMerger.this.autoMergeNode(leftChild, rightChild).node);

    assert mergedChildren != null : "Merged Node null for " + childMerger.link();

    for (SNode mergedChild : ListSequence.fromList(mergedChildren)) {
      SNode newChildInstance = mergedChild;
      List<MergedNode> mergedNodes = ListSequence.fromList(new LinkedList<MergedNode>());

      if (wasMergedFromLeftOrRight(mergedChild)) {
        newChildInstance = CopyMaker.deepCopy(mergedChild);
        ListSequence.fromList(mergedNodes).addSequence(ListSequence.fromList(createMergedNodeForDescendants(newChildInstance)));
      }

      if (wasMergedManually(mergedChild)) {
        ListSequence.fromList(mergedNodes).addElement(new MergedNode(link, newChildInstance, idOf(originalNodeFor(mergedChild))));
      } else {
        // Auto merged, Left and Right
        ListSequence.fromList(mergedNodes).addElement(new MergedNode(link, newChildInstance, idOf(mergedChild)));
      }

      newInstance.addChild(childMerger.link(), newChildInstance);
      ListSequence.fromList(mergedNodes).visitAll((it) -> {
        if (it.originalId != null) {
          MapSequence.fromMap(idToMergedNodes).put(it.originalId, it);
        }
      });
    }
  }

  private Multimap<SContainmentLink, SNode> makeLinkToChildren(SNode node) {
    ImmutableMultimap.Builder<SContainmentLink, SNode> builder = ImmutableMultimap.<SContainmentLink,SNode>builder();
    Iterable<? extends SNode> children = node.getChildren();
    for (SNode child : Sequence.fromIterable(children).where((it) -> !(SNodeOperations.isInstanceOf(((SNode) it), CONCEPTS.Attribute$g1)))) {
      builder.put(child.getContainmentLink(), child);
    }
    return builder.build();
  }

  private void mergeProperties(SNode leftNode, SNode rightNode, SNode newInstance) {
    for (SProperty property : Sequence.fromIterable(propertiesOfNode(SNodeOperations.getConcept(newInstance)))) {
      PropertyMerger propertyMerger = resolvedMergingPolicy.propertyMergerFor(SNodeOperations.getConcept(newInstance), property);
      assert propertyMerger != null : "PropertyMerger not found for Concept " + leftNode.getConcept() + " and Property " + property + ".";

      Object mergedProperty = propertyMerger.merge(leftNode, rightNode);
      if (mergedProperty != null) {
        newInstance.setProperty(property, mergedProperty.toString());
      }
    }
  }

  private Iterable<SProperty> propertiesOfNode(SAbstractConcept sconcept) {
    final Collection<SProperty> forbiddenProperties = CONCEPTS.BaseConcept$gP.getProperties();
    CollectionSequence.fromCollection(forbiddenProperties).addSequence(CollectionSequence.fromCollection(CONCEPTS.IResolveInfo$$k.getProperties()));

    Iterable<SProperty> allProperties = sconcept.getProperties();
    List<SProperty> filteredProperties = Sequence.fromIterable(allProperties).where((it) -> !(CollectionSequence.fromCollection(forbiddenProperties).contains(it))).toList();
    ListSequence.fromList(filteredProperties).addElement(CollectionSequence.fromCollection(forbiddenProperties).findFirst((it) -> Objects.equals(it.getName(), PROPS.virtualPackage$EkXl.getName())));

    return filteredProperties;
  }

  private void mergeAllReferences() {

    Set<String> alreadyMergedRefs = SetSequence.fromSet(new HashSet<String>());

    mergeReferences(idToLeftNodes, idToRightNodes, alreadyMergedRefs);

    mergeReferences(idToRightNodes, ImmutableBiMap.<String,SNode>builder().build(), alreadyMergedRefs);
  }

  private void mergeReferences(BiMap<String, SNode> idToLeftNodes, BiMap<String, SNode> idToRightNodes, Set<String> idOfMergedNodes) {

    for (Map.Entry<String, SNode> idToNode : SetSequence.fromSet(idToLeftNodes.entrySet())) {
      if (!(SetSequence.fromSet(idOfMergedNodes).contains(idToNode.getKey()))) {
        SNode mergedNodeWithoutRef;
        if (MapSequence.fromMap(idToMergedNodes).containsKey(idToNode.getKey())) {
          mergedNodeWithoutRef = MapSequence.fromMap(idToMergedNodes).get(idToNode.getKey()).node;
        } else {
          SetSequence.fromSet(idOfMergedNodes).addElement(idToNode.getKey());
          continue;
        }

        SNode rightNode = idToRightNodes.get(idToNode.getKey());
        SNode leftNode = idToLeftNodes.get(idToNode.getKey());

        assert (leftNode != null) || (rightNode != null);

        SetSequence.fromSet(idOfMergedNodes).addElement(idToNode.getKey());
        if ((rightNode != null) && (leftNode != null)) {
          assert SNodeOperations.getConcept(leftNode).equals(SNodeOperations.getConcept(rightNode)) : "Left / Right Concepts do not match " + SNodeOperations.getConcept(leftNode) + "/" + SNodeOperations.getConcept(rightNode);

          for (SReference mergedReference : Sequence.fromIterable(leftNode.getReferences())) {
            SReferenceLink link = mergedReference.getLink();
            ConceptRefMerger referenceMerger = resolvedMergingPolicy.referenceMergerFor(SNodeOperations.getConcept(mergedNodeWithoutRef), link);
            assert referenceMerger != null : "ReferenceMerger not found for " + SNodeOperations.getConcept(mergedNodeWithoutRef) + "/" + link.getName();

            Optional<SNode> mergedLeftRefed = findRefTarget(leftNode, link, idToLeftNodes);
            Optional<SNode> mergedRightRefed = findRefTarget(rightNode, link, idToRightNodes);

            SNode foundMergedRefed = referenceMerger.merge(mergedLeftRefed.orElse(null), mergedRightRefed.orElse(null));
            setMergedReference(foundMergedRefed, mergedNodeWithoutRef, link);
          }

        } else {
          SNode originalNode = ((leftNode != null) ? leftNode : rightNode);
          BiMap<String, SNode> idToOrginalNodes = ((leftNode != null) ? idToLeftNodes : idToRightNodes);

          for (SReference mergedReference : Sequence.fromIterable(originalNode.getReferences())) {
            SReferenceLink link = mergedReference.getLink();
            Optional<SNode> foundMergedRefed = findRefTarget(originalNode, link, idToOrginalNodes);
            setMergedReference(foundMergedRefed.orElse(null), mergedNodeWithoutRef, link);
          }
        }
      }
    }
  }

  private Optional<SNode> findRefTarget(SNode original, SReferenceLink link, final BiMap<String, SNode> idToNodes) {
    Optional<SNode> originalTargetMaybe = targetOf(original, link);
    Optional<SNode> mergedRefedMaybe = originalTargetMaybe.flatMap((target) -> findMergedRefed(idToNodes, target));

    if (targetIsInAnExternalModel(originalTargetMaybe, mergedRefedMaybe)) {
      return originalTargetMaybe;
    }

    return mergedRefedMaybe;
  }

  private boolean targetIsInAnExternalModel(Optional<SNode> target, Optional<SNode> mergedRefed) {
    return target.isPresent() && mergedRefed.isEmpty();
  }

  private void setMergedReference(SNode foundMergedRefed, SNode mergedNodeWithoutRef, SReferenceLink link) {
    if ((foundMergedRefed != null) && (mergedNodeWithoutRef != null)) {
      mergedNodeWithoutRef.setReferenceTarget(link, foundMergedRefed);
    }
  }

  private Optional<SNode> findMergedRefed(BiMap<String, SNode> idToOriginalNode, SNode target) {
    return Optional.ofNullable(idToOriginalNode.inverse().get(target)).flatMap((id) -> Optional.ofNullable(check_gat80h_a0a0a0a0a28(MapSequence.fromMap(idToMergedNodes).get(id))));
  }

  private static Optional<SNode> targetOf(SNode originalNode, SReferenceLink link) {
    return Optional.ofNullable(check_gat80h_a0a0gd(check_gat80h_a0a0a48(originalNode, link)));
  }

  private MergedNode createMergedNode(SNode copiedNode) {
    MergedNode merged = new MergedNode(copiedNode.getContainmentLink(), copiedNode, idOf(copiedNode));
    if (merged.originalId != null) {
      MapSequence.fromMap(idToMergedNodes).put(merged.originalId, merged);
    }
    return merged;
  }

  private List<MergedNode> createMergedNodeForDescendants(SNode newInstance) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(newInstance, null, false, new SAbstractConcept[]{})).select((it) -> {
      MergedNode merged = new MergedNode(it.getContainmentLink(), it, idOf(it));
      if (merged.originalId != null) {
        MapSequence.fromMap(idToMergedNodes).put(merged.originalId, merged);
      }
      return merged;
    }).toList();
  }

  private boolean wasMergedFromLeftOrRight(SNode mergedChild) {
    return SNodeOperations.getParent(mergedChild) != null;
  }

  private boolean wasMergedManually(SNode mergedChild) {
    return mergedChild.getUserObject(ORIGINAL_KEY) != null;
  }


  private BiMap<String, SNode> idToNodes(Iterable<SNode> rootNoodes) {
    List<SNode> allNodes = Sequence.fromIterable(rootNoodes).translate((it) -> SNodeOperations.getNodeDescendants(it, null, false, new SAbstractConcept[]{})).union(Sequence.fromIterable(rootNoodes)).distinct().toList();

    BiMap<String, SNode> idToNodeMap = HashBiMap.create();
    for (SNode localNode : ListSequence.fromList(allNodes)) {
      Identity identity = conceptToIdFunction.get(SNodeOperations.getConcept(localNode));
      if (!(SPropertyOperations.getBoolean(this.policy, PROPS.partialIDFunctions$xEJ0))) {
        assert identity != null : "No Identity-Function found for concept " + SNodeOperations.getConcept(localNode);
      } else if (identity == null) {
        continue;
      }
      String id = identity.get(localNode);

      putMergeId(localNode, id);
      SNode oldNode = idToNodeMap.putIfAbsent(id, localNode);
      assert oldNode == null : "For id " + id + " two nodes are present: " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(oldNode) + "  -AND- " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(localNode);
    }
    return idToNodeMap;
  }

  @Nullable
  private String idOf(SNode localNode) {
    try {
      if (isNotEmptyString(originalMergedId(localNode))) {
        return originalMergedId(localNode);
      } else {
        if (!(SPropertyOperations.getBoolean(this.policy, PROPS.partialIDFunctions$xEJ0))) {
          throw new RuntimeException("### No original merge id for " + SNodeOperations.present(localNode) + "  trying to retrieve from input " + SNodeOperations.getConcept(localNode));
        } else {
          return null;
        }
      }
    } catch (NullPointerException e) {
      throw e;
    }
  }

  private String recalculateId(SNode localNode) {
    Identity idFunction = conceptToIdFunction.get(SNodeOperations.getConcept(localNode));
    assert idFunction != null : "NO Id-Function found for " + SNodeOperations.getConcept(localNode);
    return idFunction.get(localNode);
  }

  private String originalMergedId(SNode localNode) {
    if (localNode.getUserObject(MERGEDID_KEY) != null) {
      return (String) localNode.getUserObject(MERGEDID_KEY);
    }
    return EMPTY_STR;
  }

  private void putMergeId(SNode localNode, String id) {
    localNode.putUserObject(MERGEDID_KEY, id);
  }

  private SNode originalNodeFor(SNode mergedChild) {
    return (SNode) mergedChild.getUserObject(ORIGINAL_KEY);
  }

  private String pickAnyIdfrom(SNode left, SNode right) {
    return Stream.of(idOf(left), idOf(right)).filter((String s) -> !(Objects.isNull(s))).findAny().get();
  }


  private static SNode check_gat80h_a0a0a0a0a28(MergedNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.node;
    }
    return null;
  }
  private static SNode check_gat80h_a0a0gd(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetNode();
    }
    return null;
  }
  private static SReference check_gat80h_a0a0a48(SNode checkedDotOperand, SReferenceLink link) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getReference(link);
    }
    return null;
  }
  private static <T> T as_gat80h_a0a0a0a6a05(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink rootPolicies$AdrT = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42dcce87L, 0x732319fb4a8f06bbL, "rootPolicies");
    /*package*/ static final SContainmentLink existingInBothSides$HAOr = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x732319fb4b32eae2L, 0x72f63c9eeb57790aL, "existingInBothSides");
    /*package*/ static final SContainmentLink action$nr8l = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1ed6b4fde1c3243aL, 0x1ed6b4fde1c4a617L, "action");
    /*package*/ static final SContainmentLink existingOnlyLeft$O_fB = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x732319fb4b32eae2L, 0x72f63c9eebb73a6bL, "existingOnlyLeft");
    /*package*/ static final SContainmentLink existingOnlyRight$mCmD = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x732319fb4b32eae2L, 0x72f63c9eebb7601cL, "existingOnlyRight");
    /*package*/ static final SContainmentLink smodelAttribute$KJ43 = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept RootMergingPolicy$9P = MetaAdapterFactory.getConcept(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x732319fb4b32eae2L, "de.itemis.model.merge.structure.RootMergingPolicy");
    /*package*/ static final SConcept Auto$g6 = MetaAdapterFactory.getConcept(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x74e2e0579b2e78b7L, "de.itemis.model.merge.structure.Auto");
    /*package*/ static final SConcept Drop$fB = MetaAdapterFactory.getConcept(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x74e2e0579b2e78b6L, "de.itemis.model.merge.structure.Drop");
    /*package*/ static final SConcept Add$Cr = MetaAdapterFactory.getConcept(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x74e2e0579b54de6bL, "de.itemis.model.merge.structure.Add");
    /*package*/ static final SConcept Left$9M = MetaAdapterFactory.getConcept(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42e44bcaL, "de.itemis.model.merge.structure.Left");
    /*package*/ static final SConcept Right$Y2 = MetaAdapterFactory.getConcept(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x68dab8ecba0b4ed6L, "de.itemis.model.merge.structure.Right");
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SInterfaceConcept IResolveInfo$$k = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x116b17c6e46L, "jetbrains.mps.lang.core.structure.IResolveInfo");
  }

  private static final class PROPS {
    /*package*/ static final SProperty virtualPackage$EkXl = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x115eca8579fL, "virtualPackage");
    /*package*/ static final SProperty partialIDFunctions$xEJ0 = MetaAdapterFactory.getProperty(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42dcce87L, 0x4eeb3d86e240b8a1L, "partialIDFunctions");
  }
}

package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import de.itemis.mps.editor.diagram.runtime.model.SerializableObjectHolder;
import com.mxgraph.model.mxGeometry;
import java.util.List;
import jetbrains.mps.openapi.editor.style.StyleAttribute;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.mxgraph.view.mxCellState;
import java.util.ArrayList;
import com.mxgraph.canvas.mxGraphics2DCanvas;
import java.awt.Graphics2D;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import com.intellij.openapi.progress.EmptyProgressIndicator;
import com.intellij.openapi.progress.ProgressIndicator;
import org.jetbrains.mps.openapi.module.SRepository;
import com.intellij.openapi.progress.PerformInBackgroundOption;
import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.progress.ProgressManager;

public abstract class BaseDiagramDCell extends BaseDCell implements ISelfPaintingCell, ISupportButtonHiding {
  protected final boolean DEFAULT_BOOL_VALUE = true;
  protected Map<Integer, Boolean> buttonVisibility = MapSequence.fromMap(new HashMap<Integer, Boolean>());

  private SerializableObjectHolder<ContextButtonContainer> myContextButtonContainer;

  public BaseDiagramDCell(MyGraph graph) {
    super(graph);
    myContextButtonContainer = new SerializableObjectHolder<ContextButtonContainer>(new ContextButtonContainer(graph.getView()));
  }
  public BaseDiagramDCell(Object value, mxGeometry geometry, String style, MyGraph graph) {
    super(value, geometry, style, graph);
  }

  @Override
  public Map<Integer, Boolean> getButtonVisibilityMap() {
    return buttonVisibility;
  }

  public ContextButtonContainer getContextButtonContainer() {
    return myContextButtonContainer.get();
  }

  public List<StyleAttribute> getStyleButtonAttributes() {
    return Sequence.fromIterable(Sequence.fromArray(new StyleAttribute[]{StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__layout-diagram-button"), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__sync-with-model-button")})).toList();
  }

  public void updateButtonConfig(final Style style) {
    ListSequence.fromList(getStyleButtonAttributes()).visitAll(new _FunctionTypes._void_P1_E0<StyleAttribute>() {
      public void invoke(StyleAttribute it) {
        setButtonVisibilityFromStyle(style, it);
      }
    });
  }

  public void resetButtonConfig() {
    ListSequence.fromList(getStyleButtonAttributes()).visitAll(new _FunctionTypes._void_P1_E0<StyleAttribute>() {
      public void invoke(StyleAttribute it) {
        resetButtonVisibility(it);
      }
    });
  }

  public void updateButtons(mxCellState state) {
    getContextButtonContainer().setButtons(createButtons(state));
    getContextButtonContainer().setScale(getButtonScale());
    getContextButtonContainer().relayout();
    moveButtonsContainer(state, getContextButtonContainer());
  }

  protected List<ContextButton> createButtons(mxCellState state) {
    double scale = getButtonScale();
    List<ContextButton> buttons = ListSequence.fromList(new ArrayList<ContextButton>());
    if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__layout-diagram-button"))) {
      ListSequence.fromList(buttons).addElement(new AutoLayoutDiagramButton(ContextButton.DEFAULT_BUTTON_SIZE * scale, state));
    }
    if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__sync-with-model-button")) && _getGraph().getRootDiagramModel().getDiagramAccessor().syncWithModelOnlyOnOpening()) {
      ListSequence.fromList(buttons).addElement(new SyncWithModelButton(ContextButton.DEFAULT_BUTTON_SIZE * scale, state));
    }
    return buttons;
  }

  protected double getButtonScale() {
    return _getGraph().getView().getScale();
  }

  protected void moveButtonsContainer(mxCellState state, ContextButtonContainer container) {
    double spacing = getButtonScale() * ContextButtonContainer.BUTTON_SPACING;
    container.moveTo(state.getX() + spacing, state.getY() + spacing);
  }

  @Override
  public boolean canPaintSelf(mxGraphics2DCanvas canvas, mxCellState state) {
    return true;
  }
  @Override
  public boolean doesAdditionalPaintingOnly() {
    return true;
  }
  @Override
  public void paintBackground(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {
  }
  @Override
  public void paintForeground(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {
  }
  @Override
  public void paintTop(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {
    getContextButtonContainer().paint(g);
  }

  public abstract DiagramModel getDiagramModel();
  public abstract BaseDiagramECell getECell();

  public void runLayouterSync() {
    runLayouterSync(new EmptyProgressIndicator());
  }

  public void runLayouterSync(ProgressIndicator progress) {
    getDiagramModel().getLayouter().layout(myGraph.get(), progress);
  }

  public void runLayouter() {
    SRepository repository = getECell().getContext().getRepository();
    PerformInBackgroundOption showProgress = PerformInBackgroundOption.ALWAYS_BACKGROUND;
    final Project ideaProject = ProjectHelper.toIdeaProject(ProjectHelper.getProject(repository));

    final Task.Backgroundable backgroundable = new Task.Backgroundable(ideaProject, "Auto-layouting diagram", true, showProgress) {
      @Override
      public void run(@NotNull ProgressIndicator progress) {
        runLayouterSync(progress);
      }
    };
    ApplicationManager.getApplication().invokeLater(() -> ProgressManager.getInstance().run(backgroundable));
  }
}

package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.IdentityHashMap;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Iterator;
import org.jetbrains.annotations.Nullable;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.Objects;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.grammarcells.runtime.plugin.ParserFailureNotifier;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class Parser implements IRecycledNodes {
  private static final Logger LOG = Logger.getLogger(Parser.class);
  public static int DEFAULT_TIMEOUT = 100000;

  private SModel myModel;
  private List<IRule> myRules;
  private int myCurrentDepth = 0;
  private int myTimeout = 0;
  private long myStartTime = 0;
  private boolean myIgnoreArbitraryText = false;
  private Map<IToken, SAbstractConcept> myOriginalConcept = new IdentityHashMap<IToken, SAbstractConcept>();
  private Map<IToken, SNode> myOriginalNode = new IdentityHashMap<IToken, SNode>();
  private List<IRule> myPrefilteredRules = null;

  public Parser(SModel contextModel) {
    myModel = contextModel;
  }

  public SNode processAfterTextInsert(SNode rootNode) {
    return processAfterTextDelete(rootNode);
  }

  public SNode processAfterTextDelete(SNode rootNode) {
    SNode nodeToParse = rootNode;
    if ((SNodeOperations.getParent(rootNode) == null)) {
      // if the root node is an actual root node and not just the root of an expression (happens in editor tests),
      // we cannot replace that node
      nodeToParse = findNodeForReparse(rootNode);
      while (nodeToParse != rootNode && SNodeOperations.getParent(SNodeOperations.getParent(nodeToParse)) != null) {
        nodeToParse = SNodeOperations.getParent(nodeToParse);
      }
    }

    moveArbitraryTextsToLeafs(nodeToParse);
    SNode newTree = reparse(nodeToParse);
    if (newTree != null) {
      return newTree;
    }
    return rebalanceIfRequired(nodeToParse);
  }

  public SNode rebalanceIfRequired(SNode rootNode) {
    boolean wasIgnored = myIgnoreArbitraryText;
    try {
      myIgnoreArbitraryText = true;
      PNode newTree = parse(rootNode, DEFAULT_TIMEOUT);
      if (newTree != null) {
        PNode currentTree = calculateCurrentParseTree(rootNode);
        if (!(newTree.matches(currentTree))) {
          specializeTree(SNodeOperations.getNodeDescendants(rootNode, CONCEPTS.BaseConcept$gP, true, new SAbstractConcept[]{}), newTree);
          return applyParseTree(newTree, rootNode);
        }
      }
      return null;
    } finally {
      myIgnoreArbitraryText = wasIgnored;
    }
  }

  protected void specializeTree(List<SNode> existingNodes, PNode newTree) {
    // If there are subconcepts that have the same rule. For a given input we cannot know which is the
    // correct subconcept.
    // In case of a rebalance, we can assume, that there are no  nodes removed or added.
    // Here we try to find out the correct subconcept by searching in the existing tree.
    if (newTree.getRule() != null) {
      List<IRule> alternativesList = getAlternatives(newTree.getRule());
      if (ListSequence.fromList(alternativesList).count() > 1) {
        boolean isNotOverriden = ListSequence.fromList(alternativesList).contains(getRule(newTree.getRule().getOutputConcept()));
        if (isNotOverriden) {
          final Map<SAbstractConcept, IRule> alternatives = MapSequence.fromMap(new HashMap<SAbstractConcept, IRule>());
          ListSequence.fromList(alternativesList).visitAll((it) -> MapSequence.fromMap(alternatives).put(it.getOutputConcept(), it));

          Iterator<SNode> existingNodesItr = ListSequence.fromList(existingNodes).iterator();
          while (existingNodesItr.hasNext()) {
            SNode existingNode = existingNodesItr.next();

            IRule specializedRule = MapSequence.fromMap(alternatives).get(SNodeOperations.getConcept(existingNode));
            if (specializedRule != null && SNodeOperations.isInstanceOf(existingNode, SNodeOperations.asSConcept(newTree.getRule().getOutputConcept()))) {
              newTree.setRule(specializedRule);
              existingNodesItr.remove();
            }
          }
        }
      }
    }

    for (PNode child : ListSequence.fromList(newTree.getChildren())) {
      specializeTree(existingNodes, child);
    }
  }

  protected SNode findNodeForReparse(SNode rootNode) {
    List<SNode> arbitraryTextNodes = SNodeOperations.getNodeDescendants(rootNode, CONCEPTS.ArbitraryTextAnnotation$hv, false, new SAbstractConcept[]{});
    if (ListSequence.fromList(arbitraryTextNodes).isEmpty()) {
      return null;
    }
    return commonAncestor(arbitraryTextNodes);
  }

  public SNode reparse(SNode rootNode) {
    return reparse(rootNode, DEFAULT_TIMEOUT);
  }

  public SNode reparse(SNode rootNode, int timeout) {
    PNode parseTree = parse(rootNode, timeout);
    if (parseTree != null) {
      SNode newTree = applyParseTree(parseTree, rootNode);
      ListSequence.fromList(SNodeOperations.getNodeDescendants(newTree, CONCEPTS.ArbitraryTextAnnotation$hv, false, new SAbstractConcept[]{})).visitAll((it) -> SNodeOperations.deleteNode(it));
      return newTree;
    }

    return null;
  }

  public SNode applyParseTree(PNode parseTree, SNode nodeToReplace) {
    // It can happen, that the rootNode will be a child in the new tree. Building the tree removes the rootNode
    // from its original location. That's why we use the 'placeholder' during the creation of the new tree.
    SNode placeholder = SNodeOperations.replaceWithNewChild(nodeToReplace, CONCEPTS.BaseConcept$gP);
    SNode newTree = parseTree.createSNode(this);
    SNodeOperations.replaceWithAnother(placeholder, newTree);
    return newTree;
  }

  public PNode parse(SNode input, int timeout) {
    List<IToken> tokens = getTokens(input);
    return parse(tokens, check_jpiiov_b0b0eb(input.getContainmentLink()), timeout);
  }

  public PNode parse(List<IToken> tokens, @Nullable SAbstractConcept expectedConcept) {
    return parse(tokens, expectedConcept, DEFAULT_TIMEOUT);
  }

  public PNode parse(List<IToken> tokens, @Nullable SAbstractConcept expectedConcept, int timeout) {
    try {
      myTimeout = timeout;
      myStartTime = System.currentTimeMillis();
      if (LOG.isDebugLevel()) {
        LOG.debug("tokens: " + tokens);
      }

      // There are usually a lot of rules in a grammar that are rarely used.
      // Check if their constants appear in the input. If not, we can exclude them from the parsing process.
      List<IRule> rules = getRules();
      final Set<String> textTokens = SetSequence.fromSetWithValues(new HashSet<String>(), ListSequence.fromList(tokens).ofType(TextToken.class).select((it) -> it.getTextValue()));

      myPrefilteredRules = ListSequence.fromList(rules).where((it) -> {
        return ListSequence.fromList(it.getSymbols()).ofType(ConstantSymbol.class).all(new _FunctionTypes._return_P1_E0<Boolean, ConstantSymbol>() {
          public Boolean invoke(ConstantSymbol it) {
            return SetSequence.fromSet(textTokens).contains(it.getConstant());
          }
        });
      }).toList();

      final Set<SAbstractConcept> originalConcepts = SetSequence.fromSetWithValues(new HashSet<SAbstractConcept>(), ListSequence.fromList(tokens).select((it) -> getOriginalNode(it)).where((it) -> (it != null)).select((it) -> SNodeOperations.getConcept(it)));

      myPrefilteredRules = ListSequence.fromList(myPrefilteredRules).sort((it) -> (SetSequence.fromSet(originalConcepts).contains(it.getOutputConcept()) ? -1 : 0), true).alsoSort((it) -> it.getPriority(), true).toList();

      PNode tree = parse(new InputCursor(tokens), expectedConcept, null);
      if (LOG.isDebugLevel()) {
        LOG.debug("parse tree (" + (System.currentTimeMillis() - myStartTime) + " ms): " + tree);
      }
      return tree;
    } catch (Exception ex) {
      if (LOG.isWarningLevel()) {
        LOG.warning("Parsing failed", ex);
      }
      return null;
    } finally {
      myPrefilteredRules = null;
    }

  }

  public PNode parse(InputCursor input, @Nullable final SAbstractConcept expectedConcept, @Nullable SymbolInRule symbolInParent) {
    if (myCurrentDepth > 20) {
      return null;
    }
    try {
      myCurrentDepth++;
      List<IRule> rules = (myPrefilteredRules != null ? myPrefilteredRules : getRules());
      if (expectedConcept != null) {
        rules = ListSequence.fromList(rules).where((it) -> SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(it.getOutputConcept()), SNodeOperations.asSConcept(expectedConcept))).toList();
      }

      // prefer concept that the token had before destruction
      Set<SAbstractConcept> originalConcepts = SetSequence.fromSetWithValues(new HashSet<SAbstractConcept>(), ListSequence.fromList(input.getAll()).select((it) -> MapSequence.fromMap(myOriginalConcept).get(it)).where((it) -> it != null));
      if (SetSequence.fromSet(originalConcepts).count() == 1) {
        final SAbstractConcept preferedConcept = SetSequence.fromSet(originalConcepts).first();
        rules = ListSequence.fromList(rules).where((it) -> Objects.equals(it.getOutputConcept(), preferedConcept)).concat(ListSequence.fromList(rules).where((it) -> !(Objects.equals(it.getOutputConcept(), preferedConcept)))).toList();
      }

      for (IRule rule : ListSequence.fromList(rules)) {
        // check associativity
        if (symbolInParent != null) {
          IRule parentRule = symbolInParent.getRule();
          boolean canBeRotated = canBeRotated(rule, symbolInParent);
          boolean isSamePriority = parentRule.getPriority() == rule.getPriority() && parentRule.isLeftAssociative() == rule.isLeftAssociative();
          if (isSamePriority && canBeRotated) {
            List<ISymbol> parentSymbols = parentRule.getSymbols();
            List<Integer> sameOutputConceptIndices = ListSequence.fromList(new ArrayList<Integer>());
            for (int i = 0; i < ListSequence.fromList(parentSymbols).count(); i++) {
              SAbstractConcept oc = ListSequence.fromList(parentSymbols).getElement(i).getOutputConcept();
              if (oc != null && SConceptOperations.isExactly(SNodeOperations.asSConcept(oc), SNodeOperations.asSConcept(expectedConcept))) {
                ListSequence.fromList(sameOutputConceptIndices).addElement(i);
              }
            }

            if (ListSequence.fromList(sameOutputConceptIndices).count() > 1) {
              int allowedIndex = ListSequence.fromList(sameOutputConceptIndices).getElement((parentRule.isLeftAssociative() ? 0 : ListSequence.fromList(sameOutputConceptIndices).count() - 1));
              if (symbolInParent.getIndex() != allowedIndex) {
                // In case of left associativity, the same concept is allowed only on the left side.
                // For example, for the input 1+2+3, there are the two possible trees 1+(2+3) and (1+2)+3.
                // We want the second one.
                continue;
              }
            }
          }

          // check priority
          if (canBeRotated && parentRule.getPriority() > rule.getPriority()) {
            // A * is not allowed as the parent of a +, because for the input 1+2*3 we don't want (1+2)*3
            continue;
          }
        }

        InputCursor saved = input.save();
        PNode result = tryParseRule(input, rule);
        if (result != null) {
          return result;
        }
        input.restore(saved);
      }

      return null;
    } finally {
      myCurrentDepth--;
    }
  }

  protected boolean canBeRotated(@NotNull IRule childRule, @NotNull SymbolInRule symbolInRule) {
    IRule parentRule = symbolInRule.getRule();
    SAbstractConcept expectedConcept = symbolInRule.getSymbol().getOutputConcept();

    if (!(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(parentRule.getOutputConcept()), SNodeOperations.asSConcept(expectedConcept)))) {
      return false;
    }

    boolean isFirstSymbol = symbolInRule.getIndex() == 0;
    boolean isLastSymbol = symbolInRule.getIndex() == ListSequence.fromList(parentRule.getSymbols()).count() - 1;

    if (isFirstSymbol) {
      if (SConceptOperations.isSuperConceptOf(SNodeOperations.asSConcept(ListSequence.fromList(childRule.getSymbols()).last().getOutputConcept()), SNodeOperations.asSConcept(parentRule.getOutputConcept()))) {

      }
      SAbstractConcept lastChildSymbolConcept = ListSequence.fromList(childRule.getSymbols()).last().getOutputConcept();
      if (lastChildSymbolConcept != null && SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(parentRule.getOutputConcept()), SNodeOperations.asSConcept(lastChildSymbolConcept))) {
        return true;
      }
    }
    if (isLastSymbol) {
      SAbstractConcept firstChildSymbolConcept = ListSequence.fromList(childRule.getSymbols()).first().getOutputConcept();
      if (firstChildSymbolConcept != null && SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(parentRule.getOutputConcept()), SNodeOperations.asSConcept(firstChildSymbolConcept))) {
        return true;
      }
    }

    return false;
  }

  public PNode tryParseRule(InputCursor input, IRule rule) {
    InputCursor saved = input.save();
    PNode result = parseRule(input, rule);
    if (result != null) {
      return result;
    } else {
      input.restore(saved);
      return null;
    }
  }

  public PNode parseRule(InputCursor input, IRule rule) {
    countDown();
    List<ISymbol> symbols = rule.getSymbols();

    if (!(containsRequiredConstants(input, symbols))) {
      return null;
    }

    Iterator<InputCursor[]> rangesIterator = input.save().iterateRanges(symbols, rule.isLeftAssociative());
rangeLoop:
    while (rangesIterator.hasNext()) {
      countDown();
      InputCursor[] ranges = rangesIterator.next();
      for (InputCursor range : Sequence.fromIterable(Sequence.fromArray(ranges))) {
        range.resetPosition();
      }
      if (ranges.length != ListSequence.fromList(symbols).count()) {
        continue;
      }
      if (Sequence.fromIterable(Sequence.fromArray(ranges)).any((it) -> ListSequence.fromList(it.getAll()).count() == 0)) {
        continue;
      }

      // check constants first
      {
        Iterator<ISymbol> symbol_it = ListSequence.fromList(symbols).iterator();
        Iterator<InputCursor> range_it = Sequence.fromArray(ranges).iterator();
        ISymbol symbol_var;
        InputCursor range_var;
        while (symbol_it.hasNext() && range_it.hasNext()) {
          symbol_var = symbol_it.next();
          range_var = range_it.next();
          if (isConstant(symbol_var)) {
            IToken token = range_var.peek();
            if (token == null || !(symbol_var.matches(token))) {
              continue rangeLoop;
            }
          }
        }
      }

      PNode result = new PNode(rule);
      int symbolIndex = -1;
      {
        Iterator<ISymbol> symbol_it = ListSequence.fromList(symbols).iterator();
        Iterator<InputCursor> range_it = Sequence.fromArray(ranges).iterator();
        ISymbol symbol_var;
        InputCursor range_var;
        while (symbol_it.hasNext() && range_it.hasNext()) {
          symbol_var = symbol_it.next();
          range_var = range_it.next();
          symbolIndex++;
          PNode subResult = symbol_var.parse(range_var, this, new SymbolInRule(rule, symbol_var, symbolIndex));
          if (subResult == null) {
            if (symbolIndex == 0 && symbol_var.hasFixedTokenNumber()) {
              // The range will not change
              return null;
            }
            continue rangeLoop;
          }
          subResult.setSymbol(symbol_var);
          result.addChild(subResult);
        }
      }

      return result;
    }
    return null;
  }

  protected void countDown() {
    // timeout of 0 negative means disabled
    if (myTimeout > 0) {
      myTimeout--;
      if (myTimeout == 0) {
        final long duration = System.currentTimeMillis() - myStartTime;
        final Iterable<ParserFailureNotifier> extensions = new ExtensionPoint<ParserFailureNotifier>("com.mbeddr.mpsutil.grammarcells.runtime.ParserFailureNotifierExtensionPoint").getObjects();
        for (ParserFailureNotifier extension : Sequence.fromIterable(extensions)) {
          extension.notifyParsingTimedOut(duration, this.myModel);
        }
        throw new RuntimeException("Search for a parse tree timed out after " + duration + " ms");
      }
    }
  }

  protected boolean containsRequiredConstants(InputCursor input, List<ISymbol> symbols) {
    List<IToken> tokens = input.getAll();

    for (final ISymbol symbol : ListSequence.fromList(symbols)) {
      if (isConstant(symbol)) {
        if (ListSequence.fromList(tokens).all((token) -> !(symbol.matches(token)))) {
          return false;
        }
      }
    }

    return true;
  }

  protected boolean isConstant(ISymbol symbol) {
    return symbol.hasFixedTokenNumber() && symbol.getNumTokens() == 1;
  }

  protected List<IToken> getTokens(final SNode node) {
    List<IToken> result = ListSequence.fromList(new ArrayList<IToken>());
    ListSequence.fromList(result).addSequence(ListSequence.fromList(getArbitraryTextTokens(node, true)));

    boolean destruct = destructionRequired(node);
    IRule rule = null;
    if (destruct) {
      rule = getRule(SNodeOperations.getConcept(node));
    }
    if (destruct && rule != null) {
      for (ISymbol symbol : ListSequence.fromList(rule.getSymbols())) {
        IToken token = symbol.read(node);
        if (token.isChild()) {
          SNode child = token.getChildNode();
          ListSequence.fromList(result).addSequence(ListSequence.fromList(getTokens(child)));
        } else {
          ListSequence.fromList(result).addElement(token);
          MapSequence.fromMap(myOriginalNode).put(token, node);
        }
      }
    } else {
      ListSequence.fromList(result).addElement(new ChildToken(node));
    }

    ListSequence.fromList(result).addSequence(ListSequence.fromList(getArbitraryTextTokens(node, false)));

    ListSequence.fromList(result).visitAll((it) -> {
      if (MapSequence.fromMap(myOriginalConcept).get(it) == null) {
        MapSequence.fromMap(myOriginalConcept).put(it, SNodeOperations.getConcept(node));
      }
    });
    return result;
  }

  protected List<IToken> getArbitraryTextTokens(SNode node, final boolean left) {
    List<IToken> result = ListSequence.fromList(new ArrayList<IToken>());
    if (!(myIgnoreArbitraryText)) {
      for (SNode arbitraryText : ListSequence.fromList(new IAttributeDescriptor.NodeAttribute(CONCEPTS.ArbitraryTextAnnotation$hv).list(node)).where((it) -> SPropertyOperations.getBoolean(it, PROPS.left$Cu1K) == left)) {
        ListSequence.fromList(result).addElement(new TextToken(SPropertyOperations.getString(arbitraryText, PROPS.text$Fl1W)));
      }
    }
    return result;
  }

  protected IRule getRule(SAbstractConcept concept) {
    return RulesCache.getInstance(myModel).getRule(concept);
  }

  protected List<IRule> getRules() {
    return RulesCache.getInstance(myModel).getRules();
  }

  protected List<IRule> getAlternatives(IRule rule) {
    List<IRule> result = ListSequence.fromList(new ArrayList<IRule>());
    for (IRule alternative : ListSequence.fromList(getRules())) {
      if (Objects.equals(rule.getDefinedForConcept(), alternative.getDefinedForConcept())) {
        ListSequence.fromList(result).addElement(alternative);
      }
    }
    return result;
  }

  protected boolean destructionRequired(SNode node) {
    return true;
  }

  protected SNode commonAncestor(List<SNode> nodes) {
    return ListSequence.fromList(nodes).foldLeft(((SNode) null), (SNode s, SNode it) -> commonAncestor(s, it));
  }

  protected SNode commonAncestor(SNode n1, SNode n2) {
    if ((n1 == null)) {
      return n2;
    }
    if ((n2 == null)) {
      return n1;
    }
    Set<SNode> a1 = SetSequence.fromSetWithValues(new HashSet<SNode>(), SNodeOperations.getNodeAncestors(n1, null, true));
    for (SNode a2 : ListSequence.fromList(SNodeOperations.getNodeAncestors(n2, null, true))) {
      if (SetSequence.fromSet(a1).contains(a2)) {
        return a2;
      }
    }
    return null;
  }

  public PNode calculateCurrentParseTree(SNode snode) {
    IRule rule = getRule(SNodeOperations.getConcept(snode));
    if (rule == null) {
      return new PNode(new ChildToken(snode), null);
    }
    PNode pnode = new PNode(rule);

    for (ISymbol symbol : ListSequence.fromList(rule.getSymbols())) {
      pnode.addChild(symbol.calcCurrentParseTree(snode, this));
    }

    return pnode;
  }

  protected void moveArbitraryTextsToLeafs(SNode rootNode) {
    for (SNode atext : ListSequence.fromList(SNodeOperations.getNodeDescendants(rootNode, CONCEPTS.ArbitraryTextAnnotation$hv, false, new SAbstractConcept[]{}))) {
      moveArbitraryTextToLeaf(atext);
    }
  }

  protected void moveArbitraryTextToLeaf(SNode atext) {
    SNode annotatedNode = SNodeOperations.getParent(atext);
    IRule rule = getRule(SNodeOperations.getConcept(annotatedNode));
    if (rule != null) {
      ISymbol firstLastSymbol = (SPropertyOperations.getBoolean(atext, PROPS.left$Cu1K) ? ListSequence.fromList(rule.getSymbols()).first() : ListSequence.fromList(rule.getSymbols()).last());
      IToken firstLastToken = check_jpiiov_a0b0c0sc(firstLastSymbol, annotatedNode);
      if (check_jpiiov_a2a2a07(firstLastToken)) {
        ListSequence.fromList(SLinkOperations.getChildren(firstLastToken.getChildNode(), LINKS.smodelAttribute$KJ43)).addElement(atext);
        // move further down
        moveArbitraryTextToLeaf(atext);
      }
    }
  }

  /**
   * Returns true, if the 'nodeToCheck' is the first/last symbol of a subtree with root 'ofConcept'
   */
  public SNode isEndOf(SNode nodeToCheck, boolean leftEnd, SAbstractConcept ofConcept, @Nullable final SContainmentLink link) {
    if (ofConcept == null) {
      return null;
    }

    if (link != null) {
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeToCheck), SNodeOperations.asSConcept(ofConcept)) && Objects.equals(nodeToCheck.getContainmentLink(), link)) {
        return SNodeOperations.getParent(nodeToCheck);
      }
    }

    if (SNodeOperations.isInstanceOf(nodeToCheck, SNodeOperations.asSConcept(ofConcept)) && link == null) {
      IRule rule = getRule(SNodeOperations.getConcept(nodeToCheck));
      if (rule != null) {
        ISymbol endSymbol = (leftEnd ? ListSequence.fromList(rule.getSymbols()).first() : ListSequence.fromList(rule.getSymbols()).last());
        if (endSymbol.getOutputConcept() != null) {
          // In a BinaryExpression we don't want do allow side transformations on the operator
          return null;
        }
      }
      return nodeToCheck;
    }

    SNode parent = SNodeOperations.getParent(nodeToCheck);
    if (parent == null) {
      return null;
    }

    IRule parentRule = getRule(SNodeOperations.getConcept(parent));
    if (parentRule == null) {
      return null;
    }

    List<ISymbol> symbols = parentRule.getSymbols();
    ISymbol endSymbol;
    if (link != null && SNodeOperations.isInstanceOf(parent, SNodeOperations.asSConcept(ofConcept))) {
      endSymbol = ListSequence.fromList(symbols).findFirst((it) -> Objects.equals(it.getLink(), link));
    } else {
      endSymbol = (leftEnd ? ListSequence.fromList(symbols).first() : ListSequence.fromList(symbols).last());
    }
    if (endSymbol == null) {
      return null;
    }
    SAbstractConcept endSymbolConcept = endSymbol.getOutputConcept();
    if (endSymbolConcept == null) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(nodeToCheck, SNodeOperations.asSConcept(endSymbolConcept)))) {
      return null;
    }
    if (endSymbol.read(SNodeOperations.getParent(nodeToCheck)).getChildNode() != nodeToCheck) {
      return null;
    }

    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(parent)), SNodeOperations.asSConcept(ofConcept))) {
      return parent;
    }

    return isEndOf(parent, leftEnd, ofConcept, link);
  }

  public SNode getOriginalNode(IToken token) {
    return MapSequence.fromMap(myOriginalNode).get(token);
  }

  public SNode findRootExpression(SNode start) {
    return ListSequence.fromList(SNodeOperations.getNodeAncestors(start, null, true)).findFirst((it) -> (SNodeOperations.getParent(it) == null) || getRule(SNodeOperations.getConcept(SNodeOperations.getParent(it))) == null);
  }

  private static SAbstractConcept check_jpiiov_b0b0eb(SContainmentLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetConcept();
    }
    return null;
  }
  private static IToken check_jpiiov_a0b0c0sc(ISymbol checkedDotOperand, SNode annotatedNode) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.read(annotatedNode);
    }
    return null;
  }
  private static boolean check_jpiiov_a2a2a07(IToken checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isChild();
    }
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SConcept ArbitraryTextAnnotation$hv = MetaAdapterFactory.getConcept(0xb4f35ed845af4efaL, 0xabe400ac26956e69L, 0x468dcccb641e8fb9L, "com.mbeddr.mpsutil.grammarcells.runtimelang.structure.ArbitraryTextAnnotation");
  }

  private static final class PROPS {
    /*package*/ static final SProperty text$Fl1W = MetaAdapterFactory.getProperty(0xb4f35ed845af4efaL, 0xabe400ac26956e69L, 0x468dcccb641e8fb9L, 0x468dcccb641e99b6L, "text");
    /*package*/ static final SProperty left$Cu1K = MetaAdapterFactory.getProperty(0xb4f35ed845af4efaL, 0xabe400ac26956e69L, 0x468dcccb641e8fb9L, 0x468dcccb641e9989L, "left");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink smodelAttribute$KJ43 = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");
  }
}

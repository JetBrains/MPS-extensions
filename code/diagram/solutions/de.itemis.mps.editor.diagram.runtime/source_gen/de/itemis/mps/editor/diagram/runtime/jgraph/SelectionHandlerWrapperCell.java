package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.Map;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.openapi.editor.selection.SelectionListener;
import java.util.WeakHashMap;
import java.util.Set;
import java.util.HashMap;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import java.util.HashSet;
import java.util.List;

public abstract class SelectionHandlerWrapperCell extends EditorCell_Collection {
  private static final Map<EditorComponent, SelectionListener> selectionListeners = new WeakHashMap<EditorComponent, SelectionListener>();
  private static final Map<EditorComponent, Set<SelectionHandlerWrapperCell>> ourWrapperCellsInEditorComponent = new HashMap<EditorComponent, Set<SelectionHandlerWrapperCell>>();


  public static void installListener(EditorComponent editorComponent) {
    SelectionListener listener = new SelectionListener() {
      private EditorCell lastWrapper;
      public void selectionChanged(EditorComponent editorComponent, Selection oldSelection, Selection newSelection) {
        SelectionHandlerWrapperCell newWrapper = getWrapper(getSelectedCell(newSelection));
        if (newWrapper != lastWrapper) {
          if (newWrapper != null) {
            newWrapper.handleSelection();
          }
          lastWrapper = newWrapper;
        }
      }
    };
    selectionListeners.put(editorComponent, listener);
    editorComponent.getSelectionManager().addSelectionListener(listener);

  }

  public static void uninstallListener(EditorComponent editorComponent) {
    SelectionListener listener = selectionListeners.get(editorComponent);
    editorComponent.getSelectionManager().removeSelectionListener(listener);
    selectionListeners.remove(editorComponent);
  }

  public SelectionHandlerWrapperCell(EditorContext context, SNode node) {
    super(context, node, new CellLayout_Horizontal(), null);
  }

  protected abstract void handleSelection();

  @Override
  public void onAdd() {
    super.onAdd();

    Set<SelectionHandlerWrapperCell> cells = ourWrapperCellsInEditorComponent.get(getEditorComponent());
    if (cells == null) {
      cells = new HashSet<SelectionHandlerWrapperCell>();
      ourWrapperCellsInEditorComponent.put(getEditorComponent(), cells);
    }

    if (cells.isEmpty()) {
      installListener(getEditorComponent());
    }

    cells.add(this);
  }

  @Override
  public void onRemove() {
    super.onRemove();

    Set<SelectionHandlerWrapperCell> cells = ourWrapperCellsInEditorComponent.get(getEditorComponent());
    if (cells != null) {
      cells.remove(this);
      if (cells.isEmpty()) {
        uninstallListener(getEditorComponent());
        ourWrapperCellsInEditorComponent.remove(getEditorComponent());
      }
    }
  }

  private static EditorCell getSelectedCell(Selection newSelection) {
    if (newSelection == null) {
      return null;
    }
    List<EditorCell> cells = newSelection.getSelectedCells();
    if (cells == null || cells.size() < 1) {
      return null;
    }
    return cells.get(0);
  }

  private static SelectionHandlerWrapperCell getWrapper(final EditorCell cell) {
    for (EditorCell current = cell; current != null; current = current.getParent()) {
      if (current instanceof SelectionHandlerWrapperCell) {
        return (SelectionHandlerWrapperCell) current;
      }
    }
    return null;
  }
}

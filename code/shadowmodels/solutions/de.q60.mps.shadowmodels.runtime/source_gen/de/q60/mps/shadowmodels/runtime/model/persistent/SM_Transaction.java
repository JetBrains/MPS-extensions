package de.q60.mps.shadowmodels.runtime.model.persistent;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.IBranch;
import org.modelix.model.api.ITree;
import org.modelix.model.api.IConcept;
import org.modelix.model.api.IConceptReference;
import org.modelix.model.api.INodeReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.modelix.model.api.INode;

public abstract class SM_Transaction implements SM_ITransaction {
  private Map<Object, Object> userObjects = MapSequence.fromMap(new HashMap<Object, Object>());
  protected final SM_PBranch branch;

  public SM_Transaction(SM_PBranch branch) {
    this.branch = branch;
  }

  @Nullable
  public Object getUserObject(@NotNull Object key) {
    return MapSequence.fromMap(userObjects).get(key);
  }

  public void putUserObject(@NotNull Object key, @Nullable Object value) {
    MapSequence.fromMap(userObjects).put(key, value);
  }

  public abstract SM_PTree getPTree();

  @Override
  public IBranch getBranch() {
    return branch;
  }

  @NotNull
  @Override
  public Iterable<String> getReferenceRoles(long nodeId) {
    return getTree().getReferenceRoles(nodeId);
  }

  @NotNull
  @Override
  public Iterable<String> getPropertyRoles(long nodeId) {
    return getTree().getPropertyRoles(nodeId);
  }

  @Override
  public void ensureLoaded(long nodeId) {
    if (!(getPTree().isLoaded(nodeId))) {
      throw new RuntimeException("Lazy loading not supported");
    }
  }

  @Override
  public boolean isLoaded(long nodeId) {
    if (!(getTree() instanceof SM_PTree)) {
      return true;
    }
    return getPTree().isLoaded(nodeId);
  }

  @Override
  public ITree getTree() {
    return getPTree();
  }

  @Override
  public boolean containsNode(long nodeId) {
    return getTree().containsNode(nodeId);
  }

  @Override
  public IConcept getConcept(long nodeId) {
    return getTree().getConcept(nodeId);
  }

  @Nullable
  @Override
  public IConceptReference getConceptReference(long nodeId) {
    return getTree().getConceptReference(nodeId);
  }

  @Override
  public long getParent(long nodeId) {
    return getTree().getParent(nodeId);
  }

  @Override
  public String getRole(long nodeId) {
    return getTree().getRole(nodeId);
  }

  @Override
  public String getProperty(long nodeId, String role) {
    return getTree().getProperty(nodeId, role);
  }

  @Override
  public Object getUserObject(long nodeId, Object key) {
    return getPTree().getUserObject(nodeId, key);
  }

  @Override
  public INodeReference getReferenceTarget(long sourceId, String role) {
    return getTree().getReferenceTarget(sourceId, role);
  }

  @Override
  public Iterable<Long> getChildren(long parentId, String role) {
    Iterable<Long> result = getTree().getChildren(parentId, role);
    return result;
  }

  @Override
  public Iterable<Long> getAllChildren(long parentId) {
    Iterable<Long> result = getTree().getAllChildren(parentId);
    return result;
  }

  @Override
  public void visitNodes(final _FunctionTypes._return_P1_E0<? extends Boolean, ? super INode> visitor) {
    getPTree().visitNodes((Long id, SM_PTree.PNode node) -> visitor.invoke(new SM_PNodeAdapter(id, branch)));
  }
}

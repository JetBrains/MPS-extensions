package de.itemis.mps.editor.pagination.plugin;

/*Generated by MPS */

import java.awt.event.MouseAdapter;
import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.lang.ref.WeakReference;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.Optional;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Objects;
import de.itemis.mps.editor.pagination.runtime.pages.Pages;
import de.itemis.mps.editor.pagination.runtime.pages.PagesUserObject;
import de.itemis.mps.editor.pagination.runtime.pages.Page;
import de.itemis.mps.editor.pagination.runtime.plugin.utils.EditorCellUtil;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import java.awt.event.MouseEvent;
import com.intellij.openapi.util.SystemInfo;
import jetbrains.mps.nodeEditor.EditorContext;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.project.Project;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.editor.runtime.style.StyleAttributes;

/**
 * this listener was inspired by com.mbeddr.mpsutil.hyperlink.plugin.HyperlinkListener
 */
public class PaginationListener extends MouseAdapter {

  private static Map<EditorComponent, PaginationListener> instances = MapSequence.fromMap(new WeakHashMap<EditorComponent, PaginationListener>());

  public static PaginationListener getOrCreateInstance(EditorComponent editorComponent) {
    PaginationListener listener = MapSequence.fromMap(instances).get(editorComponent);
    if (listener == null) {
      listener = new PaginationListener(editorComponent);
      MapSequence.fromMap(instances).put(editorComponent, listener);
    }
    return listener;
  }

  @Nullable
  public static PaginationListener getInstance(EditorComponent editorComponent) {
    return MapSequence.fromMap(instances).get(editorComponent);
  }

  public static void uninstallAll() {
    for (PaginationListener listener : ListSequence.fromListWithValues(new ArrayList<PaginationListener>(), MapSequence.fromMap(instances).values())) {
      listener.uninstall();
    }
  }

  private WeakReference<EditorComponent> editorComponentRef;

  private PaginationListener(final EditorComponent editorComponent) {
    editorComponentRef = new WeakReference<EditorComponent>(editorComponent);
    editorComponent.addDisposeListener(new EditorComponent.EditorDisposeListener() {
      @Override
      public void editorWillBeDisposed(@NotNull EditorComponent p1) {
        editorComponent.removeDisposeListener(this);
      }
    });
  }

  public EditorComponent getEditorComponent() {
    return editorComponentRef.get();
  }

  public void install() {
    getEditorComponent().addMouseListener(this);
  }

  public void uninstall() {
    getEditorComponent().removeMouseListener(this);
  }

  public boolean isPaginatedCell(EditorCell cell) {
    return check_jbb13b_a0a0t(cell.getStyle()) && (cell.getSRole() instanceof SContainmentLink);
  }

  public Optional<SNode> getAncestorWithLink(SNode node, final SContainmentLink link) {
    return Optional.ofNullable(ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true)).findFirst((ancestorNode) -> Objects.equals(SNodeOperations.getContainingLink(ancestorNode), link)));
  }

  public Optional<Pages> getNewPagesForTarget(SNode targetNode, final PagesUserObject pagesUserObject) {
    return getAncestorWithLink(targetNode, pagesUserObject.getLinkToPaginate()).map((SNode paginatedChild) -> {
      Pages oldPages = pagesUserObject.getPages();
      Page newPage = oldPages.findPageFor(paginatedChild);
      if (oldPages.getCurrentPage().equals(newPage)) {
        return null;
      }
      return oldPages.getPagesWith(newPage);
    });
  }

  public Optional<PagesUserObject> getPagesUserObject(final EditorCell paginatedCell) {
    return Optional.ofNullable(EditorCellUtil.geContainmentLinkInRole(paginatedCell)).flatMap((final SContainmentLink paginatedLink) -> {

      return Optional.ofNullable(paginatedCell.getSNode()).map((SNode paginatedNode) -> {
        Pages oldPages = PagesUserObject.get(paginatedNode, paginatedLink);
        return new PagesUserObject(paginatedNode, paginatedLink, oldPages.getCurrentPage().getPageSize());
      });
    });
  }

  public Iterable<EditorCell_Collection> findDescendantsPaginatedCells(EditorCell startingCell) {
    return Sequence.fromIterable(EditorCellUtil.getDescendants(startingCell, true)).select((cell) -> as_jbb13b_a0a0a0a0a0a72(cell, EditorCell_Collection.class)).where(new NotNullWhereFilter()).where((cell) -> isPaginatedCell(cell));
  }

  public PageChange getPaginatedCellChange(final EditorCell paginatedCell, final SNode targetNode) {
    return getPagesUserObject(paginatedCell).flatMap((final PagesUserObject pagesUserObj) -> getNewPagesForTarget(targetNode, pagesUserObj).map((Pages newPages) -> new PageChange(paginatedCell, newPages, pagesUserObj))).orElse(null);
  }

  public Iterable<PageChange> getPaginatedCellsChanges(EditorCell closestVisibleCell, final SNode targetNode) {
    return Sequence.fromIterable(findDescendantsPaginatedCells(closestVisibleCell)).select((paginatedCell) -> getPaginatedCellChange(paginatedCell, targetNode)).where(new NotNullWhereFilter());
  }

  @Override
  public void mousePressed(MouseEvent e) {
    super.mousePressed(e);
    boolean ctrlDown = (SystemInfo.isMac ? e.isMetaDown() : e.isControlDown());
    final EditorCell cellAtCursor = getEditorComponent().getRootCell().findLeaf(e.getX(), e.getY());
    boolean gotoLink = ctrlDown && check_jbb13b_a0a3a33(cellAtCursor);
    if (!(gotoLink)) {
      return;
    }

    EditorContext editorContext = getEditorComponent().getEditorContext();
    final SRepository repository = editorContext.getRepository();
    final Project project = editorContext.getOperationContext().getProject();
    repository.getModelAccess().runReadAction(() -> {
      Optional.ofNullable(EditorCellUtil.getReferenceTargetInRole(cellAtCursor, repository)).ifPresent((final SNode targetNode) -> {

        Optional.ofNullable(EditorCellUtil.openEditorComponentForNode(targetNode, project)).ifPresent((jetbrains.mps.openapi.editor.EditorComponent editorComponentForTarget) -> {

          boolean pageChanged = true;
          // changing page could render a new paginated cell that we would have to fix
          while (pageChanged) {
            pageChanged = Optional.ofNullable(Sequence.fromIterable(EditorCellUtil.getNodesWithCell(SNodeOperations.getNodeAncestors(targetNode, null, true), editorComponentForTarget)).first()).map((EditorCell firstAncestorVisibleCell) -> {

              Iterable<PageChange> changesToApply = getPaginatedCellsChanges(firstAncestorVisibleCell, targetNode);
              Sequence.fromIterable(changesToApply).visitAll((change) -> {
                change.pagesUserObj.setPages(change.newPages);
                change.paginatedCell.getEditorComponent().rebuildEditorContent();
              });
              return Sequence.fromIterable(changesToApply).isNotEmpty();
            }).orElse(false);
          }
        });
      });

    });
  }

  private final class PageChange {
    /*package*/ final EditorCell paginatedCell;
    /*package*/ final Pages newPages;
    /*package*/ final PagesUserObject pagesUserObj;

    public PageChange(EditorCell paginatedCell, Pages newPages, PagesUserObject pagesUserObj) {
      this.paginatedCell = paginatedCell;
      this.newPages = newPages;
      this.pagesUserObj = pagesUserObj;
    }
  }
  private static Boolean check_jbb13b_a0a0t(Style checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.pagination", "paginated"));
    }
    return null;
  }
  private static boolean check_jbb13b_a0a3a33(EditorCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isReferenceCell();
    }
    return false;
  }
  private static <T> T as_jbb13b_a0a0a0a0a0a72(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

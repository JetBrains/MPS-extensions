package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import de.itemis.mps.editor.diagram.runtime.model.Port;
import com.mxgraph.model.mxGeometry;
import com.mxgraph.util.mxStyleUtils;
import com.mxgraph.util.mxConstants;
import de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods;
import java.awt.Graphics2D;
import com.mxgraph.canvas.mxGraphics2DCanvas;
import com.mxgraph.view.mxCellState;
import com.mxgraph.swing.handler.mxConnectionHandler;
import com.mxgraph.swing.handler.mxConnectPreview;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import com.mxgraph.swing.util.mxSwingConstants;
import com.mxgraph.swing.handler.mxCellMarker;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.mxgraph.util.mxUtils;
import java.awt.geom.Rectangle2D;
import java.awt.AlphaComposite;
import com.intellij.ui.JBColor;
import org.jetbrains.annotations.Nullable;
import de.itemis.mps.editor.diagram.runtime.model.IDiagramElement;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import java.util.List;
import com.mxgraph.util.mxPoint;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class PortDCell extends BaseDCell implements ISelfPaintingCell, IDiagramDCell {
  private Port myPort;
  private double myLabelOpacity = 0.0;

  public PortDCell(Port port, double width, double height, MyGraph graph) {
    super(graph);
    myPort = port;
    setVertex(true);

    mxGeometry geometry = new mxGeometry(0.0, 0.5, width, height);
    geometry.setRelative(false);
    this.setGeometry(geometry);

    String style = "";
    style = mxStyleUtils.setStyle(style, mxConstants.STYLE_FONTCOLOR, "black");
    style = mxStyleUtils.setStyle(style, mxConstants.STYLE_NOLABEL, "true");
    this.setStyle(style);

  }

  public Port getPort() {
    return myPort;
  }

  public void setPort(Port port) {
    myPort = port;
  }

  public boolean setLabelOpacity(double opacity) {
    boolean changed = !(ExtensionMethods.isNear(myLabelOpacity, opacity));
    myLabelOpacity = opacity;
    return changed;
  }

  public double getLabelOpacity() {
    return myLabelOpacity;
  }

  @Override
  public void paintBackground(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {

  }

  @Override
  public void paintForeground(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {
    DrawUtil.drawShape(canvas, state);
    mxConnectionHandler connectionHandler = this._getGraph().getGraphComponent().getConnectionHandler();
    mxConnectPreview connectPreview = connectionHandler.getConnectPreview();
    mxCellState sourceState = ((mxCellState) ReflectionUtil.readField(mxConnectionHandler.class, connectionHandler, "source"));
    if (connectPreview.isActive() && sourceState != state) {
      if (connectionHandler.validateConnection(sourceState.getCell(), state.getCell()) == null) {
        g.setColor(mxSwingConstants.DEFAULT_VALID_COLOR);
      } else {
        g.setColor(mxSwingConstants.DEFAULT_INVALID_COLOR);
      }
      g.setStroke(mxCellMarker.DEFAULT_STROKE);
      g.drawRect((int) state.getX(), (int) state.getY(), (int) state.getWidth(), (int) state.getHeight());

    }

  }

  public String getPortLabel() {
    return "" + getValue();
  }

  @Override
  public void paintTop(final Graphics2D g, final mxGraphics2DCanvas canvas, final mxCellState state) {
    // draw label
    if (this.getLabelOpacity() > 0.0) {
      DrawUtil.executeWithGraphicsCopy(g, canvas, new _FunctionTypes._void_P1_E0<Graphics2D>() {
        public void invoke(Graphics2D g) {
          g.setFont(mxUtils.getFont(state.getStyle(), state.getView().getScale()));

          String label = getPortLabel();

          Rectangle2D labelBounds = g.getFontMetrics().getStringBounds(label, g);

          if (label != null && labelBounds != null) {
            double scale = state.getView().getScale();
            double x;
            if (getGeometry().getX() > 0.5) {
              x = state.getX() + state.getWidth();
              x += 5.0 * scale;
            } else {
              x = state.getX() - labelBounds.getWidth();
              x -= 5.0 * scale;
            }
            double y = state.getY();

            g.translate(x, y);
            g.translate(-labelBounds.getX(), -labelBounds.getY());

            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) PortDCell.this.getLabelOpacity()));

            // background
            {
              Rectangle2D fillBounds = JGraphUtil.extend(labelBounds, 2.0 * scale, 3.0 * scale);
              g.setColor(JBColor.WHITE);
              g.fill(fillBounds);
            }

            // text
            g.setColor(JBColor.BLACK);
            g.drawString(getPortLabel(), 0.0f, 0.0f);
          }
        }
      });
    }
  }
  @Override
  public boolean canPaintSelf(mxGraphics2DCanvas canvas, mxCellState state) {
    return true;
  }
  @Override
  public boolean doesAdditionalPaintingOnly() {
    return false;
  }

  @Override
  public BoxDCell getParent() {
    return (BoxDCell) super.getParent();
  }

  public BoxDCell getBox() {
    return getParent();
  }

  @Override
  public boolean constrainPosition() {
    return true;
  }

  @Override
  public String getTooltipText() {
    return null;
  }

  @Nullable
  @Override
  public IDiagramElement getDiagramElement() {
    return null;
  }

  @Override
  public boolean canDrop(Object data) {
    return false;
  }
  @Override
  public void drop(Object data) {
  }

  public double getLayoutedX() {
    return CellExtensions.getBounds(this).getX();
  }

  public double getLayoutedY() {
    return CellExtensions.getBounds(this).getY();
  }

  public void setLayoutedX(double x) {
    Bounds bounds = CellExtensions.getBounds(this);
    bounds.setX(x);
    CellExtensions.setBounds(this, bounds);
  }

  public void setLayoutedY(double y) {
    Bounds bounds = CellExtensions.getBounds(this);
    bounds.setY(y);
    CellExtensions.setBounds(this, bounds);
  }

  public int getNewOrdinal() {
    for (Object edge : _getGraph().getEdges(this, null, true, false, false)) {
      mxCellState state = _getGraph().getView().getState(edge);
      List<mxPoint> points = state.getAbsolutePoints();
      if (ListSequence.fromList(points).count() >= 2) {
        return getNewOrdinal(ListSequence.fromList(points).reversedList());
      }
    }
    for (Object edge : _getGraph().getEdges(this, null, false, true, false)) {
      mxCellState state = _getGraph().getView().getState(edge);
      List<mxPoint> points = state.getAbsolutePoints();
      if (ListSequence.fromList(points).count() >= 2) {
        return getNewOrdinal(points);
      }
    }

    return 0;
  }

  public static int getNewOrdinal(List<mxPoint> points) {
    mxPoint p0 = null;
    mxPoint p1 = null;
    mxPoint p2 = null;
    for (mxPoint p : ListSequence.fromList(points)) {
      p2 = p1;
      p1 = p0;
      p0 = p;
      if (p0 != null && p1 != null && p2 != null) {
        double delta01 = p0.getX() - p1.getX();
        double delta12 = p1.getX() - p2.getX();
        double signum0 = Math.signum(delta01);
        double signum1 = Math.signum(delta12);
        boolean directionChanged = signum0 > 0.0 && signum1 < 0.0 || signum0 < 0.0 && signum1 > 0.0;
        if (directionChanged) {
          return ExtensionMethods.toInt(p1.getY());
        }
      }
    }
    if (p0 != null) {
      return ExtensionMethods.toInt(p0.getY());
    }
    return 0;
  }

}

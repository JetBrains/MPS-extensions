package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.shape.mxConnectorShape;
import com.mxgraph.canvas.mxGraphics2DCanvas;
import java.util.List;
import com.mxgraph.util.mxPoint;
import java.util.Map;
import de.itemis.mps.editor.diagram.runtime.model.Point;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import java.awt.geom.Path2D;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Line2D;
import de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.awt.Graphics2D;
import com.mxgraph.view.mxCellState;
import de.itemis.mps.editor.diagram.runtime.model.Edge;
import de.itemis.mps.editor.diagram.styles.editor.StyleUtils;
import jetbrains.mps.errors.MessageStatus;
import java.awt.Color;
import jetbrains.mps.typesystem.checking.HighlightUtil;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.message.SimpleEditorMessage;
import java.util.ListIterator;

public class MyConnectorShape extends mxConnectorShape {
  private static final double WAVE_AMPLITUDE = 2.0;

  private boolean myIsWaveLine = false;

  @Override
  protected void paintPolyline(mxGraphics2DCanvas canvas, List<mxPoint> points, Map<String, Object> style) {
    paintPolyLine(canvas, points, style, isRounded(style), myIsWaveLine);
  }

  public Iterable<Point> getPointsOnCurve(List<mxPoint> anchorPoints, double desiredDistance) {
    final List<Point> result = ListSequence.fromList(new ArrayList<Point>());
    visitPointsOnPath(pointsToPath(anchorPoints, true), desiredDistance, (Vector2D point, Vector2D direction) -> ListSequence.fromList(result).addElement(new Point(point.getX(), point.getY())));
    return result;
  }

  public static Path2D visitPointsOnPath(Path2D path, double desiredDistance, _FunctionTypes._void_P2_E0<? super Vector2D, ? super Vector2D> visitor) {
    GeneralPath wave = new GeneralPath();


    List<double[]> pointList = new ArrayList<double[]>();
    double[] coords = new double[6];
    int numSubPaths = 0;

    Point2D prevPoint = null;
    boolean beginningVisited = false;
    Vector2D visitPoint = new Vector2D(0.0, 0.0);
    double distanceToLast = 0.0;
    Vector2D lastDirection = null;
    for (PathIterator pi = path.getPathIterator(null, 1.0); !(pi.isDone()); pi.next()) {
      int type = pi.currentSegment(coords);
      Point2D currentPoint = new Point2D.Double(coords[0], coords[1]);
      switch (type) {
        case PathIterator.SEG_MOVETO:
          wave.moveTo(coords[0], coords[1]);
          beginningVisited = false;
          break;
        case PathIterator.SEG_LINETO:
          Line2D.Double line = new Line2D.Double(prevPoint, currentPoint);
          visitPoint = ExtensionMethods.toVector2D(prevPoint);
          Vector2D direction = ExtensionMethods.toVector2D(currentPoint).subtract(ExtensionMethods.toVector2D(prevPoint));
          double length = direction.getNorm();
          direction = VectorExtensions.normalizeSafe(direction);
          if (!(beginningVisited)) {
            visitor.invoke(visitPoint, direction);
            beginningVisited = true;
            distanceToLast = 0.0;
          }
          double remaining = length + distanceToLast;
          for (; remaining >= desiredDistance; remaining -= desiredDistance) {
            double moveDistance = desiredDistance - distanceToLast;
            visitPoint = visitPoint.add(moveDistance, direction);
            visitor.invoke(visitPoint, direction);
            distanceToLast = 0.0;
          }
          distanceToLast = remaining;
          lastDirection = direction;
          break;
        case PathIterator.SEG_CLOSE:
          break;
        default:
          throw new IllegalArgumentException("Unexpected segment type: " + type);
      }
      prevPoint = currentPoint;
    }
    if (lastDirection != null && distanceToLast > 0.0) {
      visitor.invoke(ExtensionMethods.toVector2D(prevPoint), lastDirection);
    }

    return wave;
  }

  public Path2D pathToWave(Path2D path, final double amplitude) {
    final GeneralPath wave = new GeneralPath();

    final Wrappers._boolean first = new Wrappers._boolean(true);
    final Wrappers._boolean sideA = new Wrappers._boolean(true);
    visitPointsOnPath(path, amplitude, (Vector2D point, Vector2D direction) -> {
      if (first.value) {
        wave.moveTo(point.getX(), point.getY());
        first.value = false;
      } else {
        Vector2D direction90 = VectorExtensions.rotate90(direction);
        if (sideA.value) {
          direction90 = direction90.scalarMultiply(-1);
        }
        Vector2D wavePoint = point.add(amplitude / 2, direction90);
        wave.lineTo(wavePoint.getX(), wavePoint.getY());
        sideA.value = !(sideA.value);
      }

    });

    return wave;
  }

  protected void paintPolyLine(mxGraphics2DCanvas canvas, List<mxPoint> points, Map<String, Object> style, boolean rounded, boolean wave) {
    if (points.size() < 2) {
      return;
    }

    Path2D path = pointsToPath(points, rounded);
    if (wave) {
      double scale = canvas.getScale();
      double amplitude = WAVE_AMPLITUDE * scale;
      path = pathToWave(path, amplitude);
    }
    Graphics2D g = canvas.getGraphics();
    g.draw(path);
  }

  protected Path2D pointsToPath(List<mxPoint> points, boolean rounded) {
    GeneralPath path = new GeneralPath();
    path.moveTo(points.get(0).getX(), points.get(0).getY());

    if (rounded && points.size() > 2) {
      for (int i = 1; i < points.size() - 1; i += 2) {
        Vector2D p1 = VectorExtensions.toVector2D(points.get(i));
        Vector2D p2 = VectorExtensions.toVector2D(points.get(i + 1));
        Vector2D p3 = check_mk8rog_a0c0a0d0o(get(points, i + 2), this);
        Vector2D cp1 = p1;
        Vector2D cp2 = p2;
        Vector2D endPoint;
        if (i + 2 == points.size() - 1) {
          endPoint = p3;
        } else {
          if (i + 2 > points.size() - 1) {
            endPoint = p2;
            cp2 = p1;
          } else {
            Vector2D d23 = p3.subtract(p2);
            endPoint = p2.add(d23.getNorm() / 2, VectorExtensions.normalizeSafe(d23));
          }
        }
        path.curveTo(cp1.getX(), cp1.getY(), cp2.getX(), cp2.getY(), endPoint.getX(), endPoint.getY());
      }
    } else {
      for (int i = 1; i < points.size(); i++) {
        mxPoint currentPoint = points.get(i);
        path.lineTo(currentPoint.getX(), currentPoint.getY());
      }
    }
    return path;
  }

  private <T> T get(List<T> list, int index) {
    return (0 <= index && index < list.size() ? list.get(index) : null);
  }

  @Override
  protected boolean configureGraphics(mxGraphics2DCanvas canvas, mxCellState state, boolean background) {
    super.configureGraphics(canvas, state, background);
    EdgeDCell edgeCell = ((EdgeDCell) state.getCell());
    Edge edge = edgeCell.getEdge();
    if (edge != null) {
      StyleUtils.configureLineStyle(canvas.getGraphics(), edge.getStyle(), canvas.getScale());
      MessageStatus messageType = getMostImportantMessageType(edge.getRootCell());
      myIsWaveLine = useWaveLine(messageType);
      if (myIsWaveLine) {
        Color messageColor = HighlightUtil.getMessageColor(messageType);
        canvas.getGraphics().setColor(messageColor);
      }
    }

    return true;
  }

  protected MessageStatus getMostImportantMessageType(EditorCell cell) {
    if (cell == null) {
      return null;
    }
    MessageStatus result = null;
    List<SimpleEditorMessage> messages = cell.getMessages();
    for (ListIterator<SimpleEditorMessage> it = messages.listIterator(messages.size()); it.hasPrevious();) {
      SimpleEditorMessage message = it.previous();
      result = getMostImportant(result, message.getStatus());
    }
    return result;
  }

  protected MessageStatus getMostImportant(MessageStatus s1, MessageStatus s2) {
    if (s1 == null) {
      return s2;
    }
    if (s2 == null) {
      return s1;
    }
    if (s1 == MessageStatus.ERROR || s2 == MessageStatus.ERROR) {
      return MessageStatus.ERROR;
    }
    if (s1 == MessageStatus.WARNING || s2 == MessageStatus.WARNING) {
      return MessageStatus.WARNING;
    }
    if (s1 == MessageStatus.OK || s2 == MessageStatus.OK) {
      return MessageStatus.OK;
    }
    return null;
  }

  protected boolean useWaveLine(MessageStatus type) {
    return type == MessageStatus.ERROR || type == MessageStatus.WARNING;
  }
  private static Vector2D check_mk8rog_a0c0a0d0o(mxPoint checkedDotOperand, MyConnectorShape checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return VectorExtensions.toVector2D(checkedDotOperand);
    }
    return null;
  }
}

package de.q60.mps.shadowmodels.runtime.model.persistent;

/*Generated by MPS */

import org.modelix.model.area.IArea;
import org.modelix.model.api.IBranch;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.area.IAreaReference;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConcept;
import org.modelix.model.api.IConceptReference;
import java.util.Objects;
import org.modelix.model.api.INode;
import org.modelix.model.api.INodeReference;
import org.modelix.model.api.ITree;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import kotlin.jvm.functions.Function0;
import org.modelix.model.area.IAreaListener;
import org.modelix.model.area.AreaListenerRegistry;

public class SM_PArea implements IArea {
  private IBranch branch;

  public SM_PArea(IBranch branch) {
    this.branch = branch;
  }

  @Override
  public long getLockOrderingPriority() {
    return System.identityHashCode(branch);
  }

  @NotNull
  @Override
  public IAreaReference getReference() {
    return new AreaReference(branch);
  }

  @Nullable
  @Override
  public IConcept resolveConcept(@NotNull IConceptReference reference) {
    return null;
  }

  @Nullable
  @Override
  public IArea resolveArea(@NotNull IAreaReference reference) {
    return (Objects.equals(reference, getReference()) ? this : null);
  }

  public IBranch getBranch() {
    return branch;
  }

  @Override
  public INode resolveNode(INodeReference ref) {
    return resolveOriginalNode(ref);
  }

  @NotNull
  @Override
  public INode getRoot() {
    return SM_PNodeAdapter.wrap(ITree.ROOT_ID, branch);
  }

  @Nullable
  @Override
  public INode resolveOriginalNode(@NotNull INodeReference ref) {
    return (ref instanceof SM_PNodeReference && branch.getTransaction().containsNode(((SM_PNodeReference) ref).getId()) ? new SM_PNodeAdapter(((SM_PNodeReference) ref).getId(), branch) : null);
  }

  @Nullable
  @Override
  public IBranch resolveBranch(@NotNull String id) {
    return (Objects.equals(id, branch.getId()) ? branch : null);
  }

  @NotNull
  @Override
  public List<IArea> collectAreas() {
    return ListSequence.fromListAndArray(new ArrayList<IArea>(), this);
  }

  @Override
  public <T> T executeRead(@NotNull Function0<? extends T> f) {
    return branch.computeRead(f);
  }

  @Override
  public <T> T executeWrite(@NotNull Function0<? extends T> f) {
    return branch.computeWrite(f);
  }

  @Override
  public boolean canRead() {
    return branch.canRead();
  }

  @Override
  public boolean canWrite() {
    return branch.canWrite();
  }

  @Override
  public void addListener(@NotNull IAreaListener listener) {
    AreaListenerRegistry.INSTANCE.registerListener(this, listener);
  }

  @Override
  public void removeListener(@NotNull IAreaListener listener) {
    AreaListenerRegistry.INSTANCE.registerListener(this, listener);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    SM_PArea that = (SM_PArea) o;
    if ((branch != null ? !(branch.equals(that.branch)) : that.branch != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((branch != null ? ((Object) branch).hashCode() : 0));
    return result;
  }

  public static class AreaReference implements IAreaReference {
    private IBranch branch;

    public AreaReference(IBranch branch) {
      this.branch = branch;
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      AreaReference that = (AreaReference) o;
      if ((branch != null ? !(branch.equals(that.branch)) : that.branch != null)) {
        return false;
      }

      return true;
    }
    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((branch != null ? ((Object) branch).hashCode() : 0));
      return result;
    }
  }
}

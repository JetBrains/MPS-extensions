package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public abstract class AbstractScope implements IScope {

  public AbstractScope() {
  }

  @Override
  public ISubgraphStage getStage(ITransformationEngine engine) {
    IStageReference ref = getStage();
    return (ref == null ? null : engine.resolveStage(ref));
  }

  @Override
  public Iterable<ScopeImport> getImports(ITransformationEngine engine) {
    return Sequence.fromIterable(Collections.<ScopeImport>emptyList());
  }

  @Override
  public boolean visitScopes(_FunctionTypes._return_P1_E0<? extends Boolean, ? super IScope> visitor, Set<IScope> visitedScopes, boolean includeTransitive, ITransformationEngine engine) {
    if (SetSequence.fromSet(visitedScopes).contains(this)) {
      return true;
    }
    if (!(visitor.invoke(this))) {
      return false;
    }

    for (ScopeImport imp : Sequence.fromIterable(getImports(engine))) {
      if (!(includeTransitive) && !(imp.isReexport())) {
        continue;
      }
      IScope resolvedScope = imp.getScopeReference().resolve(this, engine);
      if (resolvedScope == null) {
        continue;
      }
      if (!(resolvedScope.visitScopes(visitor, visitedScopes, imp.isIncludeTransitive(), engine))) {
        return false;
      }
    }

    if (!(includeTransitive)) {
      return true;
    }
    IScope parent = getParent();
    if (parent != null) {
      return parent.visitScopes(visitor, visitedScopes, true, engine);
    }

    return true;
  }

  @Override
  public IScope resolve(IScope importingScope, ITransformationEngine engine) {
    return this;
  }
}

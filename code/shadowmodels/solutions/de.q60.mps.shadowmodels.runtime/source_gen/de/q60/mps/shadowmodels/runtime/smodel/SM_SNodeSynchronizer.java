package de.q60.mps.shadowmodels.runtime.smodel;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.Iterator;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class SM_SNodeSynchronizer {

  private Map<SNode, SNode> newNodeToActualNode = MapSequence.fromMap(new HashMap<SNode, SNode>());
  private List<ReferenceToResolve> referencesQueue = ListSequence.fromList(new ArrayList<ReferenceToResolve>());

  public void processReferences() {
    ListSequence.fromList(referencesQueue).visitAll((it) -> it.run());
    for (SNode sourceNode : Sequence.fromIterable(MapSequence.fromMap(newNodeToActualNode).values())) {
      for (SReference reference : ListSequence.fromList(SNodeOperations.getReferences(sourceNode))) {
        SNode currentTarget = reference.getTargetNode();
        if (currentTarget == null) {
          continue;
        }
        SNode expectedTarget = MapSequence.fromMap(newNodeToActualNode).get(currentTarget);
        if (expectedTarget != null && !(Objects.equals(currentTarget, expectedTarget))) {
          sourceNode.setReferenceTarget(reference.getLink(), expectedTarget);
        }
      }
    }
  }

  public void synchronizeNode(SNode newNode, SNode existingNode) {
    SAbstractConcept concept = SNodeOperations.getConcept(newNode);
    if (Objects.equals(SNodeOperations.getConcept(newNode), SNodeOperations.getConcept(existingNode))) {
      MapSequence.fromMap(newNodeToActualNode).put(newNode, existingNode);
      for (SProperty property : CollectionSequence.fromCollection(concept.getProperties())) {
        String newValue = newNode.getProperty(property);
        if (!(Objects.equals(existingNode.getProperty(property), newValue))) {
          existingNode.setProperty(property, newValue);
        }
      }
      for (SReferenceLink link : CollectionSequence.fromCollection(concept.getReferenceLinks())) {
        SNode newValue = newNode.getReferenceTarget(link);
        ListSequence.fromList(referencesQueue).addElement(new ReferenceToResolve(existingNode, link, newValue));
      }
      for (SContainmentLink link : CollectionSequence.fromCollection(concept.getContainmentLinks())) {
        List<SNode> currentChildren = SNodeOperations.getChildren(existingNode, link);
        List<SNode> newChildren = SNodeOperations.getChildren(newNode, link);
        if (ListSequence.fromList(currentChildren).count() == ListSequence.fromList(newChildren).count()) {
          {
            Iterator<SNode> currentChild_it = ListSequence.fromList(currentChildren).iterator();
            Iterator<SNode> newChild_it = ListSequence.fromList(newChildren).iterator();
            SNode currentChild_var;
            SNode newChild_var;
            while (currentChild_it.hasNext() && newChild_it.hasNext()) {
              currentChild_var = currentChild_it.next();
              newChild_var = newChild_it.next();
              synchronizeNode(newChild_var, currentChild_var);
            }
          }
        } else {
          ListSequence.fromList(SNodeOperations.getChildren(existingNode, link)).clear();
          ListSequence.fromList(SNodeOperations.getChildren(existingNode, link)).addSequence(ListSequence.fromList(newChildren));
          ListSequence.fromList(newChildren).translate((it) -> SNodeOperations.getNodeDescendants(it, CONCEPTS.BaseConcept$gP, true, new SAbstractConcept[]{})).visitAll((it) -> MapSequence.fromMap(newNodeToActualNode).put(it, it));
        }
      }
    } else {
      SNodeOperations.replaceWithAnother(existingNode, newNode);
      ListSequence.fromList(SNodeOperations.getNodeDescendants(newNode, CONCEPTS.BaseConcept$gP, true, new SAbstractConcept[]{})).visitAll((it) -> MapSequence.fromMap(newNodeToActualNode).put(it, it));
    }
  }

  private class ReferenceToResolve {
    private SNode source;
    private SReferenceLink link;
    private SNode target;

    public ReferenceToResolve(SNode source1, SReferenceLink link1, SNode target1) {
      source = source1;
      link = link1;
      target = target1;
    }

    public void run() {
      SNode actualTarget = (target == null ? null : MapSequence.fromMap(newNodeToActualNode).get(target));
      if (!(Objects.equals(source.getReferenceTarget(link), actualTarget))) {
        source.setReferenceTarget(link, actualTarget);
      }
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
  }
}

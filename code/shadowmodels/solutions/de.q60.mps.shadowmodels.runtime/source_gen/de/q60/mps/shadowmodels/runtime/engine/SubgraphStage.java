package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import java.util.List;
import java.util.Map;
import com.google.common.collect.ListMultimap;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.google.common.collect.MultimapBuilder;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.google.common.collect.SetMultimap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.q60.mps.logging.runtime.ShadowLogging;
import java.util.Objects;

public class SubgraphStage implements ISubgraphStage {

  private final ITransformationEngine engine;
  private final SubstepStageReference stageRef;
  @Nullable
  private final SubstepStageReference previousStageRef;
  private List<IUniqueContainmentTarget> roots;

  /**
   * Doesn't contain all the content. There are different ways to make a containment unique.
   */
  private Map<IScope, ListMultimap<IContainmentTarget, IUniqueContainmentTarget>> uniqueContainmentTargets = MapSequence.fromMap(new HashMap<IScope, ListMultimap<IContainmentTarget, IUniqueContainmentTarget>>());
  private Set<IUniqueContainmentTarget> contents = SetSequence.fromSet(new HashSet<IUniqueContainmentTarget>());
  private final Map<IUniqueContainmentTarget, IContainment> containments = MapSequence.fromMap(new HashMap<IUniqueContainmentTarget, IContainment>());
  private ListMultimap<IOutputNodeReference, IOutputWrapper> outputWrappers = MultimapBuilder.hashKeys().arrayListValues(1).<IOutputNodeReference,IOutputWrapper>build();
  private List<IWeaving> pendingWeavings = ListSequence.fromList(new ArrayList<IWeaving>());
  private Set<IUniqueContainmentTarget> callsWithLabels = SetSequence.fromSet(new HashSet<IUniqueContainmentTarget>());
  private Set<IUniqueContainmentTarget> callsWithDependencies = SetSequence.fromSet(new HashSet<IUniqueContainmentTarget>());
  private Map<IUniqueContainmentTarget<RewriteCall>, IUniqueContainmentTarget> rewriteReplacements = MapSequence.fromMap(new HashMap<IUniqueContainmentTarget<RewriteCall>, IUniqueContainmentTarget>());
  private SetMultimap<IContainmentTarget, IUniqueContainmentTarget> referenceTargets = MultimapBuilder.hashKeys().hashSetValues(1).<IContainmentTarget,IUniqueContainmentTarget>build();

  private boolean anyTransformationsApplied = false;
  private boolean isResolvingWeavingTarget = false;

  private boolean frozen = false;
  private boolean frozenCheckDisabled = false;

  public SubgraphStage(ITransformationEngine engine, SubstepStageReference stageRef, SubstepStageReference previousStageRef, Iterable<IContainmentTarget> roots) {
    this.engine = engine;
    this.stageRef = stageRef;
    this.previousStageRef = previousStageRef;
    this.roots = Sequence.fromIterable(roots).select(new _FunctionTypes._return_P1_E0<IUniqueContainmentTarget, IContainmentTarget>() {
      public IUniqueContainmentTarget invoke(IContainmentTarget it) {
        IUniqueContainmentTarget r = makeUnique(null, it);
        return r;
      }
    }).toList();
  }

  public void freeze() {
    if (frozen) {
      return;
    }
    frozen = true;
  }

  protected void checkNotFrozen() {
    if (frozen) {
      throw new IllegalStateException("Subgraph computation is already completed. " + stageRef);
    }
  }

  protected void checkFrozen() {
    if (frozenCheckDisabled) {
      return;
    }
    if (!(frozen)) {
      throw new IllegalStateException("Subgraph computation is still in progress. " + stageRef);
    }
  }

  public <T> T computeWithFrozenCheckDisabled(_FunctionTypes._return_P0_E0<? extends T> r) {
    boolean wasDisabled = frozenCheckDisabled;
    try {
      frozenCheckDisabled = true;
      return r.invoke();
    } finally {
      frozenCheckDisabled = wasDisabled;
    }
  }

  public void runWithFrozenCheckDisabled(_FunctionTypes._void_P0_E0 r) {
    boolean wasDisabled = frozenCheckDisabled;
    try {
      frozenCheckDisabled = true;
      r.invoke();
    } finally {
      frozenCheckDisabled = wasDisabled;
    }
  }

  @Override
  public SubstepStageReference getStageReference() {
    return this.stageRef;
  }

  @Override
  public SubstepStageReference getPreviousStageRef() {
    return this.previousStageRef;
  }

  @Override
  public Iterable<IUniqueContainmentTarget> getRoots() {
    return roots;
  }

  @Override
  public IScope getOwnScope() {
    return new StageScope(stageRef);
  }

  @Override
  public <T extends IContainmentTarget> IUniqueContainmentTarget<T> makeUnique(@Nullable IScope scope, T target) {
    checkNotFrozen();
    if (scope == null) {
      scope = getOwnScope();
    }
    ListMultimap<IContainmentTarget, IUniqueContainmentTarget> uct = MapSequence.fromMap(uniqueContainmentTargets).get(scope);
    if (uct == null) {
      uct = MultimapBuilder.hashKeys().arrayListValues(1).<IContainmentTarget,IUniqueContainmentTarget>build();
      MapSequence.fromMap(uniqueContainmentTargets).put(scope, uct);
    }

    int sequenceNumber = uct.get(target).size();
    IUniqueContainmentTarget<T> uniqueTarget = new SequentialUniqueContainmentTarget<T>(target, sequenceNumber);
    uct.put(target, uniqueTarget);
    return new UniqueTargetInScope<T>(scope, uniqueTarget);
  }

  @Override
  public void registerContent(IUniqueContainmentTarget call, @Nullable ITransformationResult tresult, @Nullable IContainment containment) {
    checkNotFrozen();
    SetSequence.fromSet(contents).addElement(call);
    referenceTargets.put(call.getTarget(), call);
    if (containment != null) {
      MapSequence.fromMap(containments).put(call, containment);
    }
    if (tresult != null) {
      anyTransformationsApplied = true;
      if (!(tresult.mappingLabels().isEmpty())) {
        SetSequence.fromSet(callsWithLabels).addElement(call);
      }
      if (Sequence.fromIterable(tresult.getDependencies()).isNotEmpty()) {
        SetSequence.fromSet(callsWithDependencies).addElement(call);
      }
      ListSequence.fromList(pendingWeavings).addSequence(Sequence.fromIterable(tresult.getWeavings()));
    }
  }

  public void addPendingWeaving(IWeaving weaving) {
    ListSequence.fromList(pendingWeavings).addElement(weaving);
  }

  @Override
  public Iterable<IUniqueContainmentTarget> resolveContent(IContainmentTarget target) {
    if (!(isResolvingWeavingTarget)) {
      checkFrozen();
    }
    Iterable<IUniqueContainmentTarget> targets = referenceTargets.get(target);
    return Sequence.fromIterable(targets).where(new _FunctionTypes._return_P1_E0<Boolean, IUniqueContainmentTarget>() {
      public Boolean invoke(IUniqueContainmentTarget it) {
        return SetSequence.fromSet(contents).contains(it);
      }
    });
  }

  @Override
  public void registerRewriteReplacement(IUniqueContainmentTarget<RewriteCall> rewriteCall, IUniqueContainmentTarget replacement) {
    checkNotFrozen();
    MapSequence.fromMap(rewriteReplacements).put(rewriteCall, replacement);
    referenceTargets.put(rewriteCall.getTarget(), replacement);
  }

  @Nullable
  @Override
  public Iterable<IOutputNodeReference> resolveContainmentTarget(IUniqueContainmentTarget target) {
    if (target.getTarget() instanceof TransformationCall) {
      ITransformationResult tresult = getTransformationResult(((IUniqueContainmentTarget<TransformationCall>) target));
      return Sequence.fromIterable(tresult.getRootNodes()).select((it) -> applyWeavings(it));
    } else if (target.getTarget() instanceof RewriteCall) {
      IUniqueContainmentTarget replacement = MapSequence.fromMap(rewriteReplacements).get((IUniqueContainmentTarget<RewriteCall>) target);
      if (replacement == null) {
        throw new RuntimeException("Unknown rewrite: " + target);
      }
      return resolveContainmentTarget(replacement);
    } else if (target.getTarget() instanceof CopyCall) {
      return Sequence.fromIterable(Sequence.<IOutputNodeReference>singleton(new CopiedOutputNodeReference(getStageReference(), (IUniqueContainmentTarget<CopyCall>) target))).select((it) -> applyWeavings(it));
    } else {
      throw new RuntimeException("Not supported: " + target);
    }
  }

  public IOutputNodeReference resolveWeavingTarget(IScope sourceScope, IReferenceTarget target) {
    // Weavings need to be resolved before the stage is frozen
    boolean wasResolvingWeavingTarget = isResolvingWeavingTarget;
    try {
      isResolvingWeavingTarget = true;
      return target.resolve(sourceScope, engine);
    } finally {
      isResolvingWeavingTarget = wasResolvingWeavingTarget;
    }
  }

  @Override
  public Iterable<MappingLabels> getMappingLabels() {
    checkFrozen();
    return SetSequence.fromSet(callsWithLabels).where(new _FunctionTypes._return_P1_E0<Boolean, IUniqueContainmentTarget>() {
      public Boolean invoke(IUniqueContainmentTarget it) {
        return it.getTarget() instanceof TransformationCall;
      }
    }).select(new _FunctionTypes._return_P1_E0<ITransformationResult, IUniqueContainmentTarget>() {
      public ITransformationResult invoke(IUniqueContainmentTarget it) {
        return getTransformationResult(it);
      }
    }).select((it) -> it.mappingLabels());
  }

  public Iterable<IUniqueContainmentTarget> getAllContent() {
    checkFrozen();
    return contents;
  }

  @Override
  public ITransformationResult getTransformationResult(IUniqueContainmentTarget<TransformationCall> call) {
    if (frozen && !(SetSequence.fromSet(contents).contains(call))) {
      RuntimeException ex = new RuntimeException(stageRef + " doesn't contain " + call);
      ShadowLogging.logError(ex, stageRef, call);
      throw ex;
    }
    return engine.execute(stageRef, call);
  }

  @Override
  public IContainment resolveContainment(IOutputNodeReference child) {
    checkFrozen();
    if (child instanceof ResultElementOutputNodeReference_Id) {
      ContainmentTargetRootNodes<TransformationCall> resultRef = ((ResultElementOutputNodeReference) child).getResultRef();
      if (Objects.equals(resultRef.getStageRef(), stageRef)) {
        ITransformationResult tr = getTransformationResult(resultRef.getContainmentTarget());
        TransformationResult.ResultElement re = as_d95i60_a0a1a1a1a26(tr.getElementById(((ResultElementOutputNodeReference_Id) child).getId()), TransformationResult.ResultElement.class);
        TransformationResult.ResultElement parentRE = re.getParent();
        if (parentRE != null) {
          return new KnownContainment(parentRE.getCanonicalReference(), re.getRoleInParent());
        }
        return resolveContainment(resultRef.getContainmentTarget());
      }
    }
    return null;
  }

  @Override
  public IContainment resolveContainment(IUniqueContainmentTarget child) {
    checkFrozen();
    return MapSequence.fromMap(containments).get(child);
  }

  public IOutputNodeReference applyWeavings(IOutputNodeReference node) {
    boolean done = false;
    while (!(done)) {
      done = true;
      for (IOutputWrapper wrapper : ListSequence.fromList(outputWrappers.get(node))) {
        node = wrapper.wrap(node);
        done = false;
      }
    }
    return node;
  }

  @Override
  public boolean hasPendingWeavings() {
    return ListSequence.fromList(pendingWeavings).isNotEmpty();
  }

  @Override
  public Iterable<IWeaving> getPendingWeavings() {
    return pendingWeavings;
  }

  @Override
  public void clearPendingWeavings() {
    ListSequence.fromList(pendingWeavings).clear();
  }

  @Override
  public void registerWeaving(IWeaving weaving) {
    IOutputNodeReference target = resolveWeavingTarget(weaving.getSourceScope(), weaving.getTargetNode());
    if (target == null) {
      RuntimeException ex = new RuntimeException("Weaving target " + weaving.getTargetNode() + " not found in " + getStageReference());
      ShadowLogging.logError(ex, weaving, getStageReference());
      throw ex;
    }
    if (!(Objects.equals(target.getStageRef(), getStageReference()))) {
      RuntimeException ex = new RuntimeException("Weaving target " + target + " is not part of stage " + getStageReference());
      ShadowLogging.logError(ex, target, weaving, getStageReference());
      throw ex;
    }
    registerOutputWrapper(target, weaving);
  }

  public void registerOutputWrapper(IOutputNodeReference output, IOutputWrapper wrapper) {
    outputWrappers.put(output, wrapper);
  }

  public boolean hasAnyTransformationsApplied() {
    return anyTransformationsApplied;
  }

  public ITransformationEngine getEngine() {
    return this.engine;
  }

  public Iterable<ScopeImport> getDeclaredImports() {
    return SetSequence.fromSet(callsWithDependencies).select(new _FunctionTypes._return_P1_E0<ITransformationResult, IUniqueContainmentTarget>() {
      public ITransformationResult invoke(IUniqueContainmentTarget it) {
        return getTransformationResult(it);
      }
    }).translate((it) -> it.getDependencies()).distinct();
  }
  private static <T> T as_d95i60_a0a1a1a1a26(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

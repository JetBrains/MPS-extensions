package de.q60.mps.incremental.runtime;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class TrackableMap<K, V> {

  private Map<K, V> values = MapSequence.fromMap(new HashMap<K, V>());

  public void put(K key, V value) {
    if (Objects.equals(MapSequence.fromMap(values).get(key), value)) {
      return;
    }
    MapSequence.fromMap(values).put(key, value);
    DependencyBroadcaster.INSTANCE.dependenciesChanged(Sequence.<DependencyKey>singleton(new MapValueDependency(this, key)));
  }

  public V get(K key) {
    V value;
    if (MapSequence.fromMap(values).containsKey(key)) {
      value = MapSequence.fromMap(values).get(key);
    } else {
      value = createInitialValue(key);
      MapSequence.fromMap(values).put(key, value);
    }
    DependencyBroadcaster.INSTANCE.dependencyAccessed(new MapValueDependency(this, key));
    return value;
  }

  protected V createInitialValue(K key) {
    return null;
  }

  public static class MapValueDependency extends DependencyKey {
    private TrackableMap state;
    private Object key;

    public MapValueDependency(TrackableMap state, Object key) {
      this.state = state;
      this.key = key;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      MapValueDependency that = (MapValueDependency) o;
      if ((state != null ? !(state.equals(that.state)) : that.state != null)) {
        return false;
      }
      if ((key != null ? !(((Object) key).equals(that.key)) : that.key != null)) {
        return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      int result = Objects.hashCode(state);
      result = 31 * result + Objects.hashCode(key);
      return result;
    }
  }
}

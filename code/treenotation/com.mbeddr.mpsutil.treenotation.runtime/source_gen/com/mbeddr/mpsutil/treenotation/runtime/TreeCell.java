package com.mbeddr.mpsutil.treenotation.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.style.StyleAttribute;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import com.mbeddr.mpsutil.treenotation.styles.editor.ITreeLayoutType;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.style.StyleChangeEvent;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.util.Pair;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.util.Collections;
import jetbrains.mps.editor.runtime.style.CellAlign;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import java.util.Iterator;
import java.awt.geom.Point2D;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;

public class TreeCell extends EditorCell_Collection {
  private static final StyleAttribute<Boolean> TRANSPARENT_COLLECTION = StyleAttributes.getInstance().<Boolean>getAttribute("com.mbeddr.mpsutil.treenotation.styles", "tree-transparent-collection");
  private static final StyleAttribute<Boolean> LEFT_TO_RIGHT = StyleAttributes.getInstance().<Boolean>getAttribute("com.mbeddr.mpsutil.treenotation.styles", "tree-left-to-right");
  private static final StyleAttribute<Object> INCOMING_SHAPE = StyleAttributes.getInstance().<Object>getAttribute("com.mbeddr.mpsutil.treenotation.styles", "_tree-incoming-shape");
  private static final StyleAttribute<ITreeLayoutType> TREE_LAYOUT = StyleAttributes.getInstance().<ITreeLayoutType>getAttribute("com.mbeddr.mpsutil.treenotation.styles", "tree-layout");
  protected static final StyleAttribute<Boolean> FLATTEN = StyleAttributes.getInstance().<Boolean>getAttribute("com.mbeddr.mpsutil.treenotation.styles", "tree-flatten");
  public static final int ENDPOINT_SPACING = 4;

  private IDeleteHandler myDeleteHandler;
  private List<Button> myDeleteButtons = ListSequence.fromList(new ArrayList<Button>());
  private List<Button> myInsertButtons = ListSequence.fromList(new ArrayList<Button>());
  private EditorCell myTreeRootCell;
  private EditorCell myTreeChildrenCell;
  private IShape myIncomingShape;
  private IShape myOutgoingShape;
  private Button myFoldButton;
  private boolean myTreeCollapsed = false;

  public TreeCell(EditorContext editorContext, SNode node) {
    super(editorContext, node, new TreeCellLayout(), null);
    getStyle().addListener((StyleChangeEvent e) -> requestRelayout());
  }

  public ITreeLayouter getTreeLayouter() {
    return getTreeLayoutType().createLayouter(this);
  }

  public void setTreeLayoutType(TreeLayoutType type) {
    getStyle().set(TREE_LAYOUT, type);
  }

  @NotNull
  public TreeLayoutType getTreeLayoutType() {
    TreeLayoutType type = ((TreeLayoutType) getStyle().get(TREE_LAYOUT));
    return (type != null ? type : TreeLayoutTypes.DEFAULT);
  }

  public void loadFoldingState() {
    EditorComponent editorComponent = ((EditorComponent) getEditorComponent());
    List<Pair<EditorCell, Boolean>> collapseStates = editorComponent.getCollapseStates();
    Boolean collapsed = check_bzqhpc_a0c0z(ListSequence.fromList(collapseStates).findFirst((it) -> Objects.equals(it.o1, TreeCell.this)), this);
    myTreeCollapsed = (collapsed == null ? false : collapsed);
    updateChildrenAfterCollapse();
  }

  public void saveFoldingState() {
    EditorComponent editorComponent = ((EditorComponent) getEditorComponent());
    editorComponent.setCollapseState(this, (myTreeCollapsed ? true : null));
  }

  public void setDeleteHandler(IDeleteHandler deleteHandler) {
    myDeleteHandler = deleteHandler;
  }

  public IDeleteHandler getDeleteHandler() {
    return myDeleteHandler;
  }

  public void setInsertHandlers(List<IInsertHandler> insertHandlers) {
    ListSequence.fromList(myInsertButtons).visitAll((it) -> removeCell(it));
    ListSequence.fromList(myInsertButtons).clear();

    if (ListSequence.fromList(insertHandlers).isNotEmpty()) {
      List<EditorCell> treeChildren = Sequence.fromIterable(getTreeChildren()).toList();
      for (int i = 0; i <= ListSequence.fromList(treeChildren).count(); i++) {
        Button insertButton = new InsertButton(getContext(), getSNode(), insertHandlers, i, () -> isLeftToRight());
        ListSequence.fromList(myInsertButtons).addElement(insertButton);
        addEditorCell(insertButton);
      }
    }
  }

  @Override
  protected void paintContent(Graphics g, ParentSettings settings) {
    super.paintContent(g, settings);
    if (isTreeCollapsed()) {
      return;
    }

    getTreeLayouter().paintLines(((Graphics2D) g));
  }

  protected void drawChildIncomingShape(Graphics2D _g, EditorCell child, Line2D line) {
    checkNotFolded();
    IShape shape = null;
    shape = as_bzqhpc_a0a2a73(child.getStyle().get(INCOMING_SHAPE), IShape.class);
    if (shape == null && child instanceof TreeCell) {
      shape = ((TreeCell) child).getIncomingShape();
    }
    if (shape == null) {
      return;
    }

    Graphics2D g2 = ((Graphics2D) _g.create());
    try {
      shape.paint(g2, ListSequence.fromListAndArray(new ArrayList<Line2D>(), line));
    } finally {
      g2.dispose();
    }
  }

  protected void drawOutgoingShape(Graphics2D _g, List<Line2D> lines) {
    checkNotFolded();
    if (myOutgoingShape == null) {
      return;
    }
    Graphics2D g = ((Graphics2D) _g.create());
    try {
      lines = ListSequence.fromList(lines).select((it) -> {
        Line2D reversedLine = new Line2D.Double(it.getP2(), it.getP1());
        return reversedLine;
      }).toList();
      if (isLeftToRight()) {
        lines = ListSequence.fromList(lines).reversedList();
      }
      myOutgoingShape.paint(g, lines);
    } finally {
      g.dispose();
    }
  }

  protected void checkNotFolded() {
    if (isCollapsed()) {
      throw new IllegalStateException("TreeCell is folded");
    }
  }

  public List<Button> getDeleteButtons() {
    checkNotFolded();
    return myDeleteButtons;
  }

  public List<Button> getInsertButtons() {
    checkNotFolded();
    return myInsertButtons;
  }

  public Button getFoldButton() {
    return myFoldButton;
  }

  public Iterable<EditorCell> getNonButtonCells() {
    checkNotFolded();
    Iterable<EditorCell> allCells = this;
    return Sequence.fromIterable(allCells).where((it) -> !(it instanceof Button));
  }

  public Iterable<Button> getButtonCells() {
    checkNotFolded();
    Iterable<EditorCell> allCells = this;
    return Sequence.fromIterable(allCells).ofType(Button.class);
  }

  public void setTreeRoot(EditorCell cell) {
    checkNotFolded();
    myTreeRootCell = cell;
    addEditorCell(cell);
  }

  public EditorCell getTreeRoot() {
    checkNotFolded();
    return myTreeRootCell;
  }

  public void setTreeChildren(EditorCell cell) {
    checkNotFolded();
    myTreeChildrenCell = cell;
    addEditorCell(cell);
    initDeleteButtons();
    initFoldButton();
  }

  public Iterable<EditorCell> getTreeChildren() {
    checkNotFolded();
    if (myTreeChildrenCell == null) {
      return Sequence.fromIterable(Collections.<EditorCell>emptyList());
    }
    if (myTreeChildrenCell instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection) {
      return getTreeChildren_(((jetbrains.mps.openapi.editor.cells.EditorCell_Collection) myTreeChildrenCell));
    } else {
      return Sequence.<EditorCell>singleton(myTreeChildrenCell);
    }
  }

  protected Iterable<EditorCell> getTreeChildren_(jetbrains.mps.openapi.editor.cells.EditorCell_Collection treeChildrenCollection) {
    Iterable<EditorCell> children = treeChildrenCollection;
    return Sequence.fromIterable(children).translate((it) -> {
      if (it instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection && it.getStyle().get(FLATTEN)) {
        return getTreeChildren_(((jetbrains.mps.openapi.editor.cells.EditorCell_Collection) it));
      } else {
        return Sequence.<EditorCell>singleton(it);
      }
    });
  }

  protected void initDeleteButtons() {
    checkNotFolded();
    ListSequence.fromList(myDeleteButtons).visitAll((it) -> removeCell(it));
    ListSequence.fromList(myDeleteButtons).clear();

    if (getStyle().get(StyleAttributes.READ_ONLY)) {
      return;
    }

    Iterable<EditorCell> treeChildren = getTreeChildren();
    for (EditorCell treeChild : Sequence.fromIterable(treeChildren)) {
      if (treeChild.getStyle().get(StyleAttributes.getInstance().<Boolean>getAttribute("com.mbeddr.mpsutil.treenotation.styles", "tree-show-delete-icon"))) {
        DeleteButton button = new DeleteButton(getContext(), getSNode(), treeChild);
        addEditorCell(button);
        ListSequence.fromList(myDeleteButtons).addElement(button);
      } else {
        Button button = new InvisibleButton(getContext(), getSNode());
        addEditorCell(button);
        ListSequence.fromList(myDeleteButtons).addElement(button);
      }
    }
  }

  protected void initFoldButton() {
    boolean needsButton = Sequence.fromIterable(getTreeChildren()).isNotEmpty();
    if (myFoldButton == null && needsButton) {
      myFoldButton = new FoldButton(getContext(), getSNode(), this);
      myFoldButton.getStyle().set(StyleAttributes.HORIZONTAL_ALIGN, CellAlign.CENTER);
      addEditorCell(myFoldButton);
    } else if (myFoldButton != null && !(needsButton)) {
      removeCell(myFoldButton);
      myFoldButton = null;
    }
  }

  @Override
  public void toggleCollapsed(boolean collapsed) {
    setTreeCollapsed(collapsed);
  }

  public void setTreeCollapsed(boolean collapsed) {
    if (myTreeCollapsed != collapsed) {
      myTreeCollapsed = collapsed;
      updateChildrenAfterCollapse();
      saveFoldingState();
      requestRelayout();
      ((EditorComponent) getEditorComponent()).relayout();
    }
  }

  protected void updateChildrenAfterCollapse() {
    for (EditorCell child : ListSequence.fromList(IterableUtil.asList(this))) {
      removeCell(child);
    }
    addEditorCell(myTreeRootCell);
    addEditorCell(myFoldButton);
    if (!(myTreeCollapsed)) {
      ListSequence.fromList(myDeleteButtons).visitAll((it) -> addEditorCell(it));
      ListSequence.fromList(myInsertButtons).visitAll((it) -> addEditorCell(it));
      addEditorCell(myTreeChildrenCell);
    }
  }

  public boolean isTreeCollapsed() {
    return myTreeCollapsed;
  }

  public Iterable<jetbrains.mps.openapi.editor.cells.EditorCell_Collection> getIntermediateCells() {
    checkNotFolded();

    return Sequence.fromIterable(getTreeChildren()).translate((it) -> getIntermediateCells__(it)).distinct();

  }

  protected Iterable<jetbrains.mps.openapi.editor.cells.EditorCell_Collection> getIntermediateCells_(jetbrains.mps.openapi.editor.cells.EditorCell_Collection parent) {
    Iterable<jetbrains.mps.openapi.editor.cells.EditorCell_Collection> result = Sequence.<jetbrains.mps.openapi.editor.cells.EditorCell_Collection>singleton(parent);

    Iterable<EditorCell> children = parent;
    Sequence.fromIterable(result).concat(Sequence.fromIterable(children).translate((it) -> {
      return (Iterable<jetbrains.mps.openapi.editor.cells.EditorCell_Collection>) () -> {
        return new YieldingIterator<jetbrains.mps.openapi.editor.cells.EditorCell_Collection>() {
          private int __CP__ = 0;
          protected boolean moveToNext() {
__loop__:
            do {
__switch__:
              switch (this.__CP__) {
                case -1:
                  assert false : "Internal error";
                  return false;
                case 4:
                  this._4__yield_bzqhpc_a0a0a0a0a3a77_it = Sequence.fromIterable(getIntermediateCells_(((jetbrains.mps.openapi.editor.cells.EditorCell_Collection) it))).iterator();
                case 5:
                  if (!(this._4__yield_bzqhpc_a0a0a0a0a3a77_it.hasNext())) {
                    this.__CP__ = 1;
                    break;
                  }
                  this._4__yield_bzqhpc_a0a0a0a0a3a77 = this._4__yield_bzqhpc_a0a0a0a0a3a77_it.next();
                  this.__CP__ = 6;
                  break;
                case 2:
                  if (it instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection && it.getStyle().get(FLATTEN)) {
                    this.__CP__ = 3;
                    break;
                  }
                  this.__CP__ = 1;
                  break;
                case 7:
                  this.__CP__ = 5;
                  this.yield(_4__yield_bzqhpc_a0a0a0a0a3a77);
                  return true;
                case 0:
                  this.__CP__ = 2;
                  break;
                case 3:
                  this.__CP__ = 4;
                  break;
                case 6:
                  this.__CP__ = 7;
                  break;
                default:
                  break __loop__;
              }
            } while (true);
            return false;
          }
          private jetbrains.mps.openapi.editor.cells.EditorCell_Collection _4__yield_bzqhpc_a0a0a0a0a3a77;
          private Iterator<jetbrains.mps.openapi.editor.cells.EditorCell_Collection> _4__yield_bzqhpc_a0a0a0a0a3a77_it;
        };
      };
    }));

    return result;
  }
  protected Iterable<jetbrains.mps.openapi.editor.cells.EditorCell_Collection> getIntermediateCells__(EditorCell child) {
    jetbrains.mps.openapi.editor.cells.EditorCell_Collection parent = child.getParent();
    if (parent == this) {
      return Sequence.fromIterable(Collections.<jetbrains.mps.openapi.editor.cells.EditorCell_Collection>emptyList());
    } else {
      return Sequence.fromIterable(Sequence.<jetbrains.mps.openapi.editor.cells.EditorCell_Collection>singleton(parent)).concat(Sequence.fromIterable(getIntermediateCells__(parent)));
    }
  }

  protected <T> T getStyleForChild(EditorCell child, StyleAttribute<T> attribute) {
    if (child.getStyle().isSpecified(attribute)) {
      return child.getStyle().get(attribute);
    }
    if (isNonFoldedTreeCell(child)) {
      TreeCell childTree = ((TreeCell) child);
      if (childTree.getTreeRoot().getStyle().isSpecified(attribute)) {
        return childTree.getTreeRoot().getStyle().get(attribute);
      }
    }
    for (EditorCell intermediate = child.getParent(); intermediate != null && intermediate != this; intermediate = intermediate.getParent()) {
      if (intermediate.getStyle().isSpecified(attribute)) {
        return intermediate.getStyle().get(attribute);
      }
    }

    // default value
    return child.getStyle().get(attribute);
  }

  public Point2D getStartPoint(EditorCell cell) {
    if (isLeftToRight()) {
      return new Point2D.Float(cell.getX() + cell.getWidth() + ENDPOINT_SPACING, cell.getY() + cell.getHeight() / 2);
    } else {
      return new Point2D.Float(cell.getX() + cell.getWidth() / 2, cell.getY() + cell.getHeight() + ENDPOINT_SPACING);
    }
  }

  public Point2D getEndPoint(EditorCell cell) {
    cell = getChildRoot(cell);
    if (isLeftToRight()) {
      return new Point2D.Float(cell.getX() - ENDPOINT_SPACING, cell.getY() + cell.getHeight() / 2);
    } else {
      return new Point2D.Float(cell.getX() + cell.getWidth() / 2, cell.getY() - ENDPOINT_SPACING);
    }
  }

  public EditorCell getChildRoot(EditorCell child) {
    child = ignoreTransparentCollections(child);
    if (child instanceof TreeCell) {
      child = ((TreeCell) child).getTreeRoot();
    }
    return child;
  }

  protected EditorCell ignoreTransparentCollections(EditorCell cell) {
    TreeCell treeCell = getTreeCell(cell);
    return (treeCell != null ? treeCell : cell);
  }

  public boolean isLeftToRight() {
    return getStyle().get(LEFT_TO_RIGHT);
  }

  public IShape getIncomingShape() {
    return myIncomingShape;
  }

  public void setIncomingShape(IShape incomingShape) {
    myIncomingShape = incomingShape;
  }

  public IShape getOutgoingShape() {
    return myOutgoingShape;
  }

  public void setOutgoingShape(IShape outgoingShape) {
    myOutgoingShape = outgoingShape;
  }

  public static boolean isNonFoldedTreeCell(EditorCell cell) {
    return cell instanceof TreeCell && !(((TreeCell) cell).isCollapsed());
  }

  public TreeCell getTreeCell(EditorCell cell) {
    if (cell instanceof TreeCell) {
      return ((TreeCell) cell);
    }
    if (cell instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection && cell.getStyle().get(TRANSPARENT_COLLECTION)) {
      for (EditorCell child : Sequence.fromIterable(((jetbrains.mps.openapi.editor.cells.EditorCell_Collection) cell))) {
        TreeCell t = getTreeCell(child);
        if (t != null) {
          return t;
        }
      }
    }
    return null;
  }
  @Override
  public TextBuilder renderText() {
    TextBuilder builder = new TextBuilderImpl();
    if (myTreeRootCell != null) {
      builder.appendToTheBottom(myTreeRootCell.renderText());
      builder.appendToTheBottom(new TextBuilderImpl("â†“"));
    }
    if (myTreeChildrenCell != null) {
      builder.appendToTheBottom(myTreeChildrenCell.renderText());
    }
    return builder;
  }
  private static Boolean check_bzqhpc_a0c0z(Pair<EditorCell, Boolean> checkedDotOperand, TreeCell checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.o2;
    }
    return null;
  }
  private static <T> T as_bzqhpc_a0a2a73(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

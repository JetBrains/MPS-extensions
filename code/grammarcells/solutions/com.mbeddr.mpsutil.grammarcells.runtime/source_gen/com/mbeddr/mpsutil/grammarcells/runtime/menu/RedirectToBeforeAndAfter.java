package com.mbeddr.mpsutil.grammarcells.runtime.menu;

/*Generated by MPS */

import jetbrains.mps.lang.editor.menus.MenuPart;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuLookup;
import jetbrains.mps.lang.editor.menus.transformation.DefaultTransformationMenuLookup;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.ArrayList;
import java.util.Collection;
import jetbrains.mps.openapi.editor.descriptor.TransformationMenu;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.nodeEditor.sidetransform.EditorCell_STHint;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class RedirectToBeforeAndAfter implements MenuPart<TransformationMenuItem, TransformationMenuContext> {
  public static final Condition<EditorCell> SYNTAX_CELL_CONDITION = GrammarCellsUtil.SYNTAX_CELL_CONDITION;

  private boolean forLeftSideTransformation;

  public RedirectToBeforeAndAfter(boolean forLeftSideTransformation) {
    this.forLeftSideTransformation = forLeftSideTransformation;
  }

  @NotNull
  @Override
  public List<TransformationMenuItem> createItems(TransformationMenuContext context) {
    // We could create the items here directly,
    // but Lookup is used to prevent duplicate items by using this class multiple times for the same context
    // this allows to just generate a usage of this class into every language.
    return context.createItems(new Lookup(forLeftSideTransformation));
  }

  protected static List<TransformationMenuItem> getBeforeAfterActions(final EditorCell anchorCell, final boolean before, final TransformationMenuContext context) {
    final TransformationMenuContext beforeAfterContext = context.withLocation((before ? GrammarCellsMenuLocations.BEFORE : GrammarCellsMenuLocations.AFTER));
    List<EditorCell> alignedCells = getAlignedCells(anchorCell, before);

    // A BracketsCell inserts an ArbitraryTextAnnotation. To allow the insertion of multiple brackets, we have to include the actions from the cell next to the bracket.
    if (anchorCell.getSNode().isInstanceOfConcept(CONCEPTS.Attribute$g1)) {
      EditorCell attributedCell = getPreviousNextLeaf(!(before), anchorCell, (EditorCell c) -> !(Objects.equals(c.getSNode(), anchorCell.getSNode())) && !(c.getSNode().isInstanceOfConcept(CONCEPTS.Attribute$g1)) && GrammarCellsUtil.isSyntaxCell(c));
      if (attributedCell != null) {
        alignedCells = ListSequence.fromList(alignedCells).concat(ListSequence.fromList(getAlignedCells(attributedCell, before))).distinct().toList();
      }
    }

    List<TransformationMenuItem> result = ListSequence.fromList(alignedCells).translate((cell) -> RedirectToBeforeAndAfter.createActionsForCell(cell, beforeAfterContext)).toList();

    // include actions from empty collections
    List<EditorCell_Collection> emptyCollections = ListSequence.fromList(alignedCells).select((it) -> getPreviousNextSibling(before, it, (EditorCell c) -> GrammarCellsUtil.isSyntaxCell(c))).ofType(EditorCell_Collection.class).where((it) -> it.getCellsCount() == 0).toList();
    result = ListSequence.fromList(result).concat(ListSequence.fromList(emptyCollections).translate((it) -> Sequence.fromIterable(createActionsForCell(it, context.withLocation(GrammarCellsMenuLocations.BEFORE))).concat(Sequence.fromIterable(createActionsForCell(it, context.withLocation(GrammarCellsMenuLocations.AFTER)))))).toList();

    return result;
  }

  protected static Iterable<TransformationMenuItem> createActionsForCell(EditorCell cell, TransformationMenuContext beforeAfterContext) {
    Iterable<TransformationMenuItem> result = Sequence.fromIterable(Collections.<TransformationMenuItem>emptyList());
    TransformationMenuContext contextForCellNode = beforeAfterContext.withNode(cell.getSNode());
    TransformationMenuLookup lookup = cell.getTransformationMenuLookup();
    if (lookup != null) {
      result = Sequence.fromIterable(result).concat(ListSequence.fromList(contextForCellNode.createItems(lookup)));
    }
    if (cell.isBig()) {
      DefaultTransformationMenuLookup lookupForNode = new DefaultTransformationMenuLookup(LanguageRegistry.getInstance(beforeAfterContext.getEditorContext().getRepository()), cell.getSNode().getConcept());
      result = Sequence.fromIterable(result).concat(ListSequence.fromList(contextForCellNode.createItems(lookupForNode)));
    }
    return result;
  }

  public static List<EditorCell> getAlignedCells(EditorCell anchorCell, boolean left) {
    List<EditorCell> alignedCells = ListSequence.fromListAndArray(new ArrayList<EditorCell>(), anchorCell);
    EditorCell anchorFirstLeaf = getFirstLastLeaf(anchorCell, left, SYNTAX_CELL_CONDITION);
    for (EditorCell alignedCell = anchorFirstLeaf; alignedCell != null; alignedCell = alignedCell.getParent()) {
      if (alignedCell == anchorCell) {
        continue;
      }
      EditorCell firstLeaf = getFirstLastLeaf(alignedCell, left, SYNTAX_CELL_CONDITION);
      if (firstLeaf != anchorFirstLeaf) {
        break;
      }
      ListSequence.fromList(alignedCells).addElement(alignedCell);
    }
    return alignedCells;
  }

  public static class Lookup implements TransformationMenuLookup {
    private boolean forLeftSideTransformation;

    public Lookup(boolean forLeftSideTransformation) {
      this.forLeftSideTransformation = forLeftSideTransformation;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      Lookup that = (Lookup) o;
      if (forLeftSideTransformation != that.forLeftSideTransformation) {
        return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return (forLeftSideTransformation ? 1 : 0);
    }

    @NotNull
    @Override
    public Collection<TransformationMenu> lookup(@NotNull Collection<SLanguage> usedLanguages, @NotNull String menuLocation) {
      return ListSequence.fromListAndArray(new ArrayList<TransformationMenu>(), new Menu());
    }

    public class Menu implements TransformationMenu {
      @NotNull
      @Override
      public List<TransformationMenuItem> createMenuItems(@NotNull TransformationMenuContext context) {
        context.getEditorMenuTrace().pushTraceInfo();
        try {
          context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("include before/after transformations in " + ((forLeftSideTransformation ? "left" : "right")) + " side transformation", null));
          EditorCell anchorCell = context.getEditorContext().getSelectedCell();
          EditorCell_STHint stHint = as_k2x7ot_a0a2a1a0k41(anchorCell, EditorCell_STHint.class);
          if (stHint != null) {
            anchorCell = ((EditorCell) ReflectionUtil.readField(EditorCell_STHint.class, stHint, "myAnchorCell"));
          }

          List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
          if (anchorCell != null) {
            ListSequence.fromList(result).addSequence(ListSequence.fromList(getBeforeAfterActions(anchorCell, forLeftSideTransformation, context)));
            Condition<EditorCell> isSyntaxCell = (EditorCell c) -> GrammarCellsUtil.isSyntaxCell(c);
            EditorCell previousNextLeaf = (forLeftSideTransformation ? CellTraversalUtil.getPrevLeaf(anchorCell, isSyntaxCell) : CellTraversalUtil.getNextLeaf(anchorCell, isSyntaxCell));
            if (previousNextLeaf != null) {
              ListSequence.fromList(result).addSequence(ListSequence.fromList(getBeforeAfterActions(previousNextLeaf, !(forLeftSideTransformation), context)));
            }
          }
          return ShadowingUtil.applyShadowing(result);
        } finally {
          context.getEditorMenuTrace().popTraceInfo();
        }
      }

      @Override
      public boolean isContribution() {
        return true;
      }

      @Override
      public boolean isApplicableToLocation(String location) {
        return true;
      }
    }
    private static <T> T as_k2x7ot_a0a2a1a0k41(Object o, Class<T> type) {
      return (type.isInstance(o) ? (T) o : null);
    }
  }

  public static EditorCell getFirstLastLeaf(final EditorCell ancestor, boolean first, final Condition<EditorCell> condition) {
    EditorCell leaf = (first ? CellTraversalUtil.getFirstLeaf(ancestor) : CellTraversalUtil.getLastLeaf(ancestor));
    if (condition.met(leaf)) {
      return leaf;
    }
    Condition<EditorCell> alsoCheckAncestor = (EditorCell c) -> condition.met(c) && CellTraversalUtil.isAncestorOrEquals(ancestor, c);
    return (first ? CellTraversalUtil.getNextLeaf(leaf, alsoCheckAncestor) : CellTraversalUtil.getPrevLeaf(leaf, alsoCheckAncestor));
  }

  private static EditorCell getPreviousNextLeaf(boolean previous, EditorCell cell, Condition<EditorCell> condition) {
    return (previous ? CellTraversalUtil.getPrevLeaf(cell, condition) : CellTraversalUtil.getNextLeaf(cell, condition));
  }

  private static EditorCell getPreviousNextSibling(boolean previous, EditorCell cell, Condition<EditorCell> condition) {
    EditorCell sibling = (previous ? CellTraversalUtil.getPrevSibling(cell) : CellTraversalUtil.getNextSibling(cell));
    while (sibling != null && !(condition.met(sibling))) {
      sibling = (previous ? CellTraversalUtil.getPrevSibling(sibling) : CellTraversalUtil.getNextSibling(sibling));
    }
    return sibling;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
  }
}

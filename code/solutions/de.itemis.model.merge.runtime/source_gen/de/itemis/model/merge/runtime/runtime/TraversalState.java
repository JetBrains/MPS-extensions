package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import com.google.common.collect.Multimap;
import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.collect.MultimapBuilder;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.List;
import com.google.common.collect.ImmutableMap;
import java.util.stream.Stream;
import org.apache.commons.lang3.tuple.ImmutablePair;
import jetbrains.mps.internal.collections.runtime.ListSequence;

/**
 * During the Traversal of DAG defined by concepts and their extends- and implements-relations we need to keep track of defined values attached
 * to the concepts. On a top-down traversal we need to keep track of all values defined for properties and children defined for  ancestors of
 * the current visited concept.
 */
public class TraversalState {

  private Multimap<SNode, ContentHolder<PropertyMerger>> propertyCollector = MultimapBuilder.ListMultimapBuilder.hashKeys().linkedListValues().<SNode,ContentHolder<PropertyMerger>>build();

  private Multimap<SNode, ContentHolder<ConceptChildMerger>> childCollector = MultimapBuilder.ListMultimapBuilder.hashKeys().linkedListValues().<SNode,ContentHolder<ConceptChildMerger>>build();

  private Multimap<SNode, ContentHolder<ConceptRefMerger>> referenceCollector = MultimapBuilder.ListMultimapBuilder.hashKeys().linkedListValues().<SNode,ContentHolder<ConceptRefMerger>>build();

  private ContentHolder<Identity> idenity = null;

  public void addChildlink(SNode ld, ContentHolder<ConceptChildMerger> cm) {
    this.childCollector.put(ld, cm);
  }
  public void addRefPolicy(SNode ld, ContentHolder<ConceptRefMerger> rm) {
    this.referenceCollector.put(ld, rm);
  }

  public void addPropertyPolicy(SNode pd, ContentHolder<PropertyMerger> pm) {
    this.propertyCollector.put(pd, pm);
  }

  public void setIdentity(final Identity id, final SAbstractConcept inheritedFrom) {
    this.idenity = toContentHolder(inheritedFrom, id);
  }



  private ContentHolder<Identity> toContentHolder(final SAbstractConcept inheritedFrom, final Identity id) {
    return new ContentHolder<Identity>() {
      @Override
      public boolean isSame(ContentHolder otherStuff) {
        Object content = otherStuff.content();
        if (content instanceof Identity) {
          return idenity.equals(content);
        }
        return false;
      }

      @Override
      public Identity content() {
        return id;
      }

      @Override
      public SAbstractConcept inheritedFrom() {
        return inheritedFrom;
      }
    };
  }

  public boolean removeLastPropertyPolicy(SNode propertyId) {
    List<ContentHolder<PropertyMerger>> pps = ((List<ContentHolder<PropertyMerger>>) propertyCollector.get(propertyId));
    if (pps.size() <= 0) {
      return false;
    }
    pps.remove(pps.size() - 1);
    return true;
  }

  public boolean removeLastChildPolicy(SNode linkId) {
    List<ContentHolder<ConceptChildMerger>> sguffs = ((List<ContentHolder<ConceptChildMerger>>) childCollector.get(linkId));
    if (sguffs.size() <= 0) {
      return false;
    }
    sguffs.remove(sguffs.size() - 1);
    return true;
  }
  public boolean removeLastReferencePolicy(SNode linkId) {
    List<ContentHolder<ConceptRefMerger>> sguffs = ((List<ContentHolder<ConceptRefMerger>>) referenceCollector.get(linkId));
    if (sguffs.size() <= 0) {
      return false;
    }
    sguffs.remove(sguffs.size() - 1);
    return true;
  }

  public void resetIdentity() {
    this.idenity = null;
  }

  public MapWrapper<SNode, ContentHolder<ConceptChildMerger>> childSnapshot() {
    return snapshot(this.childCollector);
  }
  public MapWrapper<SNode, ContentHolder<ConceptRefMerger>> referenceSnapshot() {
    return snapshot(this.referenceCollector);
  }

  public MapWrapper<SNode, ContentHolder<PropertyMerger>> propertySnapshot() {
    return snapshot(this.propertyCollector);
  }

  public MapWrapper<Dummy, ContentHolder<Identity>> identitySnapshot() {
    if (this.idenity == null) {
      return null;
    }
    return new MapWrapper<Dummy, ContentHolder<Identity>>(ImmutableMap.<Dummy,ContentHolder<Identity>>of(Dummy.I, this.idenity));
  }

  private static <X, C> MapWrapper<X, ContentHolder<C>> snapshot(final Multimap<X, ContentHolder<C>> collector) {
    Stream<ImmutablePair<X, ContentHolder<C>>> snapshotData = collector.keySet().stream().map((X x) -> {
      List<ContentHolder<C>> xs = ((List<ContentHolder<C>>) collector.get(x));
      return (ListSequence.fromList(xs).isNotEmpty() ? ImmutablePair.<X,ContentHolder<C>>of(x, ListSequence.fromList(xs).last()) : null);
    }).filter((ImmutablePair<X, ContentHolder<C>> xToSTuff) -> xToSTuff != null && xToSTuff.getKey() != null);

    return new MapWrapper<X, ContentHolder<C>>(snapshotData);
  }

  public enum Dummy {
    I()
  }
}

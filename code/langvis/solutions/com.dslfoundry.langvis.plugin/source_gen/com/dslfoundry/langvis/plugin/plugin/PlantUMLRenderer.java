package com.dslfoundry.langvis.plugin.plugin;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.core.behavior.INamedConcept__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.io.FileWriter;
import java.io.IOException;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class PlantUMLRenderer {
  private boolean collapseTraits;
  private boolean collectInheritors;
  private boolean showPackages;

  /**
   * All entries except INamedConcept and IResolveInfo will also be detected
   * as traits by isTrait. Shall we remove them or give them separate treatment?
   */
  private Set<String> showAsAnnotation = SetSequence.fromSetAndArray(new HashSet<String>(), "jetbrains.mps.lang.core.structure.INamedConcept", "jetbrains.mps.lang.core.structure.IResolveInfo", "jetbrains.mps.lang.core.structure.IAntisuppressErrors", "jetbrains.mps.lang.core.structure.ICanSuppressErrors", "jetbrains.mps.lang.core.structure.IType", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault", "jetbrains.mps.lang.core.structure.IContainer", "jetbrains.mps.lang.core.structure.IDeprecatable", "jetbrains.mps.lang.core.structure.IWrapper", "jetbrains.mps.lang.core.structure.ImplementationContainer", "jetbrains.mps.lang.core.structure.InterfacePart", "jetbrains.mps.lang.core.structure.ScopeProvider", "jetbrains.mps.lang.core.structure.IStructureDeprecatable");

  private Set<String> neverABox = SetSequence.fromSetAndArray(new HashSet<String>(), "jetbrains.mps.lang.core.structure.BaseConcept");

  public PlantUMLRenderer(boolean showTraitsAsAnnotations, boolean inheritors) {
    this.collapseTraits = showTraitsAsAnnotations;
    this.collectInheritors = inheritors;
  }

  public String getName(SNode c) {
    return INamedConcept__BehaviorDescriptor.getFqName_idhEwIO9y.invoke(c);
  }

  public boolean isTrait(SNode decl) {
    // Currently this detection hides potentially interesting parts of the hierarchy. Therefore it is disabled by default (collapseTraints=false), when using this it is advisable to revise this detection.
    if (this.collapseTraits && ListSequence.fromList(SLinkOperations.getChildren(decl, LINKS.propertyDeclaration$YUgg)).isEmpty()) {
      {
        final SNode idecl = decl;
        if (SNodeOperations.isInstanceOf(idecl, CONCEPTS.InterfaceConceptDeclaration$CG)) {
          return ListSequence.fromList(SLinkOperations.getChildren(idecl, LINKS.extends$nawU)).all((it) -> PlantUMLRenderer.this.isTrait(SLinkOperations.getTarget(it, LINKS.intfc$zM4e)));
        }
      }
      {
        final SNode cdecl = decl;
        if (SNodeOperations.isInstanceOf(cdecl, CONCEPTS.ConceptDeclaration$gH)) {
          return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(cdecl, LINKS.extends$_Isg))), CONCEPTS.BaseConcept$gP) && ListSequence.fromList(SLinkOperations.getChildren(cdecl, LINKS.implements$u_P2)).all((it) -> PlantUMLRenderer.this.isTrait(SLinkOperations.getTarget(it, LINKS.intfc$zM4e)));
        }
      }
    }
    return false;
  }

  public List<SNode> inheritors(SNode base) {
    SAbstractConcept c = SNodeOperations.asSConcept(base);
    return ListSequence.fromList(SConceptOperations.getAllSubConcepts(c, SNodeOperations.getModel(base))).select((it) -> SNodeOperations.cast(SNodeOperations.asNode(it), CONCEPTS.AbstractConceptDeclaration$KA)).toList();
  }

  public boolean showAsBox(SNode concept) {
    return !(showAsAnnotation(concept)) && !(SetSequence.fromSet(neverABox).contains(getName(concept)));
  }

  public boolean showAsAnnotation(SNode concept) {
    return SetSequence.fromSet(showAsAnnotation).contains(getName(concept)) || isTrait(concept);
  }

  public void writeProperties(FileWriter fw, SNode concept) throws IOException {
    for (SNode property : ListSequence.fromList(SLinkOperations.getChildren(concept, LINKS.propertyDeclaration$YUgg))) {
      fw.write(String.format("\"%s\" : %s : %s\n", getName(concept), SPropertyOperations.getString(property, PROPS.name$MnvL), SPropertyOperations.getString(SLinkOperations.getTarget(property, LINKS.dataType$5j5Y), PROPS.name$MnvL)));
    }
  }

  public void renderPlantUMLSource(Set<SNode> elements, boolean renderChildren, boolean renderParents, boolean renderCardinalities, boolean renderRoleNames, boolean flattenNamespaces, String outFile) throws IOException {
    FileWriter fw = null;

    final List<SNode> interfaces = Sequence.fromIterable(SNodeOperations.ofConcept(elements, CONCEPTS.InterfaceConceptDeclaration$CG)).toList();
    final List<SNode> interfacesBoxes = ListSequence.fromList(interfaces).where((it) -> showAsBox(it)).toList();

    final List<SNode> concepts = Sequence.fromIterable(SNodeOperations.ofConcept(elements, CONCEPTS.ConceptDeclaration$gH)).toList();
    final List<SNode> conceptsBoxes = ListSequence.fromList(concepts).where((it) -> showAsBox(it)).toList();

    boolean showAllInheritanceAsAnnotation = !(renderParents);

    try {
      fw = new FileWriter(outFile);
      fw.write("@startuml\n\n");

      if (flattenNamespaces) {
        fw.write("set namespaceSeparator none\n");
      }

      for (SNode intf : ListSequence.fromList(interfacesBoxes)) {
        fw.write(String.format("interface \"%s\" %s\n", getName(intf), makeStereotypeList(null, SLinkOperations.getChildren(intf, LINKS.extends$nawU), showAllInheritanceAsAnnotation)));
        writeProperties(fw, intf);
      }
      for (SNode concept : ListSequence.fromList(conceptsBoxes)) {
        // A custom "spot" is the circular symbol rendered in plantUML in the top-left corner of the box
        String customSpot = "";
        if (SPropertyOperations.getBoolean(concept, PROPS.rootable$_9pz)) {
          customSpot = "<< (R, lightgrey) >>";
        }

        fw.write(String.format("class \"%s\" %s %s\n", getName(concept), makeStereotypeList(SLinkOperations.getTarget(concept, LINKS.extends$_Isg), SLinkOperations.getChildren(concept, LINKS.implements$u_P2), showAllInheritanceAsAnnotation), customSpot));
        writeProperties(fw, concept);
      }

      if (renderParents) {
        for (SNode intf : ListSequence.fromList(interfaces)) {
          // Interface extension
          for (SNode implementedInterface : ListSequence.fromList(SLinkOperations.getChildren(intf, LINKS.extends$nawU)).where((it) -> showAsBox(SLinkOperations.getTarget(it, LINKS.intfc$zM4e)))) {
            fw.write(String.format("\"%s\" <|.. \"%s\"\n", getName(SLinkOperations.getTarget(implementedInterface, LINKS.intfc$zM4e)), getName(intf)));
          }
        }

        for (SNode concept : ListSequence.fromList(concepts)) {
          // Interface implementation
          for (SNode implementedInterface : ListSequence.fromList(SLinkOperations.getChildren(concept, LINKS.implements$u_P2)).where((it) -> showAsBox(SLinkOperations.getTarget(it, LINKS.intfc$zM4e)))) {
            fw.write(String.format("\"%s\" <|.. \"%s\"\n", getName(SLinkOperations.getTarget(implementedInterface, LINKS.intfc$zM4e)), getName(concept)));
          }
          // Concept extension
          if ((SLinkOperations.getTarget(concept, LINKS.extends$_Isg) != null) && showAsBox(SLinkOperations.getTarget(concept, LINKS.extends$_Isg))) {
            fw.write(String.format("\"%s\" <|-- \"%s\"\n", getName(SLinkOperations.getTarget(concept, LINKS.extends$_Isg)), getName(concept)));
          }
        }
      }

      if (renderChildren) {
        for (SNode concept : SetSequence.fromSet(elements)) {
          // Children and references
          for (SNode child : ListSequence.fromList(SLinkOperations.getChildren(concept, LINKS.linkDeclaration$YU1f))) {
            final String relationString = (SEnumOperations.isMember(SPropertyOperations.getEnum(child, PROPS.metaClass$PeKc), 0xfc6f4e95b9L) ? "*--" : "-->");
            final String cardinalityString = (renderCardinalities ? String.format("\"%s\"", SEnumOperations.getMemberPresentation(SPropertyOperations.getEnum(child, PROPS.sourceCardinality$cxYK)).toString()) : "");
            final String roleString = (renderRoleNames ? String.format(" : %s", SPropertyOperations.getString(child, PROPS.role$Nsjf)) : "");
            fw.write(String.format("\"%s\" \"1\" %s %s \"%s\"%s\n", getName(concept), relationString, cardinalityString, getName(SLinkOperations.getTarget(child, LINKS.target$m40F)), roleString));
          }
        }
      }
      fw.write("\n@enduml\n\n");
    } finally {
      if (fw != null) {
        fw.close();
      }
    }
  }

  public void collectDown(SNode node, Set<SNode> collectedNodes) {
    // Collect children and references
    if (SetSequence.fromSet(collectedNodes).contains(node)) {
      return;
    }
    SetSequence.fromSet(collectedNodes).addElement(node);
    for (SNode child : ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.linkDeclaration$YU1f))) {
      collectDown(SLinkOperations.getTarget(child, LINKS.target$m40F), collectedNodes);
    }
  }

  public void collectUp(SNode node, Set<SNode> collectedNodes) {
    // collect implemented interfaces and extended concepts
    if (SetSequence.fromSet(collectedNodes).contains(node)) {
      return;
    }
    SetSequence.fromSet(collectedNodes).addElement(node);
    {
      final SNode cdecl = node;
      if (SNodeOperations.isInstanceOf(cdecl, CONCEPTS.ConceptDeclaration$gH)) {
        if ((SLinkOperations.getTarget(cdecl, LINKS.extends$_Isg) != null)) {
          collectUp(SLinkOperations.getTarget(cdecl, LINKS.extends$_Isg), collectedNodes);
        }
        for (SNode intf : ListSequence.fromList(SLinkOperations.getChildren(cdecl, LINKS.implements$u_P2))) {
          collectUp(SLinkOperations.getTarget(intf, LINKS.intfc$zM4e), collectedNodes);
        }
      }
    }
    {
      final SNode intfc = node;
      if (SNodeOperations.isInstanceOf(intfc, CONCEPTS.InterfaceConceptDeclaration$CG)) {
        for (SNode intf : ListSequence.fromList(SLinkOperations.getChildren(intfc, LINKS.extends$nawU))) {
          collectUp(SLinkOperations.getTarget(intf, LINKS.intfc$zM4e), collectedNodes);
        }
      }
    }
  }

  public void collectDownUp(SNode node, Set<SNode> collectedNodes) {
    Set<SNode> upCollection = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> downCollection = SetSequence.fromSet(new HashSet<SNode>());

    collectDown(node, downCollection);
    collectUp(node, upCollection);
    for (SNode n : SetSequence.fromSet(downCollection)) {
      collectUp(n, collectedNodes);
    }
    SetSequence.fromSet(collectedNodes).addSequence(SetSequence.fromSet(downCollection));
    SetSequence.fromSet(collectedNodes).addSequence(SetSequence.fromSet(upCollection));
    if (this.collectInheritors) {
      SetSequence.fromSet(collectedNodes).addSequence(ListSequence.fromList(inheritors(node)));
    }
    List<SNode> filter = SetSequence.fromSet(collectedNodes).where((it) -> !(showAsBox(it))).toList();
    SetSequence.fromSet(collectedNodes).removeSequence(ListSequence.fromList(filter));
  }

  private String makeStereotypeList(SNode extendedConcept, List<SNode> Interfaces, boolean alwaysAsAnnotation) {
    List<String> annotations;
    if (alwaysAsAnnotation) {
      annotations = ListSequence.fromList(Interfaces).select((it) -> SPropertyOperations.getString(SLinkOperations.getTarget(it, LINKS.intfc$zM4e), PROPS.name$MnvL)).toList();
      //  Render extended concept, but only if this is not MPS's standard BaseConcept
      if ((extendedConcept != null) && !(Objects.equals(SPropertyOperations.getString(extendedConcept, PROPS.name$MnvL), "BaseConcept"))) {
        ListSequence.fromList(annotations).addElement(SPropertyOperations.getString(extendedConcept, PROPS.name$MnvL));
      }

    } else {
      annotations = ListSequence.fromList(Interfaces).where((it) -> showAsAnnotation(SLinkOperations.getTarget(it, LINKS.intfc$zM4e))).select((it) -> SPropertyOperations.getString(SLinkOperations.getTarget(it, LINKS.intfc$zM4e), PROPS.name$MnvL)).toList();
    }

    String stereoTypeString = IterableUtils.join(ListSequence.fromList(annotations), "\\n");
    if ((stereoTypeString != null && stereoTypeString.length() > 0)) {
      return "<" + stereoTypeString + ">";
    } else {
      return "";
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept InterfaceConceptDeclaration$CG = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, "jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration");
    /*package*/ static final SConcept ConceptDeclaration$gH = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SConcept AbstractConceptDeclaration$KA = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink extends$nawU = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, 0x110356e9df4L, "extends");
    /*package*/ static final SReferenceLink intfc$zM4e = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x110356fc618L, 0x110356fe029L, "intfc");
    /*package*/ static final SReferenceLink extends$_Isg = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, "extends");
    /*package*/ static final SContainmentLink implements$u_P2 = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0x110358d693eL, "implements");
    /*package*/ static final SContainmentLink propertyDeclaration$YUgg = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, "propertyDeclaration");
    /*package*/ static final SReferenceLink dataType$5j5Y = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, 0xfc26f42fe5L, "dataType");
    /*package*/ static final SReferenceLink target$m40F = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, "target");
    /*package*/ static final SContainmentLink linkDeclaration$YU1f = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty rootable$_9pz = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, "rootable");
    /*package*/ static final SProperty metaClass$PeKc = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, "metaClass");
    /*package*/ static final SProperty sourceCardinality$cxYK = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, "sourceCardinality");
    /*package*/ static final SProperty role$Nsjf = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, "role");
  }
}

package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.graph.Graph;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import de.itemis.model.merge.behavior.ModelMergingPolicy__BehaviorDescriptor;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.google.common.collect.ImmutableMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.google.common.collect.Sets;
import java.util.List;
import java.util.stream.Collectors;
import java.util.HashMap;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import de.itemis.model.merge.behavior.DeclarationPolicy__BehaviorDescriptor;
import java.util.Collection;
import com.google.common.collect.Lists;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class PolicyMergerResolver {

  public static MergerResolverImpl run(SNode modelMerge) {
    return run(modelMerge, new ContentHolderFactory.Impl());
  }

  /**
   * Based on the user defined 'ModelMergingPolicy' we get an object which given 'SAbstractConcept' and 'SAbstractLink'
   * returns appropriate Merger-Objects for properties, children and references.
   * 
   * @param mergingPolicy modelMerge defined by user
   * @param contentHolderFactory  
   * @return mergerResolver
   */
  /*package*/ static MergerResolverImpl run(SNode mergingPolicy, ContentHolderFactory contentHolderFactory) {

    Graph<SAbstractConcept> conceptHierarchy = ConceptGraphBuilder.create(ModelMergingPolicy__BehaviorDescriptor.languageConcepts_id3xJ_LYXlmVz.invoke(mergingPolicy));
    Map<SNode, SNode> conceptToDefinedMergePolicy = ModelMergingPolicy__BehaviorDescriptor.conceptToDefinedMergePolicy_id3xJ_LYXj1c6.invoke(mergingPolicy);

    Set<SNode> missingConcepts = missingConcepts(conceptHierarchy.nodes(), mergingPolicy, MapSequence.fromMap(conceptToDefinedMergePolicy).keySet());

    if (!(SPropertyOperations.getBoolean(mergingPolicy, PROPS.partialPolicy$djMt)) && SetSequence.fromSet(missingConcepts).count() > 0) {
      throw new MissingMergingPolicies(missingConcepts);
    }

    ImmutableMap<SAbstractConcept, SNode> sconceptToMergePolicy = makeSconceptToMergePolicy(conceptHierarchy, conceptToDefinedMergePolicy);

    assert sconceptToMergePolicy.size() == MapSequence.fromMap(conceptToDefinedMergePolicy).count() || sconceptToMergePolicy.size() == 0 : "Concept error";

    MergerResolverImpl mergeResolver = traverse(rootsConcepts(conceptHierarchy), conceptHierarchy, sconceptToMergePolicy, contentHolderFactory);

    return mergeResolver;
  }

  /**
   * Traverses the graph from a root to the leaf (for all roots ony by one).
   * During this traversal for each concept of 'graph' it is determined what kind of merger-objects are
   * valid for its properties, children and references. During the traversal merger-objects of parent-concepts are
   * propagated to their descendants. This way an inheritance hierarchy is implemented.
   * 
   * @param graph graph of concept hierarchy
   * @param sconceptToMergePolicy concepts mapped to MergePolicies
   * @param contentHolderFactory  
   * @return  
   */
  private static MergerResolverImpl traverse(Iterable<SAbstractConcept> roots, Graph<SAbstractConcept> graph, Map<SAbstractConcept, SNode> sconceptToMergePolicy, ContentHolderFactory contentHolderFactory) {
    MergerResolverBuilder resultBuilder = new MergerResolverBuilder();
    for (SAbstractConcept r : Sequence.fromIterable(roots)) {
      traverse(graph, r, sconceptToMergePolicy, new TraversalState(), resultBuilder, contentHolderFactory);
    }

    return resultBuilder.build();
  }


  private static Set<SNode> missingConcepts(Set<SAbstractConcept> conceptsFromLanguages, final SNode modelMerge, Set<SNode> conceptsFromModelMergeDefinition) {
    Iterable<SNode> conceptsDeclarations = SetSequence.fromSet(conceptsFromLanguages).select((it) -> (SNode) ModelMergingPolicy__BehaviorDescriptor.toAbstractConceptDeclaration_id6XtVDsmtlME.invoke(modelMerge, it));

    return Sets.difference(Sets.newHashSet(conceptsDeclarations), conceptsFromModelMergeDefinition);
  }


  private static List<SAbstractConcept> rootsConcepts(final Graph<SAbstractConcept> graph) {
    return graph.nodes().stream().filter((SAbstractConcept node) -> graph.inDegree(node) <= 0).distinct().collect(Collectors.<SAbstractConcept>toList());
  }

  private static ImmutableMap<SAbstractConcept, SNode> makeSconceptToMergePolicy(Graph<SAbstractConcept> graph, Map<SNode, SNode> conceptToMergePolicy) {
    Map<SAbstractConcept, SNode> sconceptToMergePolicy = new HashMap<SAbstractConcept, SNode>();

    for (SAbstractConcept sac : SetSequence.fromSet(graph.nodes())) {
      for (Map.Entry<SNode, SNode> e : SetSequence.fromSet(conceptToMergePolicy.entrySet())) {
        SNode acd = e.getKey();
        if ((boolean) AbstractConceptDeclaration__BehaviorDescriptor.is_id4MKjpUYmGW0.invoke(acd, sac)) {
          sconceptToMergePolicy.put(sac, e.getValue());
          break;
        }
      }
    }
    return ImmutableMap.copyOf(sconceptToMergePolicy);
  }

  private static void traverse(Graph<SAbstractConcept> graph, SAbstractConcept currentNode, Map<SAbstractConcept, SNode> conceptToMergePolicy, TraversalState matc, MergerResolverBuilder resultBuilder, ContentHolderFactory stuffFactory) {

    SNode mergePolicy = conceptToMergePolicy.get(currentNode);

    addMergePoliciesToTraversalState(mergePolicy, matc, currentNode, stuffFactory);

    constructMergePolicesForNode(currentNode, matc, resultBuilder);

    for (SAbstractConcept succ : SetSequence.fromSet(graph.successors(currentNode))) {
      traverse(graph, succ, conceptToMergePolicy, matc, resultBuilder, stuffFactory);
    }

    removeMergePolicies(mergePolicy, matc);
  }

  private static void constructMergePolicesForNode(SAbstractConcept startNode, TraversalState matc, MergerResolverBuilder resultBuilder) throws MergingPolicyConflict, MergingPolicyConflict {
    // Properties
    try {
      Map<SAbstractConcept, MapWrapper<SNode, ContentHolder<PropertyMerger>>> propMap = resultBuilder.porpertyMergePolicy;
      MapWrapper<SNode, ContentHolder<PropertyMerger>> mergeWithPrevious = mergeWithPrevious(propMap.get(startNode), matc.propertySnapshot(), startNode);
      (resultBuilder.porpertyMergePolicy).put(startNode, mergeWithPrevious);
    } catch (MergingPolicyConflict mpc) {
      mpc.type = MergingPolicyConflict.Type.property;
      throw mpc;
    }
    // Children
    try {
      Map<SAbstractConcept, MapWrapper<SNode, ContentHolder<ConceptChildMerger>>> conceptMap = resultBuilder.conceptMergePolicy;
      MapWrapper<SNode, ContentHolder<ConceptChildMerger>> mergeWithPrevious = mergeWithPrevious(conceptMap.get(startNode), matc.childSnapshot(), startNode);

      (resultBuilder.conceptMergePolicy).put(startNode, mergeWithPrevious);
    } catch (MergingPolicyConflict mpc) {
      mpc.type = MergingPolicyConflict.Type.child;
      throw mpc;
    }
    // References
    try {
      Map<SAbstractConcept, MapWrapper<SNode, ContentHolder<ConceptRefMerger>>> conceptMap = resultBuilder.referenceMergePolicy;
      conceptMap.put(startNode, mergeWithPrevious(conceptMap.get(startNode), matc.referenceSnapshot(), startNode));
    } catch (MergingPolicyConflict mpc) {
      mpc.type = MergingPolicyConflict.Type.reference;
      throw mpc;
    }
    // Identity
    try {
      ContentHolder<Identity> id = (resultBuilder.conceptToIdFunction).get(startNode);
      MapWrapper<TraversalState.Dummy, ContentHolder<Identity>> identitySnapshot = matc.identitySnapshot();
      if (id != null && identitySnapshot != null) {
        MapWrapper<TraversalState.Dummy, ContentHolder<Identity>> mergeWithPrevious = mergeWithPrevious(new MapWrapper<TraversalState.Dummy, ContentHolder<Identity>>(ImmutableMap.of(TraversalState.Dummy.I, id)), identitySnapshot, startNode);
        (resultBuilder.conceptToIdFunction).put(startNode, mergeWithPrevious.get(TraversalState.Dummy.I));
      } else {
        ContentHolder<Identity> stuff = (identitySnapshot != null ? identitySnapshot.get(TraversalState.Dummy.I) : id);
        if (stuff != null) {

          resultBuilder.conceptToIdFunction.put(startNode, stuff);
        }
      }

    } catch (MergingPolicyConflict mpc) {
      mpc.type = MergingPolicyConflict.Type.idFunction;
      throw mpc;
    }

  }

  private static void removeMergePolicies(SNode mergePolicy, TraversalState matc) {
    for (SNode propertyId : ListSequence.fromList(SLinkOperations.getChildren(mergePolicy, LINKS.propertyPolicies$p_0G)).select((it) -> SLinkOperations.getTarget(it, LINKS.property$IQvu))) {
      boolean success = matc.removeLastPropertyPolicy(propertyId);
    }

    for (SNode link : ListSequence.fromList(SLinkOperations.getChildren(mergePolicy, LINKS.childPolicies$7ocQ)).where((it) -> !(SNodeOperations.getConcept(it).isAbstract())).select((it) -> (SNode) DeclarationPolicy__BehaviorDescriptor.childLink_id1VmHfRx_0K2.invoke(it))) {
      boolean success = matc.removeLastChildPolicy(link);
    }

    for (SNode link : ListSequence.fromList(SLinkOperations.getChildren(mergePolicy, LINKS.referencePolicies$lOcG)).select((it) -> (SNode) DeclarationPolicy__BehaviorDescriptor.childLink_id1VmHfRx_0K2.invoke(it))) {
      boolean success = matc.removeLastReferencePolicy(link);
    }

    matc.resetIdentity();

  }

  private static void addMergePoliciesToTraversalState(SNode mergePolicy, TraversalState matc, SAbstractConcept currentConcept, ContentHolderFactory stuffFactory) {
    for (SNode pp : ListSequence.fromList(SLinkOperations.getChildren(mergePolicy, LINKS.propertyPolicies$p_0G))) {
      ContentHolder<PropertyMerger> propertyMerger = stuffFactory.propertyMerger(pp, currentConcept);
      matc.addPropertyPolicy(SLinkOperations.getTarget(pp, LINKS.property$IQvu), propertyMerger);
    }
    for (SNode childPolicy : ListSequence.fromList(SLinkOperations.getChildren(mergePolicy, LINKS.childPolicies$7ocQ))) {
      ContentHolder<ConceptChildMerger> childMerger = stuffFactory.childMerger(childPolicy, currentConcept);
      if (childMerger != null) {
        SNode childLink = DeclarationPolicy__BehaviorDescriptor.childLink_id1VmHfRx_0K2.invoke(childPolicy);
        matc.addChildlink(childLink, childMerger);
      }
    }
    for (SNode refPolicy : ListSequence.fromList(SLinkOperations.getChildren(mergePolicy, LINKS.referencePolicies$lOcG))) {
      ContentHolder<ConceptRefMerger> refMerger = stuffFactory.refMerger(refPolicy, currentConcept);
      matc.addRefPolicy(DeclarationPolicy__BehaviorDescriptor.childLink_id1VmHfRx_0K2.invoke(refPolicy), refMerger);
    }

    SNode idFunction = SLinkOperations.getTarget(mergePolicy, LINKS.idFunction$EPRs);

    if ((idFunction != null)) {
      Identity idOf = stuffFactory.idOf(SLinkOperations.getTarget(mergePolicy, LINKS.idFunction$EPRs), currentConcept);
      matc.setIdentity(idOf, currentConcept);
    }
  }

  private static <L, C> MapWrapper<L, ContentHolder<C>> mergeWithPrevious(MapWrapper<L, ContentHolder<C>> prev, MapWrapper<L, ContentHolder<C>> childSnapshot, SAbstractConcept startNode) {
    return (prev != null ? merge(prev, childSnapshot, startNode) : childSnapshot);
  }

  private static <L, C> MapWrapper<L, ContentHolder<C>> merge(MapWrapper<L, ContentHolder<C>> prev, final MapWrapper<L, ContentHolder<C>> curr, SAbstractConcept node) {
    Collection<L> omit = Lists.newLinkedList();

    for (Map.Entry<L, ContentHolder<C>> entry : SetSequence.fromSet(prev.entries())) {
      L key = entry.getKey();
      ContentHolder<C> otherStuff = curr.get(key);
      // If for the given key there is not a value from the a previous visit during the traversal, then there is no conflict.
      if (otherStuff == null) {
        continue;
      }
      ContentHolder<C> stuff = entry.getValue();
      // If for the given key there is a value from the a previous visit during the traversal, but from the same concept as the one which is currently visited, then we can omit the current value. It has been collected in the previous traversal
      if (Objects.equals(otherStuff.inheritedFrom(), stuff.inheritedFrom())) {
        CollectionSequence.fromCollection(omit).addElement(key);
        continue;
      }
      // If for the given key there is a value from the a previous visit during the traversal (necessarily from another concept) and the current value differs from it, then there is a conflict. We discovered a diamond-like inheritance structure
      if (!(otherStuff.isSame(stuff))) {
        throw new MergingPolicyConflict(key, node);
      }
      // If for the given key there is a value from the a previous visit during the traversal (necessarily from another concept) and the current value does not differs from it, then there is not a conflict. We can omit the current value
      if (otherStuff.isSame(stuff)) {
        CollectionSequence.fromCollection(omit).addElement(key);
      }
    }
    curr.remove(omit);
    assert !(CollectionSequence.fromCollection(omit).any((it) -> curr.get(it) != null));
    return curr.merge(prev);
  }

  private static final class PROPS {
    /*package*/ static final SProperty partialPolicy$djMt = MetaAdapterFactory.getProperty(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42dcce87L, 0x5b4be50b1edb9bf2L, "partialPolicy");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink propertyPolicies$p_0G = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42de4bf5L, 0x1a8b8d3e42e44c7dL, "propertyPolicies");
    /*package*/ static final SReferenceLink property$IQvu = MetaAdapterFactory.getReferenceLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42e44628L, 0x68dab8ecba09e939L, "property");
    /*package*/ static final SContainmentLink childPolicies$7ocQ = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42de4bf5L, 0x74e2e0579b2effc5L, "childPolicies");
    /*package*/ static final SContainmentLink referencePolicies$lOcG = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42de4bf5L, 0x3d71e5f1538357ebL, "referencePolicies");
    /*package*/ static final SContainmentLink idFunction$EPRs = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42de4bf5L, 0x630e54bf6108c244L, "idFunction");
  }
}

package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuLookup;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.annotations.NotNull;
import java.util.Collection;
import jetbrains.mps.openapi.editor.descriptor.TransformationMenu;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Collections;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Objects;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsMenuLocations;
import jetbrains.mps.nodeEditor.cellMenu.SideTransformCompletionActionItem;
import jetbrains.mps.openapi.editor.menus.transformation.CompletionActionItem;
import jetbrains.mps.openapi.editor.menus.transformation.ConstraintsVerifiableActionItem;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.IShadowingTransformationAction;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.openapi.editor.menus.transformation.CommandPolicy;

public class ListInsertActionLookup implements TransformationMenuLookup {
  private List<String> matchingTexts;
  private boolean before;
  private String sourceCellId;
  private String description;
  private SNode anchorNode;
  private SNodeReference trace;
  private _FunctionTypes._void_P1_E0<? super SNode> afterInsert;

  public ListInsertActionLookup(List<String> matchingTexts, boolean before, String sourceCellId, String description, SNode anchorNode, SNodeReference trace, _FunctionTypes._void_P1_E0<? super SNode> afterInsert) {
    this.matchingTexts = matchingTexts;
    this.before = before;
    this.sourceCellId = sourceCellId;
    this.description = description;
    this.anchorNode = anchorNode;
    this.trace = trace;
    this.afterInsert = afterInsert;
  }

  @Override
  public String toString() {
    return description;
  }
  public String getSourceCellId() {
    return this.sourceCellId;
  }
  @NotNull
  @Override
  public Collection<TransformationMenu> lookup(@NotNull Collection<SLanguage> p1, @NotNull final String location) {
    return Collections.<TransformationMenu>singleton(new TransformationMenu() {
      @NotNull
      @Override
      public List<TransformationMenuItem> createMenuItems(@NotNull TransformationMenuContext context) {
        if (!(isApplicableToLocation(context.getMenuLocation()))) {
          return Collections.<TransformationMenuItem>emptyList();
        }
        context.getEditorMenuTrace().pushTraceInfo();
        try {
          context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase(toString(), trace));
          return ListSequence.fromListAndArray(new ArrayList<TransformationMenuItem>(), new Item(context));
        } finally {
          context.getEditorMenuTrace().popTraceInfo();
        }
      }

      @Override
      public boolean isContribution() {
        return true;
      }

      @Override
      public boolean isApplicableToLocation(String location) {
        return Objects.equals(location, ((before ? GrammarCellsMenuLocations.BEFORE : GrammarCellsMenuLocations.AFTER)));
      }
    });
  }

  public class Item extends MultiTextActionItem implements TransformationMenuItem, SideTransformCompletionActionItem, CompletionActionItem, ConstraintsVerifiableActionItem, IShadowingTransformationAction {
    public Item(TransformationMenuContext context) {
      super(matchingTexts, context);
    }
    public ListInsertActionLookup getLookup() {
      return ListInsertActionLookup.this;
    }
    public SNode getAnchorNode() {
      return anchorNode;
    }
    public boolean isBefore() {
      return before;
    }
    @Nullable
    @Override
    public SAbstractConcept getOutputConcept() {
      return SNodeOperations.getConcept(anchorNode);
    }
    @Override
    public void execute(@NotNull String pattern) {
      SNode newChild = SNodeFactoryOperations.createNewNode(SNodeOperations.getConcept(anchorNode), null);
      ListSequence.fromList(SNodeOperations.getChildren(SNodeOperations.getParent(anchorNode), SNodeOperations.getContainingLink(anchorNode))).insertElement(SNodeOperations.getIndexInParent(anchorNode) + ((before ? 0 : 1)), newChild);
      if (afterInsert != null) {
        afterInsert.invoke(newChild);
      }
    }
    @NotNull
    @Override
    public CommandPolicy getCommandPolicy() {
      return CommandPolicy.COMMAND_REQUIRED;
    }

    @Override
    public String getShortDescriptionText(String pattern) {
      return description;
    }
    @Override
    public boolean shadows(TransformationMenuItem shadowed_) {
      if (shadowed_ instanceof Item) {
        Item shadowed = ((Item) shadowed_);
        if (before && !(shadowed.isBefore()) && Objects.equals(SNodeOperations.getPrevSibling(anchorNode), shadowed.getAnchorNode())) {
          return true;
        }
      }
      return false;
    }
  }
}

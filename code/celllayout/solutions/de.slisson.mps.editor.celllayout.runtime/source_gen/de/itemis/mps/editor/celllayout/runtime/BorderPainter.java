package de.itemis.mps.editor.celllayout.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.AbstractAdditionalPainter;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.awt.Graphics2D;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import de.itemis.mps.editor.celllayout.boxmodel.EditorCellBoxModel;
import de.itemis.mps.editor.celllayout.boxmodel.LayoutBoxFrame;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.itemis.mps.editor.celllayout.styles.editor.LayoutStylesUtil;
import de.itemis.mps.editor.celllayout.boxmodel.LayoutBox;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.Color;
import java.util.Objects;
import com.intellij.ui.JBColor;

public class BorderPainter extends AbstractAdditionalPainter {
  private List<PaintRectOperation> myPaintQueue = ListSequence.fromList(new ArrayList<PaintRectOperation>());

  public Object getItem() {
    return this;
  }

  public void paint(Graphics g_, EditorComponent component) {
    Graphics2D g = ((Graphics2D) g_.create());
    try {
      paintBorders(g, component.getRootCell());
      processQueue(g);
    } finally {
      g.dispose();
    }
  }

  public void paintBackground(Graphics graphics, EditorComponent component) {
  }

  public boolean paintsAbove() {
    return true;
  }

  public boolean paintsBackground() {
    return false;
  }

  public void paintBorders(Graphics2D g, EditorCell cell) {
    paintBorders(g, cell, false);
  }

  public void paintBorders(Graphics2D g, EditorCell cell, boolean isCustomPainting) {
    if (cell.getStyle().get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "-custom-border-painting")) && !(isCustomPainting)) {
      return;
    }
    EditorCellBoxModel boxModel = EditorCellBoxModel.getInstance(cell);
    boxModel.readSyncPosition();
    LayoutBoxFrame borderBox = boxModel.getBorderBox();

    if (g.hitClip(borderBox.getX() - 1, borderBox.getY() - 1, borderBox.getWidth() + 2, borderBox.getHeight() + 2)) {
      paintBorder(g, cell);
      if (cell instanceof EditorCell_Collection) {
        for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) cell))) {
          paintBorders(g, child, isCustomPainting);
        }
      }
    }
  }

  protected void paintBorder(Graphics2D g, EditorCell cell) {
    int leftSize = LayoutStylesUtil.getLeftBorderSize(cell);
    int rightSize = LayoutStylesUtil.getRightBorderSize(cell);
    int topSize = LayoutStylesUtil.getTopBorderSize(cell);
    int bottomSize = LayoutStylesUtil.getBottomBorderSize(cell);
    if (leftSize == 0 && rightSize == 0 && topSize == 0 && bottomSize == 0) {
      return;
    }

    EditorCellBoxModel boxModel = EditorCellBoxModel.getInstance(cell);
    LayoutBoxFrame borderBox = boxModel.getBorderBox();
    LayoutBox innerBox = borderBox.getInnerBox();

    Rectangle2D.Double leftRect = new Rectangle2D.Double(innerBox.getX() - leftSize, innerBox.getY(), leftSize, innerBox.getHeight());
    Rectangle2D.Double rightRect = new Rectangle2D.Double(innerBox.getRight(), innerBox.getY(), rightSize, innerBox.getHeight());
    Rectangle2D.Double topRect = new Rectangle2D.Double(innerBox.getX(), innerBox.getY() - topSize, innerBox.getWidth(), topSize);
    Rectangle2D.Double bottomRect = new Rectangle2D.Double(innerBox.getX(), innerBox.getBottom(), innerBox.getWidth(), bottomSize);

    // There is one pixel less reserved than required
    leftRect.x += 0.5;
    rightRect.x -= 0.5;
    topRect.y += 0.5;
    bottomRect.y -= 0.5;

    // The top border fills the top-left and top-right corners
    if (topSize != 0 && leftSize != 0) {
      topRect.x -= leftSize - 0.5;
      topRect.width += leftSize - 0.5;
      leftRect.y += 0.5;
      leftRect.height -= 0.5;
    }
    if (topSize != 0 && rightSize != 0) {
      topRect.width += rightSize - 0.5;
      rightRect.y += 0.5;
      rightRect.height -= 0.5;
    }
    // The bottom border fills the bottom-left and bottom-right corners
    if (bottomSize != 0 && leftSize != 0) {
      bottomRect.x -= leftSize - 0.5;
      bottomRect.width += leftSize - 0.5;
      leftRect.height -= 0.5;
    }
    if (bottomSize != 0 && rightSize != 0) {
      bottomRect.width += rightSize - 0.5;
      rightRect.height -= 0.5;
    }

    if (leftSize > 0) {
      queueRect(leftRect, LayoutStylesUtil.getLeftBorderColor(cell));
    }
    if (rightSize > 0) {
      queueRect(rightRect, LayoutStylesUtil.getRightBorderColor(cell));
    }
    if (topSize > 0) {
      queueRect(topRect, LayoutStylesUtil.getTopBorderColor(cell));
    }
    if (bottomSize > 0) {
      queueRect(bottomRect, LayoutStylesUtil.getBottomBorderColor(cell));
    }
  }

  protected Rectangle toRectangle(LayoutBox borderBox) {
    return new Rectangle(borderBox.getX(), borderBox.getY(), borderBox.getWidth(), borderBox.getHeight());
  }

  protected void queueRect(Rectangle2D rect, Color color) {
    ListSequence.fromList(myPaintQueue).addElement(new PaintRectOperation(rect, color));
  }

  public void processQueue(Graphics2D g) {
    for (PaintRectOperation op : ListSequence.fromList(myPaintQueue).sort((it) -> it.getBorderWidth(), true).alsoSort((it) -> it.getBrightnessPriority(), true)) {
      op.paint(g);
    }
    ListSequence.fromList(myPaintQueue).clear();
  }

  protected class PaintRectOperation {
    private Rectangle2D myRect;
    private Color myColor;

    public PaintRectOperation(Rectangle2D rect, Color color) {
      myRect = rect;
      myColor = color;
    }

    public void paint(Graphics2D g) {
      g.setColor(myColor);
      g.fill(myRect);
    }

    public int getBorderWidth() {
      return ((int) Math.round(Math.min(myRect.getWidth(), myRect.getHeight())));
    }

    public float getBrightness() {
      float[] hsb = Color.RGBtoHSB(myColor.getRed(), myColor.getGreen(), myColor.getBlue(), null);
      return hsb[2];
    }

    protected float getBrightnessPriority() {
      // Light gray is the default color, it has the lowest priority
      return ((Objects.equals(myColor, Color.LIGHT_GRAY) || Objects.equals(myColor, JBColor.LIGHT_GRAY)) ? -1.0f : -getBrightness());
    }
  }
}

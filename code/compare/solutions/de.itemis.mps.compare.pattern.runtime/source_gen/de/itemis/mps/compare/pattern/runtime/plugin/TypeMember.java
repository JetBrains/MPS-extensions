package de.itemis.mps.compare.pattern.runtime.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class TypeMember extends PatternBuilderInitPart<IPatternEvaluator> {

  public TypeMember(Expression<IPatternEvaluator> inner, String annotation, boolean negated) {
    super(inner, annotation, negated);
  }

  public TypeMember(Expression<IPatternEvaluator> inner, String annotation) {
    this(inner, annotation, false);
  }

  public TypeMember(Expression<IPatternEvaluator> inner) {
    this(inner, null);
  }

  @Override
  public MatchResult match(SNode node) {
    if (TypecheckingFacade.getFromContext().getTypeOf(node) != null) {
      MatchResult result;

      if (inner.getFirst() == null) {
        result = new MatchResult(true, null);
      } else {
        IPatternEvaluator evaluator = inner.getFirst();
        SNode type = evaluator.build(null);
        result = new MatchResult(SNodeOperations.getConcept(TypecheckingFacade.getFromContext().getTypeOf(node)).isSubConceptOf(SNodeOperations.getConcept(type)), null);
      }

      result = result.xor(negated);

      if (result.isMatch() && shouldAnnotate()) {
        result.put(annotation, TypecheckingFacade.getFromContext().getTypeOf(node));
      }
      return result;
    }
    return MatchResult.noMatch();
  }

  @Override
  public String toString() {
    return "type@" + this.annotation + " = " + this.inner.getFirst();
  }

  @Override
  public SNode build(SNode node) {
    return node;
  }

}

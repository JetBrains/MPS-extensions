package de.itemis.mps.editor.bool.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import com.intellij.ui.ColorUtil;
import com.intellij.ui.JBColor;
import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;

public class EditorCell_BooleanText extends EditorCell_Property {

  public EditorCell_BooleanText(EditorContext context, ModelAccessor accessor, SNode snode) {
    super(context, accessor, snode);
  }

  @Override
  public void paintContent(Graphics graphics, ParentSettings settings) {
    super.paintContent(graphics, settings);

    if ("".equals(getText()) && "".equals(myNullTextLine.getText())) {
      Graphics g2 = graphics.create();
      g2.setColor(ColorUtil.withAlpha(JBColor.BLACK, 0.117));
      g2.fillRect(getFirstCaretPositionX(), getY(), 2, getHeight());
      g2.dispose();
    }
  }

  protected int getFirstCaretPositionX() {
    if (isDrawBrackets()) {
      return myX + myGapLeft + BRACKET_WIDTH;
    } else {
      return myX + myGapLeft;
    }
  }

  public static EditorCell_Property create(EditorContext editorContext, ModelAccessor modelAccessor, SNode node) {
    NodeReadAccessInEditorListener listener = NodeReadAccessCasterInEditor.getReadAccessListener();
    if (modelAccessor instanceof PropertyAccessor) {
      if (listener != null) {
        listener.clearCleanlyReadAccessProperties();
      }
    }
    EditorCell_Property result = new EditorCell_BooleanText(editorContext, modelAccessor, node);
    if (listener != null) {
      addPropertyDependenciesToEditor(listener, result);
    }
    return result;
  }

  private static void addPropertyDependenciesToEditor(NodeReadAccessInEditorListener listener, EditorCell_Property result) {
    for (Pair<SNodeReference, String> pair : listener.popCleanlyReadAccessedProperties()) {
      result.getEditorComponent().getUpdater().getCurrentUpdateSession().registerCleanDependency(result, pair);
    }
  }
}

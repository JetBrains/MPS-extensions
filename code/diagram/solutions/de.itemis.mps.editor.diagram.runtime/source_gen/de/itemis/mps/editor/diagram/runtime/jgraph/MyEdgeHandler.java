package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.swing.handler.mxEdgeHandler;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.view.mxCellState;
import java.awt.Graphics;
import java.awt.event.MouseEvent;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import com.mxgraph.util.mxPoint;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.awt.Point;
import com.mxgraph.model.mxIGraphModel;
import com.mxgraph.model.mxGeometry;
import com.mxgraph.util.mxConstants;
import java.awt.Rectangle;
import com.mxgraph.view.mxGraphView;
import java.util.Arrays;
import com.mxgraph.view.mxConnectionConstraint;
import org.jetbrains.annotations.Nullable;
import de.itemis.mps.editor.diagram.runtime.model.Edge;

public class MyEdgeHandler extends mxEdgeHandler implements ISupportButtonHiding {
  private ContextButtonContainer myButtonContainer;
  private boolean disableSnap = false;
  private EdgeLineMoveHandler myEdgeLineMoveHandler = new EdgeLineMoveHandler(this);
  private boolean defaultStyle = false;

  protected Map<Integer, Boolean> buttonVisibility = MapSequence.fromMap(new HashMap<Integer, Boolean>());

  public MyEdgeHandler(mxGraphComponent component, mxCellState state, Map<Integer, Boolean> buttonVisibility, boolean defaultStyle) {
    super(component, state);
    this.buttonVisibility = buttonVisibility;
    this.defaultStyle = defaultStyle;
  }

  @Override
  public Map<Integer, Boolean> getButtonVisibilityMap() {
    return buttonVisibility;
  }

  public ContextButtonContainer getButtonContainer() {
    if (myButtonContainer == null) {
      myButtonContainer = new ContextButtonContainer(state.getView());
      updateButtons();
    }
    return myButtonContainer;
  }

  @Override
  public void refresh(mxCellState state) {
    super.refresh(state);
    updateButtons();
    bounds.add(getButtonContainer().getBounds());
  }

  @Override
  public void paint(Graphics g) {
    super.paint(g);
    getButtonContainer().paint(g);
  }

  @Override
  public void mousePressed(MouseEvent event) {
    getButtonContainer().mousePressed(event);
    if (!(event.isConsumed())) {
      super.mousePressed(event);
    }
  }

  @Override
  public void mouseReleased(MouseEvent event) {
    getButtonContainer().mouseReleased(event);
    if (!(event.isConsumed())) {
      super.mouseReleased(event);
    }
  }

  @Override
  public void mouseMoved(MouseEvent event) {
    getButtonContainer().mouseMoved(event);
    super.mouseMoved(event);
  }

  @Override
  public String getToolTipText(MouseEvent event) {
    String toolTipText = getButtonContainer().getToolTipText(event.getX(), event.getY());
    if (toolTipText != null) {
      return toolTipText;
    }
    return super.getToolTipText(event);
  }

  public double getScale() {
    return state.getView().getScale();
  }

  protected void updateButtons() {
    List<ContextButton> buttons = ListSequence.fromList(new ArrayList<ContextButton>());
    MyGraphComponent component = ((MyGraphComponent) this.getGraphComponent());
    RootDCell rootCell = ((RootDiagramECell) ReflectionUtil.readField(MyGraphComponent.class, component, "myDiagramCell")).getDCell(component.getGraph());
    _FunctionTypes._return_P3_E0<? extends List<ContextButton>, ? super EditorContext, ? super SNode, ? super mxCellState> buttonsCreator = rootCell.getEdgeButtonsCreator();

    Object cell = state.getCell();

    if (buttonsCreator != null && cell instanceof EdgeDCell) {
      EdgeDCell edgeCell = (EdgeDCell) cell;
      EditorCell editorCell = edgeCell.getBigCell();
      ListSequence.fromList(buttons).addSequence(ListSequence.fromList(buttonsCreator.invoke(editorCell.getEditorComponent().getEditorContext(), editorCell.getSNode(), state)));
    } else {
      double size = ContextButton.DEFAULT_BUTTON_SIZE * getScale();
      if (cell instanceof EdgeDCell) {
        EdgeDCell edgeCell = ((EdgeDCell) cell);

        if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__hide-edge-button"))) {
          ListSequence.fromList(buttons).addElement(new HideEdgeButton(size, state));
        }

        if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__open-node-buttons"))) {
          for (SNode target : ListSequence.fromList(check_48sii8_a0a4a1a0h0bb(edgeCell.getEdge()))) {
            ListSequence.fromList(buttons).addElement(new OpenNodeButton(size, state, target));
          }
        }
      }
    }

    getButtonContainer().setButtons(buttons);

    updateButtonPositions();
  }

  protected void updateButtonPositions() {
    Vector2D edgeCenter;
    Vector2D direction;
    {
      Tuples._2<Vector2D, Vector2D> _tmp_48sii8_c0db = getEdgeCenter();
      edgeCenter = _tmp_48sii8_c0db._0();
      direction = _tmp_48sii8_c0db._1();
    }
    direction = VectorExtensions.rotate90(direction);
    if (direction.getX() < 0.0 || direction.getX() == 0.0 && direction.getY() < 0.0) {
      direction = direction.scalarMultiply(-1.0);
    }
    Vector2D buttonsPos = edgeCenter.add(-ContextButton.DEFAULT_BUTTON_SIZE / 2, direction);
    getButtonContainer().moveTo(buttonsPos.getX(), buttonsPos.getY());
  }

  protected Tuples._2<Vector2D, Vector2D> getEdgeCenter() {
    List<mxPoint> fullPath = state.getAbsolutePoints();

    double edgeLength = 0.0;
    Vector2D lastPoint = new Vector2D(ListSequence.fromList(fullPath).getElement(0).getX(), ListSequence.fromList(fullPath).getElement(0).getY());
    for (int i = 1; i < ListSequence.fromList(fullPath).count(); i++) {
      Vector2D point = new Vector2D(ListSequence.fromList(fullPath).getElement(i).getX(), ListSequence.fromList(fullPath).getElement(i).getY());
      edgeLength += lastPoint.distance(point);
      lastPoint = point;
    }

    double remainingLength = edgeLength / 2;
    lastPoint = new Vector2D(ListSequence.fromList(fullPath).getElement(0).getX(), ListSequence.fromList(fullPath).getElement(0).getY());
    Vector2D centerPoint = lastPoint;
    Vector2D directionAtCenter = new Vector2D(1.0, 0.0);
    for (int i = 1; i < ListSequence.fromList(fullPath).count(); i++) {
      Vector2D point = new Vector2D(ListSequence.fromList(fullPath).getElement(i).getX(), ListSequence.fromList(fullPath).getElement(i).getY());
      double distance = lastPoint.distance(point);
      if (remainingLength > distance) {
        remainingLength -= distance;
        lastPoint = point;
      } else {
        centerPoint = lastPoint.add(VectorExtensions.normalizeSafe(point.subtract(lastPoint)).scalarMultiply(remainingLength));
        directionAtCenter = VectorExtensions.normalizeSafe(point.subtract(lastPoint));
        break;
      }
    }

    return MultiTuple.<Vector2D,Vector2D>from(centerPoint, directionAtCenter);
  }

  public Point[] getPoints() {
    return p;
  }

  @Override
  protected void movePoint(Object edge, int pointIndex, mxPoint point) {
    if (myEdgeLineMoveHandler.isLineIndex(pointIndex)) {
      mxPoint startTerminalPoint = convertPoint(state.getAbsolutePoint(0), gridEnabledEvent);
      mxPoint endTerminalPoint = convertPoint(state.getAbsolutePoint(state.getAbsolutePointCount() - 1), gridEnabledEvent);
      mxPoint convertedFirst = convertPoint(new mxPoint(first), false);
      myEdgeLineMoveHandler.move(edge, startTerminalPoint, endTerminalPoint, myEdgeLineMoveHandler.indexHandleToLine(pointIndex), point.getX() - convertedFirst.getX(), point.getY() - convertedFirst.getY());
    } else {
      movePoint2(edge, pointIndex, point);
    }
  }

  protected void movePoint2(Object edge, int pointIndex, mxPoint point) {
    mxIGraphModel model = graphComponent.getGraph().getModel();
    mxGeometry geometry = model.getGeometry(edge);
    if (geometry != null) {
      model.beginUpdate();
      try {
        geometry = (mxGeometry) geometry.clone();
        if (isSource(index) || isTarget(index)) {
          connect(edge, null, isSource(index), false);
          geometry.setTerminalPoint(point, isSource(index));
        } else {
          List<mxPoint> points = geometry.getPoints();
          if (points == null) {
            points = new ArrayList<mxPoint>();
            geometry.setPoints(points);
          }
          boolean isExistingPoint = isExistingPoint(pointIndex);
          int indexInGeo = getIndexOfExisting(pointIndex);
          if (indexInGeo < points.size()) {
            if (isExistingPoint) {
              points.set(indexInGeo, point);
            } else {
              points.add(indexInGeo, point);
            }
          } else {
            points.add(point);
          }
          if (!(disableSnap) && !(defaultStyle)) {
            snapPoint(getState(), points, indexInGeo);
          }
          postprocessPoints(getStartEndPoint(true, getState()), getStartEndPoint(false, getState()), points);
        }
        model.setGeometry(edge, geometry);
      } finally {
        model.endUpdate();
      }
    }
  }

  public boolean isExistingPoint(int index) {
    return index % 2 == 0;
  }

  public int getIndexOfExisting(int index) {
    return (index - 1) / 2;
  }


  @Override
  public int getIndexAt(int x, int y) {
    int index = super.getIndexAt(x, y);
    if (index == -1) {
      index = myEdgeLineMoveHandler.getIndexAt(x, y);
    }
    return index;
  }

  protected void postprocessPoints(mxPoint start, mxPoint end, List<mxPoint> waypoints) {
    // remove points close together
    for (int i = 0; i < waypoints.size() - 1; i++) {
      mxPoint p = waypoints.get(i);
      for (int k = i + 1; k < waypoints.size(); k++) {
        mxPoint p2 = waypoints.get(k);
        if (p.getPoint().distance(p2.getPoint()) < mxConstants.HANDLE_SIZE) {
          while (k > i) {
            waypoints.remove(k);
            k--;
          }
        }
      }
    }

    List<mxPoint> all = new ArrayList<mxPoint>();
    all.add(start);
    all.addAll(waypoints);
    all.add(end);

    // remove points on a straight line
    for (int i = 1; i < all.size() - 1; i++) {
      mxPoint p1 = all.get(i - 1);
      mxPoint p2 = all.get(i);
      mxPoint p3 = all.get(i + 1);

      double angle12 = Math.atan2(p1.getX() - p2.getX(), p1.getY() - p2.getY());
      double angle23 = Math.atan2(p2.getX() - p3.getX(), p2.getY() - p3.getY());

      if (Math.abs(angle12 - angle23) < 0.0001) {
        all.remove(i);
        waypoints.remove(i - 1);
        i--;
      }
    }


  }

  public void mouseDragged2(MouseEvent e) {
    disableSnap = e.isShiftDown();
    if (!(e.isConsumed()) && first != null) {
      gridEnabledEvent = graphComponent.isGridEnabledEvent(e);
      constrainedEvent = graphComponent.isConstrainedEvent(e);
      boolean isSource = isSource(index);
      boolean isTarget = isTarget(index);
      Object source = null;
      Object target = null;
      if (isLabel(index)) {
        mxPoint abs = state.getAbsoluteOffset();
        double dx = abs.getX() - first.x;
        double dy = abs.getY() - first.y;
        mxPoint pt = new mxPoint(e.getPoint());
        if (gridEnabledEvent) {
          pt = graphComponent.snapScaledPoint(pt, dx, dy);
        }
        if (constrainedEvent) {
          if (Math.abs(e.getX() - first.x) > Math.abs(e.getY() - first.y)) {
            pt.setY(abs.getY());
          } else {
            pt.setX(abs.getX());
          }
        }
        Rectangle rect = getPreviewBounds();
        rect.translate((int) Math.round(pt.getX() - first.x), (int) Math.round(pt.getY() - first.y));
        preview.setBounds(rect);
      } else {
        // Clones the cell state and updates the absolute points using
        // the current state of this handle. This is required for
        // computing the correct perimeter points and edge style.
        mxGeometry geometry = graphComponent.getGraph().getCellGeometry(state.getCell());
        mxCellState clone = (mxCellState) state.clone();
        List<mxPoint> points = geometry.getPoints();
        if (points != null) {
          points = new ArrayList<mxPoint>(points);
        }
        mxGraphView view = clone.getView();
        if (isSource || isTarget) {
          marker.process(e);
          mxCellState currentState = marker.getValidState();
          target = state.getVisibleTerminal(!(isSource));
          if (currentState != null) {
            source = currentState.getCell();
          } else {
            mxPoint pt = new mxPoint(e.getPoint());
            if (gridEnabledEvent) {
              pt = graphComponent.snapScaledPoint(pt);
            }
            clone.setAbsoluteTerminalPoint(pt, isSource);
          }
          if (!(isSource)) {
            Object tmp = source;
            source = target;
            target = tmp;
          }
        } else {
          mxPoint point = convertPoint(new mxPoint(e.getPoint()), gridEnabledEvent);
          mxPoint convertedFirst = convertPoint(new mxPoint(first), false);
          if (points == null) {
            points = Arrays.asList(new mxPoint[]{point});
          } else {
            if (myEdgeLineMoveHandler.isLineIndex(index)) {
              mxPoint startTerminalPoint = getStartEndPoint(true, state);
              mxPoint endTerminalPoint = getStartEndPoint(false, state);
              myEdgeLineMoveHandler.movePoints(points, startTerminalPoint, endTerminalPoint, myEdgeLineMoveHandler.indexHandleToLine(index), point.getX() - convertedFirst.getX(), point.getY() - convertedFirst.getY());
            } else {
              // FIXME: not working properly for default styles
              if (isExistingPoint(index) && !(defaultStyle)) {
                points.set(getIndexOfExisting(index), point);
              } else {
                points.add(point);
              }
              if (!(disableSnap) && !(defaultStyle)) {
                snapPoint(state, points, getIndexOfExisting(index));
              }
            }
          }
          postprocessPoints(getStartEndPoint(true, state), getStartEndPoint(false, state), points);
          source = view.getVisibleTerminal(state.getCell(), true);
          target = view.getVisibleTerminal(state.getCell(), false);
        }
        // Computes the points for the edge style and terminals
        mxCellState sourceState = view.getState(source);
        mxCellState targetState = view.getState(target);
        mxConnectionConstraint sourceConstraint = graphComponent.getGraph().getConnectionConstraint(clone, sourceState, true);
        mxConnectionConstraint targetConstraint = graphComponent.getGraph().getConnectionConstraint(clone, targetState, false);
        if (!(isSource) || sourceState != null) {
          view.updateFixedTerminalPoint(clone, sourceState, true, sourceConstraint);
        }
        if (!(isTarget) || targetState != null) {
          view.updateFixedTerminalPoint(clone, targetState, false, targetConstraint);
        }
        view.updatePoints(clone, points, sourceState, targetState);
        view.updateFloatingTerminalPoints(clone, sourceState, targetState);
        // Uses the updated points from the cloned state to draw the preview
        p = createPoints(clone);
        preview.setBounds(getPreviewBounds());
      }
      if (!(preview.isVisible()) && graphComponent.isSignificant(e.getX() - first.x, e.getY() - first.y)) {
        preview.setVisible(true);
      } else
      if (preview.isVisible()) {
        preview.repaint();
      }
      e.consume();
    }
  }

  public void mouseDragged(MouseEvent e) {
    getButtonContainer().mouseDragged(e);
    if (!(e.isConsumed()) && first != null) {
      mouseDragged2(e);
    }
  }

  public mxPoint getStartEndPoint(boolean start, mxCellState cellState) {
    mxGraphView view = getGraphComponent().getGraph().getView();
    mxPoint point = cellState.getAbsolutePoint((start ? 0 : cellState.getAbsolutePointCount() - 1));
    point = JGraphUtil.convertFromView(view, point);
    return point;
  }

  public void snapPoint(mxCellState cellState, List<mxPoint> waypoints, int index) {
    snapPoint(getStartEndPoint(true, cellState), getStartEndPoint(false, cellState), waypoints, index, getSnapDistance());
  }

  protected void snapPoint(mxPoint start, mxPoint end, List<mxPoint> waypoints, int index, double snapDistance) {
    List<mxPoint> all = new ArrayList<mxPoint>(waypoints.size() + 2);
    all.add(start);
    all.addAll(waypoints);
    all.add(end);
    snapPoint(all, index + 1, snapDistance);
    waypoints.set(index, all.get(index + 1));
  }

  protected void snapPoint(List<mxPoint> points, int index, double snapDistance) {
    mxPoint pointToSnap = points.get(index);
    mxPoint prev = (index > 0 ? points.get(index - 1) : null);
    mxPoint next = (index < points.size() - 1 ? points.get(index + 1) : null);
    mxPoint snaped = (mxPoint) pointToSnap.clone();
    snapPoint(snaped, prev, next, snapDistance);
    points.set(index, snaped);
  }

  protected void snapPoint(mxPoint pointToSnap, @Nullable mxPoint previousPoint, @Nullable mxPoint nextPoint, double snapDistance) {
    mxPoint prev;
    double change;
    int timeout = 1000;
    do {
      prev = (mxPoint) pointToSnap.clone();
      snapToSquareAngles(pointToSnap, previousPoint, snapDistance);
      snapToSquareAngles(pointToSnap, nextPoint, snapDistance);
      snapToStraightLine(pointToSnap, previousPoint, nextPoint, snapDistance);
      change = Math.sqrt((prev.getX() - pointToSnap.getX()) * (prev.getX() - pointToSnap.getX()) + (prev.getY() - pointToSnap.getY()) * (prev.getY() - pointToSnap.getY()));
      timeout--;
    } while (change > 0.0001 && timeout > 0);
  }

  public void snapToStraightLine(mxPoint pointToSnap, @Nullable mxPoint previousPoint, @Nullable mxPoint nextPoint, double snapDistance) {
    if (previousPoint == null || nextPoint == null) {
      return;
    }

    Vector2D snapPoint = JGraphUtil.projectPointOnLine(VectorExtensions.toVector2D(pointToSnap), VectorExtensions.lineTo(previousPoint, nextPoint));
    double distance = VectorExtensions.toVector2D(pointToSnap).distance(snapPoint);
    if (distance <= snapDistance) {
      pointToSnap.setX(snapPoint.getX());
      pointToSnap.setY(snapPoint.getY());
    }
  }

  protected void snapToSquareAngles(mxPoint pointToSnap, mxPoint fixedPoint, double snapDistance) {
    if (fixedPoint == null) {
      return;
    }

    // 45 deg angle
    double deltaX = pointToSnap.getX() - fixedPoint.getX();
    double deltaY = pointToSnap.getY() - fixedPoint.getY();
    double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    double angle = Math.atan2(deltaX, deltaY);
    double next45 = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
    double snapX = Math.sin(next45) * distance + fixedPoint.getX();
    double snapY = Math.cos(next45) * distance + fixedPoint.getY();
    double distanceToSnap = Math.sqrt((pointToSnap.getX() - snapX) * (pointToSnap.getX() - snapX) + (pointToSnap.getY() - snapY) * (pointToSnap.getY() - snapY));
    if (distanceToSnap < snapDistance) {
      pointToSnap.setX(snapX);
      pointToSnap.setY(snapY);
    }

    // 90 deg
    if (Math.abs(pointToSnap.getX() - fixedPoint.getX()) < snapDistance) {
      pointToSnap.setX(fixedPoint.getX());
    }
    if (Math.abs(pointToSnap.getY() - fixedPoint.getY()) < snapDistance) {
      pointToSnap.setY(fixedPoint.getY());
    }

  }

  @Override
  protected Point[] createPoints(mxCellState state) {
    List<mxPoint> absolutePoints = state.getAbsolutePoints();
    Point[] pts = new Point[absolutePoints.size() * 2 - 1];
    for (int i = 0; i < absolutePoints.size(); i++) {
      pts[i * 2] = absolutePoints.get(i).getPoint();
    }
    for (int i = 0; i < absolutePoints.size() - 1; i++) {
      double x = (absolutePoints.get(i).getX() + absolutePoints.get(i + 1).getX()) / 2;
      double y = (absolutePoints.get(i).getY() + absolutePoints.get(i + 1).getY()) / 2;
      pts[i * 2 + 1] = new Point((int) Math.round(x), (int) Math.round(y));
    }
    return pts;
  }

  protected Rectangle[] createHandles() {
    p = createPoints(state);
    Rectangle[] h = new Rectangle[p.length + 1];
    for (int i = 0; i < h.length - 1; i++) {
      h[i] = createHandle(p[i], (isExistingPoint(i) ? mxConstants.HANDLE_SIZE : mxConstants.HANDLE_SIZE * 3 / 4));
    }
    h[p.length] = createHandle(state.getAbsoluteOffset().getPoint(), mxConstants.LABEL_HANDLE_SIZE);
    return h;
  }

  public double getSnapDistance() {
    return 10.0 / state.getView().getScale();
  }
  private static List<SNode> check_48sii8_a0a4a1a0h0bb(Edge checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getNavigationTargets();
    }
    return null;
  }
}

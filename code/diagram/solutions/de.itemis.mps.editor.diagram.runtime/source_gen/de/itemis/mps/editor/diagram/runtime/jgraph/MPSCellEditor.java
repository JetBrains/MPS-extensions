package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import javax.swing.JPanel;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import com.mxgraph.model.mxCell;
import java.awt.AWTEvent;
import javax.swing.border.Border;
import javax.swing.BorderFactory;
import com.intellij.ui.JBColor;
import de.itemis.mps.editor.diagram.runtime.EditorUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.List;
import com.mxgraph.model.mxIGraphModel;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.openapi.editor.cells.EditorCell_Label;
import java.awt.Color;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import de.itemis.mps.editor.diagram.runtime.shape.ShapeUtil;
import java.awt.Graphics;
import de.itemis.mps.editor.diagram.runtime.model.ScalableEditorCell;
import java.awt.Graphics2D;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.awt.Dimension;
import de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import de.itemis.mps.editor.collapsible.runtime.CollapseExpandToggleCell;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import jetbrains.mps.nodeEditor.EditorComponent;
import javax.swing.SwingUtilities;

public class MPSCellEditor extends JPanel {
  public static final int PADDING_SIZE = 3;

  private EditorCell myCell;
  private mxCell myDCell;
  private double myScale;
  private MyGraphComponent myGraphComponent;

  public MPSCellEditor(MyGraphComponent graphComponent) {
    myGraphComponent = graphComponent;
    enableEvents(AWTEvent.MOUSE_EVENT_MASK);
    enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);

    Border border = BorderFactory.createLineBorder(JBColor.BLACK, 1);
    border = BorderFactory.createCompoundBorder(border, BorderFactory.createLineBorder(JBColor.WHITE, 1));
    setBorder(border);

    setBackground(JBColor.WHITE);
  }

  public void editCell(MPSCell cell) {
    myCell = ((EditorCell) EditorUtil.getCommonAncestor(ListSequence.fromList(findLeafsWithoutSubdiagrams(cell.getEditorCell(), ListSequence.fromList(new ArrayList<jetbrains.mps.openapi.editor.cells.EditorCell>()))).toList()));
    if (myCell == null) {
      myCell = (EditorCell) cell.getEditorCell();
    }
    myDCell = findDCellForEmbeddedCell(myCell, myGraphComponent.getGraph().getModel());
    updateBackgroundColor();
  }

  private List<jetbrains.mps.openapi.editor.cells.EditorCell> findLeafsWithoutSubdiagrams(jetbrains.mps.openapi.editor.cells.EditorCell cell, List<jetbrains.mps.openapi.editor.cells.EditorCell> result) {
    if (!(cell instanceof BaseDiagramECell)) {
      List<jetbrains.mps.openapi.editor.cells.EditorCell> children = EditorUtil.getChildren(cell);
      if (ListSequence.fromList(children).isEmpty()) {
        ListSequence.fromList(result).addElement(cell);
      } else {
        for (jetbrains.mps.openapi.editor.cells.EditorCell child : ListSequence.fromList(children)) {
          findLeafsWithoutSubdiagrams(child, result);
        }
      }
    }
    return result;
  }

  public static mxCell findDCellForEmbeddedCell(final jetbrains.mps.openapi.editor.cells.EditorCell ecell, final mxIGraphModel model) {
    final Wrappers._T<mxCell> mpsCellContainer = new Wrappers._T<mxCell>(null);
    JGraphUtil.visitCells(model, (mxCell cell) -> {
      if (cell instanceof IMPSCellContainer) {
        for (MPSCell m : ListSequence.fromList(((IMPSCellContainer) cell).getMPSCells())) {
          if (m.getEditorCell() == ecell) {
            mpsCellContainer.value = cell;
            return true;
          }
        }
      }
      return false;
    });

    return mpsCellContainer.value;
  }

  protected void updateBackgroundColor() {
    float maxBrightness = 0.0f;
    float minBrightness = 1.0f;
    for (EditorCell_Label label : ListSequence.fromList(EditorUtil.descendants(myCell, EditorCell_Label.class))) {
      Color textColor = label.getStyle().get(StyleAttributes.TEXT_COLOR);
      if (textColor == null) {
        continue;
      }
      float brightness = ShapeUtil.getBrightness(textColor);
      maxBrightness = Math.max(maxBrightness, brightness);
      minBrightness = Math.min(minBrightness, brightness);
    }
    if (1.0 - maxBrightness < minBrightness) {
      setBackground(JBColor.DARK_GRAY);
    } else {
      setBackground(JBColor.WHITE);
    }
  }

  @Override
  protected void paintComponent(final Graphics g_) {
    super.paintComponent(g_);
    ScalableEditorCell.withScalingDisabled(() -> {
      DrawUtil.executeWithGraphicsCopy(((Graphics2D) g_), (Graphics2D g) -> {
        g.transform(buildTransformation());
        DrawUtil.executeWithGraphicsCopy(g, new _FunctionTypes._void_P1_E0<Graphics2D>() {
          public void invoke(Graphics2D g) {
            myCell.paint(g);
          }
        });
      });
    });
  }

  @Override
  public Dimension getPreferredSize() {
    final Wrappers._double w = new Wrappers._double();
    final Wrappers._double h = new Wrappers._double();
    ScalableEditorCell.withScalingDisabled(() -> {
      w.value = LayoutDependencies.getWidth(myCell);
      h.value = LayoutDependencies.getHeight(myCell);
    });
    w.value *= myScale;
    h.value *= myScale;
    w.value += PADDING_SIZE * 2;
    h.value += PADDING_SIZE * 2;
    return new Dimension(ExtensionMethods.toInt(w.value), ExtensionMethods.toInt(h.value));
  }

  public double getScale() {
    return myScale;
  }

  public void setScale(double scale) {
    myScale = scale;
  }

  @Override
  protected void processMouseEvent(final MouseEvent event) {
    ScalableEditorCell.withScalingDisabled(() -> {
      Point2D converted = convert(event.getX(), event.getY());
      jetbrains.mps.openapi.editor.cells.EditorCell leafAtCursor = myCell.findLeaf((int) converted.getX(), (int) converted.getY());
      if (leafAtCursor instanceof CollapseExpandToggleCell) {
        ((CollapseExpandToggleCell) leafAtCursor).toggle();
        return;
      }

      super_processMouseEvent(event);
      MPSCell.handleMouseEvent(event, myCell, 0, 0, myScale);
    });
  }

  private void super_processMouseEvent(MouseEvent event) {
    super.processMouseEvent(event);
  }

  public AffineTransform buildTransformation() {
    AffineTransform t = AffineTransform.getTranslateInstance(0, 0);
    t.translate(PADDING_SIZE, PADDING_SIZE);
    t.scale(myScale, myScale);
    t.translate(-LayoutDependencies.getX(myCell), -LayoutDependencies.getY(myCell));
    return t;
  }

  public Point2D convert(double x, double y) {
    Point2D srcPoint = new Point2D.Double(x, y);
    Point2D dstPoint = new Point2D.Double(x, y);
    try {
      buildTransformation().inverseTransform(srcPoint, dstPoint);
    } catch (NoninvertibleTransformException e) {
      throw new RuntimeException(e);
    }
    return dstPoint;
  }

  @Override
  protected void processMouseMotionEvent(MouseEvent event) {
    EditorComponent editorComponent = (EditorComponent) myCell.getEditorComponent();
    editorComponent.dispatchEvent(SwingUtilities.convertMouseEvent(this, event, editorComponent));
  }

  public EditorCell getEditorCell() {
    return myCell;
  }

  public mxCell getDCell() {
    return myDCell;
  }
}

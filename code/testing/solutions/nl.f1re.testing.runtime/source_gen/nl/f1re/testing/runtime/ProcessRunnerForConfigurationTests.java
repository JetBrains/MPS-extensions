package nl.f1re.testing.runtime;

/*Generated by MPS */

import com.intellij.execution.process.ProcessHandler;
import java.util.List;
import java.util.regex.Pattern;
import org.jetbrains.annotations.NotNull;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;
import jetbrains.mps.execution.api.commands.ProcessHandlerBuilder;
import com.intellij.execution.process.ProcessEvent;
import org.junit.Assert;
import java.util.Set;
import com.intellij.execution.process.ProcessAdapter;
import jetbrains.mps.util.Reference;
import java.util.HashSet;
import java.util.Collections;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.execution.process.ProcessOutputTypes;
import java.util.regex.Matcher;

/**
 * Copied from https://github.com/JetBrains/MPS/blob/master/testbench/testsolutions/execution-test/tests/test_gen/jetbrains/mps/execution/impl/configurations/util/ProcessRunnerForConfigurationTests.java
 */
public class ProcessRunnerForConfigurationTests {
  private final ProcessHandler myProcess;
  private final List<Pattern> myAllowedErrorPatterns;
  private final List<Pattern> myExpectedPatterns;
  private final List<Pattern> myExitPatterns;
  private final boolean myExitCodeMustBeZero;
  private final long myTimeOut;
  private ProcessRunnerForConfigurationTests(@NotNull ProcessHandler process, @NotNull List<Pattern> expectedPatterns, @NotNull List<Pattern> allowedErrorPatterns, @NotNull List<Pattern> exitPatterns, boolean exitCodeMustBeZero, long timeOut) {
    myProcess = process;
    myTimeOut = timeOut;
    myExitCodeMustBeZero = exitCodeMustBeZero;
    myAllowedErrorPatterns = Stream.concat(allowedErrorPatterns.stream(), expectedPatterns.stream()).distinct().collect(Collectors.<Pattern>toList());
    myExpectedPatterns = expectedPatterns.stream().distinct().collect(Collectors.<Pattern>toList());
    myExitPatterns = exitPatterns;
  }
  public static final class Builder {
    private final ProcessHandler myProcess;
    private final List<Pattern> myAllowedErrorPatterns = new ArrayList<Pattern>();
    private final List<Pattern> myExpectedPatterns = new ArrayList<Pattern>();
    private final List<Pattern> myExitPatterns = new ArrayList<Pattern>();
    private boolean myExitCodeMustBeZero = true;
    private long myTimeOut = TimeUnit.SECONDS.toMillis(150);
    public Builder(@NotNull ProcessHandler process) {
      myProcess = process;
    }
    public Builder setTimeOut(long millis) {
      myTimeOut = millis;
      return this;
    }
    public Builder addExpectedPaterns(@NotNull List<Pattern> expectedPatterns) {
      myExpectedPatterns.addAll(expectedPatterns);
      return this;
    }
    public Builder addAllowedErrorPaterns(@NotNull List<Pattern> allowedErrorPatterns) {
      myAllowedErrorPatterns.addAll(allowedErrorPatterns);
      return this;
    }
    public Builder addExitPaterns(@NotNull List<Pattern> exitPatterns) {
      myExitPatterns.addAll(exitPatterns);
      return this;
    }
    public Builder exitCodeMustBeZero(boolean value) {
      myExitCodeMustBeZero = value;
      return this;
    }
    @NotNull
    public ProcessRunnerForConfigurationTests build() {
      return new ProcessRunnerForConfigurationTests(myProcess, myExpectedPatterns, myAllowedErrorPatterns, myExitPatterns, myExitCodeMustBeZero, myTimeOut);
    }
  }
  public void startAndCheckProcess() {
    ProcessListenerWhichParsesOutput listenerParsingOutput = new ProcessListenerWhichParsesOutput();
    myProcess.addProcessListener(listenerParsingOutput);
    int exitCode = ProcessHandlerBuilder.startAndWait(myProcess, myTimeOut);
    ProcessEvent eventInCaseOfFailure = listenerParsingOutput.getFailedEvent();
    if (eventInCaseOfFailure != null) {
      Assert.fail("Failed with the process event " + eventInCaseOfFailure.getText());
    }
    Set<Pattern> printedPatterns = listenerParsingOutput.getPrintedPatterns();
    if (myExpectedPatterns.size() > printedPatterns.size()) {
      String failMsg = "The test has not printed all of the required messages: \n";
      for (Pattern expectedPattern : myExpectedPatterns) {
        if (!(printedPatterns.contains(expectedPattern))) {
          failMsg += "Expected message is not found : '" + expectedPattern;
        }
      }
      Assert.fail(failMsg);
    }
    if (myExitCodeMustBeZero && exitCode != 0) {
      Assert.fail("Exit with non-zero code " + exitCode);
    }
  }
  private final class ProcessListenerWhichParsesOutput extends ProcessAdapter {
    private final Reference<ProcessEvent> myFailedEvent = new Reference<ProcessEvent>();
    private final Set<Pattern> myPrintedExpectedPatterns = new HashSet<Pattern>();
    @NotNull
    public Set<Pattern> getPrintedPatterns() {
      return Collections.unmodifiableSet(myPrintedExpectedPatterns);
    }
    @Nullable
    public ProcessEvent getFailedEvent() {
      return myFailedEvent.get();
    }
    private final StringBuilder myCurText = new StringBuilder();
    private ProcessEvent myLastEvent = null;
    private Key myLastKey;
    @Override
    public synchronized void onTextAvailable(ProcessEvent event, Key key) {
      // assuming everything comes in lines
      String text = event.getText();
      if ((text == null || text.length() == 0)) {
        return;
      }
      myLastKey = key;
      myLastEvent = event;
      myCurText.append(text);
      if (text.contains("\n")) {
        flush();
      }
    }
    private void flush() {
      String text = myCurText.toString();
      int lastIndexOfBr = text.lastIndexOf("\n");
      assert lastIndexOfBr >= 0;
      text = text.substring(0, lastIndexOfBr + 1);
      myCurText.delete(0, text.length());
      String[] splitByLines = StringUtil.splitByLinesKeepSeparators(text);
      for (String line : splitByLines) {
        List<Pattern> patternsWeEncountered = getPatternsForWhichMsgExpected(line);
        myPrintedExpectedPatterns.addAll(patternsWeEncountered);
        if (ProcessOutputTypes.STDERR.equals(myLastKey)) {
          if (!(isErrMsgAllowed(line))) {
            myFailedEvent.set(myLastEvent);
          }
          System.err.print("TEST ERR OUTPUT::: " + line);
        } else {
          System.out.print("TEST OUTPUT::: " + line);
        }
        if (needToExit(line)) {
          myLastEvent.getProcessHandler().detachProcess();
        }
      }
    }

    private boolean needToExit(String text) {
      for (Pattern exitPattern : myExitPatterns) {
        if (exitPattern.matcher(text).matches()) {
          return true;
        }
      }
      return false;
    }
    private boolean isErrMsgAllowed(String text) {
      boolean allowed = false;
      for (Pattern allowedPattern : myAllowedErrorPatterns) {
        Matcher matcher = allowedPattern.matcher(text);
        if (matcher.matches()) {
          allowed = true;
          break;
        }
      }
      return allowed;
    }
    private List<Pattern> getPatternsForWhichMsgExpected(String text) {
      List<Pattern> met = new ArrayList<Pattern>();
      for (Pattern expectedPattern : myExpectedPatterns) {
        Matcher matcher = expectedPattern.matcher(text);
        if (matcher.matches()) {
          met.add(expectedPattern);
        }
      }
      return met;
    }
  }
}

package de.q60.mps.shadowmodels.runtime.model;

/*Generated by MPS */

import org.modelix.model.api.INode;
import org.modelix.model.api.INodeReference;
import org.modelix.model.api.IConcept;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.area.IArea;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConceptReference;
import java.util.Objects;
import org.modelix.model.api.ILanguageRepository;
import org.modelix.model.area.ContextArea;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class SM_SimpleNode implements INode, INodeReference {

  private IConcept concept;
  private SM___IContainment containment = SM___KnownContainment.NULL;
  private List<INode> children = ListSequence.fromList(new ArrayList<INode>());
  private Map<String, INode> references = MapSequence.fromMap(new HashMap<String, INode>());
  private Map<String, String> properties = MapSequence.fromMap(new HashMap<String, String>());

  public SM_SimpleNode(@NotNull IConcept concept) {
    this.concept = concept;
  }

  @NotNull
  @Override
  public IArea getArea() {
    return SM_SimpleArea.INSTANCE;
  }
  @Override
  public boolean isValid() {
    return true;
  }
  @Override
  public INodeReference getReference() {
    return this;
  }
  @Nullable
  @Override
  public INode resolveNode(IArea context) {
    return this;
  }
  @Override
  public IConcept getConcept() {
    return concept;
  }
  @Nullable
  @Override
  public IConceptReference getConceptReference() {
    return concept.getReference();
  }
  @Override
  public String getRoleInParent() {
    return containment.getRoleInParent();
  }
  @Override
  public INode getParent() {
    return containment.getParent();
  }
  @Override
  public Iterable<INode> getChildren(final String role) {
    return ListSequence.fromList(children).where((it) -> Objects.equals(it.getRoleInParent(), role));
  }
  @Override
  public Iterable<INode> getAllChildren() {
    return children;
  }
  @Override
  public void moveChild(final String role, int indexInRole, INode child) {
    if (!(child instanceof SM_SimpleNode)) {
      throw new RuntimeException("Not a " + SM_SimpleNode.class.getSimpleName() + ": " + child.getClass().getName());
    }
    if (child.getParent() != null) {
      throw new RuntimeException("Already has a parent: " + child);
    }

    if (indexInRole == -1) {
      ListSequence.fromList(children).addElement(child);
    } else {
      INode childAfter = ListSequence.fromList(children).where((it) -> Objects.equals(it.getRoleInParent(), role)).skip(indexInRole).first();
      if (childAfter == null) {
        ListSequence.fromList(children).addElement(child);
      } else {
        int indexInAll = ListSequence.fromList(children).indexOf(childAfter);
        ListSequence.fromList(children).insertElement(indexInAll, child);
      }
    }
    ((SM_SimpleNode) child).containment = SM___KnownContainment.create(this, role);
  }
  @Override
  public INode addNewChild(String role, int index, @Nullable IConcept concept) {
    SM_SimpleNode newChild = new SM_SimpleNode(concept);
    moveChild(role, index, newChild);
    return newChild;
  }
  @NotNull
  @Override
  public INode addNewChild(@Nullable String role, int index, @Nullable IConceptReference conceptRef) {
    return addNewChild(role, index, ILanguageRepository.Companion.resolveConcept(conceptRef));
  }
  @Override
  public void removeChild(INode child) {
    int index = ListSequence.fromList(children).indexOf(child);
    if (index == -1) {
      throw new RuntimeException(child + " is not a child of " + this);
    }
    ((SM_SimpleNode) child).containment = SM___KnownContainment.NULL;
    ListSequence.fromList(children).removeElementAt(index);
  }
  @Override
  public INode getReferenceTarget(String role) {
    return MapSequence.fromMap(references).get(role);
  }
  @Nullable
  @Override
  public INodeReference getReferenceTargetRef(@NotNull String role) {
    return getReferenceTarget(role).getReference();
  }
  @Override
  public void setReferenceTarget(String role, INode target) {
    MapSequence.fromMap(references).put(role, target);
  }
  @Override
  public void setReferenceTarget(@NotNull String role, @Nullable INodeReference target) {
    INode targetNode = (target == null ? null : target.resolveNode(ContextArea.INSTANCE.getArea()));
    setReferenceTarget(role, targetNode);
  }
  @Override
  public String getPropertyValue(String role) {
    return MapSequence.fromMap(properties).get(role);
  }
  @Override
  public void setPropertyValue(String role, String value) {
    MapSequence.fromMap(properties).put(role, value);
  }

  @NotNull
  @Override
  public List<String> getPropertyRoles() {
    return SetSequence.fromSet(MapSequence.fromMap(properties).keySet()).toList();
  }
  @NotNull
  @Override
  public List<String> getReferenceRoles() {
    return SetSequence.fromSet(MapSequence.fromMap(references).keySet()).toList();
  }
  @Override
  public String toString() {
    return "SimpleNode[" + concept + "]";
  }
}

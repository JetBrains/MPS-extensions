package de.q60.mps.shadowmodels.runtime.concurrentrepo;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.modelix.model.api.ITree;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PTree;
import de.q60.mps.shadowmodels.runtime.engine.TransformationEngine;
import de.q60.mps.incremental.runtime.IInvalidationListener;
import de.q60.mps.shadowmodels.runtime.smodel.SM_ClassChangeListener;
import java.util.Set;
import jetbrains.mps.module.ReloadableModule;
import org.jetbrains.mps.openapi.module.SRepository;
import de.q60.mps.util.invalidation.Invalidatable;
import de.q60.mps.shadowmodels.runtime.smodel.STransformationEngine;
import de.q60.mps.polymorphicfunctions.runtime.DefaultPFContext;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.q60.mps.polymorphicfunctions.runtime.IImplementationProvider;
import de.q60.mps.shadowmodels.runtime.smodel.SM_TransformationsFromGlobalRepository;
import kotlin.Unit;
import de.q60.mps.shadowmodels.runtime.engine.ITransformationEngine;
import de.q60.mps.incremental.runtime.IncrementalEngine;
import org.modelix.model.area.ContextArea;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeIdMissingException;
import de.q60.mps.incremental.runtime.DependencyKey;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_ITreeChangeVisitor;
import org.modelix.model.api.INodeReference;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeAdapter;
import de.q60.mps.shadowmodels.runtime.engine.ContainmentDependency;
import de.q60.mps.shadowmodels.runtime.engine.RoleDependency;
import de.q60.mps.shadowmodels.runtime.engine.AllChildrenDependency;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeDependency;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.classloading.ModuleClassLoader;

public abstract class SynchronizerThread extends Thread {
  private static final Logger LOG = Logger.getLogger(SynchronizerThread.class);
  private volatile boolean stopSyncThread = false;
  private long syncDelay = 100;
  private long lastClassChange = 0L;
  private volatile boolean dirty = true;
  private boolean disposed = false;
  private RepositoryMirror repositoryMirror;
  private ITree loadedInputTree = SM_PTree.EMPTY;
  private TransformationEngine engine;
  private IInvalidationListener invalidationListener = new IInvalidationListener() {
    @Override
    public void invalidated(Iterable<Object> keys) {
      dirty = true;
    }
    public void invalidatedAll() {
      dirty = true;
    }
  };
  private SM_ClassChangeListener classChangeListener = new SM_ClassChangeListener() {
    public void classesChanged(Set<ReloadableModule> modules) {
      lastClassChange = System.currentTimeMillis();
      engine.invalidateAll();
    }
  };
  private SRepository repository;
  private Invalidatable invalidatable = new Invalidatable("Analysis Thread", () -> dirty = true) {
    @Override
    public String getText() {
      return "Analysis Thread (" + getName() + ")";
    }
  };

  public SynchronizerThread(SRepository repository) {
    this.repository = repository;
    repositoryMirror = RepositoryMirror.getInstance(repository);
    engine = new STransformationEngine(new DefaultPFContext(Sequence.<IImplementationProvider>singleton(SM_TransformationsFromGlobalRepository.getInstance())), true);
    engine.getIncrementalEngine().setAsyncInvalidation(true);

    engine.addInvalidationListener(invalidationListener);
    classChangeListener.start();

    try {
      repositoryMirror.getBranch().runRead(() -> {
        repositoryMirror.getRepositoryNode().getAllChildren();
        return Unit.INSTANCE;
      });
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("", ex);
      }
    }

    this.start();
  }

  public RepositoryMirror getRepositoryMirror() {
    return repositoryMirror;
  }

  protected abstract void runAnalysis(RepositoryMirror input);

  public void scheduleUpdate() {
    dirty = true;
  }

  public ITransformationEngine getTransformationEngine() {
    return engine;
  }

  public void dispose() {
    disposed = true;
    stopSyncThread = true;
    try {
      this.join(3000);
    } catch (InterruptedException ex) {
    }
    classChangeListener.stop();
    engine.removeInvalidationListener(invalidationListener);
    engine.dispose();
    invalidatable.dispose();
  }

  @Override
  public void run() {
    try {
      while (true) {
        try {
          if (stopSyncThread) {
            return;
          }
          Thread.sleep(syncDelay);
          if (stopSyncThread) {
            return;
          }
          if (isClassLoaderDisposed()) {
            if (LOG.isErrorLevel()) {
              LOG.error("Class loader is disposed, but this thread is still running");
            }
            return;
          }
          IncrementalEngine.CONTEXT_ENGINE.runWith(engine.getIncrementalEngine(), () -> synchronize());
          syncDelay = 100;
        } catch (InterruptedException ex) {
          return;
        } catch (Throwable ex) {
          if (stopSyncThread) {
            return;
          }
          if (LOG.isErrorLevel()) {
            LOG.error("", ex);
          }
          syncDelay = Math.min(5000, syncDelay * 2);
        }
      }
    } finally {
      if (LOG.isDebugLevel()) {
        LOG.debug("Stopping sync thread");
      }
    }
  }

  protected void synchronize() {
    if (disposed) {
      return;
    }

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }

    repositoryMirror.flush();

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }

    repositoryMirror.getBranch().runRead(() -> {
      ITree newTree = repositoryMirror.getBranch().getTransaction().getTree();
      if (newTree != loadedInputTree) {
        inputChanged(newTree);
      }
      return Unit.INSTANCE;
    });

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }


    repositoryMirror.getBranch().runRead(() -> {
      ContextArea.INSTANCE.getCONTEXT_VALUE().computeWith(repositoryMirror.getArea(), () -> {
        engine.getIncrementalEngine().flushInvalidations();
        return Unit.INSTANCE;
      });
      return Unit.INSTANCE;
    });

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }

    if (dirty) {
      long transformStart = System.nanoTime();
      if (LOG.isDebugLevel()) {
        LOG.debug("Start analysis");
      }
      runReadOnTransformationOutput(() -> {
        try {
          runAnalysis(repositoryMirror);
        } catch (SM_PNodeIdMissingException ex) {
          engine.invalidateAll();
          throw ex;
        }
      });
      long transformEnd = System.nanoTime();
      if (LOG.isDebugLevel()) {
        LOG.debug("Analysis executed in " + 0.000001 * (transformEnd - transformStart) + " ms");
      }

      if (stopSyncThread) {
        return;
      }
      dirty = false;
    }

  }

  protected void inputChanged(ITree newTree) {
    if (loadedInputTree == newTree) {
      return;
    }

    final Set<DependencyKey> changes = SetSequence.fromSet(new HashSet<DependencyKey>());
    newTree.visitChanges(loadedInputTree, new SM_ITreeChangeVisitor() {
      public INodeReference toNodeRef(long nodeId) {
        return new SM_PNodeAdapter(nodeId, repositoryMirror.getBranch()).getReference();
      }
      @Override
      public void containmentChanged(long nodeId) {
        SetSequence.fromSet(changes).addElement(new ContainmentDependency(toNodeRef(nodeId)));
      }
      @Override
      public void childrenChanged(long nodeId, String role) {
        SetSequence.fromSet(changes).addElement(new RoleDependency(toNodeRef(nodeId), role));
        SetSequence.fromSet(changes).addElement(new AllChildrenDependency(toNodeRef(nodeId)));
      }
      @Override
      public void referenceChanged(long nodeId, String role) {
        SetSequence.fromSet(changes).addElement(new RoleDependency(toNodeRef(nodeId), role));
      }
      @Override
      public void propertyChanged(long nodeId, String role) {
        SetSequence.fromSet(changes).addElement(new RoleDependency(toNodeRef(nodeId), role));
      }
      @Override
      public void userObjectChanged(long nodeId, Object key) {
      }
      @Override
      public void nodeRemoved(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(repositoryMirror.getBranch(), nodeId));
      }
      @Override
      public void nodeAdded(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(repositoryMirror.getBranch(), nodeId));
      }
      @Override
      public void nodeLoaded(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(repositoryMirror.getBranch(), nodeId));
      }
      @Override
      public void nodeUnloaded(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(repositoryMirror.getBranch(), nodeId));
      }
    });
    engine.invalidate(changes);
    loadedInputTree = newTree;
  }

  public void runReadOnTransformationOutput(final _FunctionTypes._void_P0_E0 r) {
    if (!(repositoryMirror.getBranch().canRead())) {
      if (repository.getModelAccess().canRead()) {
        throw new RuntimeException("Running this from a repository read/write action can result in a deadlock");
        // ShadowTypesystemUtil starts read actions
      }
    }
    synchronized (engine.getIncrementalEngine()) {
      repositoryMirror.getBranch().runRead(() -> {
        ContextArea.INSTANCE.getCONTEXT_VALUE().computeWith(repositoryMirror.getArea(), () -> {
          r.invoke();
          return Unit.INSTANCE;
        });
        return Unit.INSTANCE;
      });
    }
  }

  protected boolean isClassLoaderDisposed() {
    ModuleClassLoader cl = (ModuleClassLoader) getClass().getClassLoader();
    return cl.isDisposed();
  }

}

package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import de.itemis.mps.editor.diagram.runtime.shape.IShape;
import de.itemis.mps.editor.diagram.runtime.shape.DefaultShape;
import com.mxgraph.shape.mxIShape;
import de.itemis.mps.editor.diagram.runtime.shape.EmptyShape;
import com.mxgraph.swing.util.mxGraphTransferable;
import com.mxgraph.swing.util.mxSwingConstants;
import com.intellij.ui.ColorUtil;
import com.intellij.ui.JBColor;
import com.mxgraph.util.mxConstants;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import com.mxgraph.util.mxEventObject;
import com.mxgraph.util.mxUndoableEdit;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mxgraph.model.mxGraphModel;
import java.util.List;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import com.mxgraph.util.mxEventSource;
import com.mxgraph.util.mxEvent;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.ide.ThreadUtils;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import de.itemis.mps.editor.diagram.runtime.model.Box;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModelListener;
import de.itemis.mps.editor.diagram.runtime.model.IPendingDiagramElement;
import de.itemis.mps.editor.diagram.runtime.model.IDiagramElement;
import com.mxgraph.model.mxCell;
import de.itemis.mps.editor.diagram.runtime.model.ScalableEditorCell;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.itemis.mps.editor.diagram.runtime.DiagramContext;
import de.itemis.mps.editor.diagram.runtime.model.IBoxCreator;
import de.itemis.mps.editor.diagram.runtime.model.PendingBox;
import de.itemis.mps.editor.diagram.runtime.model.Edge;
import de.itemis.mps.editor.diagram.runtime.model.IConnectionType_Internal;
import java.util.ArrayList;
import de.itemis.mps.editor.diagram.runtime.model.IAccessorFactory;
import de.itemis.mps.editor.diagram.runtime.model.AccessorFactory;
import com.mxgraph.model.mxGeometry;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Objects;
import com.mxgraph.util.mxStyleUtils;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import de.itemis.mps.editor.diagram.runtime.model.Port;
import de.itemis.mps.editor.diagram.runtime.model.EdgeLabelType;
import de.itemis.mps.editor.diagram.runtime.model.EdgeLabel;
import de.itemis.mps.editor.diagram.runtime.model.Point;
import org.jetbrains.annotations.Nullable;
import de.itemis.mps.editor.diagram.runtime.model.Annotation;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import de.itemis.mps.editor.diagram.runtime.EditorUtil;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import com.mxgraph.model.mxICell;
import de.itemis.mps.editor.diagram.runtime.model.IConnectionEndpoint_Internal;
import de.itemis.mps.editor.diagram.runtime.model.EndpointUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import de.itemis.mps.editor.diagram.runtime.shape.ShapeUtil;
import com.mxgraph.util.mxPoint;
import de.itemis.mps.editor.diagram.runtime.model.RelativePosition;

public class JGraphModelSynchronizer {
  private static final Logger LOG = Logger.getLogger(JGraphModelSynchronizer.class);
  private static final IShape DEFAULT_SHAPE = new DefaultShape();
  private static final mxIShape LABEL_SHAPE = new ShapeAdapter(new EmptyShape());
  private static final String PRIMARY_SYNCHRONIZER_KEY = JGraphModelSynchronizer.class.getName() + ".primarySynchronizer";

  static {
    mxGraphTransferable.enableImageSupport = false;
    mxSwingConstants.SHADOW_COLOR = ColorUtil.withAlpha(JBColor.BLACK, 0.117);
    mxConstants.SHADOW_OFFSETX = 4;
    mxConstants.SHADOW_OFFSETY = 4;
    mxConstants.MIN_HOTSPOT_SIZE = 15;
    mxConstants.DEFAULT_HOTSPOT = 0.8;
  }

  public static MyGraph getGraph(DiagramModel diagramModel) {
    return getSynchronizer(diagramModel).myGraph;
  }

  public static boolean onlyGeometryChanges(mxEventObject event) {
    for (mxUndoableEdit.mxUndoableChange change : ListSequence.fromList(((mxUndoableEdit) event.getProperty("edit")).getChanges())) {
      if (change.getClass() != mxGraphModel.mxGeometryChange.class) {
        return false;
      }
    }
    return true;
  }

  public static JGraphModelSynchronizer getSynchronizer(DiagramModel diagramModel) {
    diagramModel = diagramModel.getRootModel();
    JGraphModelSynchronizer synchronizer = as_k3jzmb_a0a1a11(diagramModel.getUserObject(PRIMARY_SYNCHRONIZER_KEY), JGraphModelSynchronizer.class);
    if (synchronizer == null) {
      Model2GraphElementMapper elementMapper = new Model2GraphElementMapper();

      MyGraph graph = DiagramCreationContext.getRootGraph();
      if (graph == null) {
        graph = new MyGraph(elementMapper, diagramModel);
      }
      synchronizer = new JGraphModelSynchronizer(graph, diagramModel, elementMapper);
      diagramModel.putUserObject(PRIMARY_SYNCHRONIZER_KEY, synchronizer);
      final JGraphModelSynchronizer finalSynchronizer = synchronizer;
      if (!(DiagramCreationContext.isSubdiagram())) {

        List<Object> existingListeners = ((List<Object>) ReflectionUtil.readField(mxEventSource.class, graph.getModel(), "eventListeners"));
        boolean alreadyListening = ListSequence.fromList(existingListeners).findFirst((it) -> it.getClass().getName().startsWith(JGraphModelSynchronizer.class.getName())) != null;
        if (alreadyListening) {
          throw new RuntimeException("There is already a synchronizer listening for model changes");
        }

        graph.getModel().addListener(mxEvent.END_UPDATE, new mxEventSource.mxIEventListener() {
          public void invoke(Object sender, final mxEventObject event) {
            if (finalSynchronizer.myGraph.isSyncSuspended()) {
              return;
            }
            try {
              if (finalSynchronizer.myCurrentDirection == SyncDirection.GRAPH2MODEL && ((mxGraphModel) sender).getUpdateLevel() == 0) {
                ModelAccess modelAccess = finalSynchronizer.myRootModel.getEditorContext().getRepository().getModelAccess();
                final _FunctionTypes._void_P0_E0 synchronizeCode = () -> {
                  finalSynchronizer.graph2Model();
                  BaseDiagramECell.withContextGraph(finalSynchronizer.myGraph, () -> {
                    RootDiagramECell rootECell = finalSynchronizer.myGraph.getGraphComponent().getDiagramCell();
                    finalSynchronizer.myRootModel.synchronizeWrite(rootECell);

                    if (finalSynchronizer.myRootModel.getDiagramAccessor().runAutoLayoutOnChange() && !(finalSynchronizer.myGraph.getView().wasAutoLayout()) && !(onlyGeometryChanges(event))) {
                      BaseDiagramDCell dcell = rootECell.getDCell(finalSynchronizer.myGraph);
                      dcell.runLayouter();
                    }
                    finalSynchronizer.myGraph.getView().setWasAutoLayout(false);

                  });
                };
                if (!(ThreadUtils.isInEDT())) {
                  modelAccess.executeCommandInEDT(() -> synchronizeCode.invoke());
                } else {
                  modelAccess.executeCommand(() -> synchronizeCode.invoke());
                }
              } else if (finalSynchronizer.myCurrentDirection == SyncDirection.MODEL2GRAPH && ((mxGraphModel) sender).getUpdateLevel() == 0) {
                RootDiagramECell rootECell = finalSynchronizer.myGraph.getGraphComponent().getDiagramCell();

                if (finalSynchronizer.myRootModel.getDiagramAccessor().runAutoLayoutOnChange() && !(finalSynchronizer.myGraph.getView().wasAutoLayout()) && !(onlyGeometryChanges(event))) {
                  BaseDiagramDCell dcell = rootECell.getDCell(finalSynchronizer.myGraph);
                  dcell.runLayouter();
                }
                finalSynchronizer.myGraph.getView().setWasAutoLayout(false);
              }
            } catch (Exception ex) {
              if (LOG.isErrorLevel()) {
                LOG.error("Synchronisation to the MPS model failed", ex);
              }
            }
          }
        });
      }
    }
    return synchronizer;
  }



  private MyGraph myGraph;
  private DiagramModel myRootModel;
  private SyncDirection myCurrentDirection = SyncDirection.GRAPH2MODEL;
  private Model2GraphElementMapper myElementMapper;
  private Map<Tuples._2<Box, String>, SubDiagramDCell> mySubdiagramCells = MapSequence.fromMap(new HashMap<Tuples._2<Box, String>, SubDiagramDCell>());
  private boolean isSynchronizing = false;

  private DiagramModelListener myModelListener = new DiagramModelListener() {
    @Override
    public void pendingElementReplaced(IPendingDiagramElement pending, IDiagramElement replacedBy) {
      elementReplaced(pending, replacedBy);
    }
    public void diagramElementReplaced(IDiagramElement previous, IDiagramElement replacedBy) {
      elementReplaced(previous, replacedBy);
    }
  };

  public JGraphModelSynchronizer(MyGraph graph, DiagramModel rootModel, Model2GraphElementMapper elementMapper) {
    myGraph = graph;
    myRootModel = rootModel;
    myElementMapper = elementMapper;

    rootModel.addListener(myModelListener);
  }

  public void suspend(Runnable r) {
    boolean wasSuspended = myGraph.isSyncSuspended();
    try {
      myGraph.setSyncSuspended(true);
      r.run();
    } finally {
      myGraph.setSyncSuspended(wasSuspended);
    }
  }

  public Model2GraphElementMapper getElementMapper() {
    return myElementMapper;
  }

  public MyGraph getGraph() {
    return myGraph;
  }

  public boolean isSynchronizing() {
    return isSynchronizing;
  }

  public void elementReplaced(IDiagramElement previous, IDiagramElement replacedBy) {
    String id = myElementMapper.getCellId(previous);
    if (id != null) {
      myElementMapper.remove(previous);
      myElementMapper.assign(id, replacedBy);
    }
  }

  public void graph2Model() {
    graph2Model((mxCell) myGraph.getDefaultParent());
  }

  public void graph2Model(final mxCell rootCell) {
    if (isSynchronizing) {
      return;
    }
    myGraph.getGraphComponent().getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
      if (isSynchronizing) {
        return;
      }
      boolean wasSynchronizing = isSynchronizing;
      try {
        isSynchronizing = true;
        ScalableEditorCell.withScalingDisabled(() -> {
          SyncContext syncContext = new SyncContext(myGraph);
          graph2Model(rootCell, myRootModel, syncContext);

          // delete elements that are removed from the graph
          for (DiagramModel dmodel : ListSequence.fromList(syncContext.getModels())) {
            for (IDiagramElement e : Sequence.fromIterable(dmodel.getElements())) {
              if (!(syncContext.shouldKeepElement(e))) {
                if (DiagramModel.ALLOW_DELETE_DURING_SYNC) {
                  e.getModel().removeElement(e);
                }
              }
            }
          }

        });
      } finally {
        isSynchronizing = wasSynchronizing;
      }
    });
  }

  public void graph2Model(final mxCell rootCell, final DiagramModel dmodel, final SyncContext syncContext) {
    DiagramContext.withContext(((BaseDiagramDCell) rootCell), () -> DiagramCreationContext.createDiagram(() -> {
      if (!(DiagramCreationContext.isSubdiagram())) {
        DiagramCreationContext.setRootGraph(myGraph);
      }
      syncContext.executeWithModel(dmodel, () -> graph2Model_(rootCell, dmodel, syncContext));
    }));
  }

  private void graph2Model_(final mxCell rootCell, final DiagramModel dmodel, SyncContext syncContext) {
    List<Object> cells = Sequence.fromIterable(Sequence.fromArray(myGraph.getChildCells(rootCell))).toList();
    // sync edges last
    cells = ListSequence.fromList(cells).sort((it) -> (it instanceof EdgeDCell ? 1 : 0), true).toList();

    for (Object cell_ : cells) {
      final mxCell cell = (mxCell) cell_;
      ensureHasId(cell);
      IDiagramElement diagramElement = myElementMapper.getDiagramElement(cell.getId());

      if (diagramElement != null) {
        syncContext.keepElement(diagramElement);
      }

      if (cell instanceof BoxDCell || cell instanceof ISelfCreatingCell) {
        Box box = (Box) diagramElement;
        if (box == null) {
          IBoxCreator snodeCreator = null;
          if (cell instanceof ISelfCreatingCell) {
            snodeCreator = new IBoxCreator() {
              public void createNode(PendingBox pendingNode) {
                ((ISelfCreatingCell) cell).createModelNode(dmodel);
              }
            };
          }
          if (snodeCreator == null) {
            myGraph.removeCells(new Object[]{cell}, true);
            continue;
          }
          box = dmodel.createNode(snodeCreator, check_k3jzmb_b0a0d0b0g0e0pb(check_k3jzmb_a1a0a3a1a6a4a14(as_k3jzmb_a0a1a0a3a1a6a4a24(cell, ISelfCreatingCell.class))));
          myElementMapper.assign(cell, box);
          syncContext.keepElement(box);
        }
        writeSyncBox(cell, box, syncContext);
      }
      if (cell instanceof EdgeDCell) {
        Edge edge = (Edge) diagramElement;
        if (edge == null) {
          Box sourceNode;
          String sourcePort;
          Box targetNode;
          String targetPort;
          {
            Tuples._2<Box, String> _tmp_k3jzmb_e0b0h0e0pb = getEdgeSourceTarget(cell, false, rootCell);
            sourceNode = _tmp_k3jzmb_e0b0h0e0pb._0();
            sourcePort = _tmp_k3jzmb_e0b0h0e0pb._1();
          }
          {
            Tuples._2<Box, String> _tmp_k3jzmb_f0b0h0e0pb = getEdgeSourceTarget(cell, true, rootCell);
            targetNode = _tmp_k3jzmb_f0b0h0e0pb._0();
            targetPort = _tmp_k3jzmb_f0b0h0e0pb._1();
          }
          IConnectionType_Internal connectionType = getGraph().getConnectionTypeChooser().getApplicable(sourceNode, sourcePort, targetNode, targetPort, new ArrayList<String>());
          if (connectionType != null) {
            edge = dmodel.createEdge(connectionType, sourceNode, sourcePort, targetNode, targetPort);
            myElementMapper.assign(cell, edge);
            writeSyncEdge((EdgeDCell) cell, edge, rootCell, syncContext);
          }
          syncContext.keepElement(edge);
        } else {
          writeSyncEdge((EdgeDCell) cell, edge, rootCell, syncContext);
        }
      }

      writeSyncAnnotations(diagramElement, cell, syncContext);
    }

  }

  public IAccessorFactory getAccessorFactory(DiagramModel dmodel) {
    return new AccessorFactory(myGraph.getGraphComponent().getEditorComponent(), dmodel);
  }


  public void model2Graph() {
    RootDCell rootDCell = (RootDCell) myGraph.getDefaultParent();
    model2Graph(rootDCell);
    myGraph.getGraphComponent().getCellEditor().updateCell();
  }

  public void model2Graph(BaseDiagramDCell rootCell) {
    if (isSynchronizing) {
      return;
    }
    boolean wasSynchronizing = isSynchronizing;
    SyncDirection wasDirection = myCurrentDirection;
    try {
      isSynchronizing = true;
      myCurrentDirection = SyncDirection.MODEL2GRAPH;

      myGraph.getModel().beginUpdate();
      try {

        model2Graph(rootCell, myRootModel, new SyncContext(myGraph));
        adjustRootCellSize(rootCell);

        myGraph.getView().updateCellStyles();
      } finally {
        myGraph.getModel().endUpdate();
      }
    } finally {
      myCurrentDirection = wasDirection;
      isSynchronizing = wasSynchronizing;
    }
    myGraph.getView().revalidate();
  }

  public void adjustRootCellSize(mxCell rootCell) {
    double maxRight = 0;
    double maxBottom = 0;
    for (mxCell child : Sequence.fromIterable(Sequence.fromArray(myGraph.getChildCells(rootCell))).ofType(mxCell.class)) {
      maxRight = Math.max(maxRight, child.getGeometry().getX() + child.getGeometry().getWidth());
      maxBottom = Math.max(maxBottom, child.getGeometry().getY() + child.getGeometry().getHeight());
    }
    double x = rootCell.getGeometry().getX();
    double y = rootCell.getGeometry().getY();
    rootCell.setGeometry(new mxGeometry(x, y, maxRight - x, maxBottom - y));
  }

  public void model2Graph(final BaseDiagramDCell rootCell, final DiagramModel dmodel, final SyncContext syncContext) {
    myGraph.getModel().beginUpdate();
    try {
      ScalableEditorCell.withScalingDisabled(() -> syncContext.executeWithModel(dmodel, () -> {
        model2Graph_(rootCell, syncContext);

        // delete cells that are not in the model anymore
        List<Object> cellsToDelete = ListSequence.fromList(new ArrayList<Object>());
        for (Object o : ((mxGraphModel) myGraph.getModel()).getCells().values()) {
          mxCell cell = (mxCell) o;
          if (cell instanceof IDiagramDCell && !(syncContext.shouldKeepCell(cell)) && getParentSubdiagramCell(cell) == rootCell || cell instanceof PaletteEntryMxCell) {
            ListSequence.fromList(cellsToDelete).addElement(cell);
          }
        }
        if (ListSequence.fromList(cellsToDelete).isNotEmpty()) {
          ListSequence.fromList(cellsToDelete).visitAll((cell) -> {
            myElementMapper.remove((mxCell) cell);
            for (final SubDiagramDCell sub : ListSequence.fromList(JGraphUtil.getDescendantsAndMe(((mxCell) cell), SubDiagramDCell.class))) {
              IMapping<Tuples._2<Box, String>, SubDiagramDCell> m = MapSequence.fromMap(mySubdiagramCells).findFirst((entry) -> entry.value() == sub);
              if (m != null) {
                MapSequence.fromMap(mySubdiagramCells).removeKey(m.key());
              }
            }
          });
          myGraph.removeCells(ListSequence.fromList(cellsToDelete).toGenericArray(Object.class), false);
        }

        new LayoutProcessor(myGraph, dmodel.getParentModel() != null).process();
      }));
    } finally {
      myGraph.getModel().endUpdate();
    }
  }

  public mxCell getParentSubdiagramCell(mxCell cell) {
    mxCell parent = (mxCell) cell.getParent();
    if (parent == null) {
      return null;
    }
    if (parent instanceof SubDiagramDCell) {
      return parent;
    }
    if (parent == myGraph.getDefaultParent()) {
      return parent;
    }
    return getParentSubdiagramCell(parent);
  }

  protected void model2Graph_(final mxCell rootCell, final SyncContext syncContext) {
    for (DiagramModel submodel : ListSequence.fromList(syncContext.getCurrentModel().getChildModels())) {
      submodel.removeListener(myModelListener);
    }
    syncContext.getCurrentModel().clearChildModels();

    List<mxCell> allCells = ListSequence.fromList(new ArrayList<mxCell>());
    for (Object c : myGraph.getChildCells(rootCell)) {
      if (c instanceof PortDCell) {
        continue;
      }
      mxCell cell = (mxCell) c;
      ensureHasId(cell);
      syncContext.registerCell(cell);
      ListSequence.fromList(allCells).addElement(cell);
    }

    for (final IDiagramElement delement : Sequence.fromIterable(syncContext.getCurrentModel().getBoxes()).ofType(IDiagramElement.class).concat(Sequence.fromIterable(syncContext.getCurrentModel().getEdges())).concat(ListSequence.fromList(syncContext.getAndRemoveUnresolvedEdges()).ofType(IDiagramElement.class))) {
      if (delement instanceof IPendingDiagramElement) {
        continue;
      }
      final Wrappers._T<mxCell> cell = new Wrappers._T<mxCell>(null);
      _FunctionTypes._return_P1_E0<? extends mxCell, ? super IDiagramElement> getOrCreateCell = (IDiagramElement diagramElement) -> {
        cell.value = syncContext.getCell(myElementMapper.getCellId(delement));
        if (delement instanceof Edge && !(cell.value instanceof EdgeDCell) || delement instanceof Box && !(cell.value instanceof BoxDCell)) {
          cell.value = null;
        }
        if (cell.value == null) {
          cell.value = (delement instanceof Box ? createNewBoxCell((Box) delement, syncContext) : createNewEdgeCell((Edge) delement));
          myElementMapper.assign(cell.value, delement);
          myGraph.addCell(cell.value, rootCell);
        } else {
          if (!(Objects.equals(cell.value.getParent(), rootCell))) {
            myGraph.addCell(cell.value, rootCell);
          }
        }
        syncContext.registerCell(cell.value);
        syncContext.keepCell(cell.value);
        return cell.value;
      };
      if (delement instanceof Edge) {
        cell.value = readSyncEdge(getOrCreateCell, (Edge) delement, rootCell, syncContext);
        if (cell.value != null) {
          model2graphLabels(rootCell, (Edge) delement, (EdgeDCell) cell.value, syncContext);
        }
      }
      if (delement instanceof Box) {
        Box box = ((Box) delement);
        readSyncBox(getOrCreateCell, box, syncContext);
        assignShape(box.getShape(), cell.value, syncContext);
      }

      readSyncAnnotations(delement, cell.value, syncContext);

      if (cell.value != null) {
        cell.value.setStyle(mxStyleUtils.setStyle(cell.value.getStyle(), mxConstants.STYLE_SHADOW, "true"));
      }
    }
  }

  public void model2graphPorts(mxCell parentCell, Box box, final SyncContext syncContext) {
    List<mxCell> portCells = getPortCells(parentCell);
    final Set<mxCell> portCellsToRemove = SetSequence.fromSetWithValues(new HashSet<mxCell>(), portCells);


    forEachPort(box, new _FunctionTypes._void_P3_E0<Port, mxCell, mxCell>() {
      public void invoke(Port port, mxCell portCell, mxCell parentCell) {
        if (portCell != null) {
          SetSequence.fromSet(portCellsToRemove).removeElement(portCell);
        }
        if (portCell == null) {
          portCell = createNewPortCell(port);
          myGraph.addCell(portCell, parentCell);
          myGraph.getModel().setValue(portCell, port.getName());
        }
        ((PortDCell) portCell).setPort(port);
        syncContext.keepCell(portCell);
        myElementMapper.assign(portCell, port);
        assignShape(port.getTransformedShape(), portCell, syncContext);

        String style = portCell.getStyle();
        portCell.setStyle(style);

        syncPortBoundsToGraph(port, portCell, parentCell);
      }
    });

    for (mxCell p : SetSequence.fromSet(portCellsToRemove)) {
      myGraph.getModel().remove(p);
    }

    PortLayouter.layoutPortCells(((BoxDCell) parentCell), false);
  }

  public void model2graphLabels(mxCell parentCell, Edge edge, EdgeDCell edgeCell, SyncContext syncContext) {
    for (EdgeLabelType type : EdgeLabelType.values()) {
      EdgeLabel label = edge.getLabel(type);
      LabelDCell labelJGraphCell = edgeCell.getLabelCell(type);
      if (label.getCell() == null) {
        if (labelJGraphCell != null) {
          myGraph.removeCells(new Object[]{labelJGraphCell});
        }
      } else {
        if (labelJGraphCell == null) {
          labelJGraphCell = createNewLabelCell(label);
          edgeCell.setLabelCell(type, labelJGraphCell);
          myGraph.addCell(labelJGraphCell, edgeCell.getParent());
        }

        labelJGraphCell.setLabel(label);
        Point position = check_k3jzmb_a0d0a2a0a06(label.getPosition());
        labelJGraphCell.adjustAndSetBounds(check_k3jzmb_a0a4a0c0a0ic(position), check_k3jzmb_b0a4a0c0a0ic(position), 0, 0);
        syncContext.keepCell(labelJGraphCell);
      }
    }
  }

  public void syncPortBoundsToGraph(Port port, mxCell portCell, mxCell parentCell) {
    CellExtensions.setSize(portCell, port.getWidth(), port.getHeight());
  }

  public void syncPortBoundsToGraph(DiagramModel dmodel) {
    for (Box node : Sequence.fromIterable(dmodel.getBoxes())) {
      mxGraphModel model = (mxGraphModel) myGraph.getModel();
      forEachPort(node, (Port port, mxCell portCell, mxCell parentCell) -> {
        if (portCell == null) {
          return;
        }
        syncPortBoundsToGraph(port, portCell, parentCell);
      });
    }
  }

  public void forEachPort(Box node, _FunctionTypes._void_P3_E0<? super Port, ? super mxCell, ? super mxCell> doIt) {
    mxGraphModel model = (mxGraphModel) myGraph.getModel();
    mxCell nodeCell = (mxCell) model.getCell(myElementMapper.getCellId(node));

    List<Port> ports = node.getPorts();
    List<mxCell> portCells = getPortCells(nodeCell);

    Map<String, mxCell> value2cell = MapSequence.fromMap(new HashMap<String, mxCell>());
    for (mxCell c : ListSequence.fromList(portCells)) {
      MapSequence.fromMap(value2cell).put(objectToString(c.getValue()), c);
    }

    for (Port port : ListSequence.fromList(ports)) {
      mxCell portCell = MapSequence.fromMap(value2cell).get(port.getName());
      doIt.invoke(port, portCell, nodeCell);
    }

  }

  public void assignShape(@Nullable IShape shape, mxCell cell, SyncContext syncContext) {
    if (shape == null) {
      shape = syncContext.getCurrentModel().getDefaultBoxShape();
    }
    if (shape == null) {
      shape = DEFAULT_SHAPE;
    }
    cell.setShape(new ShapeAdapter(shape));
  }

  public List<mxCell> getPortCells(mxCell parentCell) {
    List<mxCell> portCells = new ArrayList<mxCell>();
    for (Object c : myGraph.getChildCells(parentCell)) {
      if (c instanceof PortDCell) {
        portCells.add(((mxCell) c));
      }
    }
    return portCells;
  }

  public void ensureHasId(mxCell cell) {
    if (cell.getId() == null) {
      cell.setId(createNewId(cell));
    }
  }

  private String createNewId(mxCell cell) {
    return ((mxGraphModel) myGraph.getModel()).createId(cell);
  }

  public mxCell getDiagramCell(IDiagramElement diagramElement) {
    return ((mxCell) ((mxGraphModel) myGraph.getModel()).getCell(myElementMapper.getCellId(diagramElement)));
  }

  public BoxDCell createNewBoxCell(Box box, SyncContext syncContext) {
    BoxDCell cell = new BoxDCell(myGraph);
    cell.setBox(box);
    cell.setId(createNewId(cell));
    return cell;
  }
  public AnnotationDCell createNewAnnotationCell(mxCell parent, Annotation annotation, SyncContext syncContext) {
    AnnotationDCell annotationDCell = new AnnotationDCell(myGraph);
    annotationDCell.setAnnotation(annotation);
    annotationDCell.setId(createNewId(annotationDCell));
    assignShape(AnnotationDCell.ANNOTATION_SHAPE, annotationDCell, syncContext);
    myGraph.addCell(annotationDCell, parent);
    syncContext.keepCell(annotationDCell);
    myElementMapper.assign(annotationDCell, annotation);
    return annotationDCell;
  }
  public LabelDCell createNewLabelCell(EdgeLabel label) {
    LabelDCell cell = new LabelDCell(myGraph);
    mxGeometry geometry = new mxGeometry(0, 0, 50, 20);
    cell.setGeometry(geometry);
    cell.setVertex(true);
    cell.setConnectable(false);
    cell.setId(createNewId(cell));
    cell.setShape(LABEL_SHAPE);
    return cell;
  }
  public mxCell createNewEdgeCell(Edge edge) {
    mxCell cell = new EdgeDCell(myGraph);
    mxGeometry geometry = new mxGeometry();
    geometry.setRelative(true);
    cell.setGeometry(geometry);
    cell.setEdge(true);
    cell.setId(createNewId(cell));
    cell.setStyle("edgeStyle=elbowEdgeStyle;elbow=horizontal;orthogonal=0");
    return cell;
  }
  public mxCell createNewPortCell(Port port) {
    mxCell portCell = new PortDCell(port, port.getWidth(), port.getHeight(), myGraph);
    portCell.setId(createNewId(portCell));
    return portCell;
  }
  public void readSyncBox(_FunctionTypes._return_P1_E0<? extends mxCell, ? super IDiagramElement> getOrCreateCell, Box box, SyncContext syncContext) {
    BoxDCell dcell = (BoxDCell) getOrCreateCell.invoke(box);
    dcell.setBox(box);
    dcell.adjustAndSetBounds(box.getBounds());

    EditorCell editorCell = box.getRootCell();

    model2graphPorts(dcell, box, syncContext);

    for (SubDiagramECell subdiagram : ListSequence.fromList(EditorUtil.firstLevelDescendants(editorCell, SubDiagramECell.class))) {
      DiagramModel subModel = subdiagram.getDiagramModel();
      syncContext.getCurrentModel().addChildModel(subModel, subdiagram);
      subModel.addListener(myModelListener);

      Tuples._2<Box, String> key = MultiTuple.<Box,String>from(box, subdiagram.getCellId());
      SubDiagramDCell subdcell = MapSequence.fromMap(mySubdiagramCells).get(key);
      if (subdcell == null) {
        subdcell = new SubDiagramDCell(myGraph);
        subdcell.setECell(subdiagram);
        myGraph.addCell(subdcell, dcell);
        MapSequence.fromMap(mySubdiagramCells).put(key, subdcell);
      }
      subdcell.setECell(subdiagram);
      syncContext.keepCell(subdcell);
      subdiagram.setDCell(subdcell, myGraph);
      model2Graph(subdcell, subModel, syncContext);
      subdiagram.requestRelayout();
    }

    PortLayouter.layoutPortCells(dcell, false);
  }

  public void readSyncAnnotations(IDiagramElement parentElement, mxCell parentDCell, SyncContext syncContext) {
    List<Annotation> annotations = syncContext.getCurrentModel().getAnnotations(parentElement);
    List<AnnotationDCell> existingDCells = ListSequence.fromList(JGraphUtil.getChildCells(parentDCell)).ofType(AnnotationDCell.class).toList();
    for (final Annotation annotation : ListSequence.fromList(annotations)) {
      AnnotationDCell dCell = ListSequence.fromList(existingDCells).findFirst((it) -> it.getAnnotation() == annotation);
      if (dCell == null) {
        dCell = createNewAnnotationCell(parentDCell, annotation, syncContext);
        ListSequence.fromList(existingDCells).addElement(dCell);
      }
      syncContext.keepCell(dCell);
      readSyncAnnotation(annotation, dCell, syncContext);
    }
    for (AnnotationDCell annotationDCell : ListSequence.fromList(existingDCells)) {
      if (!(ListSequence.fromList(annotations).contains(annotationDCell.getAnnotation()))) {
        myGraph.removeCells(new Object[]{annotationDCell});
      }
    }
  }

  public void writeSyncAnnotations(IDiagramElement parentElement, mxCell parentDCell, SyncContext syncContext) {
    List<AnnotationDCell> dcells = ListSequence.fromList(JGraphUtil.getChildCells(parentDCell)).ofType(AnnotationDCell.class).toList();
    for (AnnotationDCell dcell : ListSequence.fromList(dcells)) {
      Annotation annotation = dcell.getAnnotation();
      syncContext.keepElement(annotation);
      mxGeometry geometry = dcell.getGeometry();
      annotation.setBounds(ExtensionMethods.toBounds(dcell.getGeometry()));
    }
  }

  public void readSyncAnnotation(Annotation annotation, AnnotationDCell dcell, SyncContext syncContext) {
    Bounds bounds = annotation.getBounds();
    mxGeometry geometry = new mxGeometry(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
    if (bounds.getXInt() == 0 && bounds.getYInt() == 0 && dcell.getParent() instanceof EdgeDCell) {
      EdgeDCell parent = (EdgeDCell) dcell.getParent();
      mxICell source = parent.getSource();
      mxICell target = parent.getTarget();
      if (source instanceof PortDCell) {
        source = source.getParent();
      }
      if (target instanceof PortDCell) {
        target = target.getParent();
      }
      Bounds sourceBounds = CellExtensions.getBounds(source);
      Bounds targetBounds = CellExtensions.getBounds(target);
      geometry.setX((sourceBounds.getCenterX() + targetBounds.getCenterX()) / 2);
      geometry.setY((sourceBounds.getCenterY() + targetBounds.getCenterY()) / 2);
    }
    myGraph.getModel().setGeometry(dcell, geometry);

    assignShape(AnnotationDCell.ANNOTATION_SHAPE, dcell, syncContext);
    dcell.setAnnotation(annotation);
  }

  public void writeSyncBox(mxCell cell, Box box, SyncContext syncContext) {
    String cellLabel = objectToString(cell.getValue());
    mxGeometry geometry = cell.getGeometry();
    box.setBounds(new Bounds(geometry.getX(), geometry.getY(), geometry.getWidth(), geometry.getHeight()));

    if (cell instanceof BoxDCell) {
      DiagramModel oldOwnerDiagram = check_k3jzmb_a0a0e0nd(check_k3jzmb_a0a0a4a19(as_k3jzmb_a0a0a0a4a29(cell, IDiagramDCell.class)));
      DiagramModel newOwnerDiagram = check_k3jzmb_a0b0e0nd(as_k3jzmb_a0a0b0e0od(cell.getParent(), BaseDiagramDCell.class));
      if (newOwnerDiagram != null && newOwnerDiagram != oldOwnerDiagram) {
        ((BoxDCell) cell).getBox().setNewOwnerDiagram(newOwnerDiagram);
      }
    }

    if (box.hasRootCell()) {
      for (SubDiagramECell subdiagram : ListSequence.fromList(EditorUtil.firstLevelDescendants(box.getRootCell(), SubDiagramECell.class))) {
        this.graph2Model(subdiagram.getDCell(myGraph), subdiagram.getModel(), syncContext);
      }
    }
  }

  public String resolveCellId(IDiagramElement diagramElement, SyncContext syncContext) {
    return myElementMapper.getCellId(diagramElement);
  }

  public EdgeDCell readSyncEdge(_FunctionTypes._return_P1_E0<? extends mxCell, ? super IDiagramElement> getOrCreateCell, Edge edge, mxCell rootCell, SyncContext syncContext) {
    IConnectionEndpoint_Internal endpointFrom = edge.getResolvedEndpointFrom();
    IConnectionEndpoint_Internal endpointTo = edge.getResolvedEndpointTo();
    if (endpointFrom == null || endpointTo == null) {
      syncContext.addUnresolvedEdge(edge);
      return null;
    }

    EdgeDCell cell = (EdgeDCell) getOrCreateCell.invoke(edge);
    cell.setVisible(edge.isVisible());
    cell.setEdge(edge);

    mxCell newSource = syncContext.getCell(resolveCellId(EndpointUtil.getBox(endpointFrom), syncContext));
    mxCell newTarget = syncContext.getCell(resolveCellId(EndpointUtil.getBox(endpointTo), syncContext));

    Port portFrom = EndpointUtil.getPort(endpointFrom);
    Port portTo = EndpointUtil.getPort(endpointTo);
    final String portFromName = EndpointUtil.getPortName(endpointFrom);
    final String portToName = EndpointUtil.getPortName(endpointTo);

    if (portFromName != null) {
      newSource = ListSequence.fromList(getPortCells(newSource)).findFirst((it) -> Objects.equals(it.getValue(), portFromName));
    }
    if (portToName != null) {
      newTarget = ListSequence.fromList(getPortCells(newTarget)).findFirst((it) -> Objects.equals(it.getValue(), portToName));
    }

    if (newSource != cell.getSource() || newTarget != cell.getTarget()) {
      myGraph.addEdge(cell, rootCell, newSource, newTarget, null);
    }

    String style = cell.getStyle();

    String edgeStyle = edge.getEdgeStyle();
    if (!(Objects.equals(edgeStyle, SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x5ce2f8f48ddb8d45L, "de.itemis.mps.editor.diagram.structure.EdgeStyle"), 0x5ce2f8f48e4741fcL, "none").getName()))) {
      style = mxStyleUtils.setStyle(style, mxConstants.STYLE_EDGE, edgeStyle);
    }
    if (portFrom != null) {
      final DiagramModel oppositeModel = EndpointUtil.getBox(endpointTo).getModel();
      boolean isAttachedFromInside = ListSequence.fromList(EndpointUtil.getBox(endpointFrom).getSubdiagramModels()).any((it) -> it == oppositeModel || isAncestor(it, oppositeModel));
      Point exit = calcEntryExitPoint(portFrom.getTransformedRelativePosition(), isAttachedFromInside);
      style = mxStyleUtils.setStyle(style, mxConstants.STYLE_EXIT_X, "" + exit.getX());
      style = mxStyleUtils.setStyle(style, mxConstants.STYLE_EXIT_Y, "" + exit.getY());
    }
    if (portTo != null) {
      final DiagramModel oppositeModel = EndpointUtil.getBox(endpointFrom).getModel();
      boolean isAttachedFromInside = ListSequence.fromList(EndpointUtil.getBox(endpointTo).getSubdiagramModels()).any((it) -> it == oppositeModel || isAncestor(it, oppositeModel));
      Point entry = calcEntryExitPoint(portTo.getTransformedRelativePosition(), isAttachedFromInside);
      style = mxStyleUtils.setStyle(style, mxConstants.STYLE_ENTRY_X, "" + entry.getX());
      style = mxStyleUtils.setStyle(style, mxConstants.STYLE_ENTRY_Y, "" + entry.getY());
    }
    style = mxStyleUtils.setStyle(style, mxConstants.STYLE_EXIT_PERIMETER, "" + false);
    style = mxStyleUtils.setStyle(style, mxConstants.STYLE_ENTRY_PERIMETER, "" + false);
    style = mxStyleUtils.setStyle(style, mxConstants.STYLE_ROUNDED, "" + edge.isCurved());

    double startShapeSize = ShapeUtil.calcShapeSize(edge.getStartShape(), edge.getStartShapeSize());
    double endShapeSize = ShapeUtil.calcShapeSize(edge.getEndShape(), edge.getEndShapeSize());
    style = mxStyleUtils.setStyle(style, mxConstants.STYLE_STARTSIZE, Double.toString(startShapeSize));
    style = mxStyleUtils.setStyle(style, mxConstants.STYLE_ENDSIZE, Double.toString(endShapeSize));
    cell.setStyle(style);

    cell.setEdgeStartMarker((edge.getStartShape() == null ? null : new MarkerAdapter(edge.getStartShape())));
    cell.setEdgeEndMarker((edge.getEndShape() == null ? null : new MarkerAdapter(edge.getEndShape())));

    mxGeometry geometry = (mxGeometry) cell.getGeometry().clone();
    List<Point> points_ = edge.getAnchorPoints();
    List<mxPoint> points = ListSequence.fromList(points_).select((it) -> new mxPoint(it.getX(), it.getY())).toList();
    if (cell.getSource() == cell.getTarget() && ListSequence.fromList(points).isEmpty()) {
      // Loop edges without control points will have length 0 and are not editable
      Bounds bounds = CellExtensions.getBounds(cell.getSource());
      ListSequence.fromList(points).addElement(new mxPoint(bounds.getMaxX() + 30, bounds.getCenterY()));
      ListSequence.fromList(points).addElement(new mxPoint(bounds.getMaxX() + 30, bounds.getY() - 30));
      ListSequence.fromList(points).addElement(new mxPoint(bounds.getCenterX(), bounds.getY() - 30));
    }
    geometry.setPoints(points);
    myGraph.getModel().setGeometry(cell, geometry);
    return cell;
  }

  /**
   * isSubdiagramParent: If a box contains a sub diagram and an edge connects a port of this box with
   * an element inside the sub diagram, the edge has to be attached to the opposite side of the port.
   */
  public Point calcEntryExitPoint(Point portPosition, boolean isSubdiagramParent) {
    double x = portPosition.getX();
    double y = portPosition.getY();

    if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(x, 0.0) || de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(x, 1.0)) {
      y = 0.5;
    } else if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(y, 0.0) || de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(y, 1.0)) {
      x = 0.5;
    }

    if (isSubdiagramParent) {
      if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(x, 0.0)) {
        x = 1.0;
      } else if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(x, 1.0)) {
        x = 0.0;
      }
      if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(y, 1.0)) {
        y = 0.0;
      } else if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(y, 0.0)) {
        y = 1.0;
      }
    }

    return new Point(x, y);
  }

  public void writeSyncEdge(EdgeDCell cell, Edge edge, mxCell rootCell, SyncContext syncContext) {
    edge.setEndpointFrom(getEndpoint(cell, false, rootCell));
    edge.setEndpointTo(getEndpoint(cell, true, rootCell));

    edge.setAnchorPoints(ListSequence.fromList(((List<mxPoint>) cell.getGeometry().getPoints())).select((it) -> new Point(it.getX(), it.getY())).toList());

    // label positions
    for (EdgeLabelType type : EdgeLabelType.values()) {
      LabelDCell labelCell = cell.getLabelCell(type);
      if (labelCell == null) {
        continue;
      }
      edge.getOrCreateLabelPosition(type).setAbsolutePosition(labelCell.getGeometry().getX(), labelCell.getGeometry().getY());
    }
  }

  protected IConnectionEndpoint_Internal getEndpoint(EdgeDCell edgeCell, boolean target, mxCell rootCell) {
    mxICell targetCell = (target ? edgeCell.getTarget() : edgeCell.getSource());

    Box targetNode;
    String targetPort;
    {
      Tuples._2<Box, String> _tmp_k3jzmb_e0xd = getEdgeSourceTarget(edgeCell, target, rootCell);
      targetNode = _tmp_k3jzmb_e0xd._0();
      targetPort = _tmp_k3jzmb_e0xd._1();
    }
    IConnectionEndpoint_Internal endpoint = EndpointUtil.getEndpoint(targetNode, targetPort);
    return endpoint;
  }

  public Tuples._2<Box, String> getEdgeSourceTarget(mxCell cell, boolean target, mxCell rootCell) {
    mxICell sourceTarget = (target ? cell.getTarget() : cell.getSource());
    Box node;
    String port;
    if (sourceTarget instanceof PortDCell) {
      node = (Box) myElementMapper.getDiagramElement(check_k3jzmb_a0a0a0a3a301(check_k3jzmb_a0a0a0a0d0zd(sourceTarget)));
      port = objectToString(check_k3jzmb_a0a1a3a301(sourceTarget));
    } else {
      node = (Box) myElementMapper.getDiagramElement(check_k3jzmb_a0a0a0a0d0zd_0(sourceTarget));
      port = null;
    }
    return MultiTuple.<Box,String>from(node, port);
  }

  public static String objectToString(Object obj) {
    return (obj == null ? null : String.valueOf(obj));
  }

  private static boolean isAncestor(DiagramModel ancestor, DiagramModel descendant) {
    DiagramModel parent = descendant.getParentModel();
    if (parent == null) {
      return false;
    }
    return parent == ancestor || isAncestor(ancestor, parent);
  }

  public enum SyncDirection {
    GRAPH2MODEL(),
    MODEL2GRAPH()
  }

  private static Edge check_k3jzmb_b0a0d0b0g0e0pb(EdgeDCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEdge();
    }
    return null;
  }
  private static EdgeDCell check_k3jzmb_a1a0a3a1a6a4a14(ISelfCreatingCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEdgeToSplit();
    }
    return null;
  }
  private static Point check_k3jzmb_a0d0a2a0a06(RelativePosition checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAbsolutePoint();
    }
    return null;
  }
  private static double check_k3jzmb_a0a4a0c0a0ic(Point checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getX();
    }
    return 0;
  }
  private static double check_k3jzmb_b0a4a0c0a0ic(Point checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getY();
    }
    return 0;
  }
  private static DiagramModel check_k3jzmb_a0a0e0nd(IDiagramElement checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModel();
    }
    return null;
  }
  private static IDiagramElement check_k3jzmb_a0a0a4a19(IDiagramDCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDiagramElement();
    }
    return null;
  }
  private static DiagramModel check_k3jzmb_a0b0e0nd(BaseDiagramDCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDiagramModel();
    }
    return null;
  }
  private static String check_k3jzmb_a0a0a0a3a301(mxICell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getId();
    }
    return null;
  }
  private static mxICell check_k3jzmb_a0a0a0a0d0zd(mxICell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getParent();
    }
    return null;
  }
  private static Object check_k3jzmb_a0a1a3a301(mxICell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getValue();
    }
    return null;
  }
  private static String check_k3jzmb_a0a0a0a0d0zd_0(mxICell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getId();
    }
    return null;
  }
  private static <T> T as_k3jzmb_a0a1a11(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_k3jzmb_a0a1a0a3a1a6a4a24(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_k3jzmb_a0a0a0a4a29(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_k3jzmb_a0a0b0e0od(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.itemis.mps.editor.diagram.editor;

/*Generated by MPS */

import jetbrains.mps.editor.runtime.descriptor.AbstractEditorBuilder;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.editor.runtime.style.StyleImpl;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.lang.editor.editor.Styles_StyleSheet.headerStyleClass;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.editor.runtime.cells.EmptyCellAction;
import jetbrains.mps.baseLanguage.editor.BaseLanguageStyle_StyleSheet.AnnotationStyleClass;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.openapi.editor.menus.transformation.SPropertyInfo;
import jetbrains.mps.nodeEditor.cells.SPropertyAccessor;
import jetbrains.mps.nodeEditor.cellMenu.SPropertySubstituteInfo;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import jetbrains.mps.lang.core.behavior.PropertyAttribute__BehaviorDescriptor;
import jetbrains.mps.nodeEditor.EditorManager;
import jetbrains.mps.openapi.editor.update.AttributeKind;
import jetbrains.mps.nodeEditor.cellProviders.AbstractCellListHandler;
import jetbrains.mps.lang.editor.cellProviders.RefNodeListHandler;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.openapi.editor.menus.transformation.SNodeLocation;
import jetbrains.mps.openapi.editor.cells.DefaultSubstituteInfo;
import jetbrains.mps.nodeEditor.cellMenu.SEmptyContainmentSubstituteInfo;
import jetbrains.mps.nodeEditor.cellMenu.SChildSubstituteInfo;
import jetbrains.mps.nodeEditor.cellActions.CellAction_DeleteNode;
import jetbrains.mps.lang.editor.cellProviders.RefNodeListHandlerElementKeyMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.editor.cellProviders.SingleRoleCellProvider;
import jetbrains.mps.editor.runtime.impl.cellActions.CellAction_DeleteSmart;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

/*package*/ class LayeredLayoutConfig_EditorBuilder_a extends AbstractEditorBuilder {
  @NotNull
  private SNode myNode;

  public LayeredLayoutConfig_EditorBuilder_a(@NotNull EditorContext context, @NotNull SNode node) {
    super(context);
    myNode = node;
  }

  @NotNull
  @Override
  public SNode getNode() {
    return myNode;
  }

  /*package*/ EditorCell createCell() {
    return createCollection_0();
  }

  private EditorCell createCollection_0() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_a");
    editorCell.setBig(true);
    setCellContext(editorCell);
    editorCell.setGridLayout(true);
    editorCell.addEditorCell(createCollection_1());
    editorCell.addEditorCell(createCollection_11());
    editorCell.addEditorCell(createCollection_21());
    editorCell.addEditorCell(createCollection_28());
    editorCell.addEditorCell(createCollection_33());
    editorCell.addEditorCell(createCollection_54());
    editorCell.addEditorCell(createCollection_64());
    editorCell.addEditorCell(createCollection_71());
    editorCell.addEditorCell(createCollection_75());
    editorCell.addEditorCell(createCollection_82());
    editorCell.addEditorCell(createCollection_90());
    editorCell.addEditorCell(createCollection_92());
    editorCell.addEditorCell(createCollection_95());
    editorCell.addEditorCell(createCollection_97());
    editorCell.addEditorCell(createCollection_99());
    editorCell.addEditorCell(createCollection_103());
    editorCell.addEditorCell(createComponent_0());
    return editorCell;
  }
  private EditorCell createCollection_1() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_a0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_10());
    editorCell.addEditorCell(createConstant_0());
    editorCell.addEditorCell(createCollection_2());
    editorCell.addEditorCell(createCollection_3());
    editorCell.addEditorCell(createCollection_4());
    editorCell.addEditorCell(createCollection_5());
    editorCell.addEditorCell(createCollection_6());
    editorCell.addEditorCell(createCollection_7());
    editorCell.addEditorCell(createCollection_8());
    editorCell.addEditorCell(createCollection_9());
    editorCell.addEditorCell(createCollection_10());
    return editorCell;
  }
  private EditorCell createConstant_0() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "core");
    editorCell.setCellId("Constant_1rye60_a0a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_2() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b0a");
    editorCell.addEditorCell(createConstant_1());
    editorCell.addEditorCell(createReadOnlyModelAccessor_0());
    editorCell.addEditorCell(createProperty_0());
    return editorCell;
  }
  private EditorCell createConstant_1() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "subdiagram direction");
    editorCell.setCellId("Constant_1rye60_a1a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_0() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-direction.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_0() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.subdiagramDirection$brcK;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no subdiagramDirection>");
      editorCell.setCellId("property_subdiagramDirection");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_3() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c0a");
    editorCell.addEditorCell(createConstant_2());
    editorCell.addEditorCell(createReadOnlyModelAccessor_1());
    editorCell.addEditorCell(createProperty_1());
    return editorCell;
  }
  private EditorCell createConstant_2() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "aspect ratio");
    editorCell.setCellId("Constant_1rye60_a2a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_1() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-aspectRatio.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_1() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.aspectRatio$chOg;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no aspectRatio>");
      editorCell.setCellId("property_aspectRatio");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_4() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d0a");
    editorCell.addEditorCell(createConstant_3());
    editorCell.addEditorCell(createReadOnlyModelAccessor_2());
    editorCell.addEditorCell(createRefNodeList_0());
    return editorCell;
  }
  private EditorCell createConstant_3() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "content alignment");
    editorCell.setCellId("Constant_1rye60_a3a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_2() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-contentAlignment.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createRefNodeList_0() {
    AbstractCellListHandler handler = new contentAlignmentListHandler_1rye60_c3a0(myNode, getEditorContext());
    EditorCell_Collection editorCell = handler.createCells(new CellLayout_Horizontal(), false);
    editorCell.setCellId("refNodeList_contentAlignment");
    editorCell.setSRole(handler.getElementSRole());
    return editorCell;
  }
  private static class contentAlignmentListHandler_1rye60_c3a0 extends RefNodeListHandler {
    @NotNull
    private SNode myNode;

    public contentAlignmentListHandler_1rye60_c3a0(SNode ownerNode, EditorContext context) {
      super(context, false);
      myNode = ownerNode;
    }

    @NotNull
    public SNode getNode() {
      return myNode;
    }
    public SContainmentLink getSLink() {
      return LINKS.contentAlignment$sHX9;
    }
    public SAbstractConcept getChildSConcept() {
      return CONCEPTS.ContentAlignment$XK;
    }

    public EditorCell createNodeCell(SNode elementNode) {
      EditorCell elementCell = getUpdateSession().updateChildNodeCell(elementNode);
      installElementCellActions(elementNode, elementCell, false);
      return elementCell;
    }
    public EditorCell createEmptyCell() {
      getCellFactory().pushCellContext();
      getCellFactory().setNodeLocation(new SNodeLocation.FromParentAndLink(contentAlignmentListHandler_1rye60_c3a0.this.getNode(), LINKS.contentAlignment$sHX9));
      try {
        EditorCell emptyCell = null;
        emptyCell = super.createEmptyCell();
        installElementCellActions(null, emptyCell, true);
        setCellContext(emptyCell);
        return emptyCell;
      } finally {
        getCellFactory().popCellContext();
      }
    }

    private static final Object OBJ = new Object();

    public void installElementCellActions(SNode elementNode, EditorCell elementCell, boolean isEmptyCell) {
      if (elementCell.getUserObject(AbstractCellListHandler.ELEMENT_CELL_COMPLETE_SET) == null) {
        if (elementCell.getSubstituteInfo() == null || elementCell.getSubstituteInfo() instanceof DefaultSubstituteInfo) {
          elementCell.putUserObject(AbstractCellListHandler.ELEMENT_CELL_COMPLETE_SET, OBJ);
          elementCell.setSubstituteInfo((isEmptyCell ? new SEmptyContainmentSubstituteInfo(elementCell) : new SChildSubstituteInfo(elementCell)));
        }
      }
      if (elementCell.getUserObject(AbstractCellListHandler.ELEMENT_CELL_DELETE_SET) == null) {
        if (elementNode != null) {
          elementCell.putUserObject(AbstractCellListHandler.ELEMENT_CELL_DELETE_SET, OBJ);
          elementCell.setAction(CellActionType.DELETE, new CellAction_DeleteNode(elementNode, CellAction_DeleteNode.DeleteDirection.FORWARD));
        }
      }
      if (elementCell.getUserObject(ELEMENT_CELL_BACKSPACE_SET) == null) {
        if (elementNode != null) {
          elementCell.putUserObject(ELEMENT_CELL_BACKSPACE_SET, OBJ);
          elementCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteNode(elementNode, CellAction_DeleteNode.DeleteDirection.BACKWARD));
        }
      }
      if (elementCell.getUserObject(AbstractCellListHandler.ELEMENT_CELL_ACTIONS_SET) == null) {
        if (elementNode != null) {
          elementCell.putUserObject(AbstractCellListHandler.ELEMENT_CELL_ACTIONS_SET, OBJ);
          elementCell.addKeyMap(new RefNodeListHandlerElementKeyMap(this, ","));
        }
      }
    }
    @Override
    public EditorCell createSeparatorCell(SNode prevNode, SNode nextNode) {
      EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), getNode(), ",");
      editorCell.setSelectable(false);
      Style style = new StyleImpl();
      style.set(StyleAttributes.LAYOUT_CONSTRAINT, "");
      style.set(StyleAttributes.PUNCTUATION_LEFT, true);
      editorCell.getStyle().putAll(style);
      editorCell.setAction(CellActionType.DELETE, new CellAction_DeleteNode(prevNode, CellAction_DeleteNode.DeleteDirection.FORWARD));
      editorCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteNode(prevNode, CellAction_DeleteNode.DeleteDirection.BACKWARD));
      return editorCell;
    }
  }
  private EditorCell createCollection_5() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e0a");
    editorCell.addEditorCell(createConstant_4());
    editorCell.addEditorCell(createReadOnlyModelAccessor_3());
    editorCell.addEditorCell(createProperty_2());
    return editorCell;
  }
  private EditorCell createConstant_4() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "direction");
    editorCell.setCellId("Constant_1rye60_a4a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_3() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-direction.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_2() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.direction$6zrN;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no direction>");
      editorCell.setCellId("property_direction");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_6() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f0a");
    editorCell.addEditorCell(createConstant_5());
    editorCell.addEditorCell(createReadOnlyModelAccessor_4());
    editorCell.addEditorCell(createProperty_3());
    return editorCell;
  }
  private EditorCell createConstant_5() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "fixed graph size");
    editorCell.setCellId("Constant_1rye60_a5a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_4() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-nodeSize-fixedGraphSize.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_3() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.fixedGraphSize$Sm5c;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no fixedGraphSize>");
      editorCell.setCellId("property_fixedGraphSize");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_7() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g0a");
    editorCell.addEditorCell(createConstant_6());
    editorCell.addEditorCell(createReadOnlyModelAccessor_5());
    editorCell.addEditorCell(createProperty_4());
    return editorCell;
  }
  private EditorCell createConstant_6() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "hierarchy handling");
    editorCell.setCellId("Constant_1rye60_a6a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_5() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-hierarchyHandling.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_4() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.hierarchyHandling$PAbb;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no hierarchyHandling>");
      editorCell.setCellId("property_hierarchyHandling");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_8() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_h0a");
    editorCell.addEditorCell(createConstant_7());
    editorCell.addEditorCell(createReadOnlyModelAccessor_6());
    editorCell.addEditorCell(createProperty_5());
    return editorCell;
  }
  private EditorCell createConstant_7() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "interactive layout");
    editorCell.setCellId("Constant_1rye60_a7a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_6() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b7a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-interactiveLayout.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_5() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.interactiveLayout$60Kb;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no interactiveLayout>");
      editorCell.setCellId("property_interactiveLayout");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_9() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_i0a");
    editorCell.addEditorCell(createConstant_8());
    editorCell.addEditorCell(createReadOnlyModelAccessor_7());
    editorCell.addEditorCell(createProperty_6());
    return editorCell;
  }
  private EditorCell createConstant_8() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "randomization seed");
    editorCell.setCellId("Constant_1rye60_a8a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_7() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b8a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-randomSeed.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_6() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.randomizationSeed$gPKD;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no randomizationSeed>");
      editorCell.setCellId("property_randomizationSeed");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_10() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_j0a");
    editorCell.addEditorCell(createConstant_9());
    editorCell.addEditorCell(createReadOnlyModelAccessor_8());
    editorCell.addEditorCell(createProperty_7());
    return editorCell;
  }
  private EditorCell createConstant_9() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "separate connected components");
    editorCell.setCellId("Constant_1rye60_a9a0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_8() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b9a0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-separateConnectedComponents.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_7() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.separateConnectedComponents$BBR6;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no separateConnectedComponents>");
      editorCell.setCellId("property_separateConnectedComponents");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_10() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "core (...)");
    editorCell.setCellId("Constant_1rye60_a0a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_11() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_b0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_21());
    editorCell.addEditorCell(createConstant_11());
    editorCell.addEditorCell(createCollection_12());
    editorCell.addEditorCell(createCollection_13());
    editorCell.addEditorCell(createCollection_14());
    editorCell.addEditorCell(createCollection_15());
    if (nodeCondition_1rye60_a5b0()) {
      editorCell.addEditorCell(createCollection_16());
    }
    editorCell.addEditorCell(createCollection_17());
    editorCell.addEditorCell(createCollection_18());
    editorCell.addEditorCell(createCollection_19());
    editorCell.addEditorCell(createCollection_20());
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a5b0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.cycleBreakingStrategy$xPET), 0x32d28aa5f4562ef6L) && SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.crossingMinimizationStrategy$kXP_), 0x32d28aa5f456214fL);
  }
  private EditorCell createConstant_11() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "layered");
    editorCell.setCellId("Constant_1rye60_a1a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_12() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b1a");
    editorCell.addEditorCell(createConstant_12());
    editorCell.addEditorCell(createReadOnlyModelAccessor_9());
    editorCell.addEditorCell(createProperty_8());
    return editorCell;
  }
  private EditorCell createConstant_12() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "add unnecessary bend points");
    editorCell.setCellId("Constant_1rye60_a1b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_9() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-unnecessaryBendpoints.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_8() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.addUnnecessaryBendpoints$7ZdF;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no addUnnecessaryBendpoints>");
      editorCell.setCellId("property_addUnnecessaryBendpoints");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_13() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c1a");
    editorCell.addEditorCell(createConstant_13());
    editorCell.addEditorCell(createReadOnlyModelAccessor_10());
    editorCell.addEditorCell(createProperty_9());
    return editorCell;
  }
  private EditorCell createConstant_13() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "direction congruency");
    editorCell.setCellId("Constant_1rye60_a2b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_10() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-directionCongruency.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_9() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.directionCongruence$CQhK;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no directionCongruence>");
      editorCell.setCellId("property_directionCongruence");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_14() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d1a");
    editorCell.addEditorCell(createConstant_14());
    editorCell.addEditorCell(createReadOnlyModelAccessor_11());
    editorCell.addEditorCell(createProperty_10());
    return editorCell;
  }
  private EditorCell createConstant_14() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "feedback edges");
    editorCell.setCellId("Constant_1rye60_a3b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_11() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-feedbackEdges.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_10() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.feedbackEdges$ijeg;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no feedbackEdges>");
      editorCell.setCellId("property_feedbackEdges");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_15() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e1a");
    editorCell.addEditorCell(createConstant_15());
    editorCell.addEditorCell(createReadOnlyModelAccessor_12());
    editorCell.addEditorCell(createProperty_11());
    return editorCell;
  }
  private EditorCell createConstant_15() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "generate position and layer IDs");
    editorCell.setCellId("Constant_1rye60_a4b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_12() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-generatePositionAndLayerIds.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_11() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.generatePositionAndLayerIDs$1q0a;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no generatePositionAndLayerIDs>");
      editorCell.setCellId("property_generatePositionAndLayerIDs");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_16() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f1a");
    editorCell.addEditorCell(createConstant_16());
    editorCell.addEditorCell(createReadOnlyModelAccessor_13());
    editorCell.addEditorCell(createProperty_12());
    return editorCell;
  }
  private EditorCell createConstant_16() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "interactive reference point");
    editorCell.setCellId("Constant_1rye60_a5b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_13() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-interactiveReferencePoint.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_12() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.interactiveReferencePoint$xHje;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no interactiveReferencePoint>");
      editorCell.setCellId("property_interactiveReferencePoint");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_17() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g1a");
    editorCell.addEditorCell(createConstant_17());
    editorCell.addEditorCell(createReadOnlyModelAccessor_14());
    editorCell.addEditorCell(createProperty_13());
    return editorCell;
  }
  private EditorCell createConstant_17() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "merge edges");
    editorCell.setCellId("Constant_1rye60_a6b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_14() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-mergeEdges.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_13() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.mergeEdges$XlA3;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no mergeEdges>");
      editorCell.setCellId("property_mergeEdges");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_18() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_h1a");
    editorCell.addEditorCell(createConstant_18());
    editorCell.addEditorCell(createReadOnlyModelAccessor_15());
    editorCell.addEditorCell(createProperty_14());
    return editorCell;
  }
  private EditorCell createConstant_18() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "merge hierarchy-crossing edges");
    editorCell.setCellId("Constant_1rye60_a7b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_15() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b7b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-mergeHierarchyEdges.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_14() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.mergeHierarchyCrossingEdges$AZzo;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no mergeHierarchyCrossingEdges>");
      editorCell.setCellId("property_mergeHierarchyCrossingEdges");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_19() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_i1a");
    editorCell.addEditorCell(createConstant_19());
    editorCell.addEditorCell(createReadOnlyModelAccessor_16());
    editorCell.addEditorCell(createProperty_15());
    return editorCell;
  }
  private EditorCell createConstant_19() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "port sorting strategy");
    editorCell.setCellId("Constant_1rye60_a8b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_16() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b8b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-portSortingStrategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_15() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.portSortingStrategy$UqEZ;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no portSortingStrategy>");
      editorCell.setCellId("property_portSortingStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_20() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_j1a");
    editorCell.addEditorCell(createConstant_20());
    editorCell.addEditorCell(createReadOnlyModelAccessor_17());
    editorCell.addEditorCell(createProperty_16());
    return editorCell;
  }
  private EditorCell createConstant_20() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "thoroughness");
    editorCell.setCellId("Constant_1rye60_a9b0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_17() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b9b0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-thoroughness.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_16() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.thoroughness$1WJ$;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no thoroughness>");
      editorCell.setCellId("property_thoroughness");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_21() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "layered");
    editorCell.setCellId("Constant_1rye60_a1a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_21() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_c0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_29());
    editorCell.addEditorCell(createConstant_22());
    if (nodeCondition_1rye60_a1c0()) {
      editorCell.addEditorCell(createCollection_22());
    }
    if (nodeCondition_1rye60_a2c0()) {
      editorCell.addEditorCell(createCollection_23());
    }
    editorCell.addEditorCell(createCollection_24());
    editorCell.addEditorCell(createCollection_25());
    if (nodeCondition_1rye60_a5c0()) {
      editorCell.addEditorCell(createCollection_26());
    }
    if (nodeCondition_1rye60_a6c0()) {
      editorCell.addEditorCell(createCollection_27());
    }
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a1c0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodeLayeringStrategy$SLA5), 0x32d28aa5f456f54dL);
  }
  private boolean nodeCondition_1rye60_a2c0() {
    return !(SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodePromotionStrategy$NuCw), 0x32d28aa5f457073aL));
  }
  private boolean nodeCondition_1rye60_a5c0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodeLayeringStrategy$SLA5), 0x32d28aa5f456f562L);
  }
  private boolean nodeCondition_1rye60_a6c0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodeLayeringStrategy$SLA5), 0x32d28aa5f456f562L);
  }
  private EditorCell createConstant_22() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "layering");
    editorCell.setCellId("Constant_1rye60_a2a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_22() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b2a");
    editorCell.addEditorCell(createConstant_23());
    editorCell.addEditorCell(createReadOnlyModelAccessor_18());
    editorCell.addEditorCell(createProperty_17());
    return editorCell;
  }
  private EditorCell createConstant_23() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "layer bound");
    editorCell.setCellId("Constant_1rye60_a1c0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_18() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1c0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-layering-coffmanGraham-layerBound.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_17() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.layerBound$k$mj;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no layerBound>");
      editorCell.setCellId("property_layerBound");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_23() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c2a");
    editorCell.addEditorCell(createConstant_24());
    editorCell.addEditorCell(createReadOnlyModelAccessor_19());
    editorCell.addEditorCell(createProperty_18());
    return editorCell;
  }
  private EditorCell createConstant_24() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "max node promotion iterations");
    editorCell.setCellId("Constant_1rye60_a2c0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_19() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2c0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-layering-nodePromotion-maxIterations.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_18() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.maxNodePromotionIterations$muqC;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no maxNodePromotionIterations>");
      editorCell.setCellId("property_maxNodePromotionIterations");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_24() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d2a");
    editorCell.addEditorCell(createConstant_25());
    editorCell.addEditorCell(createReadOnlyModelAccessor_20());
    editorCell.addEditorCell(createProperty_19());
    return editorCell;
  }
  private EditorCell createConstant_25() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node layering strategy");
    editorCell.setCellId("Constant_1rye60_a3c0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_20() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3c0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-layering-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_19() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.nodeLayeringStrategy$SLA5;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no nodeLayeringStrategy>");
      editorCell.setCellId("property_nodeLayeringStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_25() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e2a");
    editorCell.addEditorCell(createConstant_26());
    editorCell.addEditorCell(createReadOnlyModelAccessor_21());
    editorCell.addEditorCell(createProperty_20());
    return editorCell;
  }
  private EditorCell createConstant_26() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node promotion strategy");
    editorCell.setCellId("Constant_1rye60_a4c0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_21() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4c0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-layering-nodePromotion-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_20() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.nodePromotionStrategy$NuCw;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no nodePromotionStrategy>");
      editorCell.setCellId("property_nodePromotionStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_26() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f2a");
    editorCell.addEditorCell(createConstant_27());
    editorCell.addEditorCell(createReadOnlyModelAccessor_22());
    editorCell.addEditorCell(createProperty_21());
    return editorCell;
  }
  private EditorCell createConstant_27() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "upper bound on width");
    editorCell.setCellId("Constant_1rye60_a5c0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_22() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5c0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-layering-minWidth-upperBoundOnWidth.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_21() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.upperBoundOnWidthMinWidthLayerer$sX9c;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no upperBoundOnWidthMinWidthLayerer>");
      editorCell.setCellId("property_upperBoundOnWidthMinWidthLayerer");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_27() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g2a");
    editorCell.addEditorCell(createConstant_28());
    editorCell.addEditorCell(createReadOnlyModelAccessor_23());
    editorCell.addEditorCell(createProperty_22());
    return editorCell;
  }
  private EditorCell createConstant_28() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "upper layer estimation scaling factor");
    editorCell.setCellId("Constant_1rye60_a6c0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_23() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6c0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-layering-minWidth-upperLayerEstimationScalingFactor.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_22() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.upperLayerEstimationScalingFactorMinWidthLayerer$hdBH;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no upperLayerEstimationScalingFactorMinWidthLayerer>");
      editorCell.setCellId("property_upperLayerEstimationScalingFactorMinWidthLayerer");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_29() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "layering (...)");
    editorCell.setCellId("Constant_1rye60_a2a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_28() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_d0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_35());
    editorCell.addEditorCell(createConstant_30());
    editorCell.addEditorCell(createCollection_29());
    if (nodeCondition_1rye60_a2d0()) {
      editorCell.addEditorCell(createCollection_30());
    }
    if (nodeCondition_1rye60_a3d0()) {
      editorCell.addEditorCell(createCollection_31());
    }
    if (nodeCondition_1rye60_a4d0()) {
      editorCell.addEditorCell(createCollection_32());
    }
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a2d0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.edgeRouting$n5ng), 0x2e440a78c2259ef2L);
  }
  private boolean nodeCondition_1rye60_a3d0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.edgeRouting$n5ng), 0x2e440a78c2259f2fL) && SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.splineRoutingMode$ohBa), 0x32d28aa5f4573771L);
  }
  private boolean nodeCondition_1rye60_a4d0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.edgeRouting$n5ng), 0x2e440a78c2259f2fL);
  }
  private EditorCell createConstant_30() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge routing");
    editorCell.setCellId("Constant_1rye60_a3a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_29() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b3a");
    editorCell.addEditorCell(createConstant_31());
    editorCell.addEditorCell(createReadOnlyModelAccessor_24());
    editorCell.addEditorCell(createProperty_23());
    return editorCell;
  }
  private EditorCell createConstant_31() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge routing");
    editorCell.setCellId("Constant_1rye60_a1d0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_24() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1d0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-edgeRouting.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_23() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeRouting$n5ng;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeRouting>");
      editorCell.setCellId("property_edgeRouting");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_30() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c3a");
    editorCell.addEditorCell(createConstant_32());
    editorCell.addEditorCell(createReadOnlyModelAccessor_25());
    editorCell.addEditorCell(createProperty_24());
    return editorCell;
  }
  private EditorCell createConstant_32() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "sloped edge zone width");
    editorCell.setCellId("Constant_1rye60_a2d0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_25() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2d0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-edgeRouting-polyline-slopedEdgeZoneWidth.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_24() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.slopedEdgeZoneWidth$k3cf;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no slopedEdgeZoneWidth>");
      editorCell.setCellId("property_slopedEdgeZoneWidth");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_31() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d3a");
    editorCell.addEditorCell(createConstant_33());
    editorCell.addEditorCell(createReadOnlyModelAccessor_26());
    editorCell.addEditorCell(createProperty_25());
    return editorCell;
  }
  private EditorCell createConstant_33() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "sloppy spline layer spacing factor");
    editorCell.setCellId("Constant_1rye60_a3d0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_26() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3d0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-edgeRouting-splines-sloppy-layerSpacingFactor.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_25() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.sloppySplineLayerSpacingFactor$XQ4a;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no sloppySplineLayerSpacingFactor>");
      editorCell.setCellId("property_sloppySplineLayerSpacingFactor");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_32() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e3a");
    editorCell.addEditorCell(createConstant_34());
    editorCell.addEditorCell(createReadOnlyModelAccessor_27());
    editorCell.addEditorCell(createProperty_26());
    return editorCell;
  }
  private EditorCell createConstant_34() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "spline routing mode");
    editorCell.setCellId("Constant_1rye60_a4d0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_27() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4d0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-edgeRouting-splines-mode.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_26() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.splineRoutingMode$ohBa;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no splineRoutingMode>");
      editorCell.setCellId("property_splineRoutingMode");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_35() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge routing (...)");
    editorCell.setCellId("Constant_1rye60_a3a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_33() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_e0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_57());
    editorCell.addEditorCell(createConstant_36());
    editorCell.addEditorCell(createCollection_34());
    editorCell.addEditorCell(createCollection_35());
    editorCell.addEditorCell(createCollection_36());
    editorCell.addEditorCell(createCollection_37());
    editorCell.addEditorCell(createCollection_38());
    editorCell.addEditorCell(createCollection_39());
    editorCell.addEditorCell(createCollection_40());
    editorCell.addEditorCell(createCollection_41());
    editorCell.addEditorCell(createCollection_42());
    editorCell.addEditorCell(createCollection_43());
    editorCell.addEditorCell(createCollection_44());
    editorCell.addEditorCell(createCollection_45());
    editorCell.addEditorCell(createCollection_46());
    editorCell.addEditorCell(createCollection_47());
    editorCell.addEditorCell(createCollection_48());
    editorCell.addEditorCell(createCollection_49());
    editorCell.addEditorCell(createCollection_50());
    editorCell.addEditorCell(createCollection_51());
    editorCell.addEditorCell(createCollection_52());
    editorCell.addEditorCell(createCollection_53());
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private EditorCell createConstant_36() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "spacing");
    editorCell.setCellId("Constant_1rye60_a4a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_34() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b4a");
    editorCell.addEditorCell(createConstant_37());
    editorCell.addEditorCell(createRefNode_0());
    return editorCell;
  }
  private EditorCell createConstant_37() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node size minimum padding");
    editorCell.setCellId("Constant_1rye60_a1e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createRefNode_0() {
    SingleRoleCellProvider provider = new nodeSizeMinimumPaddingSingleRoleHandler_1rye60_b1e0(myNode, LINKS.nodeSizeMinimumPadding$f2zx, getEditorContext());
    return provider.createCell();
  }
  private static class nodeSizeMinimumPaddingSingleRoleHandler_1rye60_b1e0 extends SingleRoleCellProvider {
    @NotNull
    private SNode myNode;

    public nodeSizeMinimumPaddingSingleRoleHandler_1rye60_b1e0(SNode ownerNode, SContainmentLink containmentLink, EditorContext context) {
      super(containmentLink, context);
      myNode = ownerNode;
    }

    @Override
    @NotNull
    public SNode getNode() {
      return myNode;
    }

    protected EditorCell createChildCell(SNode child) {
      EditorCell editorCell = getUpdateSession().updateChildNodeCell(child);
      editorCell.setAction(CellActionType.DELETE, new CellAction_DeleteSmart(getNode(), LINKS.nodeSizeMinimumPadding$f2zx, child));
      editorCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteSmart(getNode(), LINKS.nodeSizeMinimumPadding$f2zx, child));
      installCellInfo(child, editorCell, false);
      return editorCell;
    }



    private void installCellInfo(SNode child, EditorCell editorCell, boolean isEmpty) {
      if (editorCell.getSubstituteInfo() == null || editorCell.getSubstituteInfo() instanceof DefaultSubstituteInfo) {
        editorCell.setSubstituteInfo((isEmpty ? new SEmptyContainmentSubstituteInfo(editorCell) : new SChildSubstituteInfo(editorCell)));
      }
      if (editorCell.getSRole() == null) {
        editorCell.setSRole(LINKS.nodeSizeMinimumPadding$f2zx);
      }
    }
    @Override
    protected EditorCell createEmptyCell() {
      getCellFactory().pushCellContext();
      getCellFactory().setNodeLocation(new SNodeLocation.FromParentAndLink(getNode(), LINKS.nodeSizeMinimumPadding$f2zx));
      try {
        EditorCell editorCell = super.createEmptyCell();
        editorCell.setCellId("empty_nodeSizeMinimumPadding");
        installCellInfo(null, editorCell, true);
        setCellContext(editorCell);
        return editorCell;
      } finally {
        getCellFactory().popCellContext();
      }
    }
    protected String getNoTargetText() {
      return "12";
    }
  }
  private EditorCell createCollection_35() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c4a");
    editorCell.addEditorCell(createConstant_38());
    editorCell.addEditorCell(createReadOnlyModelAccessor_28());
    editorCell.addEditorCell(createRefNode_1());
    return editorCell;
  }
  private EditorCell createConstant_38() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "additional port space");
    editorCell.setCellId("Constant_1rye60_a2e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_28() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-portsSurrounding.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createRefNode_1() {
    SingleRoleCellProvider provider = new additionalPortSpaceSingleRoleHandler_1rye60_c2e0(myNode, LINKS.additionalPortSpace$udd, getEditorContext());
    return provider.createCell();
  }
  private static class additionalPortSpaceSingleRoleHandler_1rye60_c2e0 extends SingleRoleCellProvider {
    @NotNull
    private SNode myNode;

    public additionalPortSpaceSingleRoleHandler_1rye60_c2e0(SNode ownerNode, SContainmentLink containmentLink, EditorContext context) {
      super(containmentLink, context);
      myNode = ownerNode;
    }

    @Override
    @NotNull
    public SNode getNode() {
      return myNode;
    }

    protected EditorCell createChildCell(SNode child) {
      EditorCell editorCell = getUpdateSession().updateChildNodeCell(child);
      editorCell.setAction(CellActionType.DELETE, new CellAction_DeleteSmart(getNode(), LINKS.additionalPortSpace$udd, child));
      editorCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteSmart(getNode(), LINKS.additionalPortSpace$udd, child));
      installCellInfo(child, editorCell, false);
      return editorCell;
    }



    private void installCellInfo(SNode child, EditorCell editorCell, boolean isEmpty) {
      if (editorCell.getSubstituteInfo() == null || editorCell.getSubstituteInfo() instanceof DefaultSubstituteInfo) {
        editorCell.setSubstituteInfo((isEmpty ? new SEmptyContainmentSubstituteInfo(editorCell) : new SChildSubstituteInfo(editorCell)));
      }
      if (editorCell.getSRole() == null) {
        editorCell.setSRole(LINKS.additionalPortSpace$udd);
      }
    }
    @Override
    protected EditorCell createEmptyCell() {
      getCellFactory().pushCellContext();
      getCellFactory().setNodeLocation(new SNodeLocation.FromParentAndLink(getNode(), LINKS.additionalPortSpace$udd));
      try {
        EditorCell editorCell = super.createEmptyCell();
        editorCell.setCellId("empty_additionalPortSpace");
        installCellInfo(null, editorCell, true);
        setCellContext(editorCell);
        return editorCell;
      } finally {
        getCellFactory().popCellContext();
      }
    }
    protected String getNoTargetText() {
      return "<no additionalPortSpace>";
    }
  }
  private EditorCell createCollection_36() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d4a");
    editorCell.addEditorCell(createConstant_39());
    editorCell.addEditorCell(createReadOnlyModelAccessor_29());
    editorCell.addEditorCell(createProperty_27());
    return editorCell;
  }
  private EditorCell createConstant_39() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "comment-comment spacing");
    editorCell.setCellId("Constant_1rye60_a3e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_29() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-commentComment.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_27() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.commentCommentSpacing$4iFG;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no commentCommentSpacing>");
      editorCell.setCellId("property_commentCommentSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_37() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e4a");
    editorCell.addEditorCell(createConstant_40());
    editorCell.addEditorCell(createReadOnlyModelAccessor_30());
    editorCell.addEditorCell(createProperty_28());
    return editorCell;
  }
  private EditorCell createConstant_40() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "comment-node spacing");
    editorCell.setCellId("Constant_1rye60_a4e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_30() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-commentNode.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_28() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.commentNodeSpacing$FfIw;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no commentNodeSpacing>");
      editorCell.setCellId("property_commentNodeSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_38() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f4a");
    editorCell.addEditorCell(createConstant_41());
    editorCell.addEditorCell(createReadOnlyModelAccessor_31());
    editorCell.addEditorCell(createProperty_29());
    return editorCell;
  }
  private EditorCell createConstant_41() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "components spacing");
    editorCell.setCellId("Constant_1rye60_a5e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_31() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-componentComponent.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_29() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.componentsSpacing$3t9G;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no componentsSpacing>");
      editorCell.setCellId("property_componentsSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_39() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g4a");
    editorCell.addEditorCell(createConstant_42());
    editorCell.addEditorCell(createReadOnlyModelAccessor_32());
    editorCell.addEditorCell(createProperty_30());
    return editorCell;
  }
  private EditorCell createConstant_42() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge-edge between layer spacing");
    editorCell.setCellId("Constant_1rye60_a6e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_32() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-spacing-edgeEdgeBetweenLayers.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_30() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeEdgeBetweenLayersSpacing$9I0L;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeEdgeBetweenLayersSpacing>");
      editorCell.setCellId("property_edgeEdgeBetweenLayersSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_40() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_h4a");
    editorCell.addEditorCell(createConstant_43());
    editorCell.addEditorCell(createReadOnlyModelAccessor_33());
    editorCell.addEditorCell(createProperty_31());
    return editorCell;
  }
  private EditorCell createConstant_43() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge-label spacing");
    editorCell.setCellId("Constant_1rye60_a7e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_33() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b7e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-edgeLabel.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_31() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeLabelSpacing$BRVD;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeLabelSpacing>");
      editorCell.setCellId("property_edgeLabelSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_41() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_i4a");
    editorCell.addEditorCell(createConstant_44());
    editorCell.addEditorCell(createReadOnlyModelAccessor_34());
    editorCell.addEditorCell(createProperty_32());
    return editorCell;
  }
  private EditorCell createConstant_44() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge-node between layers spacing");
    editorCell.setCellId("Constant_1rye60_a8e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_34() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b8e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-spacing-edgeNodeBetweenLayers.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_32() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeNodeBetweenLayersSpacing$dfBH;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeNodeBetweenLayersSpacing>");
      editorCell.setCellId("property_edgeNodeBetweenLayersSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_42() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_j4a");
    editorCell.addEditorCell(createConstant_45());
    editorCell.addEditorCell(createReadOnlyModelAccessor_35());
    editorCell.addEditorCell(createProperty_33());
    return editorCell;
  }
  private EditorCell createConstant_45() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge-node spacing");
    editorCell.setCellId("Constant_1rye60_a9e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_35() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b9e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-edgeNode.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_33() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeNodeSpacing$Ydqc;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeNodeSpacing>");
      editorCell.setCellId("property_edgeNodeSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_43() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_k4a");
    editorCell.addEditorCell(createConstant_46());
    editorCell.addEditorCell(createReadOnlyModelAccessor_36());
    editorCell.addEditorCell(createProperty_34());
    return editorCell;
  }
  private EditorCell createConstant_46() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge spacing");
    editorCell.setCellId("Constant_1rye60_a01e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_36() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b01e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-edgeEdge.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_34() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeSpacing$AHr7;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeSpacing>");
      editorCell.setCellId("property_edgeSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_44() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_l4a");
    editorCell.addEditorCell(createConstant_47());
    editorCell.addEditorCell(createReadOnlyModelAccessor_37());
    editorCell.addEditorCell(createProperty_35());
    return editorCell;
  }
  private EditorCell createConstant_47() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "horizontal spacing between label and port");
    editorCell.setCellId("Constant_1rye60_a11e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_37() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b11e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-labelPortHorizontal.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_35() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.horizontalSpacingBetweenLabelAndPort$5Qx_;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no horizontalSpacingBetweenLabelAndPort>");
      editorCell.setCellId("property_horizontalSpacingBetweenLabelAndPort");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_45() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_m4a");
    editorCell.addEditorCell(createConstant_48());
    editorCell.addEditorCell(createReadOnlyModelAccessor_38());
    editorCell.addEditorCell(createProperty_36());
    return editorCell;
  }
  private EditorCell createConstant_48() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "label-node spacing");
    editorCell.setCellId("Constant_1rye60_a21e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_38() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b21e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-labelNode.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_36() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.labelNodeSpacing$loWf;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no labelNodeSpacing>");
      editorCell.setCellId("property_labelNodeSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_46() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_n4a");
    editorCell.addEditorCell(createConstant_49());
    editorCell.addEditorCell(createReadOnlyModelAccessor_39());
    editorCell.addEditorCell(createProperty_37());
    return editorCell;
  }
  private EditorCell createConstant_49() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "label spacing");
    editorCell.setCellId("Constant_1rye60_a31e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_39() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b31e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-labelLabel.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_37() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.labelSpacing$LUJP;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no labelSpacing>");
      editorCell.setCellId("property_labelSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_47() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_o4a");
    editorCell.addEditorCell(createConstant_50());
    editorCell.addEditorCell(createReadOnlyModelAccessor_40());
    editorCell.addEditorCell(createProperty_38());
    return editorCell;
  }
  private EditorCell createConstant_50() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node-node between layers spacing");
    editorCell.setCellId("Constant_1rye60_a41e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_40() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b41e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-spacing-nodeNodeBetweenLayers.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_38() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.nodeNodeBetweenLayersSpacing$fzWI;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no nodeNodeBetweenLayersSpacing>");
      editorCell.setCellId("property_nodeNodeBetweenLayersSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_48() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_p4a");
    editorCell.addEditorCell(createConstant_51());
    editorCell.addEditorCell(createReadOnlyModelAccessor_41());
    editorCell.addEditorCell(createProperty_39());
    return editorCell;
  }
  private EditorCell createConstant_51() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node self loop spacing");
    editorCell.setCellId("Constant_1rye60_a51e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_41() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b51e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-nodeSelfLoop.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_39() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.nodeSelfLoopSpacing$zpMz;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no nodeSelfLoopSpacing>");
      editorCell.setCellId("property_nodeSelfLoopSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_49() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_q4a");
    editorCell.addEditorCell(createConstant_52());
    editorCell.addEditorCell(createReadOnlyModelAccessor_42());
    editorCell.addEditorCell(createProperty_40());
    return editorCell;
  }
  private EditorCell createConstant_52() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node spacing");
    editorCell.setCellId("Constant_1rye60_a61e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_42() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b61e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-nodeNode.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_40() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.nodeSpacing$pa7;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no nodeSpacing>");
      editorCell.setCellId("property_nodeSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_50() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_r4a");
    editorCell.addEditorCell(createConstant_53());
    editorCell.addEditorCell(createReadOnlyModelAccessor_43());
    editorCell.addEditorCell(createRefNode_2());
    return editorCell;
  }
  private EditorCell createConstant_53() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "padding");
    editorCell.setCellId("Constant_1rye60_a71e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_43() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b71e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-padding.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createRefNode_2() {
    SingleRoleCellProvider provider = new paddingSingleRoleHandler_1rye60_c71e0(myNode, LINKS.padding$yFy2, getEditorContext());
    return provider.createCell();
  }
  private static class paddingSingleRoleHandler_1rye60_c71e0 extends SingleRoleCellProvider {
    @NotNull
    private SNode myNode;

    public paddingSingleRoleHandler_1rye60_c71e0(SNode ownerNode, SContainmentLink containmentLink, EditorContext context) {
      super(containmentLink, context);
      myNode = ownerNode;
    }

    @Override
    @NotNull
    public SNode getNode() {
      return myNode;
    }

    protected EditorCell createChildCell(SNode child) {
      EditorCell editorCell = getUpdateSession().updateChildNodeCell(child);
      editorCell.setAction(CellActionType.DELETE, new CellAction_DeleteSmart(getNode(), LINKS.padding$yFy2, child));
      editorCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteSmart(getNode(), LINKS.padding$yFy2, child));
      installCellInfo(child, editorCell, false);
      return editorCell;
    }



    private void installCellInfo(SNode child, EditorCell editorCell, boolean isEmpty) {
      if (editorCell.getSubstituteInfo() == null || editorCell.getSubstituteInfo() instanceof DefaultSubstituteInfo) {
        editorCell.setSubstituteInfo((isEmpty ? new SEmptyContainmentSubstituteInfo(editorCell) : new SChildSubstituteInfo(editorCell)));
      }
      if (editorCell.getSRole() == null) {
        editorCell.setSRole(LINKS.padding$yFy2);
      }
    }
    @Override
    protected EditorCell createEmptyCell() {
      getCellFactory().pushCellContext();
      getCellFactory().setNodeLocation(new SNodeLocation.FromParentAndLink(getNode(), LINKS.padding$yFy2));
      try {
        EditorCell editorCell = super.createEmptyCell();
        editorCell.setCellId("empty_padding");
        installCellInfo(null, editorCell, true);
        setCellContext(editorCell);
        return editorCell;
      } finally {
        getCellFactory().popCellContext();
      }
    }
    protected String getNoTargetText() {
      return "<no padding>";
    }
  }
  private EditorCell createCollection_51() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_s4a");
    editorCell.addEditorCell(createConstant_54());
    editorCell.addEditorCell(createReadOnlyModelAccessor_44());
    editorCell.addEditorCell(createProperty_41());
    return editorCell;
  }
  private EditorCell createConstant_54() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "port spacing");
    editorCell.setCellId("Constant_1rye60_a81e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_44() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b81e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-portPort.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_41() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.portSpacing$qeVA;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no portSpacing>");
      editorCell.setCellId("property_portSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_52() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_t4a");
    editorCell.addEditorCell(createConstant_55());
    editorCell.addEditorCell(createReadOnlyModelAccessor_45());
    editorCell.addEditorCell(createProperty_42());
    return editorCell;
  }
  private EditorCell createConstant_55() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "spacing base value");
    editorCell.setCellId("Constant_1rye60_a91e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_45() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b91e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-spacing-baseValue.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_42() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.spacingBaseValue$JnZ3;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, true), myNode);
      editorCell.setDefaultText("<not defined>");
      editorCell.setCellId("property_spacingBaseValue");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_53() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_u4a");
    editorCell.addEditorCell(createConstant_56());
    editorCell.addEditorCell(createReadOnlyModelAccessor_46());
    editorCell.addEditorCell(createProperty_43());
    return editorCell;
  }
  private EditorCell createConstant_56() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "vertical spacing between label and port");
    editorCell.setCellId("Constant_1rye60_a02e0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_46() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b02e0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-spacing-labelPortVertical.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_43() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.verticalSpacingBetweenLabelAndPort$P333;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no verticalSpacingBetweenLabelAndPort>");
      editorCell.setCellId("property_verticalSpacingBetweenLabelAndPort");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_57() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "spacing (...)");
    editorCell.setCellId("Constant_1rye60_a4a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_54() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_f0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_68());
    editorCell.addEditorCell(createConstant_58());
    if (nodeCondition_1rye60_a1f0()) {
      editorCell.addEditorCell(createCollection_55());
    }
    if (nodeCondition_1rye60_a2f0()) {
      editorCell.addEditorCell(createCollection_56());
    }
    if (nodeCondition_1rye60_a3f0()) {
      editorCell.addEditorCell(createCollection_57());
    }
    if (nodeCondition_1rye60_a4f0()) {
      editorCell.addEditorCell(createCollection_58());
    }
    if (nodeCondition_1rye60_a5f0()) {
      editorCell.addEditorCell(createCollection_59());
    }
    editorCell.addEditorCell(createCollection_60());
    if (nodeCondition_1rye60_a7f0()) {
      editorCell.addEditorCell(createCollection_61());
    }
    if (nodeCondition_1rye60_a8f0()) {
      editorCell.addEditorCell(createCollection_62());
    }
    if (nodeCondition_1rye60_a9f0()) {
      editorCell.addEditorCell(createCollection_63());
    }
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a1f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567431L) || SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567434L);
  }
  private boolean nodeCondition_1rye60_a2f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567431L) || SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567434L);
  }
  private boolean nodeCondition_1rye60_a3f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567431L) || SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567434L);
  }
  private boolean nodeCondition_1rye60_a4f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.cuttingStrategy$5Wl7), 0x32d28aa5f4562600L);
  }
  private boolean nodeCondition_1rye60_a5f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567434L) && SPropertyOperations.getBoolean(myNode, PROPS.improveCuts$fKg);
  }
  private boolean nodeCondition_1rye60_a7f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567434L);
  }
  private boolean nodeCondition_1rye60_a8f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567434L);
  }
  private boolean nodeCondition_1rye60_a9f0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567431L) || SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.graphWrappingStrategy$W_Ud), 0x32d28aa5f4567434L);
  }
  private EditorCell createConstant_58() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "wrapping");
    editorCell.setCellId("Constant_1rye60_a5a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_55() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b5a");
    editorCell.addEditorCell(createConstant_59());
    editorCell.addEditorCell(createReadOnlyModelAccessor_47());
    editorCell.addEditorCell(createProperty_44());
    return editorCell;
  }
  private EditorCell createConstant_59() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "additional wrapped edges spacing");
    editorCell.setCellId("Constant_1rye60_a1f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_47() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-additionalEdgeSpacing.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_44() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.additionalWrappedEdgesSpacing$A6g$;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no additionalWrappedEdgesSpacing>");
      editorCell.setCellId("property_additionalWrappedEdgesSpacing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_56() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c5a");
    editorCell.addEditorCell(createConstant_60());
    editorCell.addEditorCell(createReadOnlyModelAccessor_48());
    editorCell.addEditorCell(createProperty_45());
    return editorCell;
  }
  private EditorCell createConstant_60() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "correction factor");
    editorCell.setCellId("Constant_1rye60_a2f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_48() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-correctionFactor.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_45() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.correctionFactorForWrapping$d79c;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no correctionFactorForWrapping>");
      editorCell.setCellId("property_correctionFactorForWrapping");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_57() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d5a");
    editorCell.addEditorCell(createConstant_61());
    editorCell.addEditorCell(createReadOnlyModelAccessor_49());
    editorCell.addEditorCell(createProperty_46());
    return editorCell;
  }
  private EditorCell createConstant_61() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "cutting strategy");
    editorCell.setCellId("Constant_1rye60_a3f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_49() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-cutting-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_46() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.cuttingStrategy$5Wl7;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no cuttingStrategy>");
      editorCell.setCellId("property_cuttingStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_58() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e5a");
    editorCell.addEditorCell(createConstant_62());
    editorCell.addEditorCell(createReadOnlyModelAccessor_50());
    editorCell.addEditorCell(createProperty_47());
    return editorCell;
  }
  private EditorCell createConstant_62() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "cutting freedom");
    editorCell.setCellId("Constant_1rye60_a4f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_50() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-cutting-msd-freedom.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_47() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.msdFreedom$y5P3;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no msdFreedom>");
      editorCell.setCellId("property_msdFreedom");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_59() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f5a");
    editorCell.addEditorCell(createConstant_63());
    editorCell.addEditorCell(createReadOnlyModelAccessor_51());
    editorCell.addEditorCell(createProperty_48());
    return editorCell;
  }
  private EditorCell createConstant_63() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "distance penalty when improving cuts");
    editorCell.setCellId("Constant_1rye60_a5f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_51() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-multiEdge-distancePenalty.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_48() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.multiEdgeDistancePenalty$iEkK;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no multiEdgeDistancePenalty>");
      editorCell.setCellId("property_multiEdgeDistancePenalty");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_60() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g5a");
    editorCell.addEditorCell(createConstant_64());
    editorCell.addEditorCell(createReadOnlyModelAccessor_52());
    editorCell.addEditorCell(createProperty_49());
    return editorCell;
  }
  private EditorCell createConstant_64() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "graph wrapping strategy");
    editorCell.setCellId("Constant_1rye60_a6f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_52() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_49() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.graphWrappingStrategy$W_Ud;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no graphWrappingStrategy>");
      editorCell.setCellId("property_graphWrappingStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_61() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_h5a");
    editorCell.addEditorCell(createConstant_65());
    editorCell.addEditorCell(createReadOnlyModelAccessor_53());
    editorCell.addEditorCell(createProperty_50());
    return editorCell;
  }
  private EditorCell createConstant_65() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "improve cuts");
    editorCell.setCellId("Constant_1rye60_a7f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_53() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b7f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-multiEdge-improveCuts.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_50() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.improveCuts$fKg;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no improveCuts>");
      editorCell.setCellId("property_improveCuts");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_62() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_i5a");
    editorCell.addEditorCell(createConstant_66());
    editorCell.addEditorCell(createReadOnlyModelAccessor_54());
    editorCell.addEditorCell(createProperty_51());
    return editorCell;
  }
  private EditorCell createConstant_66() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "improve wrapped edges");
    editorCell.setCellId("Constant_1rye60_a8f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_54() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b8f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-multiEdge-improveWrappedEdges.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_51() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.improveWrappedEdges$szeF;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no improveWrappedEdges>");
      editorCell.setCellId("property_improveWrappedEdges");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_63() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_j5a");
    editorCell.addEditorCell(createConstant_67());
    editorCell.addEditorCell(createReadOnlyModelAccessor_55());
    editorCell.addEditorCell(createProperty_52());
    return editorCell;
  }
  private EditorCell createConstant_67() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "validification strategy");
    editorCell.setCellId("Constant_1rye60_a9f0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_55() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b9f0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-wrapping-validify-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_52() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.validificationStrategy$G$E_;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no validificationStrategy>");
      editorCell.setCellId("property_validificationStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_68() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "wrapping (...)");
    editorCell.setCellId("Constant_1rye60_a5a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_64() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_g0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_76());
    editorCell.addEditorCell(createConstant_69());
    editorCell.addEditorCell(createCollection_65());
    if (nodeCondition_1rye60_a2g0()) {
      editorCell.addEditorCell(createCollection_66());
    }
    if (nodeCondition_1rye60_a3g0()) {
      editorCell.addEditorCell(createCollection_67());
    }
    if (nodeCondition_1rye60_a4g0()) {
      editorCell.addEditorCell(createCollection_68());
    }
    if (nodeCondition_1rye60_a5g0()) {
      editorCell.addEditorCell(createCollection_69());
    }
    if (nodeCondition_1rye60_a6g0()) {
      editorCell.addEditorCell(createCollection_70());
    }
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a2g0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodePlacementStrategy$B9EB), 0x32d28aa5f4570342L);
  }
  private boolean nodeCondition_1rye60_a3g0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodePlacementStrategy$B9EB), 0x32d28aa5f4570342L);
  }
  private boolean nodeCondition_1rye60_a4g0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodePlacementStrategy$B9EB), 0x32d28aa5f4570348L) || SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodePlacementStrategy$B9EB), 0x32d28aa5f4570342L);
  }
  private boolean nodeCondition_1rye60_a5g0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodePlacementStrategy$B9EB), 0x32d28aa5f457033dL);
  }
  private boolean nodeCondition_1rye60_a6g0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.nodePlacementStrategy$B9EB), 0x32d28aa5f4570348L);
  }
  private EditorCell createConstant_69() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node placement");
    editorCell.setCellId("Constant_1rye60_a6a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_65() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b6a");
    editorCell.addEditorCell(createConstant_70());
    editorCell.addEditorCell(createReadOnlyModelAccessor_56());
    editorCell.addEditorCell(createProperty_53());
    return editorCell;
  }
  private EditorCell createConstant_70() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node placement strategy");
    editorCell.setCellId("Constant_1rye60_a1g0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_56() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1g0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-nodePlacement-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_53() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.nodePlacementStrategy$B9EB;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no nodePlacementStrategy>");
      editorCell.setCellId("property_nodePlacementStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_66() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c6a");
    editorCell.addEditorCell(createConstant_71());
    editorCell.addEditorCell(createReadOnlyModelAccessor_57());
    editorCell.addEditorCell(createProperty_54());
    return editorCell;
  }
  private EditorCell createConstant_71() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge straightening");
    editorCell.setCellId("Constant_1rye60_a2g0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_57() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2g0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-nodePlacement-bk-edgeStraightening.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_54() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.bkEdgeStraightening$_o1e;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no bkEdgeStraightening>");
      editorCell.setCellId("property_bkEdgeStraightening");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_67() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d6a");
    editorCell.addEditorCell(createConstant_72());
    editorCell.addEditorCell(createReadOnlyModelAccessor_58());
    editorCell.addEditorCell(createProperty_55());
    return editorCell;
  }
  private EditorCell createConstant_72() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "fixed alignment");
    editorCell.setCellId("Constant_1rye60_a3g0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_58() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3g0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-nodePlacement-bk-fixedAlignment.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_55() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.bkFixedAlignment$gwHd;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no bkFixedAlignment>");
      editorCell.setCellId("property_bkFixedAlignment");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_68() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e6a");
    editorCell.addEditorCell(createConstant_73());
    editorCell.addEditorCell(createReadOnlyModelAccessor_59());
    editorCell.addEditorCell(createProperty_56());
    return editorCell;
  }
  private EditorCell createConstant_73() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "favour straight edges over Balancing");
    editorCell.setCellId("Constant_1rye60_a4g0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_59() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4g0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-nodePlacement-favorStraightEdges.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_56() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.favorStraightEdgesOverBalancing$xf$o;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no favorStraightEdgesOverBalancing>");
      editorCell.setCellId("property_favorStraightEdgesOverBalancing");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_69() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f6a");
    editorCell.addEditorCell(createConstant_74());
    editorCell.addEditorCell(createReadOnlyModelAccessor_60());
    editorCell.addEditorCell(createProperty_57());
    return editorCell;
  }
  private EditorCell createConstant_74() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "linear segments deflection dampening");
    editorCell.setCellId("Constant_1rye60_a5g0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_60() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5g0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-nodePlacement-linearSegments-deflectionDampening.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_57() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.linearSegmentDeflectionDampening$Qb2S;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no linearSegmentDeflectionDampening>");
      editorCell.setCellId("property_linearSegmentDeflectionDampening");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_70() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g6a");
    editorCell.addEditorCell(createConstant_75());
    editorCell.addEditorCell(createReadOnlyModelAccessor_61());
    editorCell.addEditorCell(createProperty_58());
    return editorCell;
  }
  private EditorCell createConstant_75() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node flexibility default");
    editorCell.setCellId("Constant_1rye60_a6g0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_61() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6g0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-nodePlacement-networkSimplex-nodeFlexibility-default.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_58() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.nodeFlexibilityDefault$7O2B;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no nodeFlexibilityDefault>");
      editorCell.setCellId("property_nodeFlexibilityDefault");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_76() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node placement (...)");
    editorCell.setCellId("Constant_1rye60_a6a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_71() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_h0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_81());
    editorCell.addEditorCell(createConstant_77());
    editorCell.addEditorCell(createCollection_72());
    editorCell.addEditorCell(createCollection_73());
    editorCell.addEditorCell(createCollection_74());
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private EditorCell createConstant_77() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "compaction");
    editorCell.setCellId("Constant_1rye60_a7a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_72() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b7a");
    editorCell.addEditorCell(createConstant_78());
    editorCell.addEditorCell(createReadOnlyModelAccessor_62());
    editorCell.addEditorCell(createProperty_59());
    return editorCell;
  }
  private EditorCell createConstant_78() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "connected components compaction");
    editorCell.setCellId("Constant_1rye60_a1h0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_62() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1h0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-compaction-connectedComponents.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_59() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.connectedComponentsCompaction$ANl8;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no connectedComponentsCompaction>");
      editorCell.setCellId("property_connectedComponentsCompaction");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_73() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c7a");
    editorCell.addEditorCell(createConstant_79());
    editorCell.addEditorCell(createReadOnlyModelAccessor_63());
    editorCell.addEditorCell(createProperty_60());
    return editorCell;
  }
  private EditorCell createConstant_79() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "post-compaction constraint calculation");
    editorCell.setCellId("Constant_1rye60_a2h0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_63() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2h0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-compaction-postCompaction-constraints.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_60() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.postCompactionConstraintCalculation$WLIB;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no postCompactionConstraintCalculation>");
      editorCell.setCellId("property_postCompactionConstraintCalculation");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_74() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d7a");
    editorCell.addEditorCell(createConstant_80());
    editorCell.addEditorCell(createReadOnlyModelAccessor_64());
    editorCell.addEditorCell(createProperty_61());
    return editorCell;
  }
  private EditorCell createConstant_80() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "post-compaction strategy");
    editorCell.setCellId("Constant_1rye60_a3h0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_64() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3h0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-compaction-postCompaction-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_61() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.postCompactionStrategy$AHLk;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no postCompactionStrategy>");
      editorCell.setCellId("property_postCompactionStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_81() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "compaction (...)");
    editorCell.setCellId("Constant_1rye60_a7a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_75() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_i0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_89());
    editorCell.addEditorCell(createConstant_82());
    editorCell.addEditorCell(createCollection_76());
    if (nodeCondition_1rye60_a2i0()) {
      editorCell.addEditorCell(createCollection_77());
    }
    editorCell.addEditorCell(createCollection_78());
    if (nodeCondition_1rye60_a4i0()) {
      editorCell.addEditorCell(createCollection_79());
    }
    if (nodeCondition_1rye60_a5i0()) {
      editorCell.addEditorCell(createCollection_80());
    }
    editorCell.addEditorCell(createCollection_81());
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a2i0() {
    return SPropertyOperations.getBoolean(myNode, PROPS.separateConnectedComponents$BBR6);
  }
  private boolean nodeCondition_1rye60_a4i0() {
    return !(SPropertyOperations.getEnum(myNode, PROPS.considerModelOrderStrategy$jshb) == null) && !(SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.considerModelOrderStrategy$jshb), 0x32d28aa5f456011fL));
  }
  private boolean nodeCondition_1rye60_a5i0() {
    return !(SPropertyOperations.getEnum(myNode, PROPS.considerModelOrderStrategy$jshb) == null) && !(SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.considerModelOrderStrategy$jshb), 0x32d28aa5f456011fL));
  }
  private EditorCell createConstant_82() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "consider model order");
    editorCell.setCellId("Constant_1rye60_a8a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_76() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b8a");
    editorCell.addEditorCell(createConstant_83());
    editorCell.addEditorCell(createReadOnlyModelAccessor_65());
    editorCell.addEditorCell(createProperty_62());
    return editorCell;
  }
  private EditorCell createConstant_83() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "consider model order");
    editorCell.setCellId("Constant_1rye60_a1i0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_65() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1i0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-considerModelOrder-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_62() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.considerModelOrderStrategy$jshb;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no considerModelOrderStrategy>");
      editorCell.setCellId("property_considerModelOrderStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_77() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c8a");
    editorCell.addEditorCell(createConstant_84());
    editorCell.addEditorCell(createReadOnlyModelAccessor_66());
    editorCell.addEditorCell(createProperty_63());
    return editorCell;
  }
  private EditorCell createConstant_84() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "consider model order for components");
    editorCell.setCellId("Constant_1rye60_a2i0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_66() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2i0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-considerModelOrder-components.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_63() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.considerModelOrderForComponents$yX_F;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no considerModelOrderForComponents>");
      editorCell.setCellId("property_considerModelOrderForComponents");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_78() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d8a");
    editorCell.addEditorCell(createConstant_85());
    editorCell.addEditorCell(createReadOnlyModelAccessor_67());
    editorCell.addEditorCell(createProperty_64());
    return editorCell;
  }
  private EditorCell createConstant_85() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "consider port order");
    editorCell.setCellId("Constant_1rye60_a3i0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_67() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3i0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-considerModelOrder-portModelOrder.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_64() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.considerPortOrder$cK0J;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no considerPortOrder>");
      editorCell.setCellId("property_considerPortOrder");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_79() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e8a");
    editorCell.addEditorCell(createConstant_86());
    editorCell.addEditorCell(createReadOnlyModelAccessor_68());
    editorCell.addEditorCell(createProperty_65());
    return editorCell;
  }
  private EditorCell createConstant_86() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "crossing counter node order influence");
    editorCell.setCellId("Constant_1rye60_a4i0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_68() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4i0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-considerModelOrder-crossingCounterNodeInfluence.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_65() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.crossingCounterNodeInfluence$Roi8;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no crossingCounterNodeInfluence>");
      editorCell.setCellId("property_crossingCounterNodeInfluence");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_80() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f8a");
    editorCell.addEditorCell(createConstant_87());
    editorCell.addEditorCell(createReadOnlyModelAccessor_69());
    editorCell.addEditorCell(createProperty_66());
    return editorCell;
  }
  private EditorCell createConstant_87() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "crossing counter port order influence");
    editorCell.setCellId("Constant_1rye60_a5i0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_69() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5i0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-considerModelOrder-crossingCounterPortInfluence.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_66() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.crossingCounterPortInfluence$$W76;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no crossingCounterPortInfluence>");
      editorCell.setCellId("property_crossingCounterPortInfluence");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_81() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g8a");
    editorCell.addEditorCell(createConstant_88());
    editorCell.addEditorCell(createReadOnlyModelAccessor_70());
    editorCell.addEditorCell(createProperty_67());
    return editorCell;
  }
  private EditorCell createConstant_88() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "long edge ordering strategy");
    editorCell.setCellId("Constant_1rye60_a6i0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_70() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6i0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-considerModelOrder-longEdgeStrategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_67() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.longEdgeOrderingStrategy$BdZH;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no longEdgeOrderingStrategy>");
      editorCell.setCellId("property_longEdgeOrderingStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_89() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "consider model order (...)");
    editorCell.setCellId("Constant_1rye60_a8a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_82() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_j0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_98());
    editorCell.addEditorCell(createConstant_90());
    editorCell.addEditorCell(createCollection_83());
    editorCell.addEditorCell(createCollection_84());
    if (nodeCondition_1rye60_a3j0()) {
      editorCell.addEditorCell(createCollection_85());
    }
    if (nodeCondition_1rye60_a4j0()) {
      editorCell.addEditorCell(createCollection_86());
    }
    if (nodeCondition_1rye60_a5j0()) {
      editorCell.addEditorCell(createCollection_87());
    }
    if (nodeCondition_1rye60_a6j0()) {
      editorCell.addEditorCell(createCollection_88());
    }
    if (nodeCondition_1rye60_a7j0()) {
      editorCell.addEditorCell(createCollection_89());
    }
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a3j0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.crossingMinimizationStrategy$kXP_), 0x32d28aa5f456214cL);
  }
  private boolean nodeCondition_1rye60_a4j0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.crossingMinimizationStrategy$kXP_), 0x32d28aa5f456214cL) && SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.hierarchyHandling$PAbb), 0x6135d43060ac269aL);
  }
  private boolean nodeCondition_1rye60_a5j0() {
    return !(SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.greedySwitchCrossingminimization$G0SC), 0x32d28aa5f4567f54L));
  }
  private boolean nodeCondition_1rye60_a6j0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.hierarchyHandling$PAbb), 0x6135d43060ac269aL);
  }
  private boolean nodeCondition_1rye60_a7j0() {
    return SEnumOperations.isMember(SPropertyOperations.getEnum(myNode, PROPS.crossingMinimizationStrategy$kXP_), 0x32d28aa5f456214cL);
  }
  private EditorCell createConstant_90() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "crossing minimization");
    editorCell.setCellId("Constant_1rye60_a9a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_83() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b9a");
    editorCell.addEditorCell(createConstant_91());
    editorCell.addEditorCell(createReadOnlyModelAccessor_71());
    editorCell.addEditorCell(createProperty_68());
    return editorCell;
  }
  private EditorCell createConstant_91() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "crossing minimization strategy");
    editorCell.setCellId("Constant_1rye60_a1j0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_71() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1j0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-crossingMinimization-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_68() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.crossingMinimizationStrategy$kXP_;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no crossingMinimizationStrategy>");
      editorCell.setCellId("property_crossingMinimizationStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_84() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c9a");
    editorCell.addEditorCell(createConstant_92());
    editorCell.addEditorCell(createReadOnlyModelAccessor_72());
    editorCell.addEditorCell(createProperty_69());
    return editorCell;
  }
  private EditorCell createConstant_92() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "force node model order");
    editorCell.setCellId("Constant_1rye60_a2j0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_72() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2j0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-crossingMinimization-forceNodeModelOrder.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_69() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.forceNodeModelOrder$qLPJ;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no forceNodeModelOrder>");
      editorCell.setCellId("property_forceNodeModelOrder");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_85() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d9a");
    editorCell.addEditorCell(createConstant_93());
    editorCell.addEditorCell(createReadOnlyModelAccessor_73());
    editorCell.addEditorCell(createProperty_70());
    return editorCell;
  }
  private EditorCell createConstant_93() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "greedy crossing minimization");
    editorCell.setCellId("Constant_1rye60_a3j0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_73() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3j0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-crossingMinimization-greedySwitch-type.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_70() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.greedySwitchCrossingminimization$G0SC;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no greedySwitchCrossingminimization>");
      editorCell.setCellId("property_greedySwitchCrossingminimization");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_86() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_e9a");
    editorCell.addEditorCell(createConstant_94());
    editorCell.addEditorCell(createReadOnlyModelAccessor_74());
    editorCell.addEditorCell(createProperty_71());
    return editorCell;
  }
  private EditorCell createConstant_94() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "crossing minimization (hierarchical)");
    editorCell.setCellId("Constant_1rye60_a4j0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_74() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b4j0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-crossingMinimization-greedySwitchHierarchical-type.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_71() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.greedySwitchCrossingminimizationHierarchical$wbIL;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no greedySwitchCrossingminimizationHierarchical>");
      editorCell.setCellId("property_greedySwitchCrossingminimizationHierarchical");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_87() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_f9a");
    editorCell.addEditorCell(createConstant_95());
    editorCell.addEditorCell(createReadOnlyModelAccessor_75());
    editorCell.addEditorCell(createProperty_72());
    return editorCell;
  }
  private EditorCell createConstant_95() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "activation threshold");
    editorCell.setCellId("Constant_1rye60_a5j0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_75() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b5j0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-crossingMinimization-greedySwitch-activationThreshold.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_72() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.greedySwitchActivationThreshold$KJ_h;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no greedySwitchActivationThreshold>");
      editorCell.setCellId("property_greedySwitchActivationThreshold");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_88() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_g9a");
    editorCell.addEditorCell(createConstant_96());
    editorCell.addEditorCell(createReadOnlyModelAccessor_76());
    editorCell.addEditorCell(createProperty_73());
    return editorCell;
  }
  private EditorCell createConstant_96() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "hierarchical sweepiness");
    editorCell.setCellId("Constant_1rye60_a6j0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_76() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b6j0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-crossingMinimization-hierarchicalSweepiness.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_73() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.hierarchicalSweepiness$Sa8X;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no hierarchicalSweepiness>");
      editorCell.setCellId("property_hierarchicalSweepiness");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_89() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_h9a");
    editorCell.addEditorCell(createConstant_97());
    editorCell.addEditorCell(createReadOnlyModelAccessor_77());
    editorCell.addEditorCell(createProperty_74());
    return editorCell;
  }
  private EditorCell createConstant_97() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "semi-interactive crossing minimization");
    editorCell.setCellId("Constant_1rye60_a7j0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_77() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b7j0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-crossingMinimization-semiInteractive.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_74() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.semiInteractiveCrossingMinimization$R0A7;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no semiInteractiveCrossingMinimization>");
      editorCell.setCellId("property_semiInteractiveCrossingMinimization");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_98() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "crossing minimization (...)");
    editorCell.setCellId("Constant_1rye60_a9a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_90() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_k0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_101());
    editorCell.addEditorCell(createConstant_99());
    editorCell.addEditorCell(createCollection_91());
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private EditorCell createConstant_99() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "cycle breaking");
    editorCell.setCellId("Constant_1rye60_a01a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_91() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b01a");
    editorCell.addEditorCell(createConstant_100());
    editorCell.addEditorCell(createReadOnlyModelAccessor_78());
    editorCell.addEditorCell(createProperty_75());
    return editorCell;
  }
  private EditorCell createConstant_100() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "cycle breaking strategy");
    editorCell.setCellId("Constant_1rye60_a1k0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_78() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1k0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-cycleBreaking-strategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_75() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.cycleBreakingStrategy$xPET;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no cycleBreakingStrategy>");
      editorCell.setCellId("property_cycleBreakingStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_101() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "cycle breaking (...)");
    editorCell.setCellId("Constant_1rye60_a01a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_92() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_l0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_105());
    editorCell.addEditorCell(createConstant_102());
    editorCell.addEditorCell(createCollection_93());
    editorCell.addEditorCell(createCollection_94());
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private EditorCell createConstant_102() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge labels");
    editorCell.setCellId("Constant_1rye60_a11a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_93() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b11a");
    editorCell.addEditorCell(createConstant_103());
    editorCell.addEditorCell(createReadOnlyModelAccessor_79());
    editorCell.addEditorCell(createProperty_76());
    return editorCell;
  }
  private EditorCell createConstant_103() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge center label placement strategy");
    editorCell.setCellId("Constant_1rye60_a1l0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_79() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1l0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-edgeLabels-centerLabelPlacementStrategy.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_76() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeCenterLabelPlacementStrategy$h_yJ;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeCenterLabelPlacementStrategy>");
      editorCell.setCellId("property_edgeCenterLabelPlacementStrategy");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_94() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c11a");
    editorCell.addEditorCell(createConstant_104());
    editorCell.addEditorCell(createReadOnlyModelAccessor_80());
    editorCell.addEditorCell(createProperty_77());
    return editorCell;
  }
  private EditorCell createConstant_104() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge-label side selection");
    editorCell.setCellId("Constant_1rye60_a2l0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_80() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2l0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-edgeLabels-sideSelection.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_77() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeLabelSideSelection$UF6d;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeLabelSideSelection>");
      editorCell.setCellId("property_edgeLabelSideSelection");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_105() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge labels (...)");
    editorCell.setCellId("Constant_1rye60_a11a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_95() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_m0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_108());
    editorCell.addEditorCell(createConstant_106());
    editorCell.addEditorCell(createCollection_96());
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private EditorCell createConstant_106() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge");
    editorCell.setCellId("Constant_1rye60_a21a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_96() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b21a");
    editorCell.addEditorCell(createConstant_107());
    editorCell.addEditorCell(createReadOnlyModelAccessor_81());
    editorCell.addEditorCell(createProperty_78());
    return editorCell;
  }
  private EditorCell createConstant_107() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge thickness");
    editorCell.setCellId("Constant_1rye60_a1m0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_81() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1m0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-edge-thickness.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_78() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.edgeThickness$VxOQ;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no edgeThickness>");
      editorCell.setCellId("property_edgeThickness");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_108() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "edge (...)");
    editorCell.setCellId("Constant_1rye60_a21a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_97() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_n0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_111());
    editorCell.addEditorCell(createConstant_109());
    editorCell.addEditorCell(createCollection_98());
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private EditorCell createConstant_109() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node labels");
    editorCell.setCellId("Constant_1rye60_a31a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_98() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b31a");
    editorCell.addEditorCell(createConstant_110());
    editorCell.addEditorCell(createReadOnlyModelAccessor_82());
    editorCell.addEditorCell(createRefNode_3());
    return editorCell;
  }
  private EditorCell createConstant_110() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node-label padding");
    editorCell.setCellId("Constant_1rye60_a1n0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_82() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1n0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-nodeLabels-padding.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createRefNode_3() {
    SingleRoleCellProvider provider = new nodeLabelPaddingSingleRoleHandler_1rye60_c1n0(myNode, LINKS.nodeLabelPadding$hjEA, getEditorContext());
    return provider.createCell();
  }
  private static class nodeLabelPaddingSingleRoleHandler_1rye60_c1n0 extends SingleRoleCellProvider {
    @NotNull
    private SNode myNode;

    public nodeLabelPaddingSingleRoleHandler_1rye60_c1n0(SNode ownerNode, SContainmentLink containmentLink, EditorContext context) {
      super(containmentLink, context);
      myNode = ownerNode;
    }

    @Override
    @NotNull
    public SNode getNode() {
      return myNode;
    }

    protected EditorCell createChildCell(SNode child) {
      EditorCell editorCell = getUpdateSession().updateChildNodeCell(child);
      editorCell.setAction(CellActionType.DELETE, new CellAction_DeleteSmart(getNode(), LINKS.nodeLabelPadding$hjEA, child));
      editorCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteSmart(getNode(), LINKS.nodeLabelPadding$hjEA, child));
      installCellInfo(child, editorCell, false);
      return editorCell;
    }



    private void installCellInfo(SNode child, EditorCell editorCell, boolean isEmpty) {
      if (editorCell.getSubstituteInfo() == null || editorCell.getSubstituteInfo() instanceof DefaultSubstituteInfo) {
        editorCell.setSubstituteInfo((isEmpty ? new SEmptyContainmentSubstituteInfo(editorCell) : new SChildSubstituteInfo(editorCell)));
      }
      if (editorCell.getSRole() == null) {
        editorCell.setSRole(LINKS.nodeLabelPadding$hjEA);
      }
    }
    @Override
    protected EditorCell createEmptyCell() {
      getCellFactory().pushCellContext();
      getCellFactory().setNodeLocation(new SNodeLocation.FromParentAndLink(getNode(), LINKS.nodeLabelPadding$hjEA));
      try {
        EditorCell editorCell = super.createEmptyCell();
        editorCell.setCellId("empty_nodeLabelPadding");
        installCellInfo(null, editorCell, true);
        setCellContext(editorCell);
        return editorCell;
      } finally {
        getCellFactory().popCellContext();
      }
    }
    protected String getNoTargetText() {
      return "<no nodeLabelPadding>";
    }
  }
  private EditorCell createConstant_111() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "node labels (...)");
    editorCell.setCellId("Constant_1rye60_a31a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_99() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_o0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_116());
    editorCell.addEditorCell(createConstant_112());
    editorCell.addEditorCell(createCollection_100());
    if (nodeCondition_1rye60_a2o0()) {
      editorCell.addEditorCell(createCollection_101());
    }
    if (nodeCondition_1rye60_a3o0()) {
      editorCell.addEditorCell(createCollection_102());
    }
    editorCell.setInitiallyCollapsed(true);
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a2o0() {
    return SPropertyOperations.getBoolean(myNode, PROPS.highDegreeNodeTreatment$nX_d);
  }
  private boolean nodeCondition_1rye60_a3o0() {
    return SPropertyOperations.getBoolean(myNode, PROPS.highDegreeNodeTreatment$nX_d);
  }
  private EditorCell createConstant_112() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "high degree nodes");
    editorCell.setCellId("Constant_1rye60_a41a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_100() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b41a");
    editorCell.addEditorCell(createConstant_113());
    editorCell.addEditorCell(createReadOnlyModelAccessor_83());
    editorCell.addEditorCell(createProperty_79());
    return editorCell;
  }
  private EditorCell createConstant_113() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "high degree node treatment");
    editorCell.setCellId("Constant_1rye60_a1o0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_83() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1o0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-highDegreeNodes-treatment.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_79() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.highDegreeNodeTreatment$nX_d;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no highDegreeNodeTreatment>");
      editorCell.setCellId("property_highDegreeNodeTreatment");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_101() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c41a");
    editorCell.addEditorCell(createConstant_114());
    editorCell.addEditorCell(createReadOnlyModelAccessor_84());
    editorCell.addEditorCell(createProperty_80());
    return editorCell;
  }
  private EditorCell createConstant_114() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "high degree node maximum tree height");
    editorCell.setCellId("Constant_1rye60_a2o0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_84() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2o0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-highDegreeNodes-treeHeight.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_80() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.highDegreeNodeMaximumTreeHeight$UHob;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no highDegreeNodeMaximumTreeHeight>");
      editorCell.setCellId("property_highDegreeNodeMaximumTreeHeight");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_102() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_d41a");
    editorCell.addEditorCell(createConstant_115());
    editorCell.addEditorCell(createReadOnlyModelAccessor_85());
    editorCell.addEditorCell(createProperty_81());
    return editorCell;
  }
  private EditorCell createConstant_115() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "high degree node threshold");
    editorCell.setCellId("Constant_1rye60_a3o0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_85() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b3o0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-layered-highDegreeNodes-threshold.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_81() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.highDegreeNodeThreshold$Ih2H;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no highDegreeNodeThreshold>");
      editorCell.setCellId("property_highDegreeNodeThreshold");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_116() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "high degree nodes (...)");
    editorCell.setCellId("Constant_1rye60_a41a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_103() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Vertical());
    editorCell.setCellId("Collection_1rye60_p0");
    Style style = new StyleImpl();
    style.set(StyleAttributes.SELECTABLE, false);
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    editorCell.setGridLayout(true);
    editorCell.setFoldable(true);
    editorCell.setFoldedCell(createConstant_120());
    editorCell.addEditorCell(createConstant_117());
    if (nodeCondition_1rye60_a1p0()) {
      editorCell.addEditorCell(createCollection_104());
    }
    editorCell.addEditorCell(createCollection_105());
    return editorCell;
  }
  private boolean nodeCondition_1rye60_a1p0() {
    return SPropertyOperations.getBoolean(myNode, PROPS.activateLayoutPartitioning$qy14);
  }
  private EditorCell createConstant_117() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "partitioning");
    editorCell.setCellId("Constant_1rye60_a51a");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createCollection_104() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_b51a");
    editorCell.addEditorCell(createConstant_118());
    editorCell.addEditorCell(createReadOnlyModelAccessor_86());
    editorCell.addEditorCell(createProperty_82());
    return editorCell;
  }
  private EditorCell createConstant_118() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "layout partition");
    editorCell.setCellId("Constant_1rye60_a1p0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_86() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b1p0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-partitioning-partition.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_82() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.layoutPartition$OgBa;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, true), myNode);
      editorCell.setDefaultText("<not defined>");
      editorCell.setCellId("property_layoutPartition");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createCollection_105() {
    EditorCell_Collection editorCell = new EditorCell_Collection(getEditorContext(), myNode, new CellLayout_Horizontal());
    editorCell.setCellId("Collection_1rye60_c51a");
    editorCell.addEditorCell(createConstant_119());
    editorCell.addEditorCell(createReadOnlyModelAccessor_87());
    editorCell.addEditorCell(createProperty_83());
    return editorCell;
  }
  private EditorCell createConstant_119() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "activiate layout partitioning");
    editorCell.setCellId("Constant_1rye60_a2p0");
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createReadOnlyModelAccessor_87() {
    EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new ModelAccessor.ReadOnly() {
      public String getText() {
        return "(?)";
      }
    }, myNode);
    editorCell.setAction(CellActionType.DELETE, EmptyCellAction.getInstance());
    editorCell.setAction(CellActionType.BACKSPACE, EmptyCellAction.getInstance());
    editorCell.setCellId("ReadOnlyModelAccessor_1rye60_b2p0");
    Style style = new StyleImpl();
    new AnnotationStyleClass(this).apply(style, editorCell);
    style.set(StyleAttributes.URL, "https://eclipse.dev/elk/reference/options/org-eclipse-elk-partitioning-activate.html");
    style.set(StyleAttributes.EDITABLE, false);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }
  private EditorCell createProperty_83() {
    getCellFactory().pushCellContext();
    try {
      final SProperty property = PROPS.activateLayoutPartitioning$qy14;
      getCellFactory().setPropertyInfo(new SPropertyInfo(myNode, property));
      EditorCell_Property editorCell = EditorCell_Property.create(getEditorContext(), new SPropertyAccessor(myNode, property, false, false), myNode);
      editorCell.setDefaultText("<no activateLayoutPartitioning>");
      editorCell.setCellId("property_activateLayoutPartitioning");
      editorCell.setSubstituteInfo(new SPropertySubstituteInfo(editorCell, property));
      setCellContext(editorCell);
      Iterable<SNode> propertyAttributes = SNodeOperations.ofConcept(new IAttributeDescriptor.AllAttributes().list(myNode), CONCEPTS.PropertyAttribute$Gb);
      Iterable<SNode> currentPropertyAttributes = Sequence.fromIterable(propertyAttributes).where((it) -> Objects.equals(PropertyAttribute__BehaviorDescriptor.getProperty_id1avfQ4BBzOo.invoke(it), property));
      if (Sequence.fromIterable(currentPropertyAttributes).isNotEmpty()) {
        EditorManager manager = EditorManager.getInstanceFromContext(getEditorContext());
        return manager.createNodeRoleAttributeCell(Sequence.fromIterable(currentPropertyAttributes).first(), AttributeKind.PROPERTY, editorCell);
      } else
      return editorCell;
    } finally {
      getCellFactory().popCellContext();
    }
  }
  private EditorCell createConstant_120() {
    EditorCell_Constant editorCell = new EditorCell_Constant(getEditorContext(), myNode, "partitioning (...)");
    editorCell.setCellId("Constant_1rye60_a51a_0");
    Style style = new StyleImpl();
    new headerStyleClass(this).apply(style, editorCell);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createComponent_0() {
    EditorCell editorCell = getCellFactory().createEditorComponentCell(myNode, "de.itemis.mps.editor.diagram.editor.TopdownOptions");
    Style style = new StyleImpl();
    style.set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), true);
    editorCell.getStyle().putAll(style);
    return editorCell;
  }

  private static final class PROPS {
    /*package*/ static final SProperty subdiagramDirection$brcK = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x1ca65386c5315f38L, "subdiagramDirection");
    /*package*/ static final SProperty aspectRatio$chOg = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455e08dL, "aspectRatio");
    /*package*/ static final SProperty direction$6zrN = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4562f7fL, "direction");
    /*package*/ static final SProperty fixedGraphSize$Sm5c = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4566683L, "fixedGraphSize");
    /*package*/ static final SProperty hierarchyHandling$PAbb = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x152fc8e2adc2509bL, "hierarchyHandling");
    /*package*/ static final SProperty interactiveLayout$60Kb = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4569f9dL, "interactiveLayout");
    /*package*/ static final SProperty randomizationSeed$gPKD = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4571f18L, "randomizationSeed");
    /*package*/ static final SProperty separateConnectedComponents$BBR6 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4572679L, "separateConnectedComponents");
    /*package*/ static final SProperty crossingMinimizationStrategy$kXP_ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4561efcL, "crossingMinimizationStrategy");
    /*package*/ static final SProperty cycleBreakingStrategy$xPET = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x2a088652834333c8L, "cycleBreakingStrategy");
    /*package*/ static final SProperty addUnnecessaryBendpoints$7ZdF = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45574aeL, "addUnnecessaryBendpoints");
    /*package*/ static final SProperty directionCongruence$CQhK = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456321bL, "directionCongruence");
    /*package*/ static final SProperty feedbackEdges$ijeg = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456636fL, "feedbackEdges");
    /*package*/ static final SProperty generatePositionAndLayerIDs$1q0a = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4566c7aL, "generatePositionAndLayerIDs");
    /*package*/ static final SProperty interactiveReferencePoint$xHje = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456a28cL, "interactiveReferencePoint");
    /*package*/ static final SProperty mergeEdges$XlA3 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456de3bL, "mergeEdges");
    /*package*/ static final SProperty mergeHierarchyCrossingEdges$AZzo = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456e1b6L, "mergeHierarchyCrossingEdges");
    /*package*/ static final SProperty portSortingStrategy$UqEZ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4571067L, "portSortingStrategy");
    /*package*/ static final SProperty thoroughness$1WJ$ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45738fcL, "thoroughness");
    /*package*/ static final SProperty nodeLayeringStrategy$SLA5 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456ee7bL, "nodeLayeringStrategy");
    /*package*/ static final SProperty nodePromotionStrategy$NuCw = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45704efL, "nodePromotionStrategy");
    /*package*/ static final SProperty layerBound$k$mj = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456ad39L, "layerBound");
    /*package*/ static final SProperty maxNodePromotionIterations$muqC = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456dadbL, "maxNodePromotionIterations");
    /*package*/ static final SProperty upperBoundOnWidthMinWidthLayerer$sX9c = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f457422bL, "upperBoundOnWidthMinWidthLayerer");
    /*package*/ static final SProperty upperLayerEstimationScalingFactorMinWidthLayerer$hdBH = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45746dbL, "upperLayerEstimationScalingFactorMinWidthLayerer");
    /*package*/ static final SProperty edgeRouting$n5ng = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x152fc8e2adc25938L, "edgeRouting");
    /*package*/ static final SProperty splineRoutingMode$ohBa = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f457357cL, "splineRoutingMode");
    /*package*/ static final SProperty slopedEdgeZoneWidth$k3cf = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4572a1eL, "slopedEdgeZoneWidth");
    /*package*/ static final SProperty sloppySplineLayerSpacingFactor$XQ4a = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4572daaL, "sloppySplineLayerSpacingFactor");
    /*package*/ static final SProperty commentCommentSpacing$4iFG = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455f06fL, "commentCommentSpacing");
    /*package*/ static final SProperty commentNodeSpacing$FfIw = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455f3d3L, "commentNodeSpacing");
    /*package*/ static final SProperty componentsSpacing$3t9G = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455f668L, "componentsSpacing");
    /*package*/ static final SProperty edgeEdgeBetweenLayersSpacing$9I0L = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45640c3L, "edgeEdgeBetweenLayersSpacing");
    /*package*/ static final SProperty edgeLabelSpacing$BRVD = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4564906L, "edgeLabelSpacing");
    /*package*/ static final SProperty edgeNodeBetweenLayersSpacing$dfBH = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4564be0L, "edgeNodeBetweenLayersSpacing");
    /*package*/ static final SProperty edgeNodeSpacing$Ydqc = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4565041L, "edgeNodeSpacing");
    /*package*/ static final SProperty edgeSpacing$AHr7 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45659d1L, "edgeSpacing");
    /*package*/ static final SProperty horizontalSpacingBetweenLabelAndPort$5Qx_ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45694ceL, "horizontalSpacingBetweenLabelAndPort");
    /*package*/ static final SProperty labelNodeSpacing$loWf = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456a73cL, "labelNodeSpacing");
    /*package*/ static final SProperty labelSpacing$LUJP = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456aa7bL, "labelSpacing");
    /*package*/ static final SProperty nodeNodeBetweenLayersSpacing$fzWI = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456f706L, "nodeNodeBetweenLayersSpacing");
    /*package*/ static final SProperty nodeSelfLoopSpacing$zpMz = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45708f1L, "nodeSelfLoopSpacing");
    /*package*/ static final SProperty nodeSpacing$pa7 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4570c5aL, "nodeSpacing");
    /*package*/ static final SProperty portSpacing$qeVA = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45713f4L, "portSpacing");
    /*package*/ static final SProperty spacingBaseValue$JnZ3 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f457323cL, "spacingBaseValue");
    /*package*/ static final SProperty verticalSpacingBetweenLabelAndPort$P333 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4575f7bL, "verticalSpacingBetweenLabelAndPort");
    /*package*/ static final SProperty graphWrappingStrategy$W_Ud = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45671e7L, "graphWrappingStrategy");
    /*package*/ static final SProperty cuttingStrategy$5Wl7 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4562360L, "cuttingStrategy");
    /*package*/ static final SProperty improveCuts$fKg = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45699f6L, "improveCuts");
    /*package*/ static final SProperty additionalWrappedEdgesSpacing$A6g$ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455dc40L, "additionalWrappedEdgesSpacing");
    /*package*/ static final SProperty correctionFactorForWrapping$d79c = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4561332L, "correctionFactorForWrapping");
    /*package*/ static final SProperty msdFreedom$y5P3 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456e720L, "msdFreedom");
    /*package*/ static final SProperty multiEdgeDistancePenalty$iEkK = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45635acL, "multiEdgeDistancePenalty");
    /*package*/ static final SProperty improveWrappedEdges$szeF = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4569c2dL, "improveWrappedEdges");
    /*package*/ static final SProperty validificationStrategy$G$E_ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45759bbL, "validificationStrategy");
    /*package*/ static final SProperty nodePlacementStrategy$B9EB = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456feb0L, "nodePlacementStrategy");
    /*package*/ static final SProperty bkEdgeStraightening$_o1e = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455e36cL, "bkEdgeStraightening");
    /*package*/ static final SProperty bkFixedAlignment$gwHd = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455ebedL, "bkFixedAlignment");
    /*package*/ static final SProperty favorStraightEdgesOverBalancing$xf$o = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4565f0aL, "favorStraightEdgesOverBalancing");
    /*package*/ static final SProperty linearSegmentDeflectionDampening$Qb2S = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456b5e1L, "linearSegmentDeflectionDampening");
    /*package*/ static final SProperty nodeFlexibilityDefault$7O2B = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456ea1bL, "nodeFlexibilityDefault");
    /*package*/ static final SProperty connectedComponentsCompaction$ANl8 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455f966L, "connectedComponentsCompaction");
    /*package*/ static final SProperty postCompactionConstraintCalculation$WLIB = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45716aaL, "postCompactionConstraintCalculation");
    /*package*/ static final SProperty postCompactionStrategy$AHLk = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4571b71L, "postCompactionStrategy");
    /*package*/ static final SProperty considerModelOrderStrategy$jshb = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f455fd1bL, "considerModelOrderStrategy");
    /*package*/ static final SProperty considerModelOrderForComponents$yX_F = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45603a3L, "considerModelOrderForComponents");
    /*package*/ static final SProperty considerPortOrder$cK0J = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4560856L, "considerPortOrder");
    /*package*/ static final SProperty crossingCounterNodeInfluence$Roi8 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45616ebL, "crossingCounterNodeInfluence");
    /*package*/ static final SProperty crossingCounterPortInfluence$$W76 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4561af3L, "crossingCounterPortInfluence");
    /*package*/ static final SProperty longEdgeOrderingStrategy$BdZH = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456ba43L, "longEdgeOrderingStrategy");
    /*package*/ static final SProperty greedySwitchCrossingminimization$G0SC = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4567c32L, "greedySwitchCrossingminimization");
    /*package*/ static final SProperty forceNodeModelOrder$qLPJ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4566930L, "forceNodeModelOrder");
    /*package*/ static final SProperty greedySwitchCrossingminimizationHierarchical$wbIL = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45680dfL, "greedySwitchCrossingminimizationHierarchical");
    /*package*/ static final SProperty greedySwitchActivationThreshold$KJ_h = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456768fL, "greedySwitchActivationThreshold");
    /*package*/ static final SProperty hierarchicalSweepiness$Sa8X = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456835eL, "hierarchicalSweepiness");
    /*package*/ static final SProperty semiInteractiveCrossingMinimization$R0A7 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4572239L, "semiInteractiveCrossingMinimization");
    /*package*/ static final SProperty edgeCenterLabelPlacementStrategy$h_yJ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4563b8eL, "edgeCenterLabelPlacementStrategy");
    /*package*/ static final SProperty edgeLabelSideSelection$UF6d = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4564521L, "edgeLabelSideSelection");
    /*package*/ static final SProperty edgeThickness$VxOQ = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4565c11L, "edgeThickness");
    /*package*/ static final SProperty highDegreeNodeTreatment$nX_d = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45690abL, "highDegreeNodeTreatment");
    /*package*/ static final SProperty highDegreeNodeMaximumTreeHeight$UHob = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f45688b6L, "highDegreeNodeMaximumTreeHeight");
    /*package*/ static final SProperty highDegreeNodeThreshold$Ih2H = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4568d25L, "highDegreeNodeThreshold");
    /*package*/ static final SProperty activateLayoutPartitioning$qy14 = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456b2ecL, "activateLayoutPartitioning");
    /*package*/ static final SProperty layoutPartition$OgBa = MetaAdapterFactory.getProperty(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456afc4L, "layoutPartition");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PropertyAttribute$Gb = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x2eb1ad060897da56L, "jetbrains.mps.lang.core.structure.PropertyAttribute");
    /*package*/ static final SConcept ContentAlignment$XK = MetaAdapterFactory.getConcept(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x5193e20464425027L, "de.itemis.mps.editor.diagram.structure.ContentAlignment");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink contentAlignment$sHX9 = MetaAdapterFactory.getContainmentLink(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4560f04L, "contentAlignment");
    /*package*/ static final SContainmentLink nodeSizeMinimumPadding$f2zx = MetaAdapterFactory.getContainmentLink(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x42db891317e61054L, "nodeSizeMinimumPadding");
    /*package*/ static final SContainmentLink additionalPortSpace$udd = MetaAdapterFactory.getContainmentLink(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4557a04L, "additionalPortSpace");
    /*package*/ static final SContainmentLink padding$yFy2 = MetaAdapterFactory.getContainmentLink(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f4570ef4L, "padding");
    /*package*/ static final SContainmentLink nodeLabelPadding$hjEA = MetaAdapterFactory.getContainmentLink(0xfa13cc63c4764d46L, 0x9c96d53670abe7bcL, 0x2e440a78c2836defL, 0x32d28aa5f456f15dL, "nodeLabelPadding");
  }
}

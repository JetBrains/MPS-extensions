package de.q60.mps.shadowmodels.runtime.util;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.RuntimeFlags;
import com.intellij.ide.util.PropertiesComponent;

public abstract class OptionalPlugin {
  private String settingsKey;
  private boolean moduleInititalized = false;
  private boolean pluginInitialized = false;
  private Set<OptionalPlugin> dependencies = SetSequence.fromSet(new HashSet<OptionalPlugin>());
  private Set<OptionalPlugin> reverseDependencies = SetSequence.fromSet(new HashSet<OptionalPlugin>());
  private boolean forceEnabled = false;
  private boolean forceDisabled = false;

  public OptionalPlugin() {
    settingsKey = getClass().getName() + ".ENABLED";
  }

  public OptionalPlugin(String settingsKey) {
    this.settingsKey = settingsKey;
  }

  public OptionalPlugin addDependency(OptionalPlugin other) {
    SetSequence.fromSet(dependencies).addElement(other);
    return this;
  }

  protected void addReverseDependency(OptionalPlugin other) {
    SetSequence.fromSet(reverseDependencies).addElement(other);
  }

  protected void removeReverseDependency(OptionalPlugin other) {
    SetSequence.fromSet(reverseDependencies).removeElement(other);
  }

  public boolean isEnabled() {
    if (forceEnabled) {
      return true;
    }
    if (forceDisabled) {
      return false;
    }

    boolean headless = ApplicationManager.getApplication().isHeadlessEnvironment() && !(RuntimeFlags.isTestMode());

    // for now we don't load plugins by default
    // code that requires a plugin can use .forceEnabled(true) before using it 
    headless = false;

    return moduleInititalized && (headless || isEnabledByUser() || isEnabledByDependencies());
  }

  public boolean isEnabledByDependencies() {
    return SetSequence.fromSet(reverseDependencies).any((it) -> it.isEnabled());
  }

  public boolean isEnabledByUser() {
    return PropertiesComponent.getInstance().getBoolean(settingsKey, false);
  }

  public void setEnabledByUser(boolean enabled) {
    PropertiesComponent.getInstance().setValue(settingsKey, enabled, false);
    if (!(enabled)) {
      SetSequence.fromSet(reverseDependencies).visitAll((it) -> it.setEnabledByUser(false));
    }
    applyStateChange();
    SetSequence.fromSet(dependencies).visitAll((it) -> it.applyStateChange());
  }

  public void forceEnabled(boolean enabled) {
    this.forceEnabled = enabled;
    applyStateChange();
    SetSequence.fromSet(dependencies).visitAll((it) -> it.applyStateChange());
  }

  public void forceDisabled(boolean disabled) {
    this.forceDisabled = disabled;
    if (disabled) {
      SetSequence.fromSet(reverseDependencies).visitAll((it) -> it.forceDisabled(true));
    }
    applyStateChange();
    SetSequence.fromSet(dependencies).visitAll((it) -> it.applyStateChange());
  }

  protected void applyStateChange() {
    if (moduleInititalized) {
      SetSequence.fromSet(dependencies).visitAll((it) -> it.addReverseDependency(OptionalPlugin.this));
    } else {
      SetSequence.fromSet(dependencies).visitAll((it) -> it.removeReverseDependency(OptionalPlugin.this));
    }

    if (isEnabled() && !(pluginInitialized)) {
      pluginInitialized = true;
      init();
    } else if (!(isEnabled()) && pluginInitialized) {
      pluginInitialized = false;
      dispose();
    }
  }

  public void moduleInitialized() {
    moduleInititalized = true;
    applyStateChange();
  }

  public void moduleDisposed() {
    moduleInititalized = false;
    applyStateChange();
  }

  public abstract void init();
  public abstract void dispose();
}

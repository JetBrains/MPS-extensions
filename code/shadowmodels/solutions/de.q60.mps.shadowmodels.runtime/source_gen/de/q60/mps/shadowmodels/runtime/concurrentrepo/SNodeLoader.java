package de.q60.mps.shadowmodels.runtime.concurrentrepo;

/*Generated by MPS */

import de.q60.mps.shadowmodels.runtime.model.persistent.SM_INodeLoader;
import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.module.SRepository;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_IncrementalIndex;
import org.jetbrains.mps.openapi.model.SNodeReference;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_UserObjectIndex;
import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_IWriteTransaction;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_IMissingNode;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_MissingNodeId;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PTree;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.modelix.model.api.INodeReference;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeAdapter;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.util.Objects;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import org.jetbrains.mps.openapi.model.SModel;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import org.modelix.model.mpsadapters.mps.SModelAsNode;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_ITransaction;

public class SNodeLoader implements SM_INodeLoader {
  private static final Logger LOG = Logger.getLogger(SNodeLoader.class);
  public static final String SOURCE_NODE_REF_KEY = "sourceNodeRef";
  public static final String DETACHED_ROLE = "detached";
  private SRepository repository;
  private SM_IncrementalIndex<SNodeReference> sourceNodeIndex = new SM_UserObjectIndex<SNodeReference>(SOURCE_NODE_REF_KEY);
  private List<_FunctionTypes._void_P1_E0<? super SM_IWriteTransaction>> pendingReferences = ListSequence.fromList(new ArrayList<_FunctionTypes._void_P1_E0<? super SM_IWriteTransaction>>());
  private boolean loadInProgress = false;

  public SNodeLoader(SRepository repository) {
    this.repository = repository;
  }

  protected boolean loadChildEagerly(SNode parent, SNode child) {
    return false;
  }

  @Override
  public void loadNode(SM_IMissingNode missingNode, SM_IWriteTransaction transaction) {
    if (missingNode instanceof SM_MissingNodeId) {
      loadNode(((SM_MissingNodeId) missingNode).getId(), transaction);
    } else if (missingNode instanceof MissingSNode) {
      SNodeReference ref = ((MissingSNode) missingNode).getRef();
      SNode node = ref.resolve(repository);
      if (node == null) {
        throw new RuntimeException("Failed to resolve " + ref);
      }
      ensureExists(node, transaction);
    }
  }

  @Override
  public void loadNode(long id, SM_IWriteTransaction transaction) {
    SNodeReference sourceNodeRef = (SNodeReference) transaction.getUserObject(id, SOURCE_NODE_REF_KEY);
    if (sourceNodeRef == null) {
      throw new RuntimeException("Node has no source node: " + id);
    }

    SNode sourceNode = sourceNodeRef.resolve(repository);
    if (sourceNode == null) {
      throw new RuntimeException("Failed to resolve node " + sourceNodeRef);
    }
    if (LOG.isDebugLevel()) {
      LOG.debug("Load " + sourceNode + " (" + sourceNode.getConcept() + ")");
    }
    ensureLoaded(sourceNode, id, transaction);
  }

  @Override
  public void runRead(final _FunctionTypes._void_P0_E0 r) {
    repository.getModelAccess().runReadAction(() -> r.invoke());
  }

  public void ensureLoaded(SNode inputSNode, long outputNode, SM_IWriteTransaction transaction) {
    if (!(((SM_PTree) transaction.getTree()).isLoaded(outputNode))) {
      updateNode(inputSNode, outputNode, transaction, false);
    }
  }

  public boolean isLoaded(SNode inputNode, SM_IWriteTransaction transaction) {
    Long id = indexGet(inputNode.getReference(), transaction);
    if (id == null) {
      return false;
    }
    return ((SM_PTree) transaction.getTree()).isLoaded(id);
  }

  public void updateNode(SNode inputSNode, long outputNode, SM_IWriteTransaction transaction, boolean updateDescendants) {
    boolean wasLoadInProgress = loadInProgress;
    try {
      loadInProgress = true;

      if (!(transaction.isLoaded(outputNode))) {
        transaction.loadNode(outputNode);
      }

      updateProperties(inputSNode, outputNode, transaction);
      updateReferences(inputSNode, outputNode, transaction);
      updateChildren(inputSNode, outputNode, transaction, updateDescendants);

      if (!(wasLoadInProgress)) {
        processPendingReferences(transaction);
      }
    } finally {
      loadInProgress = wasLoadInProgress;
    }
  }

  public void updateProperties(SNode inputSNode, long outputNode, SM_IWriteTransaction transaction) {
    SConcept concept = inputSNode.getConcept();
    for (SProperty property : CollectionSequence.fromCollection(concept.getProperties())) {
      transaction.setProperty(outputNode, property.getName(), inputSNode.getProperty(property));
    }
  }

  public void updateReferences(SNode inputSNode, final long outputNode, SM_IWriteTransaction transaction) {
    SConcept concept = inputSNode.getConcept();
    for (final SReferenceLink link : concept.getReferenceLinks()) {
      final SNode target = inputSNode.getReferenceTarget(link);
      ListSequence.fromList(pendingReferences).addElement(new _FunctionTypes._void_P1_E0<SM_IWriteTransaction>() {
        public void invoke(SM_IWriteTransaction transaction) {
          if (target != null) {
            ensureExists(target, transaction);
          }
          INodeReference outputTarget = (target == null ? null : new SM_PNodeAdapter(indexGet(target.getReference(), transaction), transaction.getBranch()).getReference());
          transaction.setReferenceTarget(outputNode, link.getName(), outputTarget);
        }
      });
    }
  }

  public void processPendingReferences(SM_IWriteTransaction transaction) {
    if (ListSequence.fromList(pendingReferences).isEmpty()) {
      return;
    }
    List<_FunctionTypes._void_P1_E0<? super SM_IWriteTransaction>> copy = pendingReferences;
    pendingReferences = ListSequence.fromList(new ArrayList<_FunctionTypes._void_P1_E0<? super SM_IWriteTransaction>>());
    for (_FunctionTypes._void_P1_E0<? super SM_IWriteTransaction> pending : ListSequence.fromList(copy)) {
      try {
        pending.invoke(transaction);
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("Failed to resolve reference", ex);
        }
      }
    }
  }

  public void updateChildren(SNode inputParent, long outputParent, SM_IWriteTransaction transaction, boolean updateDescendants) {
    SConcept concept = inputParent.getConcept();
    for (SContainmentLink link : CollectionSequence.fromCollection(concept.getContainmentLinks())) {
      updateChildren(inputParent, outputParent, link, transaction, updateDescendants);
    }
  }

  public void updateChildren(SNode inputParent, long outputParent, SContainmentLink link, final SM_IWriteTransaction t, boolean updateDescendants) {
    List<SNode> inputChildren = Sequence.fromIterable(((Iterable<SNode>) inputParent.getChildren(link))).toList();
    List<SNodeReference> expectedOutputChildren = ListSequence.fromList(inputChildren).select((it) -> it.getReference()).toList();
    Iterable<Long> outputChildren = t.getChildren(outputParent, link.getName());
    List<SNodeReference> existingOutputChildren = Sequence.fromIterable(outputChildren).select((it) -> (SNodeReference) t.getUserObject(it, SOURCE_NODE_REF_KEY)).toList();

    Set<SNode> childrenToUpdate = SetSequence.fromSet(new LinkedHashSet<SNode>());
    if (updateDescendants) {
      SetSequence.fromSet(childrenToUpdate).addSequence(ListSequence.fromList(inputChildren));
    }

    if (!(Objects.equals(existingOutputChildren, expectedOutputChildren))) {
      int index = 0;
      for (SNode inputChild : ListSequence.fromList(inputChildren)) {
        Long childId = indexGet(inputChild.getReference(), t);
        if (childId == null) {
          childId = t.addNewLazyChild(outputParent, link.getName(), index, SConceptAdapter.wrap(inputChild.getConcept()));
          t.setUserObject(childId, SOURCE_NODE_REF_KEY, inputChild.getReference());
          if (loadChildEagerly(inputParent, inputChild)) {
            SetSequence.fromSet(childrenToUpdate).addElement(inputChild);
          } else {
            SetSequence.fromSet(childrenToUpdate).removeElement(inputChild);
          }
        } else {
          t.moveChild(outputParent, link.getName(), index, childId);
        }
        index++;
      }
      Iterable<Long> outputChildren2 = t.getChildren(outputParent, link.getName());
      Sequence.fromIterable(outputChildren2).skip(index).visitAll((it) -> t.moveChild(SM_PTree.ROOT_ID, DETACHED_ROLE, -1, it));
    }

    for (SNode child : SetSequence.fromSet(childrenToUpdate)) {
      Long childId = indexGet(child.getReference(), t);
      updateNode(child, childId, t, updateDescendants);
    }
  }

  public long ensureExists(SNode inputNode, SM_IWriteTransaction transaction) {
    if (indexGet(inputNode.getReference(), transaction) == null) {
      SNode parent = inputNode.getParent();
      if (parent == null) {
        SModel model = inputNode.getModel();
        if (model != null) {
          parent = NodeToSNodeAdapter.wrap(new SModelAsNode(model), repository);
        }
      }
      if (parent == null) {
        throw new RuntimeException("Cannot load " + inputNode);
      }
      ensureExists(parent, transaction);
      Long parentIndex = indexGet(parent.getReference(), transaction);
      if (parentIndex == null) {
        throw new RuntimeException("Failed to load parent " + parent + " of " + inputNode);
      }
      ensureLoaded(parent, parentIndex, transaction);
    }

    Long id = indexGet(inputNode.getReference(), transaction);
    if (id == null) {
      throw new RuntimeException("Failed to load node " + inputNode + " (" + inputNode.getConcept() + ")");
    }
    return id;
  }

  public Long indexGet(SNodeReference key, SM_ITransaction transaction) {
    sourceNodeIndex = sourceNodeIndex.update((SM_PTree) transaction.getTree());
    Iterable<Long> matches = sourceNodeIndex.get(key);
    if (Sequence.fromIterable(matches).count() > 1) {
      throw new RuntimeException("Multiple nodes found for " + key);
    }
    return Sequence.fromIterable(matches).first();
  }
}

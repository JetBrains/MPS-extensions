package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import java.beans.PropertyChangeSupport;
import java.beans.PropertyChangeListener;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

/**
 * Maintains a list (lines) of lists of words. An empty MultilineText has a single line with one empty word.
 * Therefore an instance of this class always has at least one word.
 */
public class MultilineText {
  public static final String PROPERTY_TEXT = "text";
  public static final String PROPERTY_WORDS = "words";
  private PropertyChangeSupport myChangeSupport = new PropertyChangeSupport(this);
  private String myText;
  private String[][] myWords = textToWords(null);
  public MultilineText(String text) {
    setText(text);
  }
  public void addListener(PropertyChangeListener l) {
    myChangeSupport.addPropertyChangeListener(l);
  }
  public void addListener(String propertyName, PropertyChangeListener l) {
    myChangeSupport.addPropertyChangeListener(propertyName, l);
  }
  public void removeListener(PropertyChangeListener l) {
    myChangeSupport.removePropertyChangeListener(l);
  }
  public void removeListener(String propertyName, PropertyChangeListener l) {
    myChangeSupport.removePropertyChangeListener(propertyName, l);
  }
  public void setText(String newText) {
    if (newText == null) {
      newText = "";
    }
    String oldText = myText;
    String[][] oldWords = myWords;
    String[][] newWords = textToWords(newText);
    this.myWords = newWords;
    this.myText = newText;
    if (!(Objects.equals(newText, oldText))) {
      myChangeSupport.firePropertyChange(PROPERTY_TEXT, oldText, newText);
      myChangeSupport.firePropertyChange(PROPERTY_WORDS, oldWords, newWords);
    }
  }
  public void setTextSilently(String newText) {
    if (newText == null) {
      newText = "";
    }
    myText = newText;
    myWords = textToWords(newText);
  }
  public String getWord(int lineNum, int wordNum) {
    String[][] words = this.myWords;
    String word = null;
    if (lineNum < words.length) {
      if (wordNum < words[lineNum].length) {
        word = words[lineNum][wordNum];
      }
    }
    return word;
  }
  public String getWord(int wordNum) {
    String result = null;
    String[][] words = myWords;
    int remainingWordNum = wordNum;
    int lineNum = 0;
    for (String[] line : words) {
      if (remainingWordNum < line.length) {
        result = words[lineNum][remainingWordNum];
        break;
      } else {
        remainingWordNum -= line.length;
        ++lineNum;
      }
    }
    return result;
  }
  public void setWord(int lineNum, int wordNum, String newWord) {
    String[][] newWords = this.myWords;
    if (lineNum < newWords.length) {
      if (wordNum < newWords[lineNum].length) {
        newWords[lineNum][wordNum] = newWord;
      }
    }
    setWords(newWords);
  }
  public void setWord(int wordNum, String newWord) {
    String[][] newWords = this.myWords;
    int remainingWordNum = wordNum;
    int lineNum = 0;
    for (String[] line : newWords) {
      if (remainingWordNum < line.length) {
        newWords[lineNum][remainingWordNum] = newWord;
        break;
      } else {
        remainingWordNum -= line.length;
        ++lineNum;
      }
    }
    setWords(newWords);
  }
  public void setWords(String[][] newWords) {
    String oldText = myText;
    String[][] oldWords = myWords;
    String newText = IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(newWords)).select((line) -> IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(line)), " ")), "\n");
    myText = newText;
    myWords = newWords;
    if (!(Objects.equals(newText, oldText))) {
      myChangeSupport.firePropertyChange(PROPERTY_TEXT, oldText, newText);
      myChangeSupport.firePropertyChange(PROPERTY_WORDS, oldWords, newWords);
    }
  }
  public String[][] getWords() {
    return myWords;
  }
  public String getText() {
    return (myText == null ? "" : myText);
  }

  /**
   * Delete words from range [from, to], inclusive, where from and to are word numbers.
   *  {@code  deleteWords(2, 3)} will delete the third and fourth word.
   */
  public void deleteWords(int from, int to) {
    String[][] oldWords = myWords;
    List<String[]> newWords = ListSequence.fromList(new ArrayList<String[]>());
    IntRange rangeToRemove = new IntRange(from, to);
    IntRange lineRange = new IntRange(-1, -1);
    List<String> newLine = ListSequence.fromList(new ArrayList<String>());
    for (String[] line : oldWords) {
      lineRange = new IntRange(lineRange.getMaximum() + 1, lineRange.getMaximum() + line.length);
      if (lineRange.isOverlappedBy(rangeToRemove) || lineRange.containsRange(rangeToRemove)) {
        for (int wordNum = lineRange.getMinimum(); wordNum <= lineRange.getMaximum(); ++wordNum) {
          if (!(rangeToRemove.contains(wordNum))) {
            ListSequence.fromList(newLine).addElement(line[wordNum - lineRange.getMinimum()]);
          }
        }
        if (ListSequence.fromList(newLine).isNotEmpty() && rangeToRemove.getMaximum() <= lineRange.getMaximum()) {
          ListSequence.fromList(newWords).addElement(ListSequence.fromList(newLine).toGenericArray(String.class));
        }
      } else {
        ListSequence.fromList(newWords).addElement(line);
      }
    }
    setWords(newWords.toArray(new String[0][]));
  }

  /**
   * Split text into an array of lines where each line is an array of words. If text is null or empty, returns an array
   * of one array with one empty string.
   */
  private static String[][] textToWords(String text) {
    String[][] words;
    if ((text == null || text.length() == 0)) {
      words = new String[][]{{""}};
    } else {
      String[] lines = text.split("\\n", -1);
      words = new String[lines.length][];
      for (int lineNum = 0; lineNum < lines.length; ++lineNum) {
        words[lineNum] = lines[lineNum].split(" ", -1);
      }
    }
    return words;
  }

  public int getTotalWords() {
    return Sequence.fromIterable(Sequence.fromArray(myWords)).foldLeft(0, (Integer s, String[] it) -> s + it.length);
  }
}

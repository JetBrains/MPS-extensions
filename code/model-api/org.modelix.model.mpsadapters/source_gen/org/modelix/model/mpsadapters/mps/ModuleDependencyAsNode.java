package org.modelix.model.mpsadapters.mps;

/*Generated by MPS */

import org.modelix.model.api.INode;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConceptReference;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.area.IArea;
import org.modelix.model.api.INodeReference;
import org.modelix.model.api.IConcept;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import java.util.LinkedList;
import java.util.Collections;
import org.modelix.model.api.IChildLink;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import java.util.List;
import org.modelix.model.api.IProperty;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.modelix.model.api.IReferenceLink;
import org.jetbrains.mps.openapi.module.SModuleId;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class ModuleDependencyAsNode implements INode {
  private SModuleReference moduleReference;
  private int moduleVersion;
  private SModule importer;
  private boolean explicit;
  private boolean reexport;
  private SDependencyScope dependencyScope;

  public ModuleDependencyAsNode(SModuleReference moduleReference, int moduleVersion, boolean explicit, boolean reexport, SModule importer, SDependencyScope dependencyScope) {
    this.moduleReference = moduleReference;
    this.moduleVersion = moduleVersion;
    this.explicit = explicit;
    this.importer = importer;
    this.reexport = reexport;
    this.dependencyScope = dependencyScope;
  }

  @Nullable
  @Override
  public IConceptReference getConceptReference() {
    return getConcept().getReference();
  }

  @NotNull
  @Override
  public IArea getArea() {
    return new MPSArea();
  }
  @Override
  public boolean isValid() {
    return true;
  }
  @NotNull
  @Override
  public INodeReference getReference() {
    return new NodeReference(this.importer.getModuleReference(), this.moduleReference.getModuleId());
  }
  @Override
  public IConcept getConcept() {
    return SConceptAdapter.wrap(CONCEPTS.ModuleDependency$kc);
  }
  @Nullable
  @Override
  public String getRoleInParent() {
    return LINKS.dependencies$vC8r.getName();
  }
  @Nullable
  @Override
  public INode getParent() {
    return SModuleAsNode.wrap(this.importer);
  }
  @NotNull
  @Override
  public Iterable<INode> getChildren(@Nullable String role) {
    return LinkedListSequence.fromLinkedList(new LinkedList<INode>());
  }
  @NotNull
  @Override
  public Iterable<INode> getAllChildren() {
    IConcept concept = getConcept();
    if (concept == null) {
      return Collections.<INode>emptyList();
    }
    Iterable<IChildLink> links = concept.getAllChildLinks();
    return Sequence.fromIterable(links).select((it) -> getChildren(it.getName())).translate((it) -> it);
  }
  @Override
  public void moveChild(@Nullable String string, int i, @NotNull INode node) {
    throw new UnsupportedOperationException();
  }
  @NotNull
  @Override
  public INode addNewChild(@Nullable String string, int i, @Nullable IConcept concept) {
    throw new UnsupportedOperationException();
  }
  @NotNull
  @Override
  public INode addNewChild(@Nullable String string, int i, @Nullable IConceptReference reference) {
    throw new UnsupportedOperationException();
  }
  @Override
  public void removeChild(@NotNull INode node) {
    throw new UnsupportedOperationException();
  }
  @Nullable
  @Override
  public INode getReferenceTarget(@NotNull String role) {
    return null;
  }
  @Nullable
  @Override
  public INodeReference getReferenceTargetRef(@NotNull String string) {
    return null;
  }
  @Override
  public void setReferenceTarget(@NotNull String string, @Nullable INode node) {
    throw new UnsupportedOperationException();
  }
  @Override
  public void setReferenceTarget(@NotNull String string, @Nullable INodeReference reference) {
    throw new UnsupportedOperationException();
  }
  @Nullable
  @Override
  public String getPropertyValue(@NotNull String propertyName) {
    if (Objects.equals(PROPS.explicit$yR_K.getName(), propertyName)) {
      return Boolean.toString(this.explicit);
    } else if (Objects.equals(PROPS.name$Ahsh.getName(), propertyName)) {
      return this.moduleReference.getModuleName();
    } else if (Objects.equals(PROPS.reexport$AblR.getName(), propertyName)) {
      return Boolean.toString(this.reexport);
    } else if (Objects.equals(PROPS.uuid$AbNT.getName(), propertyName)) {
      return this.moduleReference.getModuleId().toString();
    } else if (Objects.equals(PROPS.version$yXGa.getName(), propertyName)) {
      return Integer.toString(this.moduleVersion);
    } else if (Objects.equals(PROPS.scope$mJmq.getName(), propertyName)) {
      if (this.dependencyScope == null) {
        return "UNSPECIFIED";
      }
      return this.dependencyScope.toString();
    } else {
      return null;
    }
  }
  @Override
  public void setPropertyValue(@NotNull String string, @Nullable String string1) {
    throw new UnsupportedOperationException();
  }
  @NotNull
  @Override
  public List<String> getPropertyRoles() {
    IConcept concept = getConcept();
    if (concept == null) {
      return Collections.<String>emptyList();
    }
    List<IProperty> allProperties = concept.getAllProperties();
    return ListSequence.fromList(allProperties).select((it) -> it.getName()).toList();
  }
  @NotNull
  @Override
  public List<String> getReferenceRoles() {
    IConcept concept = getConcept();
    if (concept == null) {
      return Collections.<String>emptyList();
    }
    List<IReferenceLink> allReferenceLinks = concept.getAllReferenceLinks();
    return ListSequence.fromList(allReferenceLinks).select((it) -> it.getName()).toList();
  }

  public static class NodeReference implements INodeReference {
    private SModuleReference userModuleReference;
    private SModuleId usedModuleId;

    public NodeReference(SModuleReference userModuleReference, SModuleId usedModuleId) {
      this.userModuleReference = userModuleReference;
      this.usedModuleId = usedModuleId;
    }

    @Nullable
    @Override
    public INode resolveNode(@Nullable IArea area) {
      SRepository repo = null;
      if (area != null) {
        List<IArea> areas = area.collectAreas();
        repo = ListSequence.fromList(areas).ofType(MPSArea.class).select((it) -> it.getRepository()).where(new NotNullWhereFilter()).first();
      }
      if (repo == null) {
        repo = MPSCoreComponents.getInstance().getPlatform().findComponent(MPSModuleRepository.class);
      }
      SModule user = userModuleReference.resolve(repo);
      if (user == null) {
        return null;
      }

      return new SModuleAsNode(user).findDependency(this.usedModuleId);
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      NodeReference that = (NodeReference) o;
      if (Objects.equals(this.userModuleReference, that.userModuleReference)) {
        return false;
      }
      if (Objects.equals(this.usedModuleId, that.usedModuleId)) {
        return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((userModuleReference != null ? ((Object) userModuleReference).hashCode() : 0));
      result = 11 * result + ((usedModuleId != null ? ((Object) usedModuleId).hashCode() : 0));
      return result;
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ModuleDependency$kc = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x1e9fde953529916fL, "org.modelix.model.repositoryconcepts.structure.ModuleDependency");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink dependencies$vC8r = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, 0x1e9fde9535299179L, "dependencies");
  }

  private static final class PROPS {
    /*package*/ static final SProperty explicit$yR_K = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x1e9fde953529916fL, 0x1e9fde9535315265L, "explicit");
    /*package*/ static final SProperty name$Ahsh = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x1e9fde953529916fL, 0x1e9fde9535299175L, "name");
    /*package*/ static final SProperty reexport$AblR = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x1e9fde953529916fL, 0x1e9fde9535299170L, "reexport");
    /*package*/ static final SProperty uuid$AbNT = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x1e9fde953529916fL, 0x1e9fde9535299172L, "uuid");
    /*package*/ static final SProperty version$yXGa = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x1e9fde953529916fL, 0x1e9fde953531526aL, "version");
    /*package*/ static final SProperty scope$mJmq = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x1e9fde953529916fL, 0x751b3543f508b8f9L, "scope");
  }
}

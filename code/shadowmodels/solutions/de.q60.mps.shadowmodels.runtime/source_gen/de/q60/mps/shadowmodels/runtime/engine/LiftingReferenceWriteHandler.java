package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import org.modelix.model.api.INode;
import org.modelix.model.api.IReferenceLink;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class LiftingReferenceWriteHandler extends SimpleReferenceWriteHandler {

  public LiftingReferenceWriteHandler(INode node, IReferenceLink link) {
    super(node, link);
  }

  @Override
  public void write(INode target) {
    super.write(liftTarget(target));
  }

  protected INode liftTarget(INode target) {
    if (target == null) {
      return null;
    }
    Iterable<INode> input = check_pq93z3_a0b0f(check_pq93z3_a0a1a5(as_pq93z3_a0a0a1a5(DependencyTrackingNode.unwrap(target), OutputNodeReferenceAsNode.class)));
    if (input != null && Sequence.fromIterable(input).isNotEmpty()) {
      return Sequence.fromIterable(input).first();
    }
    throw new RuntimeException("Unsupported reference target: " + target);
  }
  private static Iterable<INode> check_pq93z3_a0b0f(IOutputNodeReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getInputNodes();
    }
    return null;
  }
  private static IOutputNodeReference check_pq93z3_a0a1a5(OutputNodeReferenceAsNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getOutputNodeReference();
    }
    return null;
  }
  private static <T> T as_pq93z3_a0a0a1a5(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

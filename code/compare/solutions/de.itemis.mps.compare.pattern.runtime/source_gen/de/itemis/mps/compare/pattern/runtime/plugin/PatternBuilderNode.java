package de.itemis.mps.compare.pattern.runtime.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.List;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class PatternBuilderNode implements IPatternEvaluator {

  protected SAbstractConcept concept;
  protected List<PatternBuilderInitPart> values;
  protected boolean exact;
  protected boolean negated;

  public PatternBuilderNode(SAbstractConcept concept, boolean exact, Collection<PatternBuilderInitPart> values, boolean negated) {
    this.concept = concept;
    this.values = ListSequence.fromList(new ArrayList<PatternBuilderInitPart>());
    this.exact = exact;
    this.negated = negated;
    addValues(values);
  }

  public PatternBuilderNode() {
    this(null, false, null, false);
  }

  public void setConcept(SAbstractConcept concept) {
    this.concept = concept;
  }

  public SAbstractConcept getConcept() {
    return this.concept;
  }

  public void addValue(PatternBuilderInitPart value) {
    if (value != null) {
      ListSequence.fromList(values).addElement(value);
    }
  }

  public void addValues(Collection<PatternBuilderInitPart> values) {
    if (values != null) {
      ListSequence.fromList(this.values).addSequence(CollectionSequence.fromCollection(values));
    }
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("<" + this.concept.getName() + "(");
    boolean first = true;
    for (PatternBuilderInitPart value : ListSequence.fromList(this.values)) {
      if (first) {
        first = false;
      } else {
        builder.append(", ");
      }
      builder.append(value.toString());
    }
    builder.append(")>");
    return builder.toString();
  }

  @Override
  public MatchResult match(SNode node) {
    boolean isMatch;

    if (exact) {
      isMatch = SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(node)), SNodeOperations.asSConcept(concept));
    } else {
      isMatch = SNodeOperations.isInstanceOf(node, SNodeOperations.asSConcept(concept));
    }

    MatchResult result = new MatchResult(isMatch, null);

    result = result.xor(negated);

    if (result.isMatch()) {
      for (PatternBuilderInitPart value : ListSequence.fromList(values)) {
        result = result.unify(value.match(node));
      }
    }

    return result;
  }

  @Override
  public SNode build(SNode node) {
    SNode result = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(this.concept));
    for (PatternBuilderInitPart value : ListSequence.fromList(this.values)) {
      result = value.build(result);
    }
    return result;
  }
}

package com.mbeddr.mpsutil.treenotation.runtime;

/*Generated by MPS */

import java.awt.Shape;
import java.awt.geom.Point2D;
import java.awt.geom.GeneralPath;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class OrthogonalTreeLayouter extends DefaultTreeLayouter {
  public static final TreeLayoutType TYPE = new TreeLayoutType() {
    public ITreeLayouter createLayouter(TreeCell cell) {
      return new OrthogonalTreeLayouter(cell);
    }
  };

  public OrthogonalTreeLayouter(TreeCell treeCell) {
    super(treeCell);
  }

  @Override
  protected Shape createLine(Point2D start, Point2D end) {
    Point2D bendPoint1;
    Point2D bendPoint2;
    if (myTreeCell.isLeftToRight()) {
      double xCenter = getRootChildCenter(true);
      bendPoint1 = new Point2D.Double(xCenter, start.getY());
      bendPoint2 = new Point2D.Double(xCenter, end.getY());
    } else {
      double yCenter = getRootChildCenter(false);
      bendPoint1 = new Point2D.Double(start.getX(), yCenter);
      bendPoint2 = new Point2D.Double(end.getX(), yCenter);
    }

    GeneralPath path = new GeneralPath();
    path.moveTo(start.getX(), start.getY());
    path.lineTo(bendPoint1.getX(), bendPoint1.getY());
    path.lineTo(bendPoint2.getX(), bendPoint2.getY());
    path.lineTo(end.getX(), end.getY());
    return path;
  }

  protected int getRootChildCenter(final boolean xAxis) {
    Iterable<IBounds> childrenBounds = Sequence.fromIterable(myTreeCell.getTreeChildren()).select((it) -> getBounds(it, xAxis));
    IBounds rootBounds = getBounds(getTreeRoot(), xAxis);
    int childMin = Sequence.fromIterable(childrenBounds).select((it) -> it.getY()).reduceLeft((a, b) -> Math.min(a, b));
    return (childMin + BoundsExtensions.getMaxY(rootBounds)) / 2;
  }
}

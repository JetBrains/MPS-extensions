package de.itemis.mps.editor.celllayout.runtime;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.style.StyleAttribute;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import de.itemis.mps.editor.celllayout.layout.ILayoutableContainer;
import de.itemis.mps.editor.celllayout.layout.ILayoutable;
import jetbrains.mps.editor.runtime.style.CellAlign;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import java.awt.Font;
import jetbrains.mps.nodeEditor.cells.FontRegistry;
import java.util.Objects;
import jetbrains.mps.nodeEditor.EditorSettings;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.nodeEditor.cells.TextLine;
import java.util.Set;
import de.itemis.mps.editor.celllayout.layout.ILayouter;
import java.util.List;
import java.awt.Rectangle;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class CellLayoutUtil {
  private static final StyleAttribute<Boolean> OVERFLOW_Y = StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_overflow-y");
  private static final StyleAttribute<Boolean> OVERFLOW_X = StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_overflow-x");

  public static void invalidateUnsupportedCellLayout(EditorCell cell) {
    if (LayoutableAdapters.isSupportedCollection(cell)) {
      return;
    }
    if (cell instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) cell))) {
        invalidateUnsupportedCellLayout(child);
      }
    }
    cell.requestRelayout();
  }

  public static void invalidateAllCells(EditorCell cell) {
    if (cell instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) cell))) {
        invalidateAllCells(child);
      }
    }
    cell.requestRelayout();
  }

  public static void forceRelayout(EditorCell cell) {
    invalidateUnsupportedCellLayout(cell);
    relayout(cell);
  }

  public static void relayout(EditorCell cell) {
    int x = cell.getX();
    int y = cell.getY();
    cell.relayout();
  }

  public static void moveTreeBy(EditorCell cell, int deltaX, int deltaY) {
    moveTreeBy(cell, deltaX, deltaY, false, false);
  }

  public static void moveTreeBy(EditorCell cell, int deltaX, int deltaY, boolean skipRoot, boolean raw) {
    if (deltaX == 0 && deltaY == 0) {
      return;
    }

    if (!(skipRoot)) {
      if (raw) {
        cell.setX(cell.getX() + deltaX);
        cell.setY(cell.getY() + deltaY);
      } else {
        cell.moveTo(cell.getX() + deltaX, cell.getY() + deltaY);
      }
    }
    if (raw) {
      if (cell instanceof EditorCell_Collection) {
        for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) cell))) {
          moveTreeBy(child, deltaX, deltaY, false, raw);
        }
      }
    }
  }

  public static void moveTreeTo(EditorCell cell, int newX, int newY) {
    moveTreeTo(cell, newX, newY, false);
  }

  public static void moveTreeTo(EditorCell cell, int newX, int newY, boolean raw) {
    moveTreeBy(cell, newX - cell.getX(), newY - cell.getY(), false, raw);
  }

  public static void clearRelayoutRequests(EditorCell cell) {
    ((EditorCell_Basic) cell).unrequestLayout();
    if (cell instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) cell))) {
        clearRelayoutRequests(child);
      }
    }
  }

  public static int getCellGap(ILayoutableContainer container) {
    if (container instanceof LayoutableCollectionAdapter) {
      return ((LayoutableCollectionAdapter) container).getCellGap();
    }
    return 10;
  }


  public static boolean hasNewLineAfter(EditorCell cell) {
    if (cell == null) {
      return false;
    }
    if (cell.getStyle().get(StyleAttributes.INDENT_LAYOUT_NEW_LINE)) {
      return true;
    }
    if (cell.getParent() != null && cell.getParent().getStyle().get(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE)) {
      return true;
    }
    if (cell.getParent() != null && cell.getParent().lastCell() == cell) {
      return hasNewLineAfter(cell.getParent());
    }
    return false;
  }


  public static boolean hasNewLineBefore(EditorCell cell) {
    if (cell == null) {
      return false;
    }
    if (cell.getStyle().get(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE)) {
      return true;
    }
    if (cell.getParent() != null && cell.getParent().firstCell() == cell) {
      return hasNewLineBefore(cell.getParent());
    }
    return false;
  }

  public static boolean hasIndent(EditorCell cell) {
    if (cell == null) {
      return false;
    }
    if (cell.getStyle().get(StyleAttributes.INDENT_LAYOUT_INDENT)) {
      return true;
    }
    return false;
  }

  public static EditorCell getEditorCell(ILayoutable layoutable) {
    return check_t1kuk7_a0a13(as_t1kuk7_a0a0a13(layoutable, IEditorCellBasedLayoutable.class));
  }

  public static boolean isAlignRight(ILayoutable layoutable) {
    EditorCell editorCell = getEditorCell(layoutable);
    if (editorCell == null) {
      return false;
    }
    return editorCell.getStyle().get(StyleAttributes.HORIZONTAL_ALIGN) == CellAlign.RIGHT;
  }

  public static boolean isAlignHorizontalCenter(ILayoutable layoutable) {
    EditorCell editorCell = getEditorCell(layoutable);
    if (editorCell == null) {
      return false;
    }
    return editorCell.getStyle().get(StyleAttributes.HORIZONTAL_ALIGN) == CellAlign.CENTER;
  }

  public static void setFontFamily(EditorCell_Label cell, String fontFamily) {
    Font oldCellFont = cell.getFont();
    Font newCellFont = FontRegistry.getInstance().getFont(fontFamily, oldCellFont.getStyle(), oldCellFont.getSize());

    if (Objects.equals(oldCellFont.getName(), newCellFont.getName())) {
      return;
    }

    Font originalDefaultFont = new Font(EditorSettings.getInstance().getFontFamily(), 0, EditorSettings.getInstance().getFontSize());
    try {
      EditorSettings.getInstance().setDefaultEditorFont(newCellFont);
      ReflectionUtil.callVoidMethod(TextLine.class, ((TextLine) ReflectionUtil.callMethod(EditorCell_Label.class, cell, "getTextLine", new Class[]{}, new Object[]{})), "updateStyle", new Class[]{Set.class}, new Object[]{null});
    } finally {
      EditorSettings.getInstance().setDefaultEditorFont(originalDefaultFont);
    }
  }

  public static int getIndentSizeSetting() {
    return EditorSettings.getInstance().getSpacesWidth(EditorSettings.getInstance().getIndentSize());
  }

  public static void setLayout(EditorCell_Collection cell, ILayouter layout) {
    ReflectionUtil.writeField(jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class, ((jetbrains.mps.nodeEditor.cells.EditorCell_Collection) cell), "myCellLayout", new TopDownCellLayoutAdapter(layout));
  }

  public static boolean fixBoundsForOverflow(EditorCell cell) {
    boolean needsFix = false;
    if (cell instanceof EditorCell_Collection) {
      EditorCell_Collection collection = ((EditorCell_Collection) cell);
      for (EditorCell child : Sequence.fromIterable(collection)) {
        if (child instanceof EditorCell_Collection) {
          needsFix |= fixBoundsForOverflow(((EditorCell_Collection) child));
        }
      }

      if (needsFix) {
        int minX = collection.getX();
        int maxX = minX + collection.getWidth();
        int minY = collection.getY();
        int maxY = minY + collection.getHeight();

        for (EditorCell child : Sequence.fromIterable(collection)) {
          minX = Math.min(minX, child.getX());
          maxX = Math.max(maxX, child.getX() + child.getWidth());
          minY = Math.min(minY, child.getY());
          maxY = Math.max(maxY, child.getY() + child.getHeight());
        }

        collection.setX(minX);
        collection.setY(minY);
        collection.setWidth(maxX - minX);
        collection.setHeight(maxY - minY);
      }
    }
    needsFix |= cell.getStyle().get(OVERFLOW_X) || cell.getStyle().get(OVERFLOW_Y);
    return needsFix;
  }

  public static List<Rectangle> closeGaps(List<Rectangle> boundsList) {
    for (int i = 1; i < ListSequence.fromList(boundsList).count(); i++) {
      Rectangle bounds1 = ListSequence.fromList(boundsList).getElement(i - 1);
      Rectangle bounds2 = ListSequence.fromList(boundsList).getElement(i);
      boolean sameLine = bounds1.getMinY() <= bounds2.getMinY() && bounds2.getMinY() < bounds1.getMaxY();
      if (sameLine) {
        int gap = ((int) Math.round(bounds2.getMinX() - bounds1.getMaxX()));
        if (gap > 0) {
          int gap1 = gap / 2;
          int gap2 = gap - gap1;
          bounds1.width += gap;
          bounds2.width += gap2;
          bounds2.x -= gap2;
        }
      }
    }
    return boundsList;
  }
  private static EditorCell check_t1kuk7_a0a13(IEditorCellBasedLayoutable checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static <T> T as_t1kuk7_a0a0a13(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

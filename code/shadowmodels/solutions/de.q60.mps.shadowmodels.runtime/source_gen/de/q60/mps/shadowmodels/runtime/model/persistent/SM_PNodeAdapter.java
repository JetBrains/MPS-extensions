package de.q60.mps.shadowmodels.runtime.model.persistent;

/*Generated by MPS */

import org.modelix.model.api.INode;
import org.modelix.model.api.IBranch;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.area.IArea;
import java.util.Objects;
import de.q60.mps.incremental.runtime.DependencyBroadcaster;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConcept;
import org.modelix.model.api.IConceptReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.modelix.model.api.INodeReference;
import org.modelix.model.area.ContextArea;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class SM_PNodeAdapter implements INode {
  public static INode wrap(long id, IBranch branch) {
    return (id == 0 ? null : new SM_PNodeAdapter(id, branch));
  }

  private IBranch branch;
  private long nodeId;

  public SM_PNodeAdapter(long nodeId, IBranch branch) {
    this.nodeId = nodeId;
    this.branch = branch;
    notifyAccess();
  }

  @NotNull
  @Override
  public IArea getArea() {
    return new SM_PArea(branch);
  }

  public IBranch getBranch() {
    return branch;
  }

  public long getNodeId() {
    return nodeId;
  }

  public INode wrap(long id) {
    return wrap(id, branch);
  }

  protected long unwrap(INode node) {
    if (node == null) {
      return 0;
    }
    if (!(node instanceof SM_PNodeAdapter)) {
      throw new RuntimeException("Not a " + SM_PNodeAdapter.class.getSimpleName() + ": " + node);
    }
    SM_PNodeAdapter adapter = ((SM_PNodeAdapter) node);
    if (!(Objects.equals(adapter.branch, branch))) {
      throw new RuntimeException("Node belongs to a different branch. Expected " + branch + " but was " + adapter.branch);
    }
    return adapter.nodeId;
  }

  protected void notifyAccess() {
    DependencyBroadcaster.INSTANCE.dependencyAccessed(new SM_PNodeDependency(branch, nodeId));
  }

  @Override
  public void moveChild(String role, int index, INode node) {
    throw new UnsupportedOperationException("Not implemented");
  }
  @Override
  public INode addNewChild(String role, int index, @Nullable IConcept concept) {
    return wrap(branch.getWriteTransaction().addNewChild(nodeId, role, index, concept));
  }
  @NotNull
  @Override
  public INode addNewChild(@Nullable String role, int index, @Nullable IConceptReference concept) {
    return wrap(branch.getWriteTransaction().addNewChild(nodeId, role, index, concept));
  }
  @Override
  public Iterable<INode> getAllChildren() {
    notifyAccess();
    Iterable<Long> allChildren = branch.getTransaction().getAllChildren(nodeId);
    return Sequence.fromIterable(allChildren).select((it) -> wrap(it));
  }
  @Override
  public Iterable<INode> getChildren(String role) {
    notifyAccess();
    Iterable<Long> children = branch.getTransaction().getChildren(nodeId, role);
    return Sequence.fromIterable(children).select((it) -> wrap(it));
  }
  @Override
  public IConcept getConcept() {
    notifyAccess();
    return branch.computeRead(() -> branch.getTransaction().getConcept(nodeId));
  }
  @Nullable
  @Override
  public IConceptReference getConceptReference() {
    notifyAccess();
    return branch.computeRead(() -> branch.getTransaction().getConceptReference(nodeId));
  }
  @Override
  public INode getParent() {
    notifyAccess();
    long parent = branch.getTransaction().getParent(nodeId);
    if (parent == 0 || parent == SM_PTree.ROOT_ID) {
      return null;
    }
    return wrap(parent);
  }
  @Override
  public String getPropertyValue(String role) {
    notifyAccess();
    return branch.getTransaction().getProperty(nodeId, role);
  }
  public Object getUserObject(Object key) {
    notifyAccess();
    return ((SM_Transaction) branch.getTransaction()).getUserObject(nodeId, key);
  }
  @Override
  public INodeReference getReference() {
    return new SM_PNodeReference(nodeId);
  }
  @Override
  public INode getReferenceTarget(String role) {
    notifyAccess();
    INodeReference targetRef = getReferenceTargetRef(role);
    if (targetRef instanceof SM_PNodeReference) {
      return targetRef.resolveNode(new SM_PArea(branch));
    }
    IArea context = ContextArea.INSTANCE.getCONTEXT_VALUE().getValue();
    if (context == null) {
      throw new RuntimeException(ContextArea.class.getSimpleName() + " not available");
    }
    return (targetRef == null ? null : targetRef.resolveNode(context));

  }
  @Nullable
  @Override
  public INodeReference getReferenceTargetRef(@NotNull String role) {
    notifyAccess();
    return branch.getTransaction().getReferenceTarget(nodeId, role);
  }
  @Override
  public String getRoleInParent() {
    notifyAccess();
    return branch.getTransaction().getRole(nodeId);
  }
  @Override
  public boolean isValid() {
    notifyAccess();
    return branch.getTransaction().containsNode(nodeId);
  }
  @Override
  public void removeChild(INode child) {
    branch.getWriteTransaction().deleteNode(unwrap(child));
  }
  @Override
  public void setPropertyValue(String role, String value) {
    branch.getWriteTransaction().setProperty(nodeId, role, value);
  }
  public void setUserObject(Object key, Object value) {
    ((SM_IWriteTransaction) branch.getWriteTransaction()).setUserObject(nodeId, key, value);
  }
  @Override
  public void setReferenceTarget(String role, INode target) {
    branch.getWriteTransaction().setReferenceTarget(nodeId, role, (target == null ? null : target.getReference()));
  }
  public void setReferenceTarget(String role, INodeReference target) {
    branch.getWriteTransaction().setReferenceTarget(nodeId, role, target);
  }

  @NotNull
  @Override
  public List<String> getPropertyRoles() {
    return ListSequence.fromListWithValues(new ArrayList<String>(), branch.getTransaction().getPropertyRoles(nodeId));
  }
  @NotNull
  @Override
  public List<String> getReferenceRoles() {
    return ListSequence.fromListWithValues(new ArrayList<String>(), branch.getTransaction().getReferenceRoles(nodeId));
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    SM_PNodeAdapter that = (SM_PNodeAdapter) o;
    if ((branch != null ? !(branch.equals(that.branch)) : that.branch != null)) {
      return false;
    }
    if (nodeId != that.nodeId) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((branch != null ? ((Object) branch).hashCode() : 0));
    result = 31 * result + (int) (nodeId ^ (nodeId >> 32));
    return result;
  }

  @Override
  public String toString() {
    IConcept concept = null;
    try {
      concept = branch.computeRead(() -> branch.getTransaction().getConcept(nodeId));
    } catch (Exception ex) {
    }
    String str = "PNode" + nodeId;
    if (concept != null) {
      str += "[" + concept + "]";
    }
    return str;
  }
}

package de.q60.mps.shadowmodels.modelcheck.runtime;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collections;

public class LiftedMessagesCache {
  private static LiftedMessagesCache ourInstance = new LiftedMessagesCache();

  private long changeCount = 0;
  private Map<Object, Map<SNodeReference, List<LiftedReportItem>>> messages = MapSequence.fromMap(new HashMap<Object, Map<SNodeReference, List<LiftedReportItem>>>());


  public static LiftedMessagesCache getInstance() {
    return ourInstance;
  }

  public synchronized void putMessages(Object owner, Map<SNodeReference, List<LiftedReportItem>> sourceRoot2messages) {
    MapSequence.fromMap(messages).put(owner, sourceRoot2messages);
    changeCount++;
  }

  public synchronized void putMessages(Object owner, List<LiftedReportItem> messages) {
    Map<SNodeReference, List<LiftedReportItem>> map = MapSequence.fromMap(new HashMap<SNodeReference, List<LiftedReportItem>>());
    MapSequence.fromMap(map).put(null, messages);
    putMessages(owner, map);
  }

  public synchronized void clearMessages(Object owner) {
    MapSequence.fromMap(messages).removeKey(owner);
    changeCount++;
  }

  public long getChangeCount() {
    return changeCount;
  }

  public synchronized Tuples._2<Long, List<LiftedReportItem>> getChangeCountAndMessages() {
    return MultiTuple.<Long,List<LiftedReportItem>>from(getChangeCount(), getMessages());
  }

  public synchronized List<LiftedReportItem> getMessages() {
    return Sequence.fromIterable(MapSequence.fromMap(messages).values()).translate((it) -> MapSequence.fromMap(it).values()).translate((it) -> it).toList();
  }

  public synchronized Map<SNodeReference, List<LiftedReportItem>> getMessages(Object owner) {
    Map<SNodeReference, List<LiftedReportItem>> copy = MapSequence.fromMap(new HashMap<SNodeReference, List<LiftedReportItem>>());
    if (MapSequence.fromMap(messages).containsKey(owner)) {
      for (IMapping<SNodeReference, List<LiftedReportItem>> entry : MapSequence.fromMap(MapSequence.fromMap(messages).get(owner))) {
        MapSequence.fromMap(copy).put(entry.key(), ListSequence.fromListWithValues(new ArrayList<LiftedReportItem>(), entry.value()));
      }
    }
    return copy;
  }

  public synchronized List<LiftedReportItem> getMessages(Object owner, SNodeReference sourceRootNode) {
    if (MapSequence.fromMap(messages).containsKey(owner)) {
      Map<SNodeReference, List<LiftedReportItem>> rootNode2messages = MapSequence.fromMap(messages).get(owner);
      if (MapSequence.fromMap(rootNode2messages).containsKey(sourceRootNode)) {
        return ListSequence.fromListWithValues(new ArrayList<LiftedReportItem>(), MapSequence.fromMap(rootNode2messages).get(sourceRootNode));
      }
    }
    return Collections.emptyList();
  }
}

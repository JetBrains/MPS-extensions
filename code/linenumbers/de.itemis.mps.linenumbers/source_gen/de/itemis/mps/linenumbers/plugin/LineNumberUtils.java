package de.itemis.mps.linenumbers.plugin;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class LineNumberUtils {
  private static final String EXPANDED_LINES_CACHE_KEY = ILineList.class.getName();
  private static final String FOLDED_LINES_CACHE_KEY = ILineList.class.getName() + ".folded";
  private static final String EXPANSION_DELTA_KEY = LineNumberUtils.class.getName() + ".expansionDelta";

  @Nullable
  public static ILineList findLines(EditorCell cell) {
    return findLines(cell, false);
  }

  @Nullable
  public static ILineList findLines(EditorCell cell, boolean ignoreCache) {
    ILineList lines = findLines_(cell, ignoreCache);
    if (lines != null) {
      int expansionDelta = getExpansionDelta(cell);
      lines.setExpandedDelta(expansionDelta);
    }
    return lines;
  }

  @Nullable
  private static ILineList findLines_(EditorCell cell, final boolean ignoreCache) {
    String cacheKey = (check_e23sii_a0a0a8(as_e23sii_a0a0a0a8(cell, EditorCell_Collection.class)) ? FOLDED_LINES_CACHE_KEY : EXPANDED_LINES_CACHE_KEY);
    ILineList cached = (ignoreCache ? null : as_e23sii_a0a0b0i(cell.getUserObject(cacheKey), ILineList.class));
    if (cached != null) {
      return cached;
    }

    if (cell instanceof EditorCell_Collection) {
      Iterable<EditorCell> visibleChildren = ((EditorCell_Collection) cell);
      List<ILineList> mergedLists = mergeOverlapping(Sequence.fromIterable(visibleChildren).select((it) -> findLines(it, ignoreCache)).where(new NotNullWhereFilter()).toList());
      ILineList lines = LineList.create(mergedLists);

      if (((EditorCell_Collection) cell).isCollapsed()) {
        ILineList expandedLines = as_e23sii_a0a0a4a4a8(cell.getUserObject(EXPANDED_LINES_CACHE_KEY), ILineList.class);
        if (expandedLines != null) {
          if (lines == null) {
            setExpansionDelta(cell, expandedLines.getSize());
          } else {
            setExpansionDelta(cell, expandedLines.getExpandedSize() - lines.getSize());
          }
        }
      } else {
        setExpansionDelta(cell, null);
      }
      cell.putUserObject(cacheKey, lines);
      return lines;
    } else if (cell instanceof EditorCell_Label) {
      Line line = new Line(cell);
      cell.putUserObject(cacheKey, line);
      return line;
    } else {
      return null;
    }
  }

  private static int getExpansionDelta(EditorCell cell) {
    if (cell instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection) {
      Integer delta = as_e23sii_a0a0a0a01(cell.getUserObject(EXPANSION_DELTA_KEY), Integer.class);
      if (delta == null) {
        Iterable<EditorCell> children = ((jetbrains.mps.openapi.editor.cells.EditorCell_Collection) cell);
        delta = Sequence.fromIterable(children).foldLeft(0, (Integer s, EditorCell it) -> s + getExpansionDelta(it));
        cell.putUserObject(EXPANSION_DELTA_KEY, delta);
      }
      return delta;
    } else {
      return 0;
    }
  }

  private static void setExpansionDelta(EditorCell cell, Integer delta) {
    Object existing = cell.getUserObject(EXPANSION_DELTA_KEY);
    if (Objects.equals(delta, existing)) {
      return;
    }

    // invalidate ancestor cells
    jetbrains.mps.openapi.editor.cells.EditorCell_Collection parent = cell.getParent();
    if (parent != null) {
      setExpansionDelta(parent, null);
    }

    cell.putUserObject(EXPANSION_DELTA_KEY, delta);
  }

  public static List<ILineList> mergeOverlapping(List<ILineList> lists) {
    List<ILineList> mergedLists = ListSequence.fromList(new ArrayList<ILineList>());
    for (ILineList list : ListSequence.fromList(lists).sort((it) -> it.getMinY(), true).alsoSort((it) -> it.getMaxY(), true)) {
      if (ListSequence.fromList(mergedLists).isEmpty()) {
        ListSequence.fromList(mergedLists).addElement(list);
      } else {
        if (ListSequence.fromList(mergedLists).last().overlaps(list)) {
          ILineList merged = ListSequence.fromList(mergedLists).last().merge(list);
          if (merged != null) {
            ListSequence.fromList(mergedLists).removeLastElement();
            ListSequence.fromList(mergedLists).addElement(merged);
          }
        } else {
          ListSequence.fromList(mergedLists).addElement(list);
        }
      }
    }
    return mergedLists;
  }
  private static boolean check_e23sii_a0a0a8(EditorCell_Collection checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isCollapsed();
    }
    return false;
  }
  private static <T> T as_e23sii_a0a0a0a8(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_e23sii_a0a0b0i(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_e23sii_a0a0a4a4a8(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_e23sii_a0a0a0a01(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.q60.mps.shadowmodels.runtime.smodel;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.extapi.module.SRepositoryExt;
import de.q60.mps.shadowmodels.runtime.engine.TransformationEngine;
import de.q60.mps.incremental.runtime.IInvalidationListener;
import java.util.Set;
import jetbrains.mps.module.ReloadableModule;
import de.q60.mps.shadowmodels.runtime.engine.IOutputNodesReference;
import de.q60.mps.shadowmodels.runtime.concurrentrepo.RepositoryMirror;
import org.modelix.model.api.ITree;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PTree;
import de.q60.mps.util.invalidation.Invalidatable;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.modelix.model.api.INode;
import de.q60.mps.shadowmodels.runtime.engine.DependencyTrackingNode;
import de.q60.mps.shadowmodels.runtime.engine.TransformationCall;
import de.q60.mps.polymorphicfunctions.runtime.ParameterList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.q60.mps.shadowmodels.runtime.engine.ChildSubgraphRef;
import de.q60.mps.shadowmodels.runtime.engine.EmptyRootSubgraphRef;
import de.q60.mps.shadowmodels.runtime.engine.UniqueTargetInScope;
import de.q60.mps.shadowmodels.runtime.engine.ISubgraphCall;
import de.q60.mps.shadowmodels.runtime.engine.RootScope;
import de.q60.mps.shadowmodels.runtime.engine.SingletonUniqueContainmentTarget;
import de.q60.mps.shadowmodels.runtime.engine.ForkCall;
import de.q60.mps.shadowmodels.runtime.engine.StageRootNodes;
import de.q60.mps.shadowmodels.runtime.engine.FinalStageReference;
import de.q60.mps.polymorphicfunctions.runtime.DefaultPFContext;
import de.q60.mps.polymorphicfunctions.runtime.IImplementationProvider;
import kotlin.Unit;
import org.modelix.model.area.ContextArea;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeIdMissingException;
import org.modelix.model.mpsadapters.mps.MPSArea;
import org.jetbrains.mps.openapi.model.SNode;
import de.q60.mps.shadowmodels.runtime.engine.OutputNodeReferenceAsNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import de.q60.mps.polymorphicfunctions.runtime.NoApplicableImplementationException;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import de.q60.mps.incremental.runtime.DependencyKey;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_ITreeChangeVisitor;
import org.modelix.model.api.INodeReference;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeAdapter;
import de.q60.mps.shadowmodels.runtime.engine.ContainmentDependency;
import de.q60.mps.shadowmodels.runtime.engine.RoleDependency;
import de.q60.mps.shadowmodels.runtime.engine.AllChildrenDependency;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeDependency;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.classloading.ModuleClassLoader;
import org.jetbrains.mps.openapi.language.SConcept;

public class SM_RepositoryModulesManager {
  private static final Logger LOG = Logger.getLogger(SM_RepositoryModulesManager.class);
  private static final String REPOSITORY_TRANSFORMATION_ID = "de.q60.mps.shadowmodels.repository.transformations.ShadowRepository.Repository";
  public static final String SHADOW_REPOSITORY_FORK_ID = "$shadowRepository";

  public static boolean isEnabled() {
    return ourInstance != null;
  }

  private static SM_RepositoryModulesManager ourInstance;

  public static SM_RepositoryModulesManager getInstance() {
    if (ourInstance == null) {
      throw new IllegalStateException("Not enabled");
    }
    return ourInstance;
  }

  public static void setInstance(SM_RepositoryModulesManager instance) {
    ourInstance = instance;
  }

  private SRepositoryExt repository;
  private TransformationEngine engine;
  private SM_ShadowOutputSynchronizerStep1 synchronizer1;
  private SM_ShadowOutputSynchronizerStep2 synchronizer2;
  private IInvalidationListener invalidationListener = new IInvalidationListener() {
    @Override
    public void invalidated(Iterable<Object> keys) {
      dirty = true;
    }
    public void invalidatedAll() {
      dirty = true;
    }
  };
  private SM_ClassChangeListener classChangeListener = new SM_ClassChangeListener() {
    public void classesChanged(Set<ReloadableModule> modules) {
      lastClassChange = System.currentTimeMillis();
      engine.invalidateAll();
    }
  };
  private IOutputNodesReference transformationOutputRef;

  private volatile boolean dirty = true;
  private long lastClassChange = 0L;

  private volatile boolean stopSyncThread = false;
  private long syncDelay = 100;
  private Thread syncThread = new Thread(() -> {
    try {
      while (true) {
        try {
          if (stopSyncThread) {
            return;
          }
          Thread.sleep(syncDelay);
          if (stopSyncThread) {
            return;
          }
          if (isClassLoaderDisposed()) {
            if (LOG.isErrorLevel()) {
              LOG.error("Class loader is disposed, but this thread is still running");
            }
            return;
          }
          synchronize();
          syncDelay = 100;
        } catch (InterruptedException ex) {
          return;
        } catch (Throwable ex) {
          if (stopSyncThread) {
            return;
          }
          if (LOG.isErrorLevel()) {
            LOG.error("", ex);
          }
          syncDelay = Math.min(10000, syncDelay * 2);
        }
      }
    } finally {
      if (LOG.isDebugLevel()) {
        LOG.debug("Stopping sync thread");
      }
    }
  }, "Shadow Repository Sync Thread");

  private boolean disposed = false;

  private RepositoryMirror inputRepositoryMirror;
  private ITree loadedInputTree = SM_PTree.EMPTY;
  private Invalidatable invalidatable = new Invalidatable("Shadow Repository", () -> invalidateAll());

  public void init() {
    repository = MPSModuleRepository.getInstance();

    inputRepositoryMirror = new RepositoryMirror(repository);
    INode input = DependencyTrackingNode.wrap(inputRepositoryMirror.getRepositoryNode());

    {
      String traceInfo = "r:23ae1252-8737-4390-a684-2a013001dae4(de.q60.mps.shadowmodels.repository.transformations)/9192345617660066986";
      TransformationCall c = new TransformationCall(REPOSITORY_TRANSFORMATION_ID, new ParameterList(Sequence.<Object>singleton(input)), traceInfo);
      ChildSubgraphRef subgraphRef = new ChildSubgraphRef(EmptyRootSubgraphRef.INSTANCE, new UniqueTargetInScope<ISubgraphCall>(RootScope.INSTANCE, new SingletonUniqueContainmentTarget<ISubgraphCall>(new ForkCall(SHADOW_REPOSITORY_FORK_ID, ParameterList.EMPTY, c, false, null, traceInfo))));
      transformationOutputRef = new StageRootNodes(new FinalStageReference(subgraphRef));
    }

    engine = new STransformationEngine(new DefaultPFContext(Sequence.<IImplementationProvider>singleton(SM_TransformationsFromGlobalRepository.getInstance())), true);
    engine.getIncrementalEngine().setAsyncInvalidation(true);

    synchronizer1 = new SM_ShadowOutputSynchronizerStep1(engine.getIncrementalEngine(), repository, inputRepositoryMirror.getBranch());
    synchronizer2 = new SM_ShadowOutputSynchronizerStep2(repository);
    engine.addInvalidationListener(invalidationListener);
    classChangeListener.start();
    syncThread.start();
  }

  public void invalidateAll() {
    synchronizer1.dispose();
    synchronizer2.dispose();
    synchronizer1 = new SM_ShadowOutputSynchronizerStep1(engine.getIncrementalEngine(), repository, inputRepositoryMirror.getBranch());
    synchronizer2 = new SM_ShadowOutputSynchronizerStep2(repository);
    engine.invalidateAll();
    dirty = true;
    syncDelay = 100;
  }

  protected void synchronize() {
    if (disposed) {
      return;
    }

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }

    inputRepositoryMirror.flush();

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }

    inputRepositoryMirror.getBranch().runRead(() -> {
      ITree newTree = inputRepositoryMirror.getBranch().getTransaction().getTree();
      if (newTree != loadedInputTree) {
        inputChanged(newTree);
      }
      return Unit.INSTANCE;
    });

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }


    inputRepositoryMirror.getBranch().runRead(() -> {
      ContextArea.INSTANCE.getCONTEXT_VALUE().computeWith(inputRepositoryMirror.getArea(), () -> {
        engine.getIncrementalEngine().flushInvalidations();
        return Unit.INSTANCE;
      });
      return Unit.INSTANCE;
    });

    if (stopSyncThread) {
      return;
    }
    if (System.currentTimeMillis() - lastClassChange < 2000) {
      return;
    }

    if (dirty) {
      long transformStart = System.nanoTime();
      if (LOG.isDebugLevel()) {
        LOG.debug("Start synchronisation");
      }
      synchronizer1.getOutputBranch().runWrite(() -> {
        runReadOnTransformationOutput(() -> {
          inputChanged(inputRepositoryMirror.getBranch().getTransaction().getTree());
          try {
            synchronizer1.updateRepository(getRootTransformationOutput());
          } catch (SM_PNodeIdMissingException ex) {
            engine.invalidateAll();
            throw ex;
          }
        });
        return Unit.INSTANCE;
      });
      long transformEnd = System.nanoTime();
      if (LOG.isDebugLevel()) {
        LOG.debug("Transformations executed in " + 0.000001 * (transformEnd - transformStart) + " ms");
      }

      if (stopSyncThread) {
        return;
      }

      // Possibly expensive transformations are executed outside any write or read action.
      // Writing the result into the shadow repository is a fast operation.
      SM_CommandHelper.runInCommand(() -> {
        if (stopSyncThread) {
          return;
        }
        ContextArea.INSTANCE.getCONTEXT_VALUE().computeWith(new MPSArea(repository), () -> {
          long start = System.nanoTime();
          synchronizer2.update(synchronizer1.getOutputBranch());
          long end = System.nanoTime();
          if (LOG.isDebugLevel()) {
            LOG.debug("Shadow repository written in " + 0.000001 * (end - start) + " ms");
          }
          return Unit.INSTANCE;
        });
      });
      dirty = false;
    }

  }

  public SNode getRootTransformationOutput() {
    SNode repositorySpec;
    try {
      INode transformationOutput = OutputNodeReferenceAsNode.create(engine, Sequence.fromIterable(transformationOutputRef.getNodes(engine)).first());
      repositorySpec = SNodeOperations.cast(NodeToSNodeAdapter.wrap(DependencyTrackingNode.wrap(transformationOutput)), CONCEPTS.Repository$db);
    } catch (NoApplicableImplementationException ex) {
      if (!(Objects.equals(REPOSITORY_TRANSFORMATION_ID, ex.getFunctionId()))) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
      repositorySpec = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, "org.modelix.model.repositoryconcepts.structure.Repository"));
    }
    return repositorySpec;
  }

  protected void inputChanged(ITree newTree) {
    if (loadedInputTree == newTree) {
      return;
    }

    final Set<DependencyKey> changes = SetSequence.fromSet(new HashSet<DependencyKey>());
    newTree.visitChanges(loadedInputTree, new SM_ITreeChangeVisitor() {
      public INodeReference toNodeRef(long nodeId) {
        return new SM_PNodeAdapter(nodeId, inputRepositoryMirror.getBranch()).getReference();
      }
      @Override
      public void containmentChanged(long nodeId) {
        SetSequence.fromSet(changes).addElement(new ContainmentDependency(toNodeRef(nodeId)));
      }
      @Override
      public void childrenChanged(long nodeId, String role) {
        SetSequence.fromSet(changes).addElement(new RoleDependency(toNodeRef(nodeId), role));
        SetSequence.fromSet(changes).addElement(new AllChildrenDependency(toNodeRef(nodeId)));
      }
      @Override
      public void referenceChanged(long nodeId, String role) {
        SetSequence.fromSet(changes).addElement(new RoleDependency(toNodeRef(nodeId), role));
      }
      @Override
      public void propertyChanged(long nodeId, String role) {
        SetSequence.fromSet(changes).addElement(new RoleDependency(toNodeRef(nodeId), role));
      }
      @Override
      public void userObjectChanged(long nodeId, Object key) {
      }
      @Override
      public void nodeRemoved(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(inputRepositoryMirror.getBranch(), nodeId));
      }
      @Override
      public void nodeAdded(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(inputRepositoryMirror.getBranch(), nodeId));
      }
      @Override
      public void nodeLoaded(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(inputRepositoryMirror.getBranch(), nodeId));
      }
      @Override
      public void nodeUnloaded(long nodeId) {
        SetSequence.fromSet(changes).addElement(new SM_PNodeDependency(inputRepositoryMirror.getBranch(), nodeId));
      }
    });
    engine.invalidate(changes);
    loadedInputTree = newTree;
  }

  public void dispose() {
    ourInstance = null;
    disposed = true;
    stopSyncThread = true;
    try {
      syncThread.join(3000);
    } catch (InterruptedException ex) {
    }
    classChangeListener.stop();
    engine.removeInvalidationListener(invalidationListener);
    synchronizer1.dispose();
    synchronizer2.dispose();
    inputRepositoryMirror.dispose();
    engine.dispose();
    invalidatable.dispose();
  }

  @Nullable
  public INode getTransformationOutputNode(SNode snode) {
    SM_PNodeAdapter pnode = (SM_PNodeAdapter) synchronizer2.getInputNode(snode);
    if (pnode == null) {
      return null;
    }
    return synchronizer1.getInputNode(pnode.getNodeId());
  }

  /**
   * 
   * @deprecated  Use RepositoryMirror.getOriginalNode
   */
  @Nullable
  @Deprecated
  public SNode getOriginalInputNode(INode node) {
    return inputRepositoryMirror.getOriginalNode(node);
  }

  /**
   * 
   * @deprecated  Use RepositoryMirror.getOriginalNode
   */
  @Nullable
  @Deprecated
  public SNode getOriginalInputNode(SNode node) {
    return getOriginalInputNode(SNodeToNodeAdapter.wrap(node));
  }

  public void runRead(final _FunctionTypes._void_P0_E0 runnable) {
    synchronizer1.getOutputBranch().runRead(() -> {
      runReadOnTransformationOutput(runnable);
      return Unit.INSTANCE;
    });
  }

  public void runReadOnTransformationOutput(final _FunctionTypes._void_P0_E0 r) {
    if (!(inputRepositoryMirror.getBranch().canRead())) {
      if (repository.getModelAccess().canRead()) {
        throw new RuntimeException("Running this from a repository read/write action can result in a deadlock");
        // ShadowTypesystemUtil starts read actions
      }
    }
    synchronized (engine.getIncrementalEngine()) {
      inputRepositoryMirror.getBranch().runRead(() -> {
        ContextArea.INSTANCE.getCONTEXT_VALUE().computeWith(inputRepositoryMirror.getArea(), () -> {
          r.invoke();
          return Unit.INSTANCE;
        });
        return Unit.INSTANCE;
      });
    }
  }

  protected static boolean isClassLoaderDisposed() {
    ModuleClassLoader cl = (ModuleClassLoader) SM_RepositoryModulesManager.class.getClassLoader();
    return cl.isDisposed();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Repository$db = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, "org.modelix.model.repositoryconcepts.structure.Repository");
  }
}

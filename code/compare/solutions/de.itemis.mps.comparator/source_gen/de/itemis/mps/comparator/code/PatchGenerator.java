package de.itemis.mps.comparator.code;

/*Generated by MPS */

import jetbrains.mps.references.Reference;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.NotNull;
import java.io.Writer;
import java.io.IOException;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.vfs.VFileProperty;
import java.util.Locale;
import java.util.List;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.intellij.util.diff.Diff;
import com.intellij.util.diff.FilesTooBigForDiffException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class PatchGenerator {
  private final PatchGeneratorOptions options;

  private static final String HUNK_MARKER = "@@";
  private static final String PATH_SEPARATOR = "/";
  private static final String ADDITION_MARKER = "+++";
  private static final String ADDITION_LINE_MARKER = "+";
  private static final String REMOVAL_MARKER = "---";
  private static final String REMOVED_LINE_MARKER = "-";
  private static final String DEV_NULL = "/dev/null";

  private static final String HIDDEN_FILES_PREFIX = ".";

  public PatchGenerator() {
    this(new PatchGeneratorOptions());
  }

  public PatchGenerator(PatchGeneratorOptions options) {
    this.options = options;
  }

  public static class PatchGeneratorOptions {
    private WhitespaceHandling myWhitespaceHandling;
    public WhitespaceHandling getWhitespaceHandling() {
      return this.myWhitespaceHandling;
    }
    private void _setWhitespaceHandling(WhitespaceHandling value) {
      this.myWhitespaceHandling = value;
    }
    public WhitespaceHandling setWhitespaceHandling(WhitespaceHandling value) {
      _setWhitespaceHandling(value);
      return value;
    }
    public Reference<WhitespaceHandling> refToWhitespaceHandling() {
      return new Reference<WhitespaceHandling>() {
        public WhitespaceHandling get() {
          return getWhitespaceHandling();
        }
        public void set(WhitespaceHandling value) {
          _setWhitespaceHandling(value);
        }
      };
    }
    private boolean myIgnoreHiddenFiles;
    public boolean isIgnoreHiddenFiles() {
      return this.myIgnoreHiddenFiles;
    }
    private void _setIgnoreHiddenFiles(boolean value) {
      this.myIgnoreHiddenFiles = value;
    }
    public boolean setIgnoreHiddenFiles(boolean value) {
      _setIgnoreHiddenFiles(value);
      return value;
    }
    public Reference<Boolean> refToIgnoreHiddenFiles() {
      return new Reference<Boolean>() {
        public Boolean get() {
          return isIgnoreHiddenFiles();
        }
        public void set(Boolean value) {
          _setIgnoreHiddenFiles(value);
        }
      };
    }
    private boolean myIgnoreFileCase;
    public boolean isIgnoreFileCase() {
      return this.myIgnoreFileCase;
    }
    private void _setIgnoreFileCase(boolean value) {
      this.myIgnoreFileCase = value;
    }
    public boolean setIgnoreFileCase(boolean value) {
      _setIgnoreFileCase(value);
      return value;
    }
    public Reference<Boolean> refToIgnoreFileCase() {
      return new Reference<Boolean>() {
        public Boolean get() {
          return isIgnoreFileCase();
        }
        public void set(Boolean value) {
          _setIgnoreFileCase(value);
        }
      };
    }
    private boolean myIgnoreContentCase;
    public boolean isIgnoreContentCase() {
      return this.myIgnoreContentCase;
    }
    private void _setIgnoreContentCase(boolean value) {
      this.myIgnoreContentCase = value;
    }
    public boolean setIgnoreContentCase(boolean value) {
      _setIgnoreContentCase(value);
      return value;
    }
    public Reference<Boolean> refToIgnoreContentCase() {
      return new Reference<Boolean>() {
        public Boolean get() {
          return isIgnoreContentCase();
        }
        public void set(Boolean value) {
          _setIgnoreContentCase(value);
        }
      };
    }

    public PatchGeneratorOptions() {
      this.setWhitespaceHandling(WhitespaceHandling.KEEP);
      this.setIgnoreHiddenFiles(true);
      this.setIgnoreFileCase(true);
      this.setIgnoreContentCase(false);
    }

    public static PatchGeneratorOptions ignoreNothing() {
      PatchGeneratorOptions options = new PatchGeneratorOptions();
      options.setIgnoreContentCase(false);
      options.setIgnoreFileCase(false);
      options.setIgnoreHiddenFiles(false);
      return options;
    }
  }

  public void generateDiff(@Nullable VirtualFile expected, @Nullable VirtualFile actual, @NotNull Writer output) throws IOException {
    generateDiff(expected, actual, output, "");
  }

  public void generateDiff(@Nullable VirtualFile expected, @Nullable VirtualFile actual, @NotNull Writer output, @Nullable String pathPrefix) throws IOException {

    if ((expected != null && expected.isDirectory()) || (actual != null && actual.isDirectory())) {
      Map<String, VirtualFile> expectedChildren = getChildrenMap(expected);
      Map<String, VirtualFile> actualChildren = getChildrenMap(actual);
      // Files only in expected (deleted)
      for (String name : MapSequence.fromMap(expectedChildren).keySet()) {
        if (!(MapSequence.fromMap(actualChildren).containsKey(name))) {
          VirtualFile expChild = MapSequence.fromMap(expectedChildren).get(name);
          if (expChild.isDirectory()) {
            if (isEmptyDirectory(expChild)) {
              output.write(String.format("%s %s%s (empty directory deleted)\n", REMOVAL_MARKER, pathPrefix, expChild.getName()));
            } else {
              generateDiff(expChild, null, output, pathPrefix + expChild.getName() + PATH_SEPARATOR);
            }
          } else {
            writeFileDiff(expChild, null, output, pathPrefix + expChild.getName(), null);
          }
        }
      }
      // Files only in actual (added)
      for (String name : MapSequence.fromMap(actualChildren).keySet()) {
        if (!(MapSequence.fromMap(expectedChildren).containsKey(name))) {
          VirtualFile actChild = MapSequence.fromMap(actualChildren).get(name);
          if (actChild.isDirectory()) {
            if (isEmptyDirectory(actChild)) {
              output.write(String.format("%s %s%s (empty directory added)\n", ADDITION_MARKER, pathPrefix, actChild.getName()));
            } else {
              generateDiff(null, actChild, output, pathPrefix + actChild.getName() + PATH_SEPARATOR);
            }
          } else {
            writeFileDiff(null, actChild, output, null, pathPrefix + actChild.getName());
          }
        }
      }
      // Files in both: compare
      for (String name : MapSequence.fromMap(expectedChildren).keySet()) {
        if (MapSequence.fromMap(actualChildren).containsKey(name)) {
          VirtualFile expChild = MapSequence.fromMap(expectedChildren).get(name);
          VirtualFile actChild = MapSequence.fromMap(actualChildren).get(name);
          if (expChild.isDirectory() && actChild.isDirectory()) {
            generateDiff(expChild, actChild, output, pathPrefix + expChild.getName() + PATH_SEPARATOR);
          } else
          if (!(expChild.isDirectory()) && !(actChild.isDirectory())) {
            writeFileDiff(expChild, actChild, output, pathPrefix + expChild.getName(), pathPrefix + actChild.getName());
          } else {
            // Type changed
            output.write(String.format("%s %s%s\n", REMOVAL_MARKER, pathPrefix, expChild.getName()));
            output.write(String.format("%s %s%s\n", ADDITION_MARKER, pathPrefix, actChild.getName()));
            output.write(String.format("%s Type changed (file <-> dir) %s\n", HUNK_MARKER, HUNK_MARKER));
          }
        }
      }
    } else {
      // Both are files (or one is null)
      writeFileDiff(expected, actual, output, (expected != null ? pathPrefix + expected.getName() : null), (actual != null ? pathPrefix + actual.getName() : null));
    }
  }

  private Map<String, VirtualFile> getChildrenMap(@Nullable VirtualFile folder) {
    Map<String, VirtualFile> map = MapSequence.fromMap(new HashMap<String, VirtualFile>());
    if (folder != null && folder.isDirectory()) {
      for (VirtualFile child : folder.getChildren()) {
        String name = child.getName();
        if (options.isIgnoreHiddenFiles() && (name.startsWith(HIDDEN_FILES_PREFIX)) || child.is(VFileProperty.HIDDEN)) {
          continue;
        }

        String key = (options.isIgnoreFileCase() ? name.toLowerCase(Locale.ROOT) : name);
        MapSequence.fromMap(map).put(key, child);
      }
    }
    return map;
  }

  private void writeFileDiff(@Nullable VirtualFile expected, @Nullable VirtualFile actual, @NotNull Writer output, @Nullable String expectedPath, @Nullable String actualPath) throws IOException {
    if (expected == null && actual == null) {
      return;
      // Both missing, nothing to do
    }

    List<String> expectedLines = ((expected != null) ? readLines(expected) : Collections.<String>emptyList());
    List<String> actualLines = ((actual != null) ? readLines(actual) : Collections.<String>emptyList());
    if (expected == null) {
      // File added
      output.write(String.format("%s %s\n", REMOVAL_MARKER, DEV_NULL));
      writeAddition(output, actualPath);
      writeAddedLines(actualLines, output);
    } else
    if (actual == null) {
      // File deleted
      writeRemoval(output, expectedPath);
      output.write(String.format("%s %s\n", ADDITION_MARKER, DEV_NULL));
      writeDeletedLines(expectedLines, output);
    } else
    if (!(linesEqual(expectedLines, actualLines))) {
      // File changed
      List<String> diff = getChangedLines(expectedLines, actualLines);
      if (ListSequence.fromList(diff).isNotEmpty()) {
        writeRemoval(output, expectedPath);
        writeAddition(output, actualPath);
        for (String line : diff) {
          output.write(line);
        }
      }
    }
  }

  @Nullable
  private String processWhitespace(@Nullable String line) {
    if (line == null) {
      return null;
    }

    switch (options.getWhitespaceHandling()) {
      case IGNORE_COMPLETELY:
        return line.replaceAll("\\s+", "");
      case TRIM_BOTH:
        return ((line == null ? null : line.trim()));
      case TRIM_LEADING:
        return StringUtils.stripStart(line, " \n\r\t");
      case TRIM_TRAILING:
        return StringUtils.stripEnd(line, " \n\r\t");
      case KEEP:
        return line;
    }

    return null;
  }

  private boolean linesEqual(List<String> expectedLines, List<String> actualLines) {
    if (ListSequence.fromList(expectedLines).count() != ListSequence.fromList(actualLines).count()) {
      return false;
    }
    for (int i = 0; i < ListSequence.fromList(expectedLines).count(); i++) {
      String left = processWhitespace(ListSequence.fromList(expectedLines).getElement(i));
      String right = processWhitespace(ListSequence.fromList(actualLines).getElement(i));
      if (options.isIgnoreContentCase()) {
        if (!(check_sc8lol_a0a0c0b0cb(left, right))) {
          return false;
        }
      } else {
        if (!(check_sc8lol_a0a0a2a1a82(left, right))) {
          return false;
        }
      }
    }
    return true;
  }


  private void writeRemoval(@NotNull Writer output, @Nullable String path) throws IOException {
    output.write(String.format("%s %s\n", REMOVAL_MARKER, ((path != null ? path : DEV_NULL))));
  }

  private void writeAddition(@NotNull Writer output, @Nullable String path) throws IOException {
    output.write(String.format("%s %s\n", ADDITION_MARKER, (path != null ? path : DEV_NULL)));
  }

  private void writeAddedLines(List<String> lines, @NotNull Writer output) throws IOException {
    if (ListSequence.fromList(lines).isEmpty()) {
      return;
    }
    output.write(String.format("%s %s0,0 %s%d %s\n", HUNK_MARKER, REMOVED_LINE_MARKER, ADDITION_LINE_MARKER, ListSequence.fromList(lines).count(), HUNK_MARKER));
    for (String line : lines) {
      output.write(String.format("%s%s\n", ADDITION_LINE_MARKER, line));
    }
  }

  private void writeDeletedLines(List<String> lines, @NotNull Writer output) throws IOException {
    if (ListSequence.fromList(lines).isEmpty()) {
      return;
    }

    output.write(String.format("%s %s%d %s0,0 %s\n", HUNK_MARKER, REMOVED_LINE_MARKER, ListSequence.fromList(lines).count(), ADDITION_LINE_MARKER, HUNK_MARKER));
    for (String line : lines) {
      output.write(String.format("%s%s\n", REMOVED_LINE_MARKER, line));
    }
  }

  private List<String> getChangedLines(List<String> expectedLines, List<String> actualLines) {
    String[] leftArr;
    String[] rightArr;

    expectedLines = ListSequence.fromList(expectedLines).select((it) -> processWhitespace(it)).toList();
    actualLines = ListSequence.fromList(actualLines).select((it) -> processWhitespace(it)).toList();

    if (options.isIgnoreContentCase()) {
      leftArr = ListSequence.fromList(expectedLines).select((it) -> it.toLowerCase(Locale.ROOT)).toGenericArray(String.class);
      rightArr = ListSequence.fromList(actualLines).select((it) -> it.toLowerCase(Locale.ROOT)).toGenericArray(String.class);
    } else {
      leftArr = ListSequence.fromList(expectedLines).toGenericArray(String.class);
      rightArr = ListSequence.fromList(actualLines).toGenericArray(String.class);
    }
    List<String> result = new ArrayList<>();
    Diff.Change change;
    try {
      change = Diff.buildChanges(leftArr, rightArr);
    } catch (FilesTooBigForDiffException e) {
      return result;
    }

    while (change != null) {
      int deleted = change.deleted;
      int inserted = change.inserted;
      int line0 = change.line0;
      int line1 = change.line1;
      ListSequence.fromList(result).addElement(String.format("%s %s%d,%d %s%d,%d %s\n", HUNK_MARKER, REMOVED_LINE_MARKER, line0 + 1, deleted, ADDITION_LINE_MARKER, line1 + 1, inserted, HUNK_MARKER));
      for (int i = 0; i < deleted; i++) {
        ListSequence.fromList(result).addElement(String.format("%s%s\n", REMOVED_LINE_MARKER, leftArr[line0 + i]));
      }
      for (int i = 0; i < inserted; i++) {
        ListSequence.fromList(result).addElement(String.format("%s%s\n", ADDITION_LINE_MARKER, rightArr[line1 + i]));
      }
      change = change.link;
    }
    return result;
  }

  private List<String> readLines(@Nullable VirtualFile file) throws IOException {
    List<String> lines = ListSequence.fromList(new ArrayList<String>());
    if (file != null && !(file.isDirectory())) {
      try (BufferedReader reader = new BufferedReader(new InputStreamReader(file.getInputStream()))) {
        String line;
        while ((line = reader.readLine()) != null) {
          ListSequence.fromList(lines).addElement(line);
        }
      }
    }
    return lines;
  }

  private boolean isEmptyDirectory(@Nullable VirtualFile dir) {
    return dir != null && dir.isDirectory() && MapSequence.fromMap(getChildrenMap(dir)).isEmpty();
  }

  private static boolean check_sc8lol_a0a0a2a1a82(String checkedDotOperand, String right) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.equals(right);
    }
    return false;
  }
  private static boolean check_sc8lol_a0a0c0b0cb(String checkedDotOperand, String right) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.equalsIgnoreCase(right);
    }
    return false;
  }
}

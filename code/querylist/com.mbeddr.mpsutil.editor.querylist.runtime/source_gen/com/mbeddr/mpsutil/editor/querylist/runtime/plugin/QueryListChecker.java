package com.mbeddr.mpsutil.editor.querylist.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.checking.UpdateResult;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.util.Cancellable;
import com.intellij.ide.util.PropertiesComponent;
import java.util.Collections;
import jetbrains.mps.nodeEditor.EditorMessage;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.ExecutionException;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import java.util.HashSet;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import com.mbeddr.mpsutil.editor.querylist.runtime.EditorCell_QueryList;
import com.mbeddr.mpsutil.editor.querylist.runtime.QueryListHandler;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Collection;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.nodeEditor.HighlighterMessage;
import jetbrains.mps.components.ComponentHost;
import jetbrains.mps.util.CollectConsumer;
import jetbrains.mps.checkers.ModelCheckerBuilder;
import jetbrains.mps.errors.item.IssueKindReportItem;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.errors.item.NodeFlavouredItem;
import jetbrains.mps.checkers.IChecker;
import jetbrains.mps.lang.test.runtime.NodeCheckerUtil;
import jetbrains.mps.typesystemEngine.checker.NonTypesystemChecker;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.smodel.event.SModelEvent;

public class QueryListChecker extends BaseEditorChecker {
  public static final String MODELCHECK_ENABLED_KEY = "querylist.modelcheck.enabled";

  private final SRepository myRepository;
  private boolean myHasEvents = false;

  public QueryListChecker(SRepository repository) {
    myRepository = repository;
  }

  @NotNull
  @Override
  public UpdateResult update(final EditorComponent editorComponent, final boolean incremental, final boolean applyQuickFixes, final Cancellable cancellable) {
    QueryListConfig config = findConfig();

    if (!(!(config.disableModelChecking()) && PropertiesComponent.getInstance().getBoolean(MODELCHECK_ENABLED_KEY, true))) {
      return new UpdateResult.Completed(true, Collections.<EditorMessage>emptySet());
    }

    final Set<SNode> nodesToCheck = collectNodesToCheck(editorComponent.getRootCell());
    final List<SModel> modelsToCheck = SetSequence.fromSet(nodesToCheck).select((it) -> SNodeOperations.getModel(it)).distinct().where(new NotNullWhereFilter()).toList();

    if (config.getTimeout().isZero()) {
      return checkModels(modelsToCheck, nodesToCheck, editorComponent, cancellable);
    }

    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future<UpdateResult> handler = executor.submit(new Callable<UpdateResult>() {
      @Override
      public UpdateResult call() throws Exception {
        final Wrappers._T<UpdateResult> result = new Wrappers._T<UpdateResult>(UpdateResult.CANCELLED);
        myRepository.getModelAccess().runReadAction(() -> result.value = checkModels(modelsToCheck, nodesToCheck, editorComponent, cancellable));
        return result.value;
      }
    });

    try {
      return handler.get(config.getTimeout().toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException | InterruptedException | ExecutionException e) {
      return UpdateResult.CANCELLED;
    } finally {
      executor.shutdownNow();
    }
  }

  private QueryListConfig findConfig() {
    ExtensionPoint<QueryListConfig> ep = new ExtensionPoint<QueryListConfig>("com.mbeddr.mpsutil.editor.querylist.runtime.queryListExtPoint");
    Iterable<QueryListConfig> sortedConfigs = Sequence.fromIterable(ep.getObjects()).sort((it) -> it.getPriorityLevel(), false);
    return Sequence.fromIterable(sortedConfigs).first();
  }

  private Set<SNode> collectNodesToCheck(@Nullable EditorCell rootCell) {
    if (rootCell == null) {
      return SetSequence.fromSet(new HashSet<SNode>());
    }
    Iterable<jetbrains.mps.openapi.editor.cells.EditorCell> allCells = CellTraversalUtil.iterateTree(rootCell, rootCell, true);
    Iterable<EditorCell_QueryList> queryListCells = Sequence.fromIterable(allCells).ofType(EditorCell_QueryList.class).where((it) -> !(it.disableModelChecking()));
    return SetSequence.fromSetWithValues(new HashSet<SNode>(), Sequence.fromIterable(queryListCells).translate((it) -> {
      QueryListHandler handler = ((QueryListHandler) it.getCellListHandler());
      return handler.getNodesForList(handler.getNode());
    }));
  }

  private UpdateResult checkModels(List<SModel> modelsToCheck, Set<SNode> nodesToCheck, final EditorComponent editorComponent, Cancellable cancellable) {
    Set<EditorMessage> messages = SetSequence.fromSet(new HashSet<EditorMessage>());

    for (SModel modelToCheck : ListSequence.fromList(modelsToCheck)) {
      if (cancellable.isCancelled()) {
        return UpdateResult.CANCELLED;
      }
      Collection<NodeReportItem> errors = checkForNodeMessages(editorComponent, modelToCheck, nodesToCheck, MPSCoreComponents.getInstance().getPlatform(), cancellable);
      for (NodeReportItem errorReporter : CollectionSequence.fromCollection(errors)) {
        HighlighterMessage message = new HighlighterMessage(this, errorReporter, errorReporter.getNode().resolve(editorComponent.getEditorContext().getRepository()));
        SetSequence.fromSet(messages).addElement(message);
      }
    }

    return new UpdateResult.Completed(true, messages);
  }

  /**
   * based on NodeCheckerUtil#checkForNodeMessages
   */
  public Collection<NodeReportItem> checkForNodeMessages(EditorComponent editorComponent, SModel model, final Set<SNode> nodesToCheck, @Nullable ComponentHost host, Cancellable cancellable) {
    final CollectConsumer<NodeReportItem> resultConsumer = new CollectConsumer<NodeReportItem>();
    new ModelCheckerBuilder(false).createChecker(getCheckers(host)).check(ModelCheckerBuilder.ItemsToCheck.forSingleModel(model), myRepository, (IssueKindReportItem reportItem) -> {
      SNodeReference reportedNode = NodeFlavouredItem.FLAVOUR_NODE.tryToGet(reportItem);
      if (reportedNode != null) {
        Iterable<SNode> reportedNodeAndAncestors = SNodeOperations.getNodeAncestors(((SNode) reportedNode.resolve(myRepository)), null, true);
        if (Sequence.fromIterable(reportedNodeAndAncestors).any((it) -> SetSequence.fromSet(nodesToCheck).contains(it))) {
          resultConsumer.consume((NodeReportItem) reportItem);
        }
      }
    }, new CancellableEmptyProgessMonitor(cancellable));
    return resultConsumer.getResult();
  }

  private List<IChecker<?, ? extends IssueKindReportItem>> getCheckers(@Nullable ComponentHost host) {
    List<IChecker<?, ? extends IssueKindReportItem>> standardCheckers = NodeCheckerUtil.getStandardCheckers(host);
    IChecker<?, ? extends IssueKindReportItem> nonTypesystemChecker = ListSequence.fromList(standardCheckers).findFirst((it) -> it instanceof NonTypesystemChecker);
    if (nonTypesystemChecker != null) {
      int index = ListSequence.fromList(standardCheckers).indexOf(nonTypesystemChecker);
      ListSequence.fromList(standardCheckers).setElement(index, new ComputationModePreservingNonTypesystemChecker());
    }
    return standardCheckers;
  }

  private static class CancellableEmptyProgessMonitor extends EmptyProgressMonitor {
    private final Cancellable cancellable;

    public CancellableEmptyProgessMonitor(@NotNull Cancellable cancellable) {
      this.cancellable = cancellable;
    }

    @Override
    public boolean isCanceled() {
      return cancellable.isCancelled() || super.isCanceled();
    }
  }

  @Override
  public void processEvents(List<SModelEvent> events) {
    myHasEvents |= !(events.isEmpty());
  }

  @Override
  public boolean needsUpdate(EditorComponent component) {
    return myHasEvents;
  }

  @Override
  public void doneUpdating() {
    myHasEvents = false;
  }
}

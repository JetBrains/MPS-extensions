package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.modelix.model.api.IChildLink;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ISequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.INode;
import java.util.Objects;
import org.modelix.model.api.IConcept;

public class CopiedOutputNodeReference extends AbstractOutputNodeReference implements IOutputNodeReference {
  private IStageReference stageRef;
  private IUniqueContainmentTarget<CopyCall> copyCall;

  private CopiedOutputNodeReference() {
    // for deserialization
  }

  public CopiedOutputNodeReference(IStageReference stageRef, IUniqueContainmentTarget<CopyCall> input) {
    this.stageRef = stageRef;
    this.copyCall = input;
  }

  public Iterable<Tuples._2<String, IUniqueContainmentTarget>> getUniqueContainmentTargetForChildren(final ITransformationEngine engine) {
    final IOutputNode parent = getInputONode();
    Iterable<IChildLink> childLinks = parent.getConcept().getAllChildLinks();
    return Sequence.fromIterable(childLinks).select((it) -> it.getName()).translate(new _FunctionTypes._return_P1_E0<ISequence<Tuples._2<String, IUniqueContainmentTarget>>, String>() {
      public ISequence<Tuples._2<String, IUniqueContainmentTarget>> invoke(final String role) {
        return Sequence.fromIterable(parent.getChildren(role)).select(new _FunctionTypes._return_P1_E0<Tuples._2<String, IUniqueContainmentTarget>, IOutputNodeReference>() {
          public Tuples._2<String, IUniqueContainmentTarget> invoke(IOutputNodeReference child) {
            IUniqueContainmentTarget u = new UniqueDescendant(child, engine);
            return MultiTuple.<String,IUniqueContainmentTarget>from(role, u);
          }
        });
      }
    });
  }

  @Nullable
  @Override
  public IStageReference getStageRef() {
    return stageRef;
  }

  @Override
  public IScope getScope(ITransformationEngine engine) {
    return copyCall.getScope();
  }

  @Override
  public Iterable<INode> getInputNodes() {
    return copyCall.getTarget().getInputNodes();
  }

  public INode getInputNode() {
    return copyCall.getTarget().getInput();
  }

  public IOutputNode getInputONode() {
    INode node = getInputNode();
    INode unwrappedNode = check_p30roy_a0b0r(as_p30roy_a0a0b0r(check_p30roy_a0a0b0r(as_p30roy_a0a0a0a1a71(node, OutputNodeReferenceAsNode.class)), NodeAsOutputNodeReference.class));
    return new NodeAsOutputNode((unwrappedNode != null ? unwrappedNode : node));
  }

  @Override
  public IUniqueContainmentTarget getOriginalContainmentTarget() {
    return copyCall;
  }

  @Override
  public IOutputNode resolve(ITransformationEngine engine) {
    return new OutputNode(engine);
  }

  @Override
  public String getTraceInfo() {
    return copyCall.getTarget().getTraceInfo();
  }

  @Override
  public String toString() {
    return "" + copyCall;
  }

  private transient int _cachedHashCode;
  private transient boolean _hashCodeInitialized = false;
  @Override
  public int hashCode() {
    if (!(_hashCodeInitialized)) {
      int c = 0;
      c = 31 * c + Objects.hashCode(stageRef);
      c = 31 * c + Objects.hashCode(copyCall);
      _cachedHashCode = c;
      _hashCodeInitialized = true;
    }
    return _cachedHashCode;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    CopiedOutputNodeReference that = (CopiedOutputNodeReference) o;
    if (!(Objects.equals(stageRef, that.stageRef))) {
      return false;
    }
    if (!(Objects.equals(copyCall, that.copyCall))) {
      return false;
    }
    return true;
  }

  public class UniqueDescendant implements IUniqueContainmentTarget<RewriteCall> {
    private IOutputNodeReference inputDescendant;
    private ITransformationEngine engine;

    public UniqueDescendant(IOutputNodeReference inputDescendant, ITransformationEngine engine) {
      this.inputDescendant = inputDescendant;
      this.engine = engine;
    }
    public CopiedOutputNodeReference getRootReference() {
      return CopiedOutputNodeReference.this;
    }
    @Override
    public RewriteCall getTarget() {
      return new RewriteCall(DependencyTrackingNode.wrap(OutputNodeReferenceAsNode.create(engine, inputDescendant)), copyCall.getTarget().getTraceInfo());
    }

    @Override
    public Iterable<INode> getInputNodes() {
      return Sequence.<INode>singleton(OutputNodeReferenceAsNode.create(engine, inputDescendant));
    }
    @Override
    public IScope getScope() {
      return copyCall.getScope();
    }

    private transient int _cachedHashCode;
    private transient boolean _hashCodeInitialized = false;
    @Override
    public int hashCode() {
      if (!(_hashCodeInitialized)) {
        int c = 0;
        c = 31 * c + Objects.hashCode(inputDescendant);
        c = 31 * c + Objects.hashCode(engine);
        c = 31 * c + Objects.hashCode(getRootReference());
        _cachedHashCode = c;
        _hashCodeInitialized = true;
      }
      return _cachedHashCode;
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }
      UniqueDescendant that = (UniqueDescendant) o;
      if (!(Objects.equals(inputDescendant, that.inputDescendant))) {
        return false;
      }
      if (!(Objects.equals(engine, that.engine))) {
        return false;
      }
      if (!(Objects.equals(getRootReference(), that.getRootReference()))) {
        return false;
      }
      return true;
    }

    @Override
    public String toString() {
      return getTarget().toString();
    }
  }

  public class OutputNode implements IOutputNode {
    private ITransformationEngine engine;

    public OutputNode(ITransformationEngine engine) {
      this.engine = engine;
    }

    @Override
    public IOutputNodeReference getOutputNodeReference() {
      return CopiedOutputNodeReference.this;
    }
    @Override
    public IConcept getConcept() {
      return getInputNode().getConcept();
    }
    @Override
    public IContainment getContainment() {
      return engine.resolveContainment(getOutputNodeReference());
    }
    @Override
    public Iterable<IOutputNodeReference> getChildren(String role) {
      return copyChildren(getInputONode().getChildren(role));
    }
    @Override
    public Iterable<IOutputNodeReference> getAllChildren() {
      return copyChildren(getInputONode().getAllChildren());
    }
    protected Iterable<IOutputNodeReference> copyChildren(Iterable<IOutputNodeReference> children) {
      return Sequence.fromIterable(children).select(new _FunctionTypes._return_P1_E0<ContainmentTargetRootNodes, IOutputNodeReference>() {
        public ContainmentTargetRootNodes invoke(IOutputNodeReference it) {
          return new ContainmentTargetRootNodes(stageRef, new UniqueDescendant(it, engine));
        }
      }).translate(new _FunctionTypes._return_P1_E0<Iterable<IOutputNodeReference>, ContainmentTargetRootNodes>() {
        public Iterable<IOutputNodeReference> invoke(ContainmentTargetRootNodes it) {
          return it.getNodes(engine);
        }
      });
    }
    @Override
    public void addNewChild(String role, int index, @Nullable IConcept concept) {
      throw new UnsupportedOperationException();
    }
    @Override
    public IOutputNodeReference getReferenceTarget(String role) {
      IOutputNodeReference originalTarget = getInputONode().getReferenceTarget(role);
      if (originalTarget == null) {
        return null;
      }
      DependencyTrackingCheck.check(originalTarget);
      ISubgraphStage stage = engine.resolveStage(stageRef);

      IOutputNodeReference copiedTarget = new FirstRootRefTarget(new RewriteCall(DependencyTrackingNode.wrap(OutputNodeReferenceAsNode.create(engine, originalTarget)), null)).resolve(copyCall.getScope(), engine);
      return (copiedTarget != null ? copiedTarget : originalTarget);
    }
    @Override
    public void setReferenceTarget(String role, INode target) {
      throw new UnsupportedOperationException();
    }
    @Override
    public String getPropertyValue(String role) {
      return getInputONode().getPropertyValue(role);
    }
    @Override
    public void setPropertyValue(String role, String value) {
      throw new UnsupportedOperationException();
    }

    private transient int _cachedHashCode;
    private transient boolean _hashCodeInitialized = false;
    @Override
    public int hashCode() {
      if (!(_hashCodeInitialized)) {
        int c = 0;
        c = 31 * c + Objects.hashCode(getOutputNodeReference());
        c = 31 * c + Objects.hashCode(engine);
        _cachedHashCode = c;
        _hashCodeInitialized = true;
      }
      return _cachedHashCode;
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }
      OutputNode that = (OutputNode) o;
      if (!(Objects.equals(getOutputNodeReference(), that.getOutputNodeReference()))) {
        return false;
      }
      if (!(Objects.equals(engine, that.engine))) {
        return false;
      }
      return true;
    }
  }
  private static INode check_p30roy_a0b0r(NodeAsOutputNodeReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getNode();
    }
    return null;
  }
  private static IOutputNodeReference check_p30roy_a0a0b0r(OutputNodeReferenceAsNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getOutputNodeReference();
    }
    return null;
  }
  private static <T> T as_p30roy_a0a0b0r(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_p30roy_a0a0a0a1a71(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

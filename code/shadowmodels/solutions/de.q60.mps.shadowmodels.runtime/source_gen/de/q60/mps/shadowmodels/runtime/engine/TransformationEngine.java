package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import de.q60.mps.shadowmodels.runtime.util.UserObjectContainer;
import jetbrains.mps.logging.Logger;
import de.q60.mps.incremental.util.ContextValue;
import org.modelix.model.api.INode;
import de.q60.mps.incremental.runtime.IncrementalEngine;
import de.q60.mps.polymorphicfunctions.runtime.IPFContext;
import de.q60.mps.util.invalidation.Invalidatable;
import org.modelix.model.area.IArea;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.q60.mps.logging.runtime.ShadowLogging;
import java.util.Collections;
import de.q60.mps.polymorphicfunctions.runtime.NoApplicableImplementationException;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.q60.mps.incremental.runtime.DependencyKey;
import de.q60.mps.incremental.runtime.IInvalidationListener;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Objects;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.q60.mps.shadowmodels.runtime.mpslike.Genplan;
import java.util.Map;
import de.q60.mps.shadowmodels.runtime.mpslike.MappingConfigurationId;
import de.q60.mps.shadowmodels.runtime.mpslike.MappingConfiguration;
import de.q60.mps.shadowmodels.runtime.mpslike.GenplanStep;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import de.q60.mps.shadowmodels.runtime.mpslike.ReductionRule;
import de.q60.mps.shadowmodels.runtime.mpslike.IGenplanRule;
import de.q60.mps.polymorphicfunctions.runtime.ParameterList;
import de.q60.mps.shadowmodels.runtime.mpslike.GenplanGenerator;
import java.util.HashMap;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import de.q60.mps.shadowmodels.runtime.mpslike.WeavingRule;
import de.q60.mps.shadowmodels.runtime.model.SM_NodeUtil;
import de.q60.mps.shadowmodels.runtime.mpslike.IOutputWrapperRule;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import de.q60.mps.incremental.runtime.DependencyCycleException;

public class TransformationEngine extends UserObjectContainer implements ITransformationEngine {
  private static final Logger LOG = Logger.getLogger(TransformationEngine.class);

  public static final ContextValue<TransformationEngine> CONTEXT_ENGINE = new ContextValue();

  public static ITransformationEngine getInstance() {
    return CONTEXT_ENGINE.getValue();
  }

  public static ITransformationEngine getInstanceFromNode(INode node) {
    if (node instanceof DependencyTrackingNode) {
      return getInstanceFromNode(DependencyTrackingNode.unwrap(node));
    } else if (node instanceof ResultElementAsOutputNode) {
      return ((ResultElementAsOutputNode) node).getEngine();
    } else if (node instanceof OutputNodeReferenceAsNode) {
      return ((OutputNodeReferenceAsNode) node).getEngine();
    } else {
      return null;
    }
  }

  private IncrementalEngine incremental = new IncrementalEngine();
  private IPFContext myTransformationFunctions;
  private final ContextValue<IStageReference> currentContext;
  private final ContextValue<ISubgraphStage> currentlyComputedStage = new ContextValue<ISubgraphStage>();
  private Invalidatable invalidatable = new Invalidatable(getClass().getSimpleName() + " " + System.identityHashCode(this), () -> incremental.invalidateAll());

  public TransformationEngine(IPFContext transformationFunctions, boolean eager) {
    myTransformationFunctions = transformationFunctions;
    currentContext = new ContextValue<IStageReference>((eager ? EmptyRootSubgraphRef.INSTANCE : LazyRootSubgraphRef.INSTANCE));
  }

  public TransformationEngine(IPFContext transformationFunctions) {
    this(transformationFunctions, false);
  }

  @Override
  public IArea getArea() {
    return new TransformationOutputArea(this);
  }

  public IncrementalEngine getIncrementalEngine() {
    return incremental;
  }

  public void dispose() {
    incremental.dispose();
    invalidatable.dispose();
  }

  public IStageReference getCurrentContext() {
    return currentContext.getValue();
  }

  public ContextValue<IStageReference> currentContext() {
    return currentContext;
  }

  @Override
  public ISubgraphStage getCurrentlyComputedStage() {
    return currentlyComputedStage.getValue();
  }

  protected void applyRules(ContainmentTargetRootNodes<TransformationCall> call, TransformationResult result) {
    DependencyTrackingNode.checkHasTracking(call);

    Iterable<ITransformationRule> rules = selectRule(call.getContainmentTarget().getTarget(), false);
    for (ITransformationRule rule : Sequence.fromIterable(rules)) {
      applyRule(rule, call, result);
    }
  }

  protected void applyRule(final ITransformationRule rule, final ContainmentTargetRootNodes<TransformationCall> call, final TransformationResult result) {
    DependencyTrackingNode.checkHasTracking(call);
    rule.apply(call, result);
  }

  protected Iterable<ITransformationRule> selectRule(TransformationCall transformationCall, boolean allowNone) {
    DependencyTrackingNode.checkHasTracking(transformationCall);
    ITransformationRule rule;
    if (allowNone) {
      Iterable<Object> rules = Sequence.fromIterable(this.getTransformationFunctions().callFunctions(transformationCall.getId(), transformationCall.getParameters())).toList();
      if (Sequence.fromIterable(rules).count() > 1) {
        RuntimeException ex = new RuntimeException("Multiple applicable transformations found for " + transformationCall);
        ShadowLogging.logError(ex, transformationCall, rules);
        throw ex;
      }
      rule = (ITransformationRule) Sequence.fromIterable(rules).first();
      if (rule == null) {
        return Sequence.fromIterable(Collections.<ITransformationRule>emptyList());
      }
    } else {
      try {
        rule = (ITransformationRule) this.getTransformationFunctions().callFunction(transformationCall.getId(), transformationCall.getParameters());
      } catch (NoApplicableImplementationException ex) {
        RuntimeException ex2 = new RuntimeException("No transformation found for " + transformationCall.getId() + "(" + IterableUtils.join(Sequence.fromIterable(transformationCall.getParameters().asSequence()).select((it) -> "" + ((it instanceof INode ? ((INode) it).getConcept() : it))), ", ") + ")", ex);
        ShadowLogging.logError(ex2, transformationCall);
        throw ex2;
      }
    }
    List<ITransformationRule> contributions = Sequence.fromIterable(this.getTransformationFunctions().callFunctions(transformationCall.getId() + "&", transformationCall.getParameters())).select((it) -> (ITransformationRule) it).toList();
    return Sequence.fromIterable(Sequence.<ITransformationRule>singleton(rule)).concat(ListSequence.fromList(contributions));
  }

  @Override
  public Iterable<INode> executeInCurrentStage(IContainmentTarget call) {
    IStageReference stageRef = getCurrentContext();
    if (stageRef.isEager()) {
      throw new RuntimeException("Not supported by the current stage: " + stageRef);
    }
    ISubgraphStage stage = this.resolveStage(stageRef);
    Iterable<IOutputNodeReference> nodes = new ContainmentTargetRootNodes(stageRef, stage.makeUnique(null, call)).getNodes(this);
    return Sequence.fromIterable(nodes).select((it) -> {
      INode n = OutputNodeReferenceAsNode.create(TransformationEngine.this, it);
      return n;
    }).toList();
  }

  @Override
  public ITransformationResult execute(final IStageReference stage, final IUniqueContainmentTarget<TransformationCall> call) {
    return incremental.evaluate(new CK_TransformationEngine_execute(stage, call), () -> CONTEXT_ENGINE.computeWith(TransformationEngine.this, () -> currentContext.computeWith(stage, () -> doExecute(stage, call))));
  }

  protected ITransformationResult doExecute(IStageReference stage, IUniqueContainmentTarget<TransformationCall> call) {
    ContainmentTargetRootNodes targetRef = new ContainmentTargetRootNodes(stage, call);
    TransformationResult tresult = new TransformationResult(targetRef, this);
    applyRules(targetRef, tresult);
    tresult.freeze();
    return tresult;
  }

  public IPFContext getTransformationFunctions() {
    return myTransformationFunctions;
  }

  public void invalidateAll() {
    if (LOG.isDebugLevel()) {
      LOG.debug("Invalidate Engine");
    }
    incremental.invalidateAll();
  }

  public void invalidate(Iterable<DependencyKey> changes) {
    incremental.invalidate(changes);
  }

  public void addInvalidationListener(IInvalidationListener l) {
    incremental.addInvalidationListener(l);
  }

  public void removeInvalidationListener(IInvalidationListener l) {
    incremental.removeInvalidationListener(l);
  }

  @Override
  public ISubgraphStage resolveStage(@NotNull IStageReference stageRef) {
    final Wrappers._T<IStageReference> _stageRef = new Wrappers._T<IStageReference>(stageRef);
    ISubgraphStage current = Sequence.fromIterable(currentlyComputedStage.getAllValues()).findLast((it) -> Objects.equals(it.getStageReference(), _stageRef.value));
    if (current != null) {
      return current;
    }
    if (_stageRef.value.getSubgraphRef() instanceof ILazySubgraphRef) {
      if (!(_stageRef.value instanceof ILazyStageRef)) {
        _stageRef.value = new LazySubgraphStageReference((ILazySubgraphRef) _stageRef.value.getSubgraphRef());
      }
      return new LazyStage(this, (ILazyStageRef) _stageRef.value);
    }
    if (_stageRef.value instanceof StageReference) {
      return findStage(_stageRef.value);
    }
    throw new RuntimeException("Unsupported reference type: " + _stageRef.value.getClass().getName());
  }

  @Override
  public INode resolveResultElement(IOutputNodeReference ref) {
    return null;
  }

  @Override
  public Iterable<IOutputNodeReference> resolveRootNodes(ContainmentTargetRootNodes ref) {
    IUniqueContainmentTarget uniqueTarget = ref.getContainmentTarget();
    IContainmentTarget call = uniqueTarget.getTarget();
    ISubgraphStage stage = this.resolveStage(ref.getStageRef());
    if (call instanceof ISubgraphCall) {
      final ISubgraphStage childStage = this.getSubgraph(new ChildSubgraphRef(ref.getStageRef(), (IUniqueContainmentTarget<ISubgraphCall>) uniqueTarget));
      return Sequence.fromIterable(childStage.getRoots()).translate(new _FunctionTypes._return_P1_E0<Iterable<IOutputNodeReference>, IUniqueContainmentTarget>() {
        public Iterable<IOutputNodeReference> invoke(IUniqueContainmentTarget it) {
          return resolveRootNodes(new ContainmentTargetRootNodes(childStage.getStageReference(), it));
        }
      });
    } else {
      return stage.resolveContainmentTarget(uniqueTarget);
    }
  }

  @Override
  public IContainment resolveContainment(IOutputNodesReference child) {
    IContainment containment = strictResolveContainment(child);
    if (containment == null && child instanceof IOutputNodeReference) {
      containment = getRememberedContainmentsMap().get((IOutputNodeReference) child);
    }
    return containment;
  }

  protected IContainment strictResolveContainment(IOutputNodesReference child) {
    IContainment containment = null;

    if (child instanceof ResultElementOutputNodeReference) {
      ResultElementOutputNodeReference cast_it = (ResultElementOutputNodeReference) child;
      ISubgraphStage stage = this.resolveStage(cast_it.getStageRef());
      containment = stage.resolveContainment(cast_it);
    } else if (child instanceof ContainmentTargetRootNodes) {
      ContainmentTargetRootNodes cast_it = (ContainmentTargetRootNodes) child;
      ISubgraphStage stage = this.resolveStage(cast_it.getStageRef());
      containment = stage.resolveContainment(cast_it.getContainmentTarget());
    } else {
    }

    return containment;
  }

  @Override
  public void rememberContainment(IOutputNodeReference child, KnownContainment containment) {
    RememberedContainments rememberedContainments = getRememberedContainmentsMap();
    IContainment existing = rememberedContainments.get(child);
    if (Objects.equals(containment, existing)) {
      return;
    }

    if (strictResolveContainment(child) == null) {
      rememberedContainments.remember(child, containment);
    }
  }

  protected RememberedContainments getRememberedContainmentsMap() {
    return incremental.evaluate(new CK_TransformationEngine_getRememberedContainmentsMap(), () -> new RememberedContainments());
  }

  @Override
  public Iterable<? extends Iterable<INode>> executeCallExpression(IContainmentTarget call) {

    LazySubgraphStageReference stageRef = new LazySubgraphStageReference(new LazyChildSubgraphRef(getCurrentContext()));
    ContainmentTargetRootNodes containmentRef = new ContainmentTargetRootNodes(stageRef, new UniqueTargetInScope(new StageScope(stageRef), new LazyContainmentTarget(call)));
    Iterable<IOutputNodeReference> rootRefs = this.resolveRootNodes(containmentRef);

    // TODO a transformation can have multiple root sequences
    return Sequence.<Iterable<INode>>singleton(Sequence.fromIterable(rootRefs).select((it) -> OutputNodeReferenceAsNode.create(TransformationEngine.this, it)));
  }




  public IContainmentTarget computeRewriteReplacement(SubgraphStage stage, IUniqueContainmentTarget<RewriteCall> call) {
    DependencyTrackingNode.checkHasTracking(call);

    IRewriter rewriter = getRewriterFromContext(stage.getStageReference().getSubgraphRef());
    if (rewriter instanceof MPSLikeRewriter) {
      GoalCall goalCall = (GoalCall) ((ChildSubgraphRef) stage.getStageReference().getSubgraphRef()).getCall().getTarget();
      Genplan genplan = getGenplan(goalCall);
      final Map<MappingConfigurationId, MappingConfiguration> allMCs = getMappingConfigurationsMap(goalCall);
      int stepNumber = stage.getStageReference().getStepNumber();
      GenplanStep step = genplan.getStep(stepNumber);
      List<MappingConfiguration> mcs = Sequence.fromIterable(step.getMappingConfigurations()).select((it) -> MapSequence.fromMap(allMCs).get(it)).toList();
      Iterable<ReductionRule> reductionRules = ListSequence.fromList(mcs).translate((it) -> it.getReductionRules());
      for (ReductionRule rule : Sequence.fromIterable(reductionRules)) {
        if (!(call.getTarget().getInput().getConcept().isSubConceptOf(rule.getInputConcept()))) {
          continue;
        }
        if (!(rule.isApplicable(call.getTarget().getInput(), call.getScope()))) {
          continue;
        }
        return call.getTarget().toTransformationCall(rule.getTransformationId(), rule.getTraceInfo());
      }
    } else {
      if (rewriter != null) {
tid:
        for (String transformationId : rewriter.getTransformationIds()) {
          Iterable<ITransformationRule> rules = this.selectRule(call.getTarget().toTransformationCall(transformationId), true);
          if (Sequence.fromIterable(rules).isNotEmpty()) {
            return call.getTarget().toTransformationCall(transformationId);
          }
        }
      }
    }

    return call.getTarget().toCopyCall();
  }

  public Genplan getGenplan(final GoalCall goalCall) {
    return getIncrementalEngine().evaluate(new CK_TransformationEngine_getGenplan(goalCall), () -> {
      String goalId = goalCall.getGoalId();
      List<MappingConfiguration> mcs = ListSequence.fromList(getMappingConfigurationsList(goalCall)).toList();
      List<IGenplanRule> rules = Sequence.fromIterable(TransformationEngine.this.getTransformationFunctions().callFunctions(goalId + "/rules", new ParameterList(new Object[0]))).ofType(IGenplanRule.class).toList();
      return new GenplanGenerator().generate(mcs, rules);
    });
  }

  public Map<MappingConfigurationId, MappingConfiguration> getMappingConfigurationsMap(final GoalCall goalCall) {
    return this.getIncrementalEngine().evaluate(new CK_TransformationEngine_getMappingConfigurationsMap(goalCall), () -> {
      List<MappingConfiguration> mcs = getMappingConfigurationsList(goalCall);
      final Map<MappingConfigurationId, MappingConfiguration> map = MapSequence.fromMap(new HashMap<MappingConfigurationId, MappingConfiguration>());
      ListSequence.fromList(mcs).visitAll((it) -> MapSequence.fromMap(map).put(it.getId(), it));
      return map;
    });
  }

  public List<MappingConfiguration> getMappingConfigurationsList(final GoalCall goalCall) {
    return this.getIncrementalEngine().evaluate(new CK_TransformationEngine_getMappingConfigurationsList(goalCall), () -> {
      Iterable<Object> result = TransformationEngine.this.getTransformationFunctions().callFunctions(goalCall.getGoalId() + "/mc", new ParameterList(new Object[0]));
      return Sequence.fromIterable(result).translate((it) -> (Iterable<MappingConfiguration>) it).toList();
    });
  }

  protected IRewriter resolveRewriter(String id) {
    if (id == null) {
      return null;
    }
    Iterable<Object> rewriters = this.getTransformationFunctions().callFunctions(id, ParameterList.EMPTY);
    if (Sequence.fromIterable(rewriters).isEmpty()) {
      throw new RuntimeException("Cannot resolve rewriter: " + id);
    }
    return new CompositeRewriter(Sequence.fromIterable(rewriters).select((it) -> ((IRewriter) it)));
  }

  protected IRewriter getRewriterFromContext(ISubgraphRef context) {
    DependencyTrackingNode.checkHasTracking(context);
    if (context == null) {
      return null;
    } else if (context instanceof ChildSubgraphRef) {
      return getRewriterFromCall(((ChildSubgraphRef) context).getCall().getTarget());
    } else {
      return getRewriterFromContext(check_ghsvvp_a0a0a1a08(context.getParent()));
    }
  }

  protected IRewriter getRewriterFromCall(ISubgraphCall call) {
    DependencyTrackingNode.checkHasTracking(call);
    if (call instanceof ForkCall) {
      String id = ((ForkCall) call).getRewriterId();
      return resolveRewriter(id);
    } else if (call instanceof GoalCall) {
      return new MPSLikeRewriter((GoalCall) call);
    } else {
      return null;
    }
  }

  public ISubgraphStage getSubgraph(ISubgraphRef subgraphRef) {
    return resolveStage(new FinalStageReference(subgraphRef));
  }

  protected ISubgraphStage findStage(final IStageReference expectedStageRef) {
    DependencyTrackingNode.checkHasTracking(expectedStageRef);
    return incremental.evaluate(new CK_TransformationEngine_findStage(expectedStageRef), () -> CONTEXT_ENGINE.computeWith(TransformationEngine.this, () -> doFindStage(expectedStageRef)));
  }

  protected ISubgraphStage doFindStage(IStageReference expectedStageRef) {
    ISubgraphCall subgraphCall = ((ChildSubgraphRef) expectedStageRef.getSubgraphRef()).getCall().getTarget();
    SubstepStageReference currentStageRef = new SubstepStageReference(expectedStageRef.getSubgraphRef(), 0, 0);
    SubstepStageReference previousStageRef = null;
    final Wrappers._T<ISubgraphStage> currentStage = new Wrappers._T<ISubgraphStage>(computeStage(currentStageRef, previousStageRef, ListSequence.fromListAndArray(new ArrayList<IContainmentTarget>(), subgraphCall.getRootCall())));

    Genplan genplan = null;
    if (subgraphCall instanceof GoalCall) {
      genplan = getGenplan(((GoalCall) subgraphCall));
    }

    if (subgraphCall.isFixpoint()) {
      while (true) {
        if (currentStageRef.getSubstepNumber() >= 10) {
          RuntimeException ex = new RuntimeException("Subgraph stage limit (10) exceeded: " + currentStageRef);
          ShadowLogging.logError(ex, currentStageRef);
          return currentStage.value;
        }
        if (expectedStageRef instanceof SubstepStageReference) {
          SubstepStageReference expectedSubstep = (SubstepStageReference) expectedStageRef;
          if (expectedSubstep.getStepNumber() == currentStageRef.getStepNumber()) {
            if (expectedSubstep.getSubstepNumber() == currentStageRef.getSubstepNumber()) {
              return currentStage.value;
            }
          }
          if (currentStageRef.getStepNumber() > expectedSubstep.getStepNumber()) {
            throw new RuntimeException("There is no substep " + expectedSubstep.getSubstepNumber() + " for step " + expectedSubstep.getStepNumber());
          }
        }

        List<IContainmentTarget> nextRoots = Sequence.fromIterable(currentStage.value.getRoots()).select(new _FunctionTypes._return_P1_E0<ContainmentTargetRootNodes, IUniqueContainmentTarget>() {
          public ContainmentTargetRootNodes invoke(IUniqueContainmentTarget it) {
            return new ContainmentTargetRootNodes(currentStage.value.getStageReference(), it);
          }
        }).translate(new _FunctionTypes._return_P1_E0<Iterable<IOutputNodeReference>, ContainmentTargetRootNodes>() {
          public Iterable<IOutputNodeReference> invoke(ContainmentTargetRootNodes it) {
            return it.getNodes(TransformationEngine.this);
          }
        }).select((it) -> OutputNodeReferenceAsNode.create(TransformationEngine.this, it)).select((it) -> DependencyTrackingNode.wrap(it)).select((it) -> {
          IContainmentTarget c = new RewriteCall(it, null);
          return c;
        }).toList();

        previousStageRef = currentStageRef;
        SubstepStageReference nextStageRef = currentStageRef.nextSubstep();
        ISubgraphStage nextStage = computeStage(nextStageRef, previousStageRef, nextRoots);
        if (!(nextStage.hasAnyTransformationsApplied())) {
          // Last substep reached. Switch to next step.
          if (genplan == null) {
            // There is only one step without a genplan
            return currentStage.value;
          }
          if (currentStageRef.getStepNumber() == Sequence.fromIterable(genplan.getSteps()).count() - 1) {
            // End of genplan. No more steps.
            return currentStage.value;
          }
          if (expectedStageRef instanceof StepStageReference && ((StepStageReference) expectedStageRef).getStepNumber() == currentStageRef.getStepNumber()) {
            return currentStage.value;
          }

          nextStageRef = currentStageRef.nextStep();
          nextStage = computeStage(nextStageRef, previousStageRef, nextRoots);
        }
        currentStageRef = nextStageRef;
        currentStage.value = nextStage;
      }
    } else {
      return currentStage.value;
    }
  }

  protected ISubgraphStage computeStage(final SubstepStageReference stageRef, @Nullable final SubstepStageReference previousStageRef, final List<IContainmentTarget> roots) {
    DependencyTrackingNode.checkHasTracking(stageRef);
    DependencyTrackingNode.checkHasTracking(previousStageRef);
    return this.getIncrementalEngine().evaluate(new CK_TransformationEngine_computeStage(stageRef, roots), () -> TransformationEngine.CONTEXT_ENGINE.computeWith(TransformationEngine.this, () -> TransformationEngine.this.currentContext().computeWith(stageRef, () -> doComputeStage(stageRef, roots, previousStageRef))));
  }

  protected ISubgraphStage doComputeStage(SubstepStageReference stageRef, List<IContainmentTarget> roots, SubstepStageReference previousStageRef) {
    final SubgraphStage stage = new SubgraphStage(this, stageRef, previousStageRef, roots);
    return this.currentlyComputedStage.computeWith(stage, () -> {
      for (IUniqueContainmentTarget rootCall : Sequence.fromIterable(stage.getRoots())) {
        loadSubgraphData(stage, rootCall, null);
      }
      applyWeavingRules(stage);

      int timeout = 10;
      while (stage.hasPendingWeavings()) {
        if (timeout-- == 0) {
          throw new RuntimeException("Abort processing weavings after 10 iterations");
        }
        Iterable<IWeaving> pendingWeavings = ListSequence.fromListWithValues(new ArrayList<IWeaving>(), stage.getPendingWeavings());
        stage.clearPendingWeavings();
        for (IWeaving weaving : Sequence.fromIterable(pendingWeavings)) {
          IOutputNodeReference weavingTarget = stage.resolveWeavingTarget(weaving.getSourceScope(), weaving.getTargetNode());
          if (weavingTarget == null) {
            RuntimeException ex = new RuntimeException("Weaving target not found: " + weaving.getTargetNode());
            ShadowLogging.logError(ex, weaving);
            throw ex;
          }
          loadSubgraphData(stage, weaving.getContent(stage), new KnownContainment(weavingTarget, weaving.getTargetRole()));
          stage.registerWeaving(weaving);
        }
      }

      applyPropertyRules(stage);

      stage.freeze();
      return stage;
    });
  }

  public void applyWeavingRules(final SubgraphStage stage) {
    List<MappingConfiguration> mcs = getMappingConfigurations(stage);
    Iterable<WeavingRule> weavingRules = ListSequence.fromList(mcs).translate((it) -> it.getWeavingRules());
    if (Sequence.fromIterable(weavingRules).isEmpty()) {
      return;
    }

    Iterable<INode> inputRoots = Sequence.fromIterable(stage.getRoots()).translate(new _FunctionTypes._return_P1_E0<Iterable<INode>, IUniqueContainmentTarget>() {
      public Iterable<INode> invoke(IUniqueContainmentTarget it) {
        return it.getInputNodes();
      }
    });
    for (INode inputNode : Sequence.fromIterable(inputRoots).translate((it) -> SM_NodeUtil.getDescendants(it, true))) {
      // Prevent reapplying weaving rules on the same node multiple times
      if (stage.getStageReference().getSubstepNumber() > 0) {
        CopiedOutputNodeReference copiedInputNode = as_ghsvvp_a0a0a1a5a59(check_ghsvvp_a0a0a1a5a49(as_ghsvvp_a0a0a0a0b0f0rd(DependencyTrackingNode.unwrap(inputNode), OutputNodeReferenceAsNode.class)), CopiedOutputNodeReference.class);
        if (copiedInputNode != null && Objects.equals(copiedInputNode.getStageRef(), stage.getPreviousStageRef())) {
          continue;
        }
      }

      for (WeavingRule rule : Sequence.fromIterable(weavingRules)) {
        if (!(inputNode.getConcept().isSubConceptOf(rule.getInputConcept()))) {
          continue;
        }
        if (!(rule.isApplicable(inputNode, stage.getOwnScope()))) {
          continue;
        }


        IWeaving weaving = rule.getWeaving(stage, inputNode);
        stage.addPendingWeaving(weaving);
      }
    }
  }

  public void applyPropertyRules(SubgraphStage stage) {
    List<MappingConfiguration> mcs = getMappingConfigurations(stage);
    Iterable<IOutputWrapperRule> rules = ListSequence.fromList(mcs).translate((it) -> it.getOutputWrapperRules());
    if (Sequence.fromIterable(rules).isEmpty()) {
      return;
    }

    final Iterable<INode> inputRoots = Sequence.fromIterable(new StageRootNodes(stage.getStageReference()).getNodes(this)).select((it) -> new OutputNodeReferenceAsNode(TransformationEngine.this, it));
    for (INode node : ListSequence.fromList(stage.computeWithFrozenCheckDisabled(() -> Sequence.fromIterable(inputRoots).translate((it) -> SM_NodeUtil.getDescendants(it, true)).toList()))) {
      IOutputNodeReference nodeRef = ((OutputNodeReferenceAsNode) node).getOutputNodeReference();

      for (IOutputWrapperRule rule : Sequence.fromIterable(rules)) {
        if (!(node.getConcept().isSubConceptOf(rule.getInputConcept()))) {
          continue;
        }
        if (!(rule.isApplicable(node, nodeRef.getScope(this)))) {
          continue;
        }

        stage.registerOutputWrapper(nodeRef, rule.apply(stage, node));
      }
    }

  }

  public List<MappingConfiguration> getMappingConfigurations(SubgraphStage stage) {
    GoalCall goalCall = as_ghsvvp_a0a0a99(((ChildSubgraphRef) stage.getStageReference().getSubgraphRef()).getCall().getTarget(), GoalCall.class);
    if (goalCall == null) {
      return ListSequence.fromList(new ArrayList<MappingConfiguration>());
    }
    Genplan genplan = getGenplan(goalCall);
    final Map<MappingConfigurationId, MappingConfiguration> allMCs = getMappingConfigurationsMap(goalCall);
    int stepNumber = stage.getStageReference().getStepNumber();
    GenplanStep step = genplan.getStep(stepNumber);
    return Sequence.fromIterable(step.getMappingConfigurations()).select((it) -> MapSequence.fromMap(allMCs).get(it)).toList();
  }

  protected IOutputNodeReference asOutputNodeReference(INode node) {
    if (node instanceof OutputNodeReferenceAsNode) {
      return ((OutputNodeReferenceAsNode) node).getOutputNodeReference();
    }
    return null;
  }

  protected void loadSubgraphData(SubgraphStage stage, final IUniqueContainmentTarget call, @Nullable IContainment containment) {
    DependencyTrackingNode.checkHasTracking(call);
    try {
      if (call.getTarget() instanceof ISubgraphCall) {
        stage.registerContent(call, null, containment);
      } else if (call.getTarget() instanceof TransformationCall) {
        ITransformationResult tresult = execute(stage.getStageReference(), (IUniqueContainmentTarget<TransformationCall>) call);
        stage.registerContent(call, tresult, containment);
        for (Tuples._2<IUniqueContainmentTarget, IContainment> childAndParent : Sequence.fromIterable(tresult.getChildCalls())) {
          IUniqueContainmentTarget<IContainmentTarget> child = childAndParent._0();
          loadSubgraphData(stage, child, (childAndParent._1() != null ? childAndParent._1() : containment));
        }
      } else if (call.getTarget() instanceof RewriteCall) {
        IUniqueContainmentTarget replacement = new ReplacementTarget(call, computeRewriteReplacement(stage, (IUniqueContainmentTarget<RewriteCall>) call));
        stage.registerRewriteReplacement(call, replacement);
        loadSubgraphData(stage, replacement, containment);
      } else if (call.getTarget() instanceof CopyCall) {
        CopiedOutputNodeReference copiedNode = new CopiedOutputNodeReference(stage.getStageReference(), (IUniqueContainmentTarget<CopyCall>) call);
        stage.registerContent(call, null, containment);
        for (Tuples._2<String, IUniqueContainmentTarget> child : Sequence.fromIterable(copiedNode.getUniqueContainmentTargetForChildren(this))) {
          loadSubgraphData(stage, child._1(), new KnownContainment(copiedNode, child._0()));
        }
      } else {
        throw new RuntimeException("Unsupported: " + call.getTarget().getClass().getName());
      }
    } catch (DependencyCycleException ex) {
      if (!(ex.willRetry())) {
        ShadowLogging.logError(ex, call, stage);
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
    } catch (Exception ex) {
      ShadowLogging.logError(ex, call, stage);
      if (LOG.isErrorLevel()) {
        LOG.error("", ex);
      }
      // Otherwise, the whole subgraph doesn't produce any output.
      // TODO Flag the subgraph as invalid?
    }
  }
  private static ISubgraphRef check_ghsvvp_a0a0a1a08(IStageReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSubgraphRef();
    }
    return null;
  }
  private static IOutputNodeReference check_ghsvvp_a0a0a1a5a49(OutputNodeReferenceAsNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getOutputNodeReference();
    }
    return null;
  }
  private static <T> T as_ghsvvp_a0a0a1a5a59(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ghsvvp_a0a0a0a0b0f0rd(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ghsvvp_a0a0a99(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

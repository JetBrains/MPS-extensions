package de.itemis.mps.selection.runtime.linear;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.CellActionType;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.ide.datatransfer.CopyPasteUtil;
import java.util.Set;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public class CopyAction extends LinearSelectionAction {

  public CopyAction() {
    super(CellActionType.COPY);
  }

  public void execute(LinearSelection selection) {
    List<SNode> selectedNodes = selection.getSelectedNodes();
    SNode commonParent = commonParent(selectedNodes);

    final Map<SNode, SNode> copiedNodes = MapSequence.fromMap(new HashMap<SNode, SNode>());
    SNode copy = CopyUtil.copy(commonParent, copiedNodes, true);
    Iterable<SNode> selectedCopies = ListSequence.fromList(selectedNodes).select((it) -> MapSequence.fromMap(copiedNodes).get(it));
    deleteNonSelectedNodes(copy, SetSequence.fromSetWithValues(new HashSet<SNode>(), selectedCopies));
    CopyPasteUtil.copyNodeToClipboard(copy);
  }

  public void deleteNonSelectedNodes(SNode copy, Set<SNode> selectedNodes) {
    for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(copy))) {
      deleteIfNotPartOfTheSelection(copy, child, selectedNodes);
    }
  }

  public void deleteIfNotPartOfTheSelection(SNode root, SNode node, Set<SNode> selectedNodes) {
    if (SetSequence.fromSet(selectedNodes).contains(node)) {
      return;
    }

    for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(node))) {
      deleteIfNotPartOfTheSelection(root, child, selectedNodes);
    }

    if (ListSequence.fromList(SNodeOperations.getChildren(node)).isEmpty()) {
      SNodeOperations.deleteNode(node);
    }

    // handling for binary expressions
    if (!(SetSequence.fromSet(selectedNodes).contains(node)) && ListSequence.fromList(SNodeOperations.getChildren(node)).count() == 1) {
      SAbstractConcept requiredConcept = SNodeOperations.getContainingLink(node).getTargetConcept();
      SNode child = ListSequence.fromList(SNodeOperations.getChildren(node)).first();
      if (SNodeOperations.isInstanceOf(child, SNodeOperations.asSConcept(requiredConcept))) {
        SNodeOperations.deleteNode(child);
        SNodeOperations.replaceWithAnother(node, child);
      }
    }
  }


  public SNode commonParent(List<SNode> childs) {
    if (ListSequence.fromList(childs).isEmpty()) {
      return null;
    }

    boolean found;
    List<SNode> candidates = ListSequence.fromList(SNodeOperations.getNodeAncestors(ListSequence.fromList(childs).first(), null, false)).toList();
    for (SNode candidate : ListSequence.fromList(candidates)) {
      found = true;
      for (SNode child : ListSequence.fromList(childs)) {
        if (!(isAncestor(candidate, child))) {
          found = false;
          break;
        }
      }
      if (found) {
        return candidate;
      }
    }
    return null;
  }

  public boolean isAncestor(SNode ancestor, SNode child) {
    for (SNode parent = child; parent != null; parent = SNodeOperations.getParent(parent)) {
      if (parent == ancestor) {
        return true;
      }
    }
    return false;
  }
}

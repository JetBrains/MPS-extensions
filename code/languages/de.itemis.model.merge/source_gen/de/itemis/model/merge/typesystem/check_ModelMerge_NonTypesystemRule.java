package de.itemis.model.merge.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import de.itemis.model.merge.runtime.runtime.MergerResolverImpl;
import de.itemis.model.merge.runtime.runtime.PolicyMergerResolver;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.HashSet;
import java.util.Collection;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.structure.behavior.PropertyDeclaration__BehaviorDescriptor;
import de.itemis.model.merge.behavior.ModelMergingPolicy__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.lang.structure.behavior.LinkDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import java.util.Set;
import java.util.Map;
import com.google.common.collect.ImmutableMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.apache.commons.lang3.tuple.ImmutablePair;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import de.itemis.model.merge.runtime.runtime.MergingPolicyConflict;
import de.itemis.model.merge.runtime.runtime.MissingMergingPolicies;
import jetbrains.mps.errors.BaseQuickFixProvider;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class check_ModelMerge_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_ModelMerge_NonTypesystemRule() {
  }
  public void applyRule(final SNode modelMerge, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    try {
      MergerResolverImpl mergerResolver = PolicyMergerResolver.run(modelMerge);

      SRepository repository = SLinkOperations.getTarget(modelMerge, LINKS.lang$Bfub).getModel().getRepository();


      if (!(SPropertyOperations.getBoolean(modelMerge, PROPS.partialPolicy$djMt))) {
        // --Missing Property Policy
        _FunctionTypes._return_P1_E0<? extends HashSet<SNode>, ? super SNode> conceptToRelevantProperties = (SNode acd) -> {
          final Collection<SProperty> forbiddenProperties = CONCEPTS.BaseConcept$gP.getProperties();
          CollectionSequence.fromCollection(forbiddenProperties).addSequence(CollectionSequence.fromCollection(CONCEPTS.IResolveInfo$$k.getProperties()));
          return new HashSet<SNode>(ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getPropertyDeclarations_idhEwILLM.invoke(acd)).where((final SNode it) -> !(CollectionSequence.fromCollection(forbiddenProperties).any((prop) -> (boolean) PropertyDeclaration__BehaviorDescriptor.is_id4MKjpUYnih4.invoke(it, prop)))).toList());
        };
        // This warning ensures that is not possible that a Auto-Merge-Policy is propagated down to
        // some leaf-Concepts. Even if all children in all Concepts would be handled by Auto, then it is assured
        // that the defined Merge-Policies for properties makes the ModelMerge well defined.
        CheckinRuleUtil.warn(ModelMergingPolicy__BehaviorDescriptor.languageConcepts_id3xJ_LYXlmVz.invoke(modelMerge), repository, mergerResolver.conceptToProperty(), conceptToRelevantProperties, (SAbstractConcept sac, SNode pd) -> {
          {
            final MessageTarget errorTarget = new NodeMessageTarget();
            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(CheckinRuleUtil.warningNode(modelMerge, sac), "concept " + sac + " is missing merge policy for property " + pd, "r:02b6652e-c87d-4bb2-bfc0-4b5c0d5b9442(de.itemis.model.merge.typesystem)", "7822999013394073142", null, errorTarget);
          }
        });

        // --Missing Child Policy
        _FunctionTypes._return_P1_E0<? extends HashSet<SNode>, ? super SNode> conceptToRelevantChildren = (SNode acd) -> {
          final Collection<SContainmentLink> forbiddenChildren = CONCEPTS.BaseConcept$gP.getContainmentLinks();
          return new HashSet<SNode>(ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getLinkDeclarations_idhEwILKK.invoke(acd)).where((it) -> !(SEnumOperations.isMember(SPropertyOperations.getEnum(it, PROPS.metaClass$PeKc), 0xfc6f4e95b8L))).where((final SNode it) -> !(CollectionSequence.fromCollection(forbiddenChildren).any((child) -> (boolean) LinkDeclaration__BehaviorDescriptor.is_id4MKjpUYniHA.invoke(it, child)))).toList());
        };
        CheckinRuleUtil.warn(ModelMergingPolicy__BehaviorDescriptor.languageConcepts_id3xJ_LYXlmVz.invoke(modelMerge), repository, mergerResolver.conceptToChildLink(), conceptToRelevantChildren, (SAbstractConcept sac, SNode ld) -> {
          {
            final MessageTarget errorTarget = new NodeMessageTarget();
            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(CheckinRuleUtil.warningNode(modelMerge, sac), "concept" + sac + " is missing merge policy for child " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(ld), "r:02b6652e-c87d-4bb2-bfc0-4b5c0d5b9442(de.itemis.model.merge.typesystem)", "7822999013394055521", null, errorTarget);
          }
        });

        // --Missing Reference Policy
        _FunctionTypes._return_P1_E0<? extends HashSet<SNode>, ? super SNode> conceptToRelevantReferences = (SNode acd) -> {
          final Collection<SContainmentLink> forbiddenChildren = CONCEPTS.BaseConcept$gP.getContainmentLinks();
          return new HashSet<SNode>(ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getLinkDeclarations_idhEwILKK.invoke(acd)).where((it) -> SEnumOperations.isMember(SPropertyOperations.getEnum(it, PROPS.metaClass$PeKc), 0xfc6f4e95b8L)).where((final SNode it) -> !(CollectionSequence.fromCollection(forbiddenChildren).any((child) -> (boolean) LinkDeclaration__BehaviorDescriptor.is_id4MKjpUYniHA.invoke(it, child)))).toList());
        };

        CheckinRuleUtil.warn(ModelMergingPolicy__BehaviorDescriptor.languageConcepts_id3xJ_LYXlmVz.invoke(modelMerge), repository, mergerResolver.conceptToReferenceLink(), conceptToRelevantReferences, (SAbstractConcept sac, SNode ld) -> {
          {
            final MessageTarget errorTarget = new NodeMessageTarget();
            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(CheckinRuleUtil.warningNode(modelMerge, sac), "concept" + sac + " is missing merge policy for reference " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(ld), "r:02b6652e-c87d-4bb2-bfc0-4b5c0d5b9442(de.itemis.model.merge.typesystem)", "7822999013394721314", null, errorTarget);
          }
        });
      }

      // ---ID
      if (!(SPropertyOperations.getBoolean(modelMerge, PROPS.partialIDFunctions$xEJ0))) {

        Set<SAbstractConcept> conceptsWithId = mergerResolver.conceptsWithId();
        Map<SAbstractConcept, Set<SAbstractConcept>> isCovered = ImmutableMap.copyOf(SetSequence.fromSet(conceptsWithId).select((it) -> ImmutablePair.of(it, Collections.singleton(it))));

        _FunctionTypes._return_P1_E0<? extends Set<SAbstractConcept>, ? super SNode> mustBeCovered = (SNode acd) -> {
          boolean ignoreable = SNodeOperations.isInstanceOf(acd, CONCEPTS.InterfaceConceptDeclaration$CG) || (boolean) AbstractConceptDeclaration__BehaviorDescriptor.isSubconceptOf_id4UTtJHK9fEJ.invoke(acd, CONCEPTS.Attribute$g1);
          return (ignoreable ? Collections.<SAbstractConcept>emptySet() : Collections.singleton(SNodeOperations.asSConcept(acd)));
        };

        CheckinRuleUtil.warn(ModelMergingPolicy__BehaviorDescriptor.languageConcepts_id3xJ_LYXlmVz.invoke(modelMerge), repository, isCovered, mustBeCovered, (SAbstractConcept sac, SAbstractConcept id) -> {
          {
            final MessageTarget errorTarget = new NodeMessageTarget();
            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(CheckinRuleUtil.warningNode(modelMerge, sac), "concept " + sac + " is missing ID function ", "r:02b6652e-c87d-4bb2-bfc0-4b5c0d5b9442(de.itemis.model.merge.typesystem)", "6922793481539920664", null, errorTarget);
          }
        });
      }


    } catch (MergingPolicyConflict e) {
      String violationForStr = e.violationFor.toString();
      if (e.violationFor instanceof SNode) {
        SNode node = ((SNode) e.violationFor);
        {
          final SNode ld = node;
          if (SNodeOperations.isInstanceOf(ld, CONCEPTS.LinkDeclaration$1p)) {
            violationForStr = BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(ld);
          }
        }
      }
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(CheckinRuleUtil.warningNode(modelMerge, e.violationConcept), e.type + " " + violationForStr + " is already defined multiple times for " + e.violationConcept + " via super concepts. Provide a separate policy for " + e.type, "r:02b6652e-c87d-4bb2-bfc0-4b5c0d5b9442(de.itemis.model.merge.typesystem)", "9112015721049551246", null, errorTarget);
      }
    } catch (MissingMergingPolicies mmp) {
      String msg = "MergePolicies missing for concepts: " + CollectionSequence.fromCollection(mmp.missingPoliciesFor()).select((it) -> AbstractConceptDeclaration__BehaviorDescriptor.getPresentation_id280s3ZNTXNS.invoke(it) + " ");
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(modelMerge, msg, "r:02b6652e-c87d-4bb2-bfc0-4b5c0d5b9442(de.itemis.model.merge.typesystem)", "8032055585895623336", null, errorTarget);
        {
          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("de.itemis.model.merge.typesystem.AddMissingMergePolicies_QuickFix", "8032055585895636069", false);
          intentionProvider.putArgument("modelmerge", modelMerge);
          _reporter_2309309498.addIntentionProvider(intentionProvider);
        }
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.ModelMergingPolicy$MA;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink lang$Bfub = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42dcce87L, 0x1ed6b4fde203a345L, "lang");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SInterfaceConcept IResolveInfo$$k = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x116b17c6e46L, "jetbrains.mps.lang.core.structure.IResolveInfo");
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
    /*package*/ static final SConcept InterfaceConceptDeclaration$CG = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, "jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration");
    /*package*/ static final SConcept LinkDeclaration$1p = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, "jetbrains.mps.lang.structure.structure.LinkDeclaration");
    /*package*/ static final SConcept ModelMergingPolicy$MA = MetaAdapterFactory.getConcept(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42dcce87L, "de.itemis.model.merge.structure.ModelMergingPolicy");
  }

  private static final class PROPS {
    /*package*/ static final SProperty metaClass$PeKc = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, "metaClass");
    /*package*/ static final SProperty partialPolicy$djMt = MetaAdapterFactory.getProperty(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42dcce87L, 0x5b4be50b1edb9bf2L, "partialPolicy");
    /*package*/ static final SProperty partialIDFunctions$xEJ0 = MetaAdapterFactory.getProperty(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42dcce87L, 0x4eeb3d86e240b8a1L, "partialIDFunctions");
  }
}

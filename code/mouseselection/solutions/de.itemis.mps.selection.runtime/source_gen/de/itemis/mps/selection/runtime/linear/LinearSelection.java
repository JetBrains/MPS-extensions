package de.itemis.mps.selection.runtime.linear;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.selection.AbstractSelection;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.CellConditions;
import java.util.Map;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.CellInfo;
import jetbrains.mps.openapi.editor.selection.SelectionStoreException;
import jetbrains.mps.nodeEditor.selection.SelectionRestoreException;
import jetbrains.mps.nodeEditor.selection.SelectionInfoImpl;
import jetbrains.mps.openapi.editor.selection.SelectionInfo;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.openapi.editor.selection.Selection;
import java.util.Objects;
import org.jetbrains.annotations.NotNull;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import java.util.LinkedHashSet;
import java.awt.Graphics2D;
import java.awt.geom.Area;
import java.awt.Rectangle;
import com.intellij.ui.JBColor;
import java.awt.BasicStroke;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class LinearSelection extends AbstractSelection {
  private static final String PROPERTY_START_TEXT_POS = "startTextPos";
  private static final String PROPERTY_END_TEXT_POS = "endTextPos";
  private static final String PROPERTY_LEFT_TO_RIGHT = "leftToRight";
  private static final String PROPERTY_NUM_LEAFS = "numLeafs";
  public static final Condition<EditorCell> CELL_CONDITION = CellConditions.SELECTABLE;

  private EditorCell myStartCell;
  private int myStartTextPos = 0;
  private int myEndTextPos = 0;
  private int myNumOfLeafs = 0;
  private boolean myLeftToRight;

  private Map<CellActionType, LinearSelectionAction> myActions = MapSequence.fromMap(new HashMap<CellActionType, LinearSelectionAction>());

  {
    addAction(new LinearSelectionAction(CellActionType.SELECT_LEFT) {
      public void execute(LinearSelection selection) {
        EditorCell last = ListSequence.fromList(((List<EditorCell>) getSelectedCells())).last();
        if (last instanceof EditorCell_Label) {
          EditorCell_Label lastLabel = ((EditorCell_Label) last);
          if (myEndTextPos > 0) {
            setNewSelection(myStartCell, myNumOfLeafs, myStartTextPos, myEndTextPos - 1, myLeftToRight);
          }
        }
      }
    });
    addAction(new LinearSelectionAction(CellActionType.SELECT_RIGHT) {
      public void execute(LinearSelection selection) {
        EditorCell last = ListSequence.fromList(((List<EditorCell>) getSelectedCells())).last();
        if (last instanceof EditorCell_Label) {
          EditorCell_Label lastLabel = ((EditorCell_Label) last);
          if (myEndTextPos < lastLabel.getText().length()) {
            setNewSelection(myStartCell, myNumOfLeafs, myStartTextPos, myEndTextPos + 1, myLeftToRight);
          } else {
            if (myLeftToRight) {
              setNewSelection(myStartCell, myNumOfLeafs + 1, myStartTextPos, 0, myLeftToRight);
            } else {
              EditorCell_Label nextLabel = as_3qxzvn_a0a0a0a0a1a1a0a0a0b0o(CellTraversalUtil.getNextLeaf(lastLabel, LinearSelection.CELL_CONDITION), EditorCell_Label.class);
              setNewSelection(myStartCell, myNumOfLeafs - 1, myStartTextPos, check_3qxzvn_d0b0a0a0b0b0a0a0a1a41(check_3qxzvn_a3a1a0a0a1a1a0a0a0b0o(nextLabel)), myLeftToRight);
            }
          }
        } else {
          setNewSelection(myStartCell, myNumOfLeafs + ((myLeftToRight ? 1 : -1)), myStartTextPos, 0, myLeftToRight);
        }
      }
    });
    addAction(new CopyAction());
  }

  public void addAction(LinearSelectionAction action) {
    MapSequence.fromMap(myActions).put(action.getType(), action);
  }

  public LinearSelection(EditorComponent editorComponent, Map<String, String> properties, CellInfo cellInfo) throws SelectionStoreException, SelectionRestoreException {
    super(editorComponent);
    if (cellInfo == null) {
      throw new SelectionStoreException("Required CellInfo parameter is null");
    }
    myStartCell = cellInfo.findCell(((jetbrains.mps.nodeEditor.EditorComponent) editorComponent));
    if (myStartCell == null) {
      throw new SelectionRestoreException();
    }
    myNumOfLeafs = SelectionInfoImpl.Util.getIntProperty(properties, LinearSelection.PROPERTY_NUM_LEAFS);
    myStartTextPos = SelectionInfoImpl.Util.getIntProperty(properties, LinearSelection.PROPERTY_START_TEXT_POS);
    myEndTextPos = SelectionInfoImpl.Util.getIntProperty(properties, LinearSelection.PROPERTY_END_TEXT_POS);
    myLeftToRight = SelectionInfoImpl.Util.getBooleanProperty(properties, LinearSelection.PROPERTY_LEFT_TO_RIGHT);
  }

  public LinearSelection(EditorComponent editorComponent, EditorCell startCell, int numLeafs, int startTextPos, int endTextPos, boolean leftToRight) {
    super(editorComponent);
    myStartCell = startCell;
    myNumOfLeafs = numLeafs;
    myStartTextPos = startTextPos;
    myEndTextPos = endTextPos;
    myLeftToRight = leftToRight;
  }

  protected void setNewSelection(EditorCell startCell, int numLeafs, int startTextPos, int endTextPos, boolean leftToRight) {
    getEditorComponent().getSelectionManager().setSelection(new LinearSelection(getEditorComponent(), startCell, numLeafs, startTextPos, endTextPos, leftToRight));
  }

  public void activate() {
    List<EditorCell> selectedCells = getSelectedCells();
    for (EditorCell cell : ListSequence.fromList(selectedCells)) {
      if (cell instanceof EditorCell_Label) {
        ((EditorCell_Label) cell).setSelectionStart(0);
        ((EditorCell_Label) cell).setSelectionEnd(((EditorCell_Label) cell).getText().length());
      }
    }

    EditorCell_Label firstLabel = as_3qxzvn_a0a3a42(ListSequence.fromList(selectedCells).first(), EditorCell_Label.class);
    EditorCell_Label lastLabel = as_3qxzvn_a0a4a42(ListSequence.fromList(selectedCells).last(), EditorCell_Label.class);
    if (firstLabel != null) {
      if (myLeftToRight) {
        firstLabel.setSelectionStart(myStartTextPos);
        if (firstLabel != lastLabel) {
          firstLabel.setSelectionEnd(firstLabel.getText().length());
        }
      } else {
        if (firstLabel != lastLabel) {
          firstLabel.setSelectionStart(0);
        }
        firstLabel.setSelectionEnd(myStartTextPos);
      }
    }
    if (lastLabel != null) {
      if (myLeftToRight) {
        if (firstLabel != lastLabel) {
          lastLabel.setSelectionStart(0);
        }
        lastLabel.setSelectionEnd(myEndTextPos);
      } else {
        lastLabel.setSelectionStart(myEndTextPos);
        if (firstLabel != lastLabel) {
          lastLabel.setSelectionEnd(lastLabel.getText().length());
        }
      }
    }
  }

  public void deactivate() {
    for (EditorCell cell : ListSequence.fromList(getSelectedCells())) {
      if (cell instanceof EditorCell_Label) {
        ((EditorCell_Label) cell).setSelectionStart(0);
        ((EditorCell_Label) cell).setSelectionEnd(0);
      }
    }
  }

  @Override
  public SelectionInfo getSelectionInfo() throws SelectionStoreException {
    SelectionInfoImpl selectionInfo = new SelectionInfoImpl(this.getClass().getName(), PersistenceFacade.getInstance().createModuleReference("cce85e64-7b37-4ad5-b0e6-9d18324cdfb3(de.itemis.mps.selection.runtime)"));
    selectionInfo.setCellInfo(((jetbrains.mps.nodeEditor.cells.EditorCell) myStartCell).getCellInfo());
    selectionInfo.getPropertiesMap().put(LinearSelection.PROPERTY_NUM_LEAFS, Integer.toString(myNumOfLeafs));
    selectionInfo.getPropertiesMap().put(LinearSelection.PROPERTY_START_TEXT_POS, Integer.toString(myStartTextPos));
    selectionInfo.getPropertiesMap().put(LinearSelection.PROPERTY_END_TEXT_POS, Integer.toString(myEndTextPos));
    selectionInfo.getPropertiesMap().put(LinearSelection.PROPERTY_LEFT_TO_RIGHT, Boolean.toString(myLeftToRight));
    return selectionInfo;
  }

  @Override
  public boolean isSame(Selection _other) {
    if (!(_other instanceof LinearSelection)) {
      return false;
    }
    LinearSelection other = (LinearSelection) _other;
    if (!(Objects.equals(myStartCell, other.myStartCell))) {
      return false;
    }
    if (myEndTextPos != other.myEndTextPos) {
      return false;
    }
    if (myNumOfLeafs != other.myNumOfLeafs) {
      return false;
    }
    if (myLeftToRight != other.myLeftToRight) {
      return false;
    }
    return true;
  }

  @Override
  public boolean canExecuteAction(CellActionType type) {
    return MapSequence.fromMap(myActions).containsKey(type) && MapSequence.fromMap(myActions).get(type).canExecute();
  }

  @Override
  public void executeAction(CellActionType type) {
    MapSequence.fromMap(myActions).get(type).execute(this);
  }

  @NotNull
  @Override
  public List<EditorCell> getSelectedCells() {
    List<EditorCell> result = new ArrayList<EditorCell>(myNumOfLeafs);
    EditorCell current = myStartCell;
    for (int i = 0; i < myNumOfLeafs; i++) {
      result.add(current);
      if (myLeftToRight) {
        current = CellTraversalUtil.getNextLeaf(current, LinearSelection.CELL_CONDITION);
      } else {
        current = CellTraversalUtil.getPrevLeaf(current, LinearSelection.CELL_CONDITION);
      }
    }
    return result;
  }

  @NotNull
  @Override
  public List<SNode> getSelectedNodes() {
    Set<SNode> result = new LinkedHashSet<SNode>();
    for (EditorCell cell : ListSequence.fromList(getSelectedCells())) {
      result.add(cell.getSNode());
    }
    return new ArrayList<SNode>(result);
  }

  @Override
  public void ensureVisible() {
  }

  @Override
  public void paintSelection(Graphics2D _g) {
    List<EditorCell> selectedCells = getSelectedCells();

    EditorCell first = ListSequence.fromList(selectedCells).first();
    EditorCell last = ListSequence.fromList(selectedCells).last();

    Area shape = new Area();
    for (EditorCell cell : ListSequence.fromList(getSelectedCells())) {
      Rectangle rectangle = new Rectangle(cell.getX(), cell.getY(), cell.getWidth(), cell.getHeight());
      if (cell == first && cell instanceof EditorCell_Label) {
      }
      shape.add(new Area(rectangle));
    }


    Graphics2D g = (Graphics2D) _g.create();
    try {
      g.setColor(JBColor.BLACK);
      g.setStroke(new BasicStroke(1.0f));
      g.draw(shape);
    } finally {
      g.dispose();
    }
  }

  public static LinearSelection convertCurrentSelection(jetbrains.mps.nodeEditor.EditorComponent editorComponent) {
    return convert(editorComponent.getSelectionManager().getSelection());
  }

  public static LinearSelection convert(Selection selection) {
    if (selection instanceof LinearSelection) {
      return ((LinearSelection) selection);
    } else if (selection instanceof EditorCellLabelSelection) {
      return convert(((EditorCellLabelSelection) selection));
    }
    return null;
  }

  public static LinearSelection convert(EditorCellLabelSelection selection) {
    selection.getSelectionStart();
    boolean leftToRight = selection.getSideSelectDirection() != SingularSelection.SideSelectDirection.LEFT;
    EditorCell_Label cell = selection.getEditorCellLabel();
    int start = selection.getSelectionStart();
    int end = selection.getSelectionEnd();
    if (start > end == leftToRight) {
      {
        Tuples._2<Integer, Integer> _tmp_3qxzvn_a0f0wb = MultiTuple.<Integer,Integer>from(end, start);
        start = _tmp_3qxzvn_a0f0wb._0();
        end = _tmp_3qxzvn_a0f0wb._1();
      }
    }
    return new LinearSelection(selection.getEditorComponent(), cell, 1, start, end, leftToRight);
  }
  private static int check_3qxzvn_d0b0a0a0b0b0a0a0a1a41(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }
  private static String check_3qxzvn_a3a1a0a0a1a1a0a0a0b0o(EditorCell_Label checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getText();
    }
    return null;
  }
  private static <T> T as_3qxzvn_a0a0a0a0a1a1a0a0a0b0o(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_3qxzvn_a0a3a42(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_3qxzvn_a0a4a42(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.q60.mps.logging.runtime.ShadowLogging;
import java.util.Objects;

public class MappingLabelRefTarget implements IReferenceTarget {
  private MappingLabelCall labelCall;

  private MappingLabelRefTarget() {
    // for deserialization
  }

  public MappingLabelRefTarget(MappingLabelCall labelCall) {
    this.labelCall = labelCall;
  }

  public MappingLabelRefTarget(String labelId, List<Object> input) {
    this(new MappingLabelCall(labelId, input));
  }

  public MappingLabelCall getLabelCall() {
    return this.labelCall;
  }

  @Override
  public IOutputNodeReference resolve(IScope sourceScope, final ITransformationEngine engine) {
    final Set<IStageReference> visitedStages = SetSequence.fromSet(new HashSet<IStageReference>());
    final Wrappers._T<IOutputNodeReference> result = new Wrappers._T<IOutputNodeReference>(null);
    sourceScope.visitScopes((IScope scope) -> {
      IStageReference stageRef = scope.getStage();
      if (stageRef == null) {
        return true;
      }
      if (SetSequence.fromSet(visitedStages).contains(stageRef)) {
        return true;
      }
      SetSequence.fromSet(visitedStages).addElement(stageRef);

      ISubgraphStage stage = engine.resolveStage(stageRef);
      List<IOutputNodeReference> outputNodes = Sequence.fromIterable(stage.getMappingLabels()).select((it) -> it.getOutput(labelCall)).where(new NotNullWhereFilter()).translate((it) -> it.getNodes(engine)).toList();
      if (ListSequence.fromList(outputNodes).count() == 1) {
        result.value = ListSequence.fromList(outputNodes).first();
        return false;
      } else if (ListSequence.fromList(outputNodes).count() > 1) {
        RuntimeException ex = new RuntimeException("Multiple mapping label entries found for " + labelCall);
        ShadowLogging.logError(ex, labelCall, outputNodes);
        throw ex;
      }

      return true;
    }, engine);

    return result.value;
  }

  private transient int _cachedHashCode;
  private transient boolean _hashCodeInitialized = false;
  @Override
  public int hashCode() {
    if (!(_hashCodeInitialized)) {
      int c = 0;
      c = 31 * c + Objects.hashCode(labelCall);
      _cachedHashCode = c;
      _hashCodeInitialized = true;
    }
    return _cachedHashCode;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    MappingLabelRefTarget that = (MappingLabelRefTarget) o;
    if (!(Objects.equals(labelCall, that.labelCall))) {
      return false;
    }
    return true;
  }
}

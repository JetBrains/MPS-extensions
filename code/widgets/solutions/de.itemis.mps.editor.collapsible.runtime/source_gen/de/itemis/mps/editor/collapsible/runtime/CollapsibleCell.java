package de.itemis.mps.editor.collapsible.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.Map;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import java.util.HashMap;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import com.intellij.ui.JBColor;
import java.awt.BasicStroke;
import java.awt.geom.GeneralPath;
import java.awt.Dimension;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.nodeEditor.EditorCell_WithComponent;
import java.util.Iterator;
import org.jetbrains.mps.openapi.module.SRepository;

public class CollapsibleCell extends EditorCell_Collection {

  private static Map<EditorComponent, Map<Tuples._2<SNodeId, String>, Boolean>> ourStates = MapSequence.fromMap(new WeakHashMap<EditorComponent, Map<Tuples._2<SNodeId, String>, Boolean>>());

  public static Map<Tuples._2<SNodeId, String>, Boolean> getStates(EditorComponent component) {
    Map<Tuples._2<SNodeId, String>, Boolean> result = MapSequence.fromMap(ourStates).get(component);
    if (result == null) {
      result = MapSequence.fromMap(new HashMap<Tuples._2<SNodeId, String>, Boolean>());
      MapSequence.fromMap(ourStates).put(component, result);
    }
    return result;
  }

  protected CollapseExpandToggleCell myToggleCell;

  protected EditorCell myExpandedCell;
  protected EditorCell myCollapsedCell;
  protected SNodeId myNodeId;
  protected boolean myShowCollapsedAlways;
  protected boolean myCollapsedByDefault;
  protected boolean myDrawBracketLine;
  protected ICollapsibleCallback myCallback;
  protected Integer myIndent = null;
  protected CollapsibleCell myLastChild = null;
  protected boolean myLastChildValid = false;
  protected String myGroup;

  public CollapsibleCell(EditorContext context, SNode node, @NotNull EditorCell expandedCell, @Nullable EditorCell collapsedCell, boolean showCollapsedAlways, boolean collapsedByDefault, boolean drawBracketLine) {
    this(context, node, expandedCell, collapsedCell, showCollapsedAlways, collapsedByDefault, drawBracketLine, ICollapsibleCallback.EMPTY, null);
  }

  public CollapsibleCell(EditorContext context, SNode node, @NotNull EditorCell expandedCell, @Nullable EditorCell collapsedCell, boolean showCollapsedAlways, boolean collapsedByDefault, boolean drawBracketLine, @NotNull ICollapsibleCallback callback, String group) {
    super(context, node, new CellLayout_Horizontal(), null);
    myNodeId = getSNode().getNodeId();
    myToggleCell = new CollapseExpandToggleCell(context, node, this);
    myExpandedCell = expandedCell;
    myCollapsedCell = collapsedCell;
    myShowCollapsedAlways = showCollapsedAlways;
    myCollapsedByDefault = collapsedByDefault;
    myDrawBracketLine = drawBracketLine;
    myCallback = callback;
    myGroup = group;
  }

  protected void setupLayout() {
    check_syvjue_a0a32(as_syvjue_a0a0a32(check_syvjue_a0a0a32(myToggleCell), EditorCell_Collection.class), myToggleCell);
    check_syvjue_a1a32(as_syvjue_a0a1a32(check_syvjue_a0a1a32(myCollapsedCell), EditorCell_Collection.class), myCollapsedCell);
    check_syvjue_a2a32(as_syvjue_a0a2a32(check_syvjue_a0a2a32(myExpandedCell), EditorCell_Collection.class), myExpandedCell);
    for (EditorCell child : ListSequence.fromList(Sequence.fromIterable(((Iterable<EditorCell>) this)).toList())) {
      removeCell(child);
    }
    setupLayout(myToggleCell, (isCollapsibleCollapsed() || myShowCollapsedAlways ? myCollapsedCell : null), (!(isCollapsibleCollapsed()) ? myExpandedCell : null), !(myDrawBracketLine) && myShowCollapsedAlways);
  }

  protected void setupLayout(EditorCell toogleCell, EditorCell collapsedCell, EditorCell expandedCell, boolean dontIndentExpanded) {
    if (dontIndentExpanded) {
      addEditorCell(createVertical(createHorizontal(toogleCell, collapsedCell), expandedCell));
    } else {
      addEditorCell(createHorizontal(toogleCell, createVertical(collapsedCell, expandedCell)));
    }
  }

  private EditorCell createVertical(EditorCell... cells) {
    return createCollection(true, cells);
  }

  private EditorCell createHorizontal(EditorCell... cells) {
    return createCollection(false, cells);
  }

  private EditorCell createCollection(final boolean vertical, EditorCell... cells) {
    Iterable<EditorCell> seq = Sequence.fromIterable(Sequence.fromArray(cells)).where((it) -> it != null);
    if (Sequence.fromIterable(seq).isEmpty()) {
      return null;
    }
    if (Sequence.fromIterable(seq).count() == 1) {
      return Sequence.fromIterable(seq).first();
    }
    final Wrappers._T<EditorCell_Collection> collection = new Wrappers._T<EditorCell_Collection>();
    repository().getModelAccess().runReadAction(() -> collection.value = (vertical ? EditorCell_Collection.createVertical(getContext(), getSNode()) : EditorCell_Collection.createHorizontal(getContext(), getSNode())));
    Sequence.fromIterable(seq).visitAll((it) -> collection.value.addEditorCell(it));
    return collection.value;
  }


  public EditorCell getExpandedCell() {
    return myExpandedCell;
  }

  @Override
  public void paintContent(Graphics g_, ParentSettings settings) {
    super.paintContent(g_, settings);

    if (myDrawBracketLine && myCallback.customPaint()) {
      Graphics2D g = (Graphics2D) g_.create();
      try {
        paintEdgeCustom(g);
      } finally {
        g.dispose();
      }
    }

    if (myDrawBracketLine && !(isCollapsibleCollapsed())) {
      Graphics2D g = (Graphics2D) g_.create();
      try {
        if (myCallback.customPaint()) {
          CollapsibleCell child = getLastCollapsibleChild();
          if (child != null) {
            Rectangle nodeBounds = myToggleCell.getBounds();
            Rectangle childBounds = child.myToggleCell.getBounds();

            int y = nodeBounds.y + nodeBounds.height;
            Rectangle lineBounds = new Rectangle(nodeBounds.x, y, childBounds.x - nodeBounds.x, childBounds.y + childBounds.height - y);

            myCallback.paintLine(g, lineBounds, nodeBounds);
          }
        } else {
          g.setColor(JBColor.GRAY);
          g.setStroke(new BasicStroke(1.0f));

          double centerX = myToggleCell.getBounds().getCenterX();
          double topY = myToggleCell.getBounds().getMaxY() + 1;
          double bottomY = getY() + getHeight() - 2;
          double rightX = myToggleCell.getBounds().getMaxX();
          GeneralPath path = new GeneralPath();
          path.moveTo(centerX, topY);
          path.lineTo(centerX, bottomY);
          path.lineTo(rightX, bottomY);
          g.draw(path);
        }
      } finally {
        g.dispose();
      }
    }
  }

  private void paintEdgeCustom(Graphics2D g) {
    int parentX = getX() - getIndent();
    Rectangle nodeBounds = myToggleCell.getBounds();
    Rectangle edgeBounds = new Rectangle(parentX, nodeBounds.y, nodeBounds.x - parentX, nodeBounds.height);
    myCallback.paintEdge(g, edgeBounds, nodeBounds);
  }

  @Override
  protected void relayoutImpl() {
    if (myCollapsedCell != null) {
      myCollapsedCell.relayout();

      int height;
      int width;
      Dimension customSize = myCallback.getNodeSize();
      if (customSize != null) {
        height = customSize.height;
        width = customSize.width;
      } else {
        EditorCell firstLeaf = CellTraversalUtil.getFirstLeaf(myCollapsedCell);
        height = firstLeaf.getHeight();
        width = firstLeaf.getHeight();
      }

      myToggleCell.setPreferredSize(width, height);
      myToggleCell.setAscent(myCollapsedCell.getAscent());
    }

    myIndent = null;
    myLastChild = null;
    myLastChildValid = false;

    super.relayoutImpl();
  }

  @Override
  public void setCellId(String id) {
    super.setCellId(id);
    myToggleCell.setCellId(id + "_toggle");
    setupLayout();
  }

  public boolean isCollapsibleCollapsed() {
    Boolean result = MapSequence.fromMap(getStates(getEditorComponent())).get(MultiTuple.<SNodeId,String>from(myNodeId, getCellId()));
    return (result == null ? myCollapsedByDefault : result);
  }

  public void setCollapsibleCollapsed(boolean newValue) {
    boolean old = isCollapsibleCollapsed();
    if (old == newValue) {
      return;
    }
    final jetbrains.mps.nodeEditor.EditorComponent editorComponent = (jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent();
    MapSequence.fromMap(getStates(editorComponent)).put(MultiTuple.<SNodeId,String>from(myNodeId, getCellId()), newValue);
    setupLayout();
    for (EditorCell c : Sequence.fromIterable(CellTraversalUtil.iterateTree(this, this, true))) {
      c.requestRelayout();
    }

    // 'this' was already re-layouted in the iteration from above - we start from the parent
    for (EditorCell c = ((jetbrains.mps.nodeEditor.cells.EditorCell) this).getParent(); c != null; c = c.getParent()) {
      if (!(c.wasRelayoutRequested())) {
        c.requestRelayout();
      } else if (c.wasRelayoutRequested() && c instanceof CollapsibleCell) {
        // if parent was re-layouted AND is CollapsibleCell exit early to aviod many triggers of re-layout
        return;
      }
    }
    repository().getModelAccess().runReadAction(() -> {
      // remove/add JComponents from EditorCell_WithComponent's
      editorComponent.setRootCell(editorComponent.getRootCell());
    });
    editorComponent.relayout();

    if (containsEditorCell_WithComponent(myCollapsedCell) || containsEditorCell_WithComponent(myExpandedCell)) {
      repository().getModelAccess().runReadAction(() -> {
        // remove/add JComponents from EditorCell_WithComponent's
        editorComponent.setRootCell(editorComponent.getRootCell());
      });
      editorComponent.relayout();
    }
  }

  private boolean containsEditorCell_WithComponent(EditorCell cell) {
    if (cell instanceof EditorCell_WithComponent) {
      return true;
    }
    if (cell instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((jetbrains.mps.openapi.editor.cells.EditorCell_Collection) cell).getContentCells())) {
        if (containsEditorCell_WithComponent(child)) {
          return true;
        }
      }
    }
    return false;
  }

  protected boolean paintNodeCustom(Graphics2D graphics, Rectangle bounds, boolean highlighted) {
    if (!(myCallback.customPaint())) {
      return true;
    }
    myCallback.paintNode(graphics, bounds, highlighted, !(myToggleCell.isCollapsibleCollapsed()));
    return false;
  }

  /**
   * Return the last child cell for computing the vertical line length
   */
  private CollapsibleCell getLastCollapsibleChild() {
    if (!(myLastChildValid)) {
      myLastChild = computeLastCollapsibleChild(this);
      myLastChildValid = true;
    }
    return myLastChild;
  }

  private CollapsibleCell computeLastCollapsibleChild(EditorCell editorCell) {
    if (editorCell instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection) {
      jetbrains.mps.openapi.editor.cells.EditorCell_Collection collection = as_syvjue_a0a0a0a45(editorCell, jetbrains.mps.openapi.editor.cells.EditorCell_Collection.class);
      for (Iterator<EditorCell> it = collection.reverseIterator(); it.hasNext();) {
        EditorCell child = it.next();

        // check editor id, otherwise unrelated collapsibles will be found
        if (isLinkedCollapsible(child)) {
          return as_syvjue_a0a0d0b0a0cc(child, CollapsibleCell.class);
        }

        CollapsibleCell result = computeLastCollapsibleChild(child);
        if (result != null) {
          return result;
        }
      }
    }
    return null;
  }

  /**
   * Return the horizontal delta between this collapsible and its parent (0 if root).
   */
  private int getIndent() {
    if (myIndent == null) {
      myIndent = computeIndent();
    }
    return myIndent;
  }

  private int computeIndent() {
    final Wrappers._int result = new Wrappers._int(0);
    repository().getModelAccess().runReadAction(() -> {
      EditorCell c = getParent();
      while (c != null) {
        if (isLinkedCollapsible(c)) {
          result.value = getX() - c.getX();
          break;
        }
        c = c.getParent();
      }
    });
    return result.value;
  }

  /**
   * Check if the cell is a collapsible that is linked to this one.
   * If that's the case, edges are drawn between these collapsibles.
   */
  private boolean isLinkedCollapsible(EditorCell cell) {
    if (!(cell instanceof CollapsibleCell)) {
      return false;
    }
    if (myGroup != null) {
      return myGroup.equals((as_syvjue_a0a0a0a0b0ic(cell, CollapsibleCell.class)).myGroup);
    }
    return getCellId().equals(cell.getCellId());
  }

  private SRepository repository() {
    return getEditorComponent().getEditorContext().getRepository();
  }
  private static void check_syvjue_a0a32(EditorCell_Collection checkedDotOperand, CollapseExpandToggleCell myToggleCell) {
    if (null != checkedDotOperand) {
      checkedDotOperand.removeCell(myToggleCell);
    }

  }
  private static EditorCell_Collection check_syvjue_a0a0a32(CollapseExpandToggleCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getParent();
    }
    return null;
  }
  private static void check_syvjue_a1a32(EditorCell_Collection checkedDotOperand, EditorCell myCollapsedCell) {
    if (null != checkedDotOperand) {
      checkedDotOperand.removeCell((jetbrains.mps.nodeEditor.cells.EditorCell) myCollapsedCell);
    }

  }
  private static jetbrains.mps.openapi.editor.cells.EditorCell_Collection check_syvjue_a0a1a32(EditorCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getParent();
    }
    return null;
  }
  private static void check_syvjue_a2a32(EditorCell_Collection checkedDotOperand, EditorCell myExpandedCell) {
    if (null != checkedDotOperand) {
      checkedDotOperand.removeCell((jetbrains.mps.nodeEditor.cells.EditorCell) myExpandedCell);
    }

  }
  private static jetbrains.mps.openapi.editor.cells.EditorCell_Collection check_syvjue_a0a2a32(EditorCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getParent();
    }
    return null;
  }
  private static <T> T as_syvjue_a0a0a32(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_syvjue_a0a1a32(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_syvjue_a0a2a32(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_syvjue_a0a0a0a45(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_syvjue_a0a0d0b0a0cc(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_syvjue_a0a0a0a0b0ic(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.model.mxCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import de.itemis.mps.editor.diagram.runtime.model.Box;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class LayoutProcessor {

  private MyGraph myGraph;
  /*package*/ boolean isSubDiagram = false;

  public LayoutProcessor(MyGraph graph, boolean isSubDiagram) {
    myGraph = graph;
    this.isSubDiagram = isSubDiagram;
  }

  public void process() {
    processRootECell(myGraph.getGraphComponent().getDiagramCell());
  }

  protected void processRootECell(RootDiagramECell rootECell) {
    processRootDCell(rootECell.getDCell(rootECell.getGraph()));
  }

  protected void processRootDCell(RootDCell cell) {
    processDiagramDCell(cell);
  }

  public void processDiagramDCell(BaseDiagramDCell diagramDCell) {
    for (mxCell child : ListSequence.fromList(JGraphUtil.getChildCells(diagramDCell))) {
      processDCell(child);
    }
  }

  protected void processDCell(mxCell cell) {
    if (cell instanceof BaseDCell) {
      ((BaseDCell) cell).layoutMPSCells();
    }
    if (cell instanceof BoxDCell) {
      processBoxDCell(((BoxDCell) cell));
    }
  }

  protected void processBoxDCell(BoxDCell boxDCell) {
    processECell(check_a07x9w_a0a0q(ListSequence.fromList(boxDCell.getMPSCells()).first()));

    Tuples._2<Double, Double> requiredSize = boxDCell.getRequiredSize();
    if (requiredSize != null) {
      requiredSize = MultiTuple.<Double,Double>from((double) requiredSize._0(), (double) requiredSize._1());
      Bounds bounds = CellExtensions.getBounds(boxDCell);
      if (boxDCell.allowScaling()) {
        double additionalScale = 1.0;
        double scaledPadding = Box.PADDING;
        if (bounds.getWidth() < (double) requiredSize._0()) {
          additionalScale = Math.min(additionalScale, (bounds.getWidth() - scaledPadding) / (double) requiredSize._0());
        }
        if (bounds.getHeight() < (double) requiredSize._1()) {
          additionalScale = Math.min(additionalScale, (bounds.getHeight() - scaledPadding) / (double) requiredSize._1());
        }
        for (MPSCell mpsCell : ListSequence.fromList(boxDCell.getMPSCells())) {
          mpsCell.setAdditionalScale(additionalScale);
        }
      } else {
        bounds.setWidth(Math.max(bounds.getWidth(), (double) requiredSize._0()));
        bounds.setHeight(Math.max(bounds.getHeight(), (double) requiredSize._1()));
      }
      CellExtensions.setBounds(boxDCell, bounds);
    }
  }

  protected void processECell(EditorCell ecell) {
    if (ecell == null) {
      return;
    }
    if (ecell instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) ecell))) {
        processECell(child);
      }
    }

    if (!(isSubDiagram)) {
      // for the top diagram the layout is ran recursively to all sub-diagrams
      if (ecell instanceof SubDiagramECell) {
        processSubECell(((SubDiagramECell) ecell));
      }
    }
  }

  public void processSubECell(SubDiagramECell subECell) {
    SubDiagramDCell dCell = subECell.getDCell(myGraph);
    processSubDCell(dCell);
  }

  protected void processSubDCell(SubDiagramDCell subdiagram) {
    processDiagramDCell(subdiagram);
  }

  public double getScale() {
    return myGraph.getView().getScale();
  }
  private static EditorCell check_a07x9w_a0a0q(MPSCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
}

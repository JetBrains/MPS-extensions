package de.q60.mps.shadowmodels.modelcheck.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import javax.swing.Timer;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import com.intellij.openapi.application.ApplicationManager;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import de.q60.mps.shadowmodels.runtime.smodel.SM_GlobalModelListener;
import de.q60.mps.shadowmodels.runtime.smodel.SM_RepositoryModulesManager;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SModule;
import de.q60.mps.shadowmodels.runtime.smodel.SM_ShadowModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.q60.mps.shadowmodels.runtime.smodel.SM_ShadowModel;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.util.Consumer;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.typesystemEngine.checker.TypesystemChecker;
import jetbrains.mps.typesystemEngine.checker.NonTypesystemChecker;
import jetbrains.mps.checkers.ConstraintsChecker;
import de.q60.mps.shadowmodels.repository.transformations.IMessageLifter;
import de.q60.mps.shadowmodels.runtime.engine.IResultElement;
import de.q60.mps.shadowmodels.runtime.smodel.SM_TransformationTrace;
import de.q60.mps.shadowmodels.runtime.engine.IOperation;
import de.q60.mps.polymorphicfunctions.runtime.ParameterList;
import de.q60.mps.shadowmodels.runtime.concurrentrepo.RepositoryMirror;
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter;
import org.jetbrains.mps.openapi.model.SNodeChangeListener;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.event.SNodeAddEvent;
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent;
import org.jetbrains.mps.openapi.event.SPropertyChangeEvent;
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent;

public class ShadowModelChecker {
  private static final Logger LOG = Logger.getLogger(ShadowModelChecker.class);
  private static final String LIFT_OP_ID = "de.q60.mps.shadowmodels.repository.transformations.ShadowRepository.liftMessage";

  private static ShadowModelChecker ourInstance = new ShadowModelChecker();
  public static ShadowModelChecker getInstance() {
    return ourInstance;
  }

  private boolean checkInProgress = false;
  private Timer timer = new Timer(100, new ActionListener() {
    public void actionPerformed(ActionEvent e) {
      if (!(checkInProgress)) {
        checkInProgress = true;
        ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
          public void run() {
            try {
              runChecks();
              timer.setDelay(100);
            } catch (Exception ex) {
              if (LOG.isErrorLevel()) {
                LOG.error("", ex);
              }
              timer.setDelay(Math.min(3000, timer.getDelay() * 2));
            } finally {
              checkInProgress = false;
            }
          }
        });
      }
    }
  });
  private Set<SNodeReference> cleanRoots = SetSequence.fromSet(new HashSet<SNodeReference>());
  private SM_GlobalModelListener modelListener = new ModelListener();

  protected void runChecks() {
    if (!(SM_RepositoryModulesManager.isEnabled())) {
      return;
    }

    final Map<SNodeReference, List<LiftedReportItem>> newMessages = MapSequence.fromMap(new HashMap<SNodeReference, List<LiftedReportItem>>());

    final MPSModuleRepository repository = MPSCoreComponents.getInstance().getPlatform().findComponent(MPSModuleRepository.class);
    final Wrappers._T<Iterable<SNode>> shadowRoots = new Wrappers._T<Iterable<SNode>>(null);
    repository.getModelAccess().runReadAction(() -> {
      Iterable<SModule> allModules = repository.getModules();
      Iterable<SM_ShadowModule> shadowModules = Sequence.fromIterable(allModules).ofType(SM_ShadowModule.class);
      Iterable<SM_ShadowModel> shadowModels = Sequence.fromIterable(shadowModules).translate((it) -> it.getModels()).ofType(SM_ShadowModel.class);
      shadowRoots.value = Sequence.fromIterable(shadowModels).translate((it) -> it.getRootNodes()).toList();
    });

    final Wrappers._boolean anyChange = new Wrappers._boolean(false);
    for (final SNode root : Sequence.fromIterable(shadowRoots.value)) {
      SM_RepositoryModulesManager.getInstance().runRead(() -> {
        repository.getModelAccess().runReadAction(() -> {
          if (root.getModel() == null) {
            return;
          }
          long start = System.currentTimeMillis();
          if (SetSequence.fromSet(cleanRoots).contains(root.getReference())) {
            MapSequence.fromMap(newMessages).put(root.getReference(), LiftedMessagesCache.getInstance().getMessages(ShadowModelChecker.this, root.getReference()));
          } else {
            anyChange.value = true;
            final List<NodeReportItem> items = ListSequence.fromList(new ArrayList<NodeReportItem>());
            Consumer<NodeReportItem> consumer = new Consumer<NodeReportItem>() {
              public void consume(@NotNull NodeReportItem item) {
                ListSequence.fromList(items).addElement(item);
              }
            };
            EmptyProgressMonitor monitor = new EmptyProgressMonitor();
            new TypesystemChecker().check(root, repository, consumer, monitor);
            new NonTypesystemChecker().check(root, repository, consumer, monitor);
            new ConstraintsChecker(null).asRootChecker().check(root, repository, consumer, monitor);

            final List<LiftedReportItem> messagesForRoot = ListSequence.fromList(new ArrayList<LiftedReportItem>());
            for (NodeReportItem item : ListSequence.fromList(items)) {
              final SNode shadowTarget = item.getNode().resolve(repository);
              if (shadowTarget == null) {
                continue;
              }

              IMessageLifter lifter = new IMessageLifter() {
                private SNode currentNode;
                public void liftMessage(String message, SNode target) {
                  currentNode = target;
                  IResultElement resultElement = SM_TransformationTrace.getResultElement(target);
                  if (resultElement != null) {
                    IOperation op = resultElement.getOperation(LIFT_OP_ID);
                    if (op != null) {
                      op.invoke(new ParameterList(ListSequence.fromListAndArray(new ArrayList<Object>(), message, this)));
                      return;
                    }
                  } else {
                    SNode nodeInInputRepository = RepositoryMirror.getOriginalNode(SNodeToNodeAdapter.wrap(target), repository);
                    if (nodeInInputRepository != null && !(nodeInInputRepository.getModel() instanceof SM_ShadowModel)) {
                      ListSequence.fromList(messagesForRoot).addElement(new LiftedReportItem(item.getSeverity(), nodeInInputRepository.getReference(), shadowTarget.getReference(), "[LIFTED] " + message));
                      return;
                    }
                  }

                  liftMessage(message);
                }
                public void liftMessage(String message) {
                  for (SNode inputNode : Sequence.fromIterable(SM_TransformationTrace.tryGetInputNodes(currentNode))) {
                    liftMessage(message, inputNode);
                  }
                }
              };
              try {
                lifter.liftMessage(item.getMessage(), shadowTarget);
              } catch (Exception ex) {
                if (LOG.isErrorLevel()) {
                  LOG.error("", ex);
                }
              }
            }
            MapSequence.fromMap(newMessages).put(root.getReference(), messagesForRoot);
            SetSequence.fromSet(cleanRoots).addElement(root.getReference());
            long end = System.currentTimeMillis();
            if (LOG.isDebugLevel()) {
              LOG.debug(root + " [" + root.getConcept().getName() + "] checked in " + (end - start) + " ms");
            }
          }
        });
      });
    }

    if (anyChange.value && timer.isRunning()) {
      LiftedMessagesCache.getInstance().putMessages(this, newMessages);
    }
  }

  public void start() {
    SetSequence.fromSet(cleanRoots).clear();
    modelListener.start(MPSCoreComponents.getInstance().getPlatform().findComponent(MPSModuleRepository.class));
    timer.start();
  }

  public void stop() {
    timer.stop();
    modelListener.stop();
    LiftedMessagesCache.getInstance().clearMessages(this);
  }

  public void invalidate(SNode node) {
    if (node == null) {
      return;
    }
    SNode root = node.getContainingRoot();
    if (root == null) {
      return;
    }
    SetSequence.fromSet(cleanRoots).removeElement(root.getReference());
  }

  protected class ModelListener extends SM_GlobalModelListener implements SNodeChangeListener {
    protected void addListener(SModel model) {
      if (!(model instanceof SM_ShadowModel)) {
        return;
      }
      model.addChangeListener(this);
    }
    protected void removeListener(SModel model) {
      if (!(model instanceof SM_ShadowModel)) {
        return;
      }
      model.removeChangeListener(this);
    }
    @Override
    public void start(SModule module) {
      if (!(module instanceof SM_ShadowModule)) {
        return;
      }
      super.start(module);
    }
    @Override
    public void stop(SModule module) {
      if (!(module instanceof SM_ShadowModule)) {
        return;
      }
      super.stop(module);
    }

    @Override
    public void nodeAdded(@NotNull SNodeAddEvent event) {
      invalidate(event.getParent());
    }
    @Override
    public void nodeRemoved(@NotNull SNodeRemoveEvent event) {
      invalidate(event.getParent());
    }
    @Override
    public void propertyChanged(@NotNull SPropertyChangeEvent event) {
      invalidate(event.getNode());
    }
    @Override
    public void referenceChanged(@NotNull SReferenceChangeEvent event) {
      invalidate(event.getNode());
    }
  }
}

package com.mbeddr.mpsutil.intentions.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.IntentionsSupport;
import java.util.concurrent.atomic.AtomicReference;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.ActionManager;
import jetbrains.mps.ide.actions.MPSActions;
import javax.swing.KeyStroke;
import com.intellij.openapi.actionSystem.Shortcut;
import com.intellij.openapi.actionSystem.KeyboardShortcut;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent;
import javax.swing.JComponent;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import jetbrains.mps.openapi.editor.selection.SelectionListener;
import jetbrains.mps.editor.intentions.IntentionMenuProducer;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.openapi.intentions.Kind;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.intentions.IntentionsManager;
import javax.swing.Icon;
import jetbrains.mps.intentions.icons.Icons;
import jetbrains.mps.intentions.icons.IntentionIconProvider;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.nodeEditor.configuration.EditorConfiguration;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.editor.runtime.cells.ReadOnlyUtil;
import jetbrains.mps.smodel.SModelOperations;
import com.intellij.openapi.actionSystem.ShortcutSet;

/**
 * Copy of IntentionsSupport from MPS, adapted to look up intentions for read-only cells.
 */
public class MyIntentionsSupport extends IntentionsSupport {

  private final AtomicReference<MyIntentionsThread> myShowIntentionsThreadOverwritten = new AtomicReference<>();

  public MyIntentionsSupport(@NotNull EditorComponent editor) {
    super(editor);
    final AnAction ideaActionRegistration = ActionManager.getInstance().getActionOrStub(MPSActions.EDITOR_SHOW_INTENTIONS_POPUP_ACTION);
    KeyStroke firstKeyStroke = null;
    for (Shortcut shortcut : check_szd67i_a3a3(check_szd67i_a0d0d(ideaActionRegistration))) {
      if (!(shortcut.isKeyboard())) {
        continue;
      }
      if (shortcut instanceof KeyboardShortcut) {
        firstKeyStroke = ((KeyboardShortcut) shortcut).getFirstKeyStroke();
        break;
      }
    }
    if (firstKeyStroke == null) {
      // fallback
      firstKeyStroke = KeyStroke.getKeyStroke("alt ENTER");
    }
    ReflectionUtil.writeField(IntentionsSupport.class, getIntentionsSupport(), "myShowIntentionsAction", new AbstractAction() {
      @Override
      public void actionPerformed(ActionEvent e) {
        getEditor().getEditorContext().getRepository().getModelAccess().runReadAction(() -> checkAndShowMenu());
      }
    });
    // FIXME check 47d64cfa and MPS-31891. Likely we need to switch to use idea's actions not only to keep shortcut,
    // just requires some deep understanding of DataContext to integrate it with our thread to update intentions menu
    getEditor().registerKeyboardAction(((AbstractAction) ReflectionUtil.readField(IntentionsSupport.class, getIntentionsSupport(), "myShowIntentionsAction")), firstKeyStroke, JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    final FocusAdapter focusListener = new FocusAdapter() {
      @Override
      public void focusGained(FocusEvent e) {
        updateIntentionsStatus();
      }
      @Override
      public void focusLost(FocusEvent e) {
        ReflectionUtil.callVoidMethod(IntentionsSupport.class, getIntentionsSupport(), "hideLightBulb", new Class[]{}, new Object[]{});
        // If editor lost focus, thread can be stopped - it will be any way restarted on focus gain
        stopIntentionThread();
      }
    };
    getEditor().addFocusListener(focusListener);
    final SelectionListener selectionListener = (editorComponent, oldSelection, newSelection) -> {
      if (oldSelection == newSelection) {
        return;
      }
      if (!(((EditorComponent) editorComponent).isFocusOwner())) {
        return;
      }
      updateIntentionsStatus();
    };
    getEditor().getSelectionManager().addSelectionListener(selectionListener);
    final EditorComponent.EditorDisposeListener disposeListener = new EditorComponent.EditorDisposeListener() {
      @Override
      public void editorWillBeDisposed(@NotNull EditorComponent component) {
        stopIntentionThread();
        getEditor().removeFocusListener(focusListener);
        getEditor().getSelectionManager().removeSelectionListener(selectionListener);
        getEditor().removeDisposeListener(this);
      }
    };
    getEditor().addDisposeListener(disposeListener);
  }

  public static IntentionsSupport getIntentionsSupport(@NotNull EditorComponent editor) {
    return ((IntentionsSupport) ReflectionUtil.readField(EditorComponent.class, editor, "myIntentionsSupport"));
  }

  public static IntentionMenuProducer getIntentionMenuProducer(@NotNull EditorComponent editor) {
    return ((IntentionMenuProducer) ReflectionUtil.readField(IntentionsSupport.class, getIntentionsSupport(editor), "myMenuProducer"));
  }

  public IntentionsSupport getIntentionsSupport() {
    return as_szd67i_a0a0j(this, IntentionsSupport.class);
  }

  private class MyIntentionsThread extends Thread {
    private volatile boolean myStopRequested;
    public MyIntentionsThread() {
      super("Intentions");
    }
    /*package*/ void requestStop() {
      myStopRequested = true;
    }

    @Override
    public void run() {
      try {
        Thread.sleep(1000);
        if (myStopRequested) {
          return;
        }
        final boolean[] forceReturn = {false};
        ApplicationManager.getApplication().invokeAndWait(() -> ((SRepository) ReflectionUtil.callMethod(EditorComponent.class, getEditor(), "getRepository", new Class[]{}, new Object[]{})).getModelAccess().runReadAction(() -> forceReturn[0] = ((Boolean) ReflectionUtil.callMethod(IntentionsSupport.class, getIntentionsSupport(), "isInconsistentEditor", new Class[]{}, new Object[]{})) || areIntentionsNotSupported()));
        if (forceReturn[0]) {
          return;
        }
        final Kind intentionKind = getModelAccess().computeReadAction(() -> {
          // TODO check for ActionsAsIntentions
          if (getEditor().getTypecheckingSession() == null) {
            return null;
          }
          return TypecheckingFacade.getFromContext().computeWithSession(getEditor().getTypecheckingSession(), (session) -> IntentionsManager.getInstance().getHighestAvailableBaseIntentionType(getEditor().getSelectedNode(), getEditor().getEditorContext()));
        });
        if (intentionKind == null || myStopRequested) {
          return;
        }
        getModelAccess().runReadInEDT(() -> {
          if (((Boolean) ReflectionUtil.callMethod(IntentionsSupport.class, getIntentionsSupport(), "isInconsistentEditor", new Class[]{}, new Object[]{})) || areIntentionsNotSupported() || myStopRequested) {
            return;
          }
          if (getEditor().getSelectedCell() == null) {
            ReflectionUtil.callVoidMethod(IntentionsSupport.class, getIntentionsSupport(), "hideLightBulb", new Class[]{}, new Object[]{});
          } else {
            ReflectionUtil.callVoidMethod(IntentionsSupport.class, getIntentionsSupport(), "adjustLightBulbLocation", new Class[]{}, new Object[]{});
            ReflectionUtil.callVoidMethod(IntentionsSupport.class, getIntentionsSupport(), "showLightBulbComponent", new Class[]{Icon.class}, new Object[]{(intentionKind == Kind.NORMAL ? Icons.INTENTION : new IntentionIconProvider(intentionKind).getIcon())});
          }
        });
      } catch (InterruptedException e) {
        // It's ok, we don't care if the thread got interrupted
      } finally {
        intentionThreadCompleted(this);
      }
    }
  }

  private EditorComponent getEditor() {
    return ((EditorComponent) ReflectionUtil.readField(IntentionsSupport.class, as_szd67i_a1a0a0a31(this, IntentionsSupport.class), "myEditor"));
  }

  private ModelAccess getModelAccess() {
    return ((ModelAccess) ReflectionUtil.callMethod(IntentionsSupport.class, getIntentionsSupport(), "getModelAccess", new Class[]{}, new Object[]{}));
  }

  private void intentionThreadCompleted(MyIntentionsThread thread) {
    myShowIntentionsThreadOverwritten.compareAndSet(thread, null);
  }

  private void updateIntentionsStatus() {
    if (!(((EditorConfiguration) ReflectionUtil.callMethod(EditorComponent.class, getEditor(), "getEditorConfiguration", new Class[]{}, new Object[]{})).showLightBulb)) {
      return;
    }
    stopIntentionThread();
    ReflectionUtil.callVoidMethod(IntentionsSupport.class, getIntentionsSupport(), "hideLightBulb", new Class[]{}, new Object[]{});
    myShowIntentionsThreadOverwritten.set(new MyIntentionsThread());
    myShowIntentionsThreadOverwritten.get().start();
  }

  private void stopIntentionThread() {
    MyIntentionsThread thread = myShowIntentionsThreadOverwritten.getAndSet(null);
    if (thread != null) {
      thread.requestStop();
    }
  }

  private boolean areIntentionsNotSupported() {
    SModel model = getEditor().getSelectedNode().getModel();
    if (model == null) {
      return true;
    }
    if ((ReadOnlyUtil.isSelectionReadOnlyInEditor(getEditor()) || SModelOperations.isReadOnly(model)) && !(StyleUtil.allowIntentionsInReadOnlySelection(getEditor()))) {
      return true;
    }

    return false;
  }

  protected void checkAndShowMenu() {
    if (((Boolean) ReflectionUtil.callMethod(IntentionsSupport.class, getIntentionsSupport(), "isInconsistentEditor", new Class[]{}, new Object[]{}))) {
      return;
    }
    if (areIntentionsNotSupported()) {
      return;
    }
    ReflectionUtil.callVoidMethod(IntentionsSupport.class, getIntentionsSupport(), "showIntentionsMenu", new Class[]{}, new Object[]{});
  }

  private static Shortcut[] check_szd67i_a3a3(ShortcutSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getShortcuts();
    }
    return null;
  }
  private static ShortcutSet check_szd67i_a0d0d(AnAction checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getShortcutSet();
    }
    return null;
  }
  private static <T> T as_szd67i_a0a0j(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_szd67i_a1a0a0a31(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

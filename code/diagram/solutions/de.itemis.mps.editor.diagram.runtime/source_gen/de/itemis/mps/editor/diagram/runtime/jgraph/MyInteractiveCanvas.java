package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.swing.view.mxInteractiveCanvas;
import com.mxgraph.swing.mxGraphComponent;
import java.awt.Rectangle;
import com.mxgraph.view.mxCellState;
import java.awt.geom.Path2D;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import com.mxgraph.shape.mxIShape;

public class MyInteractiveCanvas extends mxInteractiveCanvas {

  @Override
  public boolean intersects(mxGraphComponent graphComponent, Rectangle rect, mxCellState state) {
    EdgeDCell edge = as_y0jn07_a0a0a1(state.getCell(), EdgeDCell.class);
    MyConnectorShape connectorShape = as_y0jn07_a0a1a1(check_y0jn07_a0a1a1(edge), MyConnectorShape.class);
    if (connectorShape != null && edge.isCurved()) {
      Path2D path = connectorShape.pointsToPath(state.getAbsolutePoints(), edge.isCurved());
      final Rectangle grown = ((Rectangle) rect.clone());
      grown.grow(graphComponent.getTolerance(), graphComponent.getTolerance());
      final Wrappers._boolean intersects = new Wrappers._boolean(path.intersects(grown));
      if (intersects.value) {
        // do a more accurate check
        intersects.value = false;
        MyConnectorShape.visitPointsOnPath(path, graphComponent.getTolerance() / 4, (Vector2D point, Vector2D direction) -> {
          if (grown.contains(point.getX(), point.getY())) {
            intersects.value = true;
          }
        });
      }
      return intersects.value;
    }

    return super.intersects(graphComponent, rect, state);
  }

  private static mxIShape check_y0jn07_a0a1a1(EdgeDCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getShape();
    }
    return null;
  }
  private static <T> T as_y0jn07_a0a0a1(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_y0jn07_a0a1a1(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

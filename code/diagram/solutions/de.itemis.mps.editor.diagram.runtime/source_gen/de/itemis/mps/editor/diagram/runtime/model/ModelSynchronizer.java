package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.openapi.editor.EditorComponent;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import de.itemis.mps.editor.diagram.runtime.DiagramContext;
import de.itemis.mps.editor.diagram.runtime.jgraph.BaseDiagramECell;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.itemis.mps.editor.diagram.runtime.EditorSelectionQueue;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.CellFinderUtil;
import javax.swing.SwingUtilities;
import de.itemis.mps.editor.diagram.runtime.jgraph.RootDiagramECell;
import de.itemis.mps.editor.diagram.runtime.EditorUtil;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import de.itemis.mps.editor.diagram.runtime.jgraph.DiagramCreationContext;
import de.itemis.mps.editor.diagram.runtime.DiagramUtil;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Objects;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.Iterator;
import org.jetbrains.mps.openapi.model.SNode;
import de.itemis.mps.editor.diagram.runtime.jgraph.MyGraph;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ModelSynchronizer {

  private DiagramModel myModel;
  private IDiagramAccessor myDiagramAccessor;

  private Map<IAccessorKey, IDiagramElementAccessor> myAccessors = MapSequence.fromMap(new HashMap<IAccessorKey, IDiagramElementAccessor>());
  private Map<IAccessorKey, IDiagramElement> myElements = MapSequence.fromMap(new HashMap<IAccessorKey, IDiagramElement>());
  private EditorComponent myEditorComponent;
  private AccessorFactory myAccessorFactory;
  private List<IDiagramElement> myNewElements = ListSequence.fromList(new ArrayList<IDiagramElement>());
  private IDiagramElement myNewestElement = null;
  private List<_FunctionTypes._void_P0_E0> myWritesAfterRead = ListSequence.fromList(new ArrayList<_FunctionTypes._void_P0_E0>());
  private Bounds myBoundsForNewBox;

  public ModelSynchronizer(DiagramModel model, EditorComponent editorComponent) {
    this.myModel = model;
    myEditorComponent = editorComponent;
    myAccessorFactory = new AccessorFactory(myEditorComponent, myModel);
  }

  public void setDiagramAccessor(@NotNull IDiagramAccessor accessor) {
    myDiagramAccessor = accessor;
  }

  @NotNull
  public IDiagramAccessor getDiagramAccessor() {
    return myDiagramAccessor;
  }

  public void toSModel(@Nullable final IDiagramCell diagramECell) {
    DiagramContext.withContext(((BaseDiagramECell) diagramECell), () -> {
      myEditorComponent.getEditorContext().getRepository().getModelAccess().executeCommand(() -> ScalableEditorCell.withScalingDisabled(() -> toSModel_(diagramECell)));
      myModel.resetModificationFlags();
    });
  }

  protected void toSModel_(@Nullable final IDiagramCell diagramECell) {
    ListSequence.fromList(myWritesAfterRead).clear();

    for (Box box : ListSequence.fromListWithValues(new ArrayList<Box>(), myModel.getBoxes())) {
      if (box instanceof PendingBox) {
        final PendingBox pending = ((PendingBox) box);
        myModel.removeBox(pending);
        if (pending.canCreate()) {
          myBoundsForNewBox = pending.getBounds();
          pending.create();
          final Edge edgeToSplit = pending.getEdgeToSplit();
          final List<Edge> edgesFrom = Sequence.fromIterable(myModel.getEdges()).where((it) -> it.getResolvedEndpointFrom() == pending).toList();
          final List<Edge> edgesTo = Sequence.fromIterable(myModel.getEdges()).where((it) -> it.getResolvedEndpointTo() == pending).toList();

          EditorSelectionQueue.queueSelectionHandler(myEditorComponent, new EditorSelectionQueue.Handler() {
            public void handle(EditorComponent editorComponent_) {
              Box newBox = as_l95w85_a0a0a0a0b0g0c0a0c0v(myNewestElement, Box.class);
              if (newBox == null) {
                return;
              }
              jetbrains.mps.nodeEditor.EditorComponent editorComponent = ((jetbrains.mps.nodeEditor.EditorComponent) editorComponent_);
              final EditorCell rootCell = newBox.getRootCell();
              if (rootCell == null) {
                return;
              }
              EditorCell cellToSelect = CellFinderUtil.findFirstError(rootCell, true);
              if (cellToSelect != null) {
                editorComponent.changeSelection(cellToSelect);
              } else {
                SwingUtilities.invokeLater(() -> {
                  RootDiagramECell diagramCell = EditorUtil.getAncestor(rootCell, RootDiagramECell.class);
                });
              }
            }
          });

          ListSequence.fromList(myWritesAfterRead).addElement(() -> {
            Box newBox = (Box) ListSequence.fromList(myNewElements).findFirst((it) -> it instanceof Box);
            if (edgeToSplit != null) {
              edgeToSplit.split(newBox);
            } else {
              for (Edge edge : ListSequence.fromList(edgesFrom)) {
                edge.setEndpointFrom(newBox);
              }
              for (Edge edge : ListSequence.fromList(edgesTo)) {
                edge.setEndpointTo(newBox);
              }
            }
          });
        } else {
          myModel.removeBox(pending);
        }
      } else {
        toSModel_BoxOrSubdiagram(box.getAccessor(), box);
      }
    }
    for (Edge e : ListSequence.fromListWithValues(new ArrayList<Edge>(), myModel.getEdges())) {
      if (e instanceof PendingEdge) {
        final PendingEdge pendingEdge = ((PendingEdge) e);
        myModel.removeEdge(pendingEdge);
        final Wrappers._T<IEdgeAccessor> newAccessor = new Wrappers._T<IEdgeAccessor>(null);
        DiagramCreationContext.ensureInContext(check_l95w85_a0d0a0d0v(as_l95w85_a0a0d0a0d0v(diagramECell, BaseDiagramECell.class)), () -> newAccessor.value = pendingEdge.getCreator().create(new ConnectionEndpointAdapter(pendingEdge.getUnresolvedEndpointFrom()), new ConnectionEndpointAdapter(pendingEdge.getUnresolvedEndpointTo()), new DeprecatedAccessorFactory()));
        if (newAccessor.value != null) {
          newAccessor.value.setParentDiagramAccessor(myDiagramAccessor);
          Edge newEdge = createEdge(newAccessor.value);
          pendingEdge.replaceWith(newEdge);
          myModel.firePendingReplaced(pendingEdge, newEdge);
          toSModel_Edge(newAccessor.value, newEdge);
        }
      } else {
        toSModel_Edge(e.getAccessor(), e);
      }
    }
    for (Annotation e : ListSequence.fromListWithValues(new ArrayList<Annotation>(), myModel.getAnnotations())) {
      toSModel_Annotation(e.getAccessor(), e);
    }
    if (DiagramModel.ALLOW_DELETE_DURING_SYNC) {
      for (IDiagramElement e : ListSequence.fromList(myModel.getElementsToDelete())) {
        e.delete();
      }
      myModel.clearElementsToDelete();
    }

    if (ListSequence.fromList(myWritesAfterRead).isNotEmpty()) {
      myEditorComponent.getUpdater().flushModelEvents();
      // FIXME I'm not sure there's need to execute elements of myWritesAfterRead from within model write
      //       However, the name suggests they are 'writes', and there's Edge.split call inside them
      //       that used to do ModelAccess.requireWrite() (now removed).
      //       The need for model write is dubious as it doesn't allow node changes (it's not a command),
      //       I don't see any reason to have it here.
      myEditorComponent.getEditorContext().getRepository().getModelAccess().runWriteAction(() -> {
        for (_FunctionTypes._void_P0_E0 r : ListSequence.fromList(myWritesAfterRead)) {
          r.invoke();
        }
      });
      ListSequence.fromList(myWritesAfterRead).clear();
    }
  }

  public void fromSModel(@Nullable final IDiagramCell diagramECell) {
    myEditorComponent.getEditorContext().getRepository().getModelAccess().runReadAction(() -> DiagramContext.withContext(((BaseDiagramECell) diagramECell), () -> ScalableEditorCell.withScalingDisabled(() -> fromSModel_(diagramECell))));
    myModel.resetModificationFlags();
  }

  public void collectAccessors(@Nullable IAccessor parent, @NotNull List<IDiagramElementAccessor> result) {
    if (parent == null) {
      return;
    }
    if (parent instanceof IDiagramElementAccessor) {
      result.add(((IDiagramElementAccessor) parent));
    }

    List<? extends IAccessor> childs = parent.getElements(myAccessorFactory);
    if (childs != null) {
      for (IAccessor child : ListSequence.fromList(childs)) {
        collectAccessors(child, result);
      }
    }
  }

  protected void fromSModel_(@Nullable final IDiagramCell diagramECell) {
    DiagramUtil.checkInUpdateSession(myEditorComponent);
    ListSequence.fromList(myNewElements).clear();

    boolean hadAnyLayoutData = myDiagramAccessor.hasAnyLayoutData();

    List<IDiagramElementAccessor> accessors = new ArrayList<IDiagramElementAccessor>();
    collectAccessors(myDiagramAccessor, accessors);
    for (IDiagramElementAccessor a : ListSequence.fromList(accessors).ofType(IDiagramElementAccessor.class)) {
      a.setParentDiagramAccessor(myDiagramAccessor);
    }

    // model
    List<IConnectionType> connectionTypes = ((List<IConnectionType>) myDiagramAccessor.getConnectionTypes());
    Iterable<IConnectionTypesExtensionProvider> connTypesProviders = new ExtensionPoint<IConnectionTypesExtensionProvider>("de.itemis.mps.editor.diagram.runtime.diagramConnectionTypesProvider").getObjects();
    ListSequence.fromList(connectionTypes).addSequence(Sequence.fromIterable(connTypesProviders).where(new _FunctionTypes._return_P1_E0<Boolean, IConnectionTypesExtensionProvider>() {
      public Boolean invoke(IConnectionTypesExtensionProvider it) {
        return it.appliesFor(SNodeOperations.getConcept(myModel.getSNode()));
      }
    }).translate(new _FunctionTypes._return_P1_E0<Iterable<IConnectionType>, IConnectionTypesExtensionProvider>() {
      public Iterable<IConnectionType> invoke(IConnectionTypesExtensionProvider it) {
        return it.getConnectionTypes(myModel.getSNode(), myModel.getEditorContext());
      }
    }));
    myModel.setConnectionTypes(ListSequence.fromList(connectionTypes).select((it) -> new ConnectionCreatorAdapter(it, myModel)).toList());
    myModel.setDefaultBoxShape(myDiagramAccessor.getDefaultBoxShape());

    // synchronize list
    Set<IAccessorKey> toRemove = SetSequence.fromSetWithValues(new HashSet<IAccessorKey>(), MapSequence.fromMap(myAccessors).keySet());
    for (IDiagramElementAccessor accessor : ListSequence.fromList(accessors).ofType(IDiagramElementAccessor.class)) {
      IAccessorKey id = accessor.getId();
      SetSequence.fromSet(toRemove).removeElement(id);

      IDiagramElement element = MapSequence.fromMap(myElements).get(id);
      if (element == null) {
        element = createDiagramElement(accessor);
        ListSequence.fromList(myNewElements).addElement(element);
        myNewestElement = element;
      }
      if (element.isAccessorAllowed(accessor)) {
        element.setAccessor(accessor);
      }
      myModel.registerDiagramElement(element);
      MapSequence.fromMap(myAccessors).put(id, accessor);
      MapSequence.fromMap(myElements).put(id, element);
    }
    for (IAccessorKey id : SetSequence.fromSet(toRemove)) {
      myModel.unregister(MapSequence.fromMap(myElements).get(id));
      MapSequence.fromMap(myAccessors).removeKey(id);
      MapSequence.fromMap(myElements).removeKey(id);
    }

    // synchronize elements (nodes first)
    Iterable<IDiagramElement> sortedElements = Sequence.fromIterable(MapSequence.fromMap(myElements).values()).where((it) -> it instanceof Box);
    sortedElements = Sequence.fromIterable(sortedElements).concat(Sequence.fromIterable(MapSequence.fromMap(myElements).values()).where((it) -> it instanceof Edge));
    sortedElements = Sequence.fromIterable(sortedElements).concat(Sequence.fromIterable(MapSequence.fromMap(myElements).values()).where((it) -> it instanceof Annotation));
    for (IDiagramElement element : Sequence.fromIterable(sortedElements)) {
      fromSModel_DiagramElement(element.getAccessor(), element);
    }

    addElementCellsTo(diagramECell);
  }

  @NotNull
  public IDiagramElement createDiagramElement(IDiagramElementAccessor accessor) {
    IDiagramElement result;
    if (accessor instanceof IBoxAccessor) {
      result = createBox(((IBoxAccessor) accessor));
    } else if (accessor instanceof IEdgeAccessor) {
      result = createEdge(((IEdgeAccessor) accessor));
    } else if (accessor instanceof IAnnotationAccessor) {
      result = createAnnotation(((IAnnotationAccessor) accessor));
    } else {
      throw new RuntimeException("Unknown accessor type: " + check_l95w85_a0a0a0a1a92(check_l95w85_a0a0a0a0b0db(accessor)));
    }
    result.setSNode(accessor.getSNode());
    return result;
  }

  @NotNull
  public Box createBox(IBoxAccessor accessor) {
    Box box = new Box();
    box.setModel(myModel);
    box.setAccessor(accessor);
    return box;
  }

  @NotNull
  public Edge createEdge(IEdgeAccessor accessor) {
    Edge edge = new Edge();
    edge.setModel(myModel);
    edge.setAccessor(accessor);
    return edge;
  }

  @NotNull
  public Annotation createAnnotation(IAnnotationAccessor accessor) {
    Annotation annotation = new Annotation();
    annotation.setModel(myModel);
    annotation.setAccessor(accessor);
    return annotation;
  }

  public void fromSModel_DiagramElement(@NotNull IDiagramElementAccessor accessor, @NotNull IDiagramElement element) {
    if (accessor instanceof IBoxAccessor && element instanceof Box) {
      fromSModel_BoxOrSubdiagram(((IBoxAccessor) accessor), ((Box) element));
    } else if (accessor instanceof IEdgeAccessor) {
      fromSModel_Edge(((IEdgeAccessor) accessor), ((Edge) element));
    } else if (accessor instanceof IAnnotationAccessor) {
      fromSModel_Annotation(((IAnnotationAccessor) accessor), ((Annotation) element));
    } else {
      throw new RuntimeException("Unknown accessor type " + check_l95w85_a0a0a0a0a0a73(check_l95w85_a0a0a0a0a0a0lb(accessor)) + " or element type " + check_l95w85_a0a0a0a0a73(check_l95w85_a0a0a0a0a0lb(element)));
    }
    element.setStyle(accessor.getStyle());
  }

  public void fromSModel_BoxOrSubdiagram(@NotNull IBoxAccessor accessor, @NotNull Box element) {
    fromSModel_Box(accessor, element);
  }

  public void fromSModel_Subdiagram(@NotNull DiagramModel subdiagramModel, @Nullable final IDiagramCell diagramECell) {
    subdiagramModel.synchronizeRead(diagramECell);
  }

  public void toSModel_Subdiagram(@NotNull DiagramModel subdiagramModel, @Nullable final IDiagramCell diagramECell) {
    subdiagramModel.synchronizeWrite(diagramECell);
  }

  public void fromSModel_Box(@NotNull IBoxAccessor accessor, @NotNull Box element) {
    element.setPorts(accessor.getPorts());
    element.setShape(accessor.getShape());
    List<EditorCell> contentCells = accessor.getContentCells();
    if (ListSequence.fromList(contentCells).count() == 1 && accessor.getRootEditorCell().getSNode().isInstanceOfConcept(CONCEPTS.NodeAttribute$x2)) {
      element.setContentCells(Sequence.fromIterable(Sequence.<EditorCell>singleton(accessor.getRootEditorCell())).toList());
    } else {
      element.setContentCells(accessor.getContentCells());
    }
    element.setPreservePortOrder(accessor.isPreservePortOrder());
    EditorCell rootEditorCell = accessor.getRootEditorCell();
    if (rootEditorCell == null) {
      throw new NullPointerException(accessor.getClass().getName() + " (" + accessor.getId() + "): root cell not set");
    }
    element.setRootCell(rootEditorCell);
    element.setAllowConnectionsToBox(accessor.allowConnectionsToBox());
    element.setScalingAllowed(accessor.allowScaling());
    element.setNavigationTargets(Sequence.fromIterable(accessor.getNavigationTargets()).where((it) -> (it != null)).toList());

    Bounds defaultBounds = myBoundsForNewBox;
    if (defaultBounds == null) {
      defaultBounds = new Bounds(0, 0, 30, 20);
    }
    accessor.readLayout(element, defaultBounds);
    element.setNewOwnerDiagram(null);
  }

  public void toSModel_BoxOrSubdiagram(@NotNull IBoxAccessor accessor, @NotNull Box element) {
    toSModel_Box(accessor, element);
    if (element.hasRootCell()) {
      for (IDiagramCell subdiagram : ListSequence.fromList(EditorUtil.firstLevelDescendants(element.getRootCell(), IDiagramCell.class))) {
        toSModel_Subdiagram(subdiagram.getDiagramModel(), subdiagram);
      }
    }
  }

  public void toSModel_Box(@NotNull IBoxAccessor accessor, @NotNull Box element) {
    accessor.writeLayout(element);
    if (element.getNewOwnerDiagram() != null) {
      element.getNewOwnerDiagram().getDiagramAccessor().changeOwner(element);
      element.setNewOwnerDiagram(null);
    }
  }

  public void fromSModel_Edge(@NotNull IEdgeAccessor accessor, @NotNull Edge element) {
    element.setVisible(accessor.isVisible());

    IConnectionEndpointReference endpointFromRef = accessor.readFrom();
    IConnectionEndpointReference endpointToRef = accessor.readTo();
    IConnectionEndpoint_Internal endpointFrom = myModel.resolveEndpointLocal(endpointFromRef, false);
    IConnectionEndpoint_Internal endpointTo = myModel.resolveEndpointLocal(endpointToRef, true);
    if (endpointFrom == null) {
      endpointFrom = new UnresolvedEndpoint(endpointFromRef);
    }
    if (endpointTo == null) {
      endpointTo = new UnresolvedEndpoint(endpointToRef);
    }
    element.setEndpointFrom(endpointFrom);
    element.setEndpointTo(endpointTo);
    element.setNew(!(accessor.hasLayoutData()));
    element.setAnchorPoints(accessor.readAnchorPoints());
    element.setNavigationTargets(Sequence.fromIterable(accessor.getNavigationTargets()).where((it) -> (it != null)).toList());
    element.setAnySideAllowedFrom(accessor.anySideAllowedFrom());
    element.setAnySideAllowedTo(accessor.anySideAllowedTo());

    EditorCell rootEditorCell = accessor.getRootEditorCell();
    if (rootEditorCell == null) {
      throw new NullPointerException(accessor.getClass().getName() + " (" + accessor.getId() + "): root cell not set");
    }
    element.setRootCell(rootEditorCell);

    element.setStartShape(accessor.getStartShape());
    element.setEndShape(accessor.getEndShape());
    element.setStartShapeSize(accessor.getStartShapeSize());
    element.setEndShapeSize(accessor.getEndShapeSize());
    element.setCurved(accessor.isCurved());
    element.setEdgeStyle(accessor.getEdgeStyle());

    for (EdgeLabelType type : EdgeLabelType.values()) {
      element.setLabelCell(type, accessor.getLabelCell(type));
      element.setLabelPosition(type, accessor.readLabelPosition(type));
    }
  }

  public void fromSModel_Annotation(@NotNull IAnnotationAccessor accessor, @NotNull Annotation element) {
    element.setAnnotatedElement(MapSequence.fromMap(myElements).get(accessor.getAnnotatedElement()));

    element.setContentCells(accessor.getContentCells());
    EditorCell rootEditorCell = accessor.getRootEditorCell();
    if (rootEditorCell == null) {
      throw new NullPointerException(accessor.getClass().getName() + " (" + accessor.getId() + "): root cell not set");
    }
    element.setRootCell(rootEditorCell);

    Bounds defaultBounds = new Bounds(0, 0, 30, 20);
    Size preferredSize = element.getPreferredSize();
    if (preferredSize != null) {
      defaultBounds.setSize(preferredSize.getWidth(), preferredSize.getHeight());
    }
    if (element.getAnnotatedElement() instanceof BoxBase) {
      defaultBounds.setY(-10 - defaultBounds.getHeight());
    }

    accessor.readLayout(element, defaultBounds);
  }

  public void toSModel_Annotation(@NotNull IAnnotationAccessor accessor, @NotNull Annotation element) {
    accessor.writeLayout(element);
  }

  public void toSModel_Edge(@NotNull IEdgeAccessor accessor, @NotNull Edge element) {
    accessor.setVisible(element.isVisible());

    if (!(Objects.equals(accessor.readFrom(), check_l95w85_a0c0fc(element.getUnresolvedEndpointFrom())))) {
      accessor.writeFrom(element.getUnresolvedEndpointFrom());
    }
    if (!(Objects.equals(accessor.readTo(), check_l95w85_a0d0fc(element.getUnresolvedEndpointTo())))) {
      accessor.writeTo(element.getUnresolvedEndpointTo());
    }
    if (!(listEquals(accessor.readAnchorPoints(), element.getAnchorPoints()))) {
      accessor.writeAnchorPoints(element.getAnchorPoints());
    }
    for (EdgeLabelType type : EdgeLabelType.values()) {
      if (!(Objects.equals(accessor.readLabelPosition(type), element.getLabelPosition(type)))) {
        accessor.writeLabelPosition(type, element.getLabelPosition(type));
      }
    }
  }

  protected Iterable<EditorCell> getElementRootCells() {
    return Sequence.fromIterable(myModel.getElements()).select((it) -> it.getRootCell()).where((it) -> it != null);
  }

  protected void addElementCellsTo(IDiagramCell parent) {
    for (EditorCell cell : Sequence.fromIterable(getElementRootCells())) {
      if (cell.getParent() != parent) {
        if (cell.getParent() != null) {
          ((EditorCell_Collection) cell.getParent()).removeCell(cell);
        }
        if (parent != null) {
          parent.addEditorCell(cell);
        }
      }
    }
  }


  private static <T> boolean listEquals(List<T> listA, List<T> listB) {
    if ((listA == null || listB == null) && listA != listB) {
      return false;
    }
    if (listA.size() != listB.size()) {
      return false;
    }
    {
      Iterator<T> a_it = ListSequence.fromList(listA).iterator();
      Iterator<T> b_it = ListSequence.fromList(listB).iterator();
      T a_var;
      T b_var;
      while (a_it.hasNext() && b_it.hasNext()) {
        a_var = a_it.next();
        b_var = b_it.next();
        if (!(Objects.equals(a_var, b_var))) {
          return false;
        }
      }
    }
    return true;
  }

  public class DeprecatedAccessorFactory implements IAccessorFactory {
    private String msg = "Use of IAccessorFactory is deprecated here. Override the alternative method that doesn't require a return value.";

    @NotNull
    public List<IDiagramElementAccessor> fromSNode(SNode node, boolean duplicatesSafe) {
      throw new UnsupportedOperationException(msg);
    }
    @NotNull
    public List<IDiagramElementAccessor> fromSNode(SNode node) {
      throw new UnsupportedOperationException(msg);
    }
    @Nullable
    public IEdgeAccessor edgeFromSNode(@NotNull SNode node) {
      throw new UnsupportedOperationException(msg);
    }
    @Nullable
    public IBoxAccessor boxFromSNode(@NotNull SNode node) {
      throw new UnsupportedOperationException(msg);
    }
  }
  private static MyGraph check_l95w85_a0d0a0d0v(BaseDiagramECell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getContextGraph();
    }
    return null;
  }
  private static String check_l95w85_a0a0a0a1a92(Class<?> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static Class<?> check_l95w85_a0a0a0a0b0db(IDiagramElementAccessor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClass();
    }
    return null;
  }
  private static String check_l95w85_a0a0a0a0a73(Class<?> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static Class<?> check_l95w85_a0a0a0a0a0lb(IDiagramElement checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClass();
    }
    return null;
  }
  private static String check_l95w85_a0a0a0a0a0a73(Class<?> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static Class<?> check_l95w85_a0a0a0a0a0a0lb(IDiagramElementAccessor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClass();
    }
    return null;
  }
  private static IConnectionEndpointReference check_l95w85_a0c0fc(IConnectionEndpoint_Internal checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEndpointReference();
    }
    return null;
  }
  private static IConnectionEndpointReference check_l95w85_a0d0fc(IConnectionEndpoint_Internal checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEndpointReference();
    }
    return null;
  }
  private static <T> T as_l95w85_a0a0a0a0b0g0c0a0c0v(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_l95w85_a0a0d0a0d0v(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept NodeAttribute$x2 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x2eb1ad060897da54L, "jetbrains.mps.lang.core.structure.NodeAttribute");
  }
}

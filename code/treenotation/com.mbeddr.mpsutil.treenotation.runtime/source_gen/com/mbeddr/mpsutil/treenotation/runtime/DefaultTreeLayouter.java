package com.mbeddr.mpsutil.treenotation.runtime;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import java.awt.Graphics2D;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.awt.RenderingHints;
import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.awt.BasicStroke;
import java.awt.Shape;
import java.awt.geom.Point2D;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.awt.geom.PathIterator;

public class DefaultTreeLayouter extends AbstractTreeLayouter {
  public static final TreeLayoutType TYPE = new TreeLayoutType() {
    public ITreeLayouter createLayouter(TreeCell cell) {
      return new DefaultTreeLayouter(cell);
    }
  };

  public DefaultTreeLayouter(TreeCell treeCell) {
    super(treeCell);
  }

  @Override
  public void layout() {
    layoutOnePass();
  }

  public void layoutOnePass() {
    TreeCell tree = myTreeCell;

    int originalX = tree.getX();
    int originalY = tree.getY();

    final boolean transposed = tree.isLeftToRight();
    int levelSpacing = getLevelSpacing();
    int nodeSpacing = tree.getStyle().get(NODE_SPACING);
    IBounds treeBounds = getBounds(tree, transposed);

    EditorCell rootCell = tree.getTreeRoot();
    IBounds rootBounds = getBounds(rootCell, transposed);

    List<EditorCell> childCells = Sequence.fromIterable(tree.getTreeChildren()).toList();
    List<IBounds> childrenBounds = ListSequence.fromList(childCells).select((it) -> getBounds(it, transposed)).toList();
    List<Button> insertButtons = tree.getInsertButtons();
    List<IBounds> insertButtonsBounds = ListSequence.fromList(insertButtons).select((it) -> getBounds(it, transposed)).toList();

    rootCell.relayout();
    ListSequence.fromList(childCells).visitAll((it) -> it.relayout());
    ListSequence.fromList(insertButtons).visitAll((it) -> it.relayout());
    ensureSpaceForButtons(childrenBounds, nodeSpacing);

    int childrenY = treeBounds.getY() + rootBounds.getHeight() + levelSpacing;
    int childrenWidth = placeChildren(childrenBounds, treeBounds.getX(), childrenY, nodeSpacing, true);
    int treeWidth = Math.max(childrenWidth, rootBounds.getWidth());

    placeChildren(childrenBounds, treeBounds.getX() + (treeWidth - childrenWidth) / 2, childrenY, nodeSpacing, false);
    ListSequence.fromList(childCells).visitAll((it) -> it.relayout());

    rootBounds.moveTo(treeBounds.getX() + (treeWidth - rootBounds.getWidth()) / 2, treeBounds.getY());
    rootCell.relayout();

    layoutDeleteButtons(childrenBounds, tree, transposed);
    layoutInsertButtons(insertButtonsBounds, rootBounds, childrenBounds, nodeSpacing, insertButtons, childrenY, transposed);
    layoutFoldButton(tree.getFoldButton(), rootBounds, transposed);

    layoutIntermediateCells(tree, treeBounds, transposed, childrenBounds);
    adjustToChildren(treeBounds, Sequence.fromIterable(((Iterable<EditorCell>) tree)).select((it) -> getBounds(it, transposed)), treeBounds.getX(), treeBounds.getY());
  }

  protected void ensureSpaceForButtons(List<IBounds> childrenBounds, int nodeSpacing) {
    int overlapInsertButtonWithChildCell = (Button.BUTTON_SIZE - nodeSpacing + 1) / 2;
    for (int i = 0; i < ListSequence.fromList(childrenBounds).count(); i++) {
      IBounds childBounds = ListSequence.fromList(childrenBounds).getElement(i);
      boolean isFirst = i == 0;
      boolean isLast = i == ListSequence.fromList(childrenBounds).count() - 1;

      // there must be at least space for the insert and delete buttons
      int childMinWidth;
      if (isFirst && isLast) {
        childMinWidth = Button.BUTTON_SIZE + BUTTON_MARGIN + Button.BUTTON_SIZE + BUTTON_MARGIN + Button.BUTTON_SIZE;
      } else if (isFirst || isLast) {
        childMinWidth = Button.BUTTON_SIZE + BUTTON_MARGIN + Button.BUTTON_SIZE + BUTTON_MARGIN + overlapInsertButtonWithChildCell;
      } else {
        childMinWidth = overlapInsertButtonWithChildCell + BUTTON_MARGIN + Button.BUTTON_SIZE + BUTTON_MARGIN + overlapInsertButtonWithChildCell;
      }

      int margin = childMinWidth - childBounds.getWidth();
      if (margin > 0) {
        int leftMargin = 0;
        if (isFirst && isLast) {
          leftMargin = margin / 2;
        } else if (isFirst) {
          // align center of the delete button with the center of the child
          leftMargin = Button.BUTTON_SIZE + BUTTON_MARGIN + Button.BUTTON_HALF_SIZE - childBounds.getWidth() / 2;
          leftMargin = Math.max(0, Math.min(margin, leftMargin));
        } else if (isLast) {
          int rightMargin = Button.BUTTON_SIZE + BUTTON_MARGIN + Button.BUTTON_HALF_SIZE - childBounds.getWidth() / 2;
          rightMargin = Math.max(0, Math.min(margin, rightMargin));
          leftMargin = margin - rightMargin;
        } else {
          leftMargin = margin / 2;
        }
        ListSequence.fromList(childrenBounds).setElement(i, new BoundsWithMargin(childBounds, leftMargin, margin - leftMargin, 0, 0));
      }
    }
  }

  protected void layoutDeleteButtons(List<IBounds> childrenBounds, TreeCell tree, boolean transposed) {

    // delete buttons are placed above the child

    {
      Iterator<IBounds> childBounds_it = ListSequence.fromList(childrenBounds).iterator();
      Iterator<Button> deleteButton_it = ListSequence.fromList(tree.getDeleteButtons()).iterator();
      IBounds childBounds_var;
      Button deleteButton_var;
      while (childBounds_it.hasNext() && deleteButton_it.hasNext()) {
        childBounds_var = childBounds_it.next();
        deleteButton_var = deleteButton_it.next();
        IBounds deleteButtonBounds = getBounds(deleteButton_var, transposed);
        deleteButton_var.relayout();
        deleteButtonBounds.moveTo(BoundsExtensions.getCenterX(childBounds_var.withoutMargin()) - deleteButtonBounds.getWidth() / 2, childBounds_var.getY() - deleteButtonBounds.getHeight() - BUTTON_MARGIN);
        deleteButton_var.relayout();
      }
    }
  }

  protected void layoutFoldButton(Button foldButton, IBounds rootBounds, boolean transposed) {

    //  fold buttons are placed bellow the root cell of the node

    if (foldButton != null) {
      foldButton.relayout();
      IBounds foldButtonBounds = getBounds(foldButton, transposed);
      foldButtonBounds.moveTo(BoundsExtensions.getCenterX(rootBounds) - foldButtonBounds.getWidth() / 2, BoundsExtensions.getMaxY(rootBounds) + BUTTON_MARGIN);
      foldButton.relayout();
    }
  }

  protected void layoutInsertButtons(List<IBounds> insertButtonsBounds, IBounds rootBounds, List<IBounds> childrenBounds, int nodeSpacing, List<Button> insertButtons, int childrenY, boolean transposed) {

    if (ListSequence.fromList(insertButtonsBounds).isNotEmpty()) {
      if (ListSequence.fromList(insertButtonsBounds).count() == 1) {
        IBounds button = ListSequence.fromList(insertButtonsBounds).first();
        button.moveTo(BoundsExtensions.getCenterX(rootBounds) - button.getWidth() / 2, BoundsExtensions.getMaxY(rootBounds) + BUTTON_MARGIN);
      } else {
        IBounds firstButton = ListSequence.fromList(insertButtonsBounds).first();
        IBounds lastButton = ListSequence.fromList(insertButtonsBounds).last();
        IBounds firstChild = ListSequence.fromList(childrenBounds).first();
        IBounds lastChild = ListSequence.fromList(childrenBounds).last();
        firstButton.moveTo(firstChild.getX(), childrenY - firstButton.getHeight() - BUTTON_MARGIN);
        lastButton.moveTo(BoundsExtensions.getMaxX(lastChild) - lastButton.getWidth(), childrenY - lastButton.getHeight() - BUTTON_MARGIN);
        if (ListSequence.fromList(insertButtonsBounds).count() > 2) {
          {
            Iterator<IBounds> button_it = ListSequence.fromList(insertButtonsBounds).subListSequence(1, ListSequence.fromList(insertButtonsBounds).count() - 1).iterator();
            Iterator<IBounds> leftChild_it = ListSequence.fromList(childrenBounds).iterator();
            Iterator<IBounds> rightChild_it = ListSequence.fromList(childrenBounds).skip(1).iterator();
            IBounds button_var;
            IBounds leftChild_var;
            IBounds rightChild_var;
            while (button_it.hasNext() && leftChild_it.hasNext() && rightChild_it.hasNext()) {
              button_var = button_it.next();
              leftChild_var = leftChild_it.next();
              rightChild_var = rightChild_it.next();
              button_var.moveTo((BoundsExtensions.getMaxX(leftChild_var) + rightChild_var.getX()) / 2 - button_var.getWidth() / 2, rightChild_var.getY() - button_var.getHeight() - BUTTON_MARGIN);
            }
          }
        }
      }
    }
    ListSequence.fromList(insertButtons).visitAll((it) -> it.relayout());
  }

  protected void layoutIntermediateCells(TreeCell tree, final IBounds treeBounds, final boolean transposed, final Iterable<IBounds> childrenBounds) {
    Sequence.fromIterable(tree.getIntermediateCells()).visitAll((it) -> {
      adjustToChildren(getBounds(it, transposed), childrenBounds, treeBounds.getX(), treeBounds.getY());
      ((EditorCell_Basic) it).unrequestLayout();
    });
  }

  protected int placeChildren(List<IBounds> childrenBounds, final int left, final int childrenY, int nodeSpacing, boolean dryRun) {
    if (ListSequence.fromList(childrenBounds).isEmpty()) {
      // space for insert button
      return Button.BUTTON_SIZE;
    }

    int x = left;
    for (IBounds childBounds : ListSequence.fromList(childrenBounds)) {
      if (!(dryRun)) {
        childBounds.moveTo(x, childrenY);
      }
      x += childBounds.getWidth() + nodeSpacing;
    }
    x -= nodeSpacing;

    return x - left;
  }

  public IBounds getBounds(EditorCell cell, boolean transposed) {
    if (cell == null) {
      return null;
    }
    IBounds bounds = new EditorCellBounds(cell);
    if (transposed) {
      bounds = new TransposedBounds(bounds);
    }
    return bounds;
  }

  protected EditorCell getTreeRoot(EditorCell cell) {
    if (TreeCell.isNonFoldedTreeCell(cell)) {
      return ((TreeCell) cell).getTreeRoot();
    }
    return cell;
  }

  protected void adjustToChildren(IBounds parent, Iterable<IBounds> children, int defaultX, int defaultY) {
    if (parent == null) {
      return;
    }
    if (Sequence.fromIterable(children).isEmpty()) {
      parent.setX(defaultX);
      parent.setY(defaultY);
      parent.setWidth(0);
      parent.setHeight(0);
    } else {
      IBounds first = Sequence.fromIterable(children).first();
      int minX = first.getX();
      int maxX = first.getX() + first.getWidth();
      int minY = first.getY();
      int maxY = first.getY() + first.getHeight();

      for (IBounds child : Sequence.fromIterable(children)) {
        minX = Math.min(minX, child.getX());
        maxX = Math.max(maxX, child.getX() + child.getWidth());
        minY = Math.min(minY, child.getY());
        maxY = Math.max(maxY, child.getY() + child.getHeight());
      }

      parent.setX(minX);
      parent.setY(minY);
      parent.setWidth(maxX - minX);
      parent.setHeight(maxY - minY);
    }
  }

  @Override
  public void paintLines(Graphics2D g) {

    EditorCell rootCell = getTreeRoot();

    Iterable<EditorCell> childCells = getTreeChildren();

    Graphics2D g2 = ((Graphics2D) g.create());
    EditorComponent.turnOnAliasingIfPossible(((Graphics2D) g2));

    g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);

    try {
      List<Line2D> lines = ListSequence.fromList(new ArrayList<Line2D>(Sequence.fromIterable(childCells).count()));
      for (EditorCell child : Sequence.fromIterable(childCells)) {
        g2.setColor(getStyleForChild(child, INCOMING_LINE_COLOR));
        g2.setStroke(new BasicStroke(getStyleForChild(child, INCOMING_LINE_WIDTH)));
        Shape line = createLine(getStartPoint(rootCell), getEndPoint(child));
        g2.draw(line);
        drawChildIncomingShape(g2, child, getLastLine(line));
        ListSequence.fromList(lines).addElement(getFirstLine(line));
      }
      drawOutgoingShape(g2, lines);
    } finally {
      g2.dispose();
    }
  }

  protected Shape createLine(Point2D start, Point2D end) {
    return new Line2D.Double(start, end);
  }

  protected Line2D getFirstLine(Shape shape) {
    final Wrappers._T<Line2D> first = new Wrappers._T<Line2D>(null);
    visitPath(shape, (Line2D segment) -> {
      if (first.value == null) {
        first.value = segment;
      }
    });
    if (first.value == null) {
      throw new RuntimeException("No line segments in " + shape);
    }
    return first.value;
  }

  protected Line2D getLastLine(Shape shape) {
    final Wrappers._T<Line2D> last = new Wrappers._T<Line2D>(null);
    visitPath(shape, (Line2D segment) -> last.value = segment);
    if (last.value == null) {
      throw new RuntimeException("No line segments in " + shape);
    }
    return last.value;
  }

  protected void visitPath(Shape shape, _FunctionTypes._void_P1_E0<? super Line2D> visitor) {
    double[] coords = new double[6];
    PathIterator pathIterator = shape.getPathIterator(null);

    Point2D p_first = null;
    Point2D p0 = null;
    Point2D p1 = null;

    for (PathIterator pi = shape.getPathIterator(null); !(pi.isDone()); pi.next()) {
      int type = pi.currentSegment(coords);
      Point2D point = new Point2D.Double(coords[0], coords[1]);

      switch (type) {
        case PathIterator.SEG_MOVETO:
          p0 = null;
          p1 = point;
          break;
        case PathIterator.SEG_LINETO:
          p0 = p1;
          p1 = point;
          break;
        case PathIterator.SEG_CLOSE:
          p0 = p1;
          p1 = p_first;
          break;
        default:
          throw new RuntimeException("Unsupported segment type: " + type);
      }

      if (p_first == null) {
        p_first = point;
      }

      if (p0 != null && p1 != null) {
        visitor.invoke(new Line2D.Double(p0, p1));
      }
    }
  }
}

package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import org.modelix.model.area.IArea;
import org.modelix.model.area.IAreaReference;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConcept;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.IConceptReference;
import java.util.Objects;
import org.modelix.model.api.INode;
import org.modelix.model.api.INodeReference;
import org.modelix.model.api.IBranch;
import java.util.List;
import java.util.Collections;
import kotlin.jvm.functions.Function0;
import org.modelix.model.area.IAreaListener;

public class TransformationOutputArea implements IArea, IAreaReference {
  private ITransformationEngine engine;

  public TransformationOutputArea(ITransformationEngine engine) {
    this.engine = engine;
  }

  @Override
  public long getLockOrderingPriority() {
    return 0L;
  }

  @Nullable
  @Override
  public IConcept resolveConcept(@NotNull IConceptReference reference) {
    return null;
  }

  @NotNull
  @Override
  public IAreaReference getReference() {
    return this;
  }

  @Nullable
  @Override
  public IArea resolveArea(@NotNull IAreaReference reference) {
    return (Objects.equals(reference, getReference()) ? this : null);
  }

  @NotNull
  @Override
  public INode getRoot() {
    throw new UnsupportedOperationException();
  }

  @Nullable
  @Override
  public INode resolveNode(@NotNull INodeReference reference) {
    return resolveOriginalNode(reference);
  }

  @Nullable
  @Override
  public INode resolveOriginalNode(@NotNull INodeReference reference) {
    if (reference instanceof OutputNodeReferenceAsNode) {
      return ((OutputNodeReferenceAsNode) reference);
    }
    return null;
  }

  @Nullable
  @Override
  public IBranch resolveBranch(@NotNull String branch) {
    return null;
  }

  @NotNull
  @Override
  public List<IArea> collectAreas() {
    return Collections.<IArea>singletonList(this);
  }

  @Override
  public <T> T executeRead(@NotNull Function0<? extends T> f) {
    return f.invoke();
  }

  @Override
  public <T> T executeWrite(@NotNull Function0<? extends T> f) {
    return f.invoke();
  }

  @Override
  public boolean canRead() {
    return true;
  }

  @Override
  public boolean canWrite() {
    return true;
  }

  @Override
  public void addListener(@NotNull IAreaListener listener) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeListener(@NotNull IAreaListener listener) {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    TransformationOutputArea that = (TransformationOutputArea) o;
    if ((engine != null ? !(engine.equals(that.engine)) : that.engine != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((engine != null ? ((Object) engine).hashCode() : 0));
    return result;
  }
}

package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuLookup;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Objects;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.CompositeTransformationMenuLookup;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.lang.editor.menus.MenuPart;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import java.util.Collection;
import jetbrains.mps.openapi.editor.descriptor.TransformationMenu;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Collections;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsMenuLocations;

public abstract class SideTransformationHolderCell extends EditorCell_Constant {

  /**
   * Is executed on the collection cell that contains instances of this class.
   * These instances are removed and the transformation menu is attached to one of the remaining cells.
   */
  public static void processParentCollection(final EditorCell_Collection parentCollection) {
    _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuLookup> removeOldLookups = (TransformationMenuLookup l) -> {
      Lookup lookup = as_h3h13r_a0a0a0a0a1(l, Lookup.class);
      SNode holderCellNode = check_h3h13r_a0b0a0a0b(check_h3h13r_a0a1a0a0a1(lookup));
      SNode parentCollectionNode = parentCollection.getSNode();
      return !(Objects.equals(holderCellNode, parentCollectionNode) && Objects.equals(parentCollection.getCellId(), lookup.getSourceCellId()));
    };
    List<EditorCell> children = ListSequence.fromListWithValues(new ArrayList<EditorCell>(), parentCollection);
    CompositeTransformationMenuLookup.filter(parentCollection, removeOldLookups);
    for (EditorCell child : ListSequence.fromList(children)) {
      CompositeTransformationMenuLookup.filter(child, removeOldLookups);
    }
    for (SideTransformationHolderCell holderCell : ListSequence.fromList(children).ofType(SideTransformationHolderCell.class)) {
      int holderCellIndex = ListSequence.fromList(children).indexOf(holderCell);
      Iterable<EditorCell> prevSiblings = ListSequence.fromList(children).take(holderCellIndex);
      Iterable<EditorCell> nextSiblings = ListSequence.fromList(children).skip(holderCellIndex + 1);
      nextSiblings = Sequence.fromIterable(nextSiblings).where((it) -> !(ignoreSibling(it)));
      prevSiblings = Sequence.fromIterable(prevSiblings).where((it) -> !(ignoreSibling(it)));
      if (Sequence.fromIterable(nextSiblings).isEmpty()) {
        CompositeTransformationMenuLookup.add(parentCollection, holderCell.createLookup(false, parentCollection.getCellId()));
        continue;
      }
      if (Sequence.fromIterable(prevSiblings).isEmpty()) {
        CompositeTransformationMenuLookup.add(parentCollection, holderCell.createLookup(true, parentCollection.getCellId()));
        continue;
      }
      if (Sequence.fromIterable(prevSiblings).isNotEmpty()) {
        CompositeTransformationMenuLookup.add(Sequence.fromIterable(prevSiblings).last(), holderCell.createLookup(false, parentCollection.getCellId()));
        continue;
      }
      if (Sequence.fromIterable(nextSiblings).isNotEmpty()) {
        CompositeTransformationMenuLookup.add(Sequence.fromIterable(nextSiblings).first(), holderCell.createLookup(true, parentCollection.getCellId()));
        continue;
      }
    }
    ListSequence.fromList(children).ofType(SideTransformationHolderCell.class).visitAll((it) -> parentCollection.removeCell(it));
  }

  private static boolean ignoreSibling(EditorCell cell) {
    return !(GrammarCellsUtil.isSyntaxCell(cell));
  }

  private SNodeReference trace;
  private String description;

  public SideTransformationHolderCell(@NotNull EditorContext editorContext, SNode node, SNodeReference trace, String description) {
    super(editorContext, node, "SIDE_TRANSFORMATION", false);
    this.trace = trace;
    this.description = (description != null ? description : "side transformation cell");
  }

  public Lookup createLookup(boolean before, String sourceCellId) {
    return new Lookup(before, sourceCellId);
  }

  @Override
  public String toString() {
    return description;
  }

  public abstract List<MenuPart<TransformationMenuItem, TransformationMenuContext>> createMenuParts();

  public class Lookup implements TransformationMenuLookup {
    private boolean before;
    private String sourceCellId;

    public Lookup(boolean before, String sourceCellId) {
      this.before = before;
      this.sourceCellId = sourceCellId;
    }
    @Override
    public String toString() {
      return description + ((before ? " (before)" : " (after)"));
    }
    public String getSourceCellId() {
      return this.sourceCellId;
    }
    public SideTransformationHolderCell getHolderCell() {
      return SideTransformationHolderCell.this;
    }
    @NotNull
    @Override
    public Collection<TransformationMenu> lookup(@NotNull Collection<SLanguage> p1, @NotNull String p2) {
      return Collections.<TransformationMenu>singleton(new TransformationMenu() {
        @NotNull
        @Override
        public List<TransformationMenuItem> createMenuItems(@NotNull final TransformationMenuContext context) {
          if (!(isApplicableToLocation(context.getMenuLocation()))) {
            return Collections.<TransformationMenuItem>emptyList();
          }
          context.getEditorMenuTrace().pushTraceInfo();
          try {
            context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase(toString(), trace));
            return ListSequence.fromList(createMenuParts()).translate((it) -> it.createItems(context.withNode(getSNode()))).toList();
          } finally {
            context.getEditorMenuTrace().popTraceInfo();
          }
        }

        @Override
        public boolean isContribution() {
          return true;
        }

        @Override
        public boolean isApplicableToLocation(String location) {
          return Objects.equals(location, ((before ? GrammarCellsMenuLocations.BEFORE : GrammarCellsMenuLocations.AFTER)));
        }
      });
    }

  }
  private static SNode check_h3h13r_a0b0a0a0b(SideTransformationHolderCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSNode();
    }
    return null;
  }
  private static SideTransformationHolderCell check_h3h13r_a0a1a0a0a1(Lookup checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getHolderCell();
    }
    return null;
  }
  private static <T> T as_h3h13r_a0a0a0a0a1(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

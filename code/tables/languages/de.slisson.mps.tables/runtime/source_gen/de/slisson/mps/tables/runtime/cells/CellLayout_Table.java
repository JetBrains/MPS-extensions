package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellLayout.AbstractCellLayout;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import de.slisson.mps.tables.runtime.gridmodel.Grid;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import de.slisson.mps.tables.runtime.gridmodel.IGridElement;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellGridLeaf;
import java.awt.Font;
import jetbrains.mps.nodeEditor.EditorSettings;
import java.awt.FontMetrics;
import java.awt.Toolkit;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.style.DefaultBaseLine;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;
import java.lang.reflect.Field;
import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;

public class CellLayout_Table extends AbstractCellLayout implements CellLayout {

  private EditorContext myContext;
  private SNode mySNode;
  private int ascent = 0;
  private int descent = 0;

  public CellLayout_Table(@NotNull EditorContext context, @NotNull SNode snode) {
    myContext = context;
    mySNode = snode;
  }

  public void doLayout(EditorCell_Collection editorCells) {
    Grid grid = getGrid(editorCells);

    setGridCellGaps(grid);
    layoutGrid(grid, editorCells.getX(), editorCells.getY(), ((TableEditor) editorCells));

    TableEditor tableEditor = (TableEditor) editorCells;
    for (PartialTableEditor partialTable : ListSequence.fromList(((List<PartialTableEditor>) tableEditor.getDescendantPartialTables())).reversedList()) {
      partialTable.relayout();
      partialTable.updateBounds();
    }
  }

  private void layoutGrid(Grid grid, int tableX, int tableY, TableEditor table) {
    int[] columnWidth = new int[grid.getSizeX()];
    int[] rowHeight = new int[grid.getSizeY()];

    // layout all child cells
    for (int x = 0; x < grid.getSizeX(); x++) {
      for (int y = 0; y < grid.getSizeY(); y++) {
        IGridElement element = grid.getElement(x, y);
        if (element instanceof EditorCellGridLeaf) {
          ((EditorCellGridLeaf) element).getEditorCell().relayout();
        }
      }
    }

    // non spanning cells
    for (int x = 0; x < grid.getSizeX(); x++) {
      for (int y = 0; y < grid.getSizeY(); y++) {
        IGridElement element = grid.getElement(x, y);
        if (element.getSpanX() == 1) {
          columnWidth[x] = Math.max(columnWidth[x], element.getMinWidth());
        }
        if (element.getSpanY() == 1) {
          rowHeight[y] = Math.max(rowHeight[y], element.getMinHeight());
        }
      }
    }

    // spanning cells
    for (int x = 0; x < grid.getSizeX(); x++) {
      for (int y = 0; y < grid.getSizeY(); y++) {
        IGridElement element = grid.getElement(x, y);
        if (element.getSpanX() > 1) {
          int sum = 0;
          for (int i = 0; i < element.getSpanX(); i++) {
            sum += columnWidth[x + i];
          }
          int difference = element.getMinWidth() - sum;
          if (difference > 0) {
            int spacePerColumn = difference / element.getSpanX();
            for (int i = 0; i < element.getSpanX() - 1; i++) {
              columnWidth[x + i] += spacePerColumn;
              difference -= spacePerColumn;
            }
            columnWidth[x + element.getSpanX() - 1] += difference;
          }
        }

        if (element.getSpanY() > 1) {
          int sum = 0;
          for (int i = 0; i < element.getSpanY(); i++) {
            sum += rowHeight[y + i];
          }
          int difference = element.getMinHeight() - sum;
          if (difference > 0) {
            int spacePerRow = difference / element.getSpanY();
            for (int i = 0; i < element.getSpanY() - 1; i++) {
              rowHeight[y + i] += spacePerRow;
              difference -= spacePerRow;
            }
            rowHeight[y + element.getSpanY() - 1] += difference;
          }
        }
      }
    }

    int[] positionsX = new int[columnWidth.length + 1];
    int[] positionsY = new int[rowHeight.length + 1];
    positionsX[0] = tableX;
    positionsY[0] = tableY;
    for (int i = 0; i < columnWidth.length; i++) {
      positionsX[i + 1] = positionsX[i] + columnWidth[i];
    }
    for (int i = 0; i < rowHeight.length; i++) {
      positionsY[i + 1] = positionsY[i] + rowHeight[i];
    }

    // layout elements
    int posX = tableX;
    for (int x = 0; x < grid.getSizeX(); x++) {
      int posY = tableY;
      for (int y = 0; y < grid.getSizeY(); y++) {
        IGridElement element = grid.getElement(x, y);
        element.setWidth(columnWidth[x]);
        element.setHeight(rowHeight[y]);
        if (element instanceof EditorCellGridLeaf) {
          EditorCell_GridCell cell = (EditorCell_GridCell) ((EditorCellGridLeaf) element).getEditorCell();
          cell.moveTo(posX, posY);
          cell.relayout();
          cell.setWidth(positionsX[x + element.getSpanX()] - positionsX[x]);
          cell.setHeight(positionsY[y + element.getSpanY()] - positionsY[y]);
        }
        posY += rowHeight[y];
      }
      posX += columnWidth[x];
    }

    // set table dimensions
    int tableWidth = 0;
    int tableHeight = 0;
    for (int i = 0; i < columnWidth.length; i++) {
      tableWidth += columnWidth[i];
    }
    for (int i = 0; i < rowHeight.length; i++) {
      tableHeight += rowHeight[i];
    }
    table.setWidth(tableWidth);
    table.setHeight(tableHeight);
  }

  private void setGridCellGaps(Grid grid) {
    Font f = EditorSettings.getInstance().getDefaultEditorFont();
    FontMetrics m = Toolkit.getDefaultToolkit().getFontMetrics(f);
    int gap = m.charWidth(' ') / 2;

    for (IGridElement element : grid) {
      EditorCell cell = check_xn71x9_a0a0e0m(as_xn71x9_a0a0a0e0m(element, EditorCellGridLeaf.class));
      if (cell == null) {
        continue;
      }
      if (check_xn71x9_a0c0e0m(as_xn71x9_a0a0c0e0m(element, EditorCell_GridCell.class)) instanceof RowEndCell) {
        continue;
      }
      cell.setLeftGap(gap);
      cell.setRightGap(gap);
    }
  }

  private int getBracesIndent(EditorCell cell) {
    return (cell instanceof EditorCell_Collection ? ((EditorCell_Collection) cell).getBracesIndent() : 0);
  }

  private Grid getGrid(EditorCell cell) {
    return ((TableEditor) cell).getGrid();
  }

  @Override
  public int getAscent(EditorCell_Collection editorCells) {
    DefaultBaseLine bL = editorCells.getStyle().get(StyleAttributes.DEFAULT_BASE_LINE);
    int result = 0;
    Grid grid = getGrid(editorCells);
    if (grid == null) {
      throw new NullPointerException("myGrid is null");
    }
    for (int gridY = 0; gridY < grid.getSizeY(); gridY++) {
      result = 0;
      for (int gridX = 0; gridX < grid.getSizeX(); gridX++) {
        EditorCell cell = check_xn71x9_a0a0b0e0s(as_xn71x9_a0a0a0b0e0s(grid.getElement(gridX, gridY), EditorCellGridLeaf.class));
        if (cell == null) {
          continue;
        }
        result = Math.max(result, cell.getAscent());
      }
      if (result > 0) {
        break;
      }
    }

    switch (bL) {
      case FIRST:
        // default behavior
        return result;
      case CENTER:
        return Math.max(result, editorCells.getHeight() / 2);
      case LAST:
        return Math.max(result, editorCells.getHeight());
      default:
    }
    return 0;
  }

  public TextBuilder doLayoutText(Iterable<EditorCell> editorCells) {
    TextBuilder result = new TextBuilderImpl();
    for (EditorCell editorCell : editorCells) {
      result = result.appendToTheBottom(editorCell.renderText());
    }
    return result;
  }

  public static void setParent(EditorCell child, EditorCell_Collection parent) {
    try {
      Field parentField = EditorCell_Basic.class.getDeclaredField("myParent");
      parentField.setAccessible(true);
      parentField.set(child, parent);
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }
  }

  private static EditorCell check_xn71x9_a0a0e0m(EditorCellGridLeaf checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static EditorCell check_xn71x9_a0c0e0m(EditorCell_GridCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.firstCell();
    }
    return null;
  }
  private static EditorCell check_xn71x9_a0a0b0e0s(EditorCellGridLeaf checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static <T> T as_xn71x9_a0a0a0e0m(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_xn71x9_a0a0c0e0m(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_xn71x9_a0a0a0b0e0s(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

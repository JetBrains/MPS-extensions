package de.q60.mps.shadowmodels.runtime.smodel;

/*Generated by MPS */

import de.q60.mps.shadowmodels.runtime.engine.TransformationEngine;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import de.q60.mps.polymorphicfunctions.runtime.IPFContext;
import org.modelix.model.area.IArea;
import de.q60.mps.shadowmodels.runtime.engine.TransformationOutputArea;
import org.jetbrains.annotations.NotNull;
import kotlin.jvm.functions.Function0;
import de.q60.mps.shadowmodels.runtime.engine.ISubgraphStage;
import de.q60.mps.shadowmodels.runtime.engine.SubstepStageReference;
import java.util.List;
import de.q60.mps.shadowmodels.runtime.engine.IContainmentTarget;
import de.q60.mps.shadowmodels.runtime.engine.ITransformationResult;
import de.q60.mps.shadowmodels.runtime.engine.IStageReference;
import de.q60.mps.shadowmodels.runtime.engine.IUniqueContainmentTarget;
import de.q60.mps.shadowmodels.runtime.engine.TransformationCall;

public class STransformationEngine extends TransformationEngine {

  private NodeToSNodeAdapter.InstancesCache nodeInstancesCache = new NodeToSNodeAdapter.InstancesCache();

  public STransformationEngine(IPFContext transformationFunctions) {
    super(transformationFunctions);
  }

  public STransformationEngine(IPFContext transformationFunctions, boolean eager) {
    super(transformationFunctions, eager);
  }


  @Override
  public IArea getArea() {
    return new TransformationOutputArea(this) {
      @Override
      public <T> T executeRead(@NotNull final Function0<? extends T> f) {
        return NodeToSNodeAdapter.computeWithCache(nodeInstancesCache, () -> super_executeRead(f));
      }
      private <T> T super_executeRead(Function0<? extends T> f) {
        return super.executeRead(f);
      }
      @Override
      public <T> T executeWrite(@NotNull final Function0<? extends T> f) {
        return NodeToSNodeAdapter.computeWithCache(nodeInstancesCache, () -> super_executeWrite(f));
      }
      private <T> T super_executeWrite(Function0<? extends T> f) {
        return super.executeWrite(f);
      }
    };
  }

  @Override
  protected ISubgraphStage doComputeStage(final SubstepStageReference stageRef, final List<IContainmentTarget> roots, final SubstepStageReference previousStageRef) {
    return NodeToSNodeAdapter.computeWithCache(nodeInstancesCache, () -> super_doComputeStage(stageRef, roots, previousStageRef));
  }
  private ISubgraphStage super_doComputeStage(SubstepStageReference stageRef, List<IContainmentTarget> roots, SubstepStageReference previousStageRef) {
    return super.doComputeStage(stageRef, roots, previousStageRef);
  }

  @Override
  protected ITransformationResult doExecute(final IStageReference stage, final IUniqueContainmentTarget<TransformationCall> call) {
    return NodeToSNodeAdapter.computeWithCache(nodeInstancesCache, () -> super_doExecute(call, stage));
  }
  private ITransformationResult super_doExecute(IUniqueContainmentTarget<TransformationCall> call, IStageReference stage) {
    return super.doExecute(stage, call);
  }

  @Override
  protected ISubgraphStage doFindStage(final IStageReference expectedStageRef) {
    return NodeToSNodeAdapter.computeWithCache(nodeInstancesCache, () -> super_doFindStage(expectedStageRef));
  }
  private ISubgraphStage super_doFindStage(IStageReference expectedStageRef) {
    return super.doFindStage(expectedStageRef);
  }
}

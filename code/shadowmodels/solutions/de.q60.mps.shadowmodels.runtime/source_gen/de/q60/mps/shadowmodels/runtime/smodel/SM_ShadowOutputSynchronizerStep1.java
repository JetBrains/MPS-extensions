package de.q60.mps.shadowmodels.runtime.smodel;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.extapi.module.SRepositoryExt;
import de.q60.mps.incremental.runtime.IncrementalEngine;
import org.modelix.model.api.IBranch;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PBranch;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_IncrementalIndex;
import org.modelix.model.api.INode;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_UserObjectIndex;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_ReverseReferences;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.Nullable;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_Transaction;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.q60.mps.shadowmodels.runtime.engine.DependencyTrackingNode;
import java.util.Objects;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PTree;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeAdapter;
import org.jetbrains.mps.openapi.model.SNode;
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter;
import org.modelix.model.api.IWriteTransaction;
import org.modelix.model.api.IProperty;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.modelix.model.api.IReferenceLink;
import org.jetbrains.mps.openapi.model.SNodeReference;
import de.q60.mps.shadowmodels.runtime.concurrentrepo.SNodeLoader;
import org.modelix.model.mpsadapters.mps.SNodeReferenceAdapter;
import org.modelix.model.api.IChildLink;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeIdMissingException;
import java.util.List;
import java.util.ArrayList;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_WriteTransaction;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.modelix.model.api.INodeReference;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class SM_ShadowOutputSynchronizerStep1 {
  private static final Logger LOG = Logger.getLogger(SM_ShadowOutputSynchronizerStep1.class);
  private static final String INPUT_NODE_KEY = SM_ShadowOutputSynchronizerStep1.class.getName() + ".INPUT";
  private static final String DETACHED_ROLE_NAME = "detached";
  private static final String REPOSITORY_ROLE_NAME = "repository";

  private SRepositoryExt repository;
  private IncrementalEngine incremental;
  private IBranch repoMirrorBranch;
  private final SM_PBranch outputBranch = new SM_PBranch();
  private SM_IncrementalIndex<INode> inputNodeIndex = new SM_UserObjectIndex<INode>(INPUT_NODE_KEY);
  private SM_ReverseReferences reverseReferences = new SM_ReverseReferences();

  public SM_ShadowOutputSynchronizerStep1(IncrementalEngine incremental, SRepository repository, SM_PBranch repoMirrorBranch) {
    this.repository = (SRepositoryExt) repository;
    this.incremental = incremental;
    this.repoMirrorBranch = repoMirrorBranch;
  }

  public IBranch getOutputBranch() {
    return outputBranch;
  }

  public void dispose() {
  }

  @Nullable
  public INode getInputNode(final long outputNode) {
    return outputBranch.computeRead(() -> {
      SM_Transaction t = outputBranch.getTransaction();
      return (t.containsNode(outputNode) ? (INode) t.getUserObject(outputNode, INPUT_NODE_KEY) : null);
    });
  }

  public Long getOutputNode(INode inputNode) {
    inputNodeIndex = inputNodeIndex.update(outputBranch.getTransaction().getPTree());
    Iterable<Long> outputNodes = inputNodeIndex.get(inputNode);
    if (Sequence.fromIterable(outputNodes).count() > 1) {
      throw new RuntimeException("Multiple output nodes found for " + inputNode);
    }
    return Sequence.fromIterable(outputNodes).first();
  }

  public INode getEmptyOutput(final INode input) {
    DependencyTrackingNode.checkHasTracking(input);

    Long outputNode = getOutputNode(input);
    if (outputNode != null && !(Objects.equals(outputBranch.getTransaction().getConcept(outputNode), input.getConcept()))) {
      outputBranch.getWriteTransaction().setUserObject(outputNode, INPUT_NODE_KEY, null);
      outputNode = null;
    }
    if (outputNode == null) {
      outputNode = outputBranch.getWriteTransaction().addNewChild(SM_PTree.ROOT_ID, DETACHED_ROLE_NAME, -1, input.getConcept());
      outputBranch.getWriteTransaction().setUserObject(outputNode, INPUT_NODE_KEY, input);
    }

    return new SM_PNodeAdapter(outputNode, outputBranch);
  }

  public void updateRepository(SNode repositorySpec) {
    INode outputRepository = this.getOutput(DependencyTrackingNode.wrap(SNodeToNodeAdapter.wrap(repositorySpec)));
    long outputId = ((SM_PNodeAdapter) outputRepository).getNodeId();
    IWriteTransaction t = this.getOutputBranch().getWriteTransaction();
    if (!(Objects.equals(t.getRole(outputId), REPOSITORY_ROLE_NAME))) {
      t.moveChild(SM_PTree.ROOT_ID, REPOSITORY_ROLE_NAME, -1, outputId);
    }
    for (Long detached : Sequence.fromIterable(t.getChildren(SM_PTree.ROOT_ID, DETACHED_ROLE_NAME))) {
      t.deleteNode(detached);
    }
  }

  public INode getOutput(final INode input) {
    DependencyTrackingNode.checkHasTracking(input);
    return incremental.evaluate(new CK_SM_ShadowOutputSynchronizerStep1_getOutput(input.getReference()), () -> {
      INode output = getEmptyOutput(input);
      return synchronizeNode(input, output);
    });
  }

  public INode synchronizeNode(INode input, INode output) {
    try {
      for (IProperty property : ListSequence.fromList(input.getConcept().getAllProperties())) {
        String newVal = input.getPropertyValue(property.getName());
        if (!(Objects.equals(output.getPropertyValue(property.getName()), newVal))) {
          output.setPropertyValue(property.getName(), newVal);
        }
      }

      for (IReferenceLink link : ListSequence.fromList(input.getConcept().getAllReferenceLinks())) {
        INode target = input.getReferenceTarget(link.getName());
        if (target == null) {
          if (output.getReferenceTarget(link.getName()) != null) {
            output.setReferenceTarget(link.getName(), (INode) null);
          }
        } else {
          if (DependencyTrackingNode.unwrap(target) instanceof SM_PNodeAdapter && ((SM_PNodeAdapter) DependencyTrackingNode.unwrap(target)).getBranch() == repoMirrorBranch) {
            SNodeReference targetRef = (SNodeReference) ((SM_PNodeAdapter) DependencyTrackingNode.unwrap(target)).getUserObject(SNodeLoader.SOURCE_NODE_REF_KEY);
            ((SM_PNodeAdapter) output).setReferenceTarget(link.getName(), new SNodeReferenceAdapter(targetRef));
          } else {
            INode outputTarget = getEmptyOutput(target);
            if (!(Objects.equals(outputTarget, output.getReferenceTarget(link.getName())))) {
              output.setReferenceTarget(link.getName(), outputTarget);
            }
          }
        }
      }

      for (IChildLink link : ListSequence.fromList(input.getConcept().getAllChildLinks())) {
        synchronizeChildren(input, output, link);
      }

      return output;
    } catch (SM_PNodeIdMissingException ex) {
      throw ex;
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("", ex);
      }
      return createErrorPlaceholder(ex);
    }
  }

  protected void synchronizeChildren(INode inputParent, final INode outputParent, final IChildLink link) {
    List<INode> inputChildren = ListSequence.fromListWithValues(new ArrayList<INode>(), inputParent.getChildren(link.getName()));
    List<INode> expectedOutputChildren = ListSequence.fromList(inputChildren).select((it) -> getOutput(it)).toList();
    List<INode> existingOutputChildren = ListSequence.fromListWithValues(new ArrayList<INode>(), outputParent.getChildren(link.getName()));

    final SM_WriteTransaction t = outputBranch.getWriteTransaction();
    if (!(Objects.equals(existingOutputChildren, expectedOutputChildren))) {
      ListSequence.fromList(existingOutputChildren).visitAll((it) -> {
        long childId = ((SM_PNodeAdapter) it).getNodeId();
        t.moveChild(SM_PTree.ROOT_ID, DETACHED_ROLE_NAME, -1, childId);
      });
      ListSequence.fromList(expectedOutputChildren).visitAll((it) -> {
        long childId = ((SM_PNodeAdapter) it).getNodeId();
        long parentId = ((SM_PNodeAdapter) outputParent).getNodeId();

        if (t.getParent(childId) != SM_PTree.ROOT_ID) {
          t.moveChild(SM_PTree.ROOT_ID, DETACHED_ROLE_NAME, -1, childId);
        }

        t.moveChild(parentId, link.getName(), -1, childId);
      });
    }
  }

  protected INode createErrorPlaceholder(Exception ex) {
    INode placeholder = new SM_PNodeAdapter(outputBranch.getWriteTransaction().addNewChild(SM_PTree.ROOT_ID, DETACHED_ROLE_NAME, -1, SConceptAdapter.wrap(CONCEPTS.ErrorPlaceholder$Uv)), outputBranch);
    SNode placeholderAdapter = SNodeOperations.cast(NodeToSNodeAdapter.wrap(placeholder), CONCEPTS.ErrorPlaceholder$Uv);
    SPropertyOperations.assign(placeholderAdapter, PROPS.message$clQk, ex.getMessage());

    StringWriter writer = new StringWriter();
    ex.printStackTrace(new PrintWriter(writer));
    SPropertyOperations.assign(placeholderAdapter, PROPS.stacktrace$nbHX, writer.toString());

    return placeholder;
  }

  public static class OutputKey {
    private INodeReference input;
    public OutputKey(@NotNull INodeReference input) {
      this.input = input;
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      OutputKey that = (OutputKey) o;
      if (!(input.equals(that.input))) {
        return false;
      }

      return true;
    }
    @Override
    public int hashCode() {
      return input.hashCode();
    }

    @Override
    public String toString() {
      return "OutputKey{" + input + "}";
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ErrorPlaceholder$Uv = MetaAdapterFactory.getConcept(0xbf7bc3bb11d42e4L, 0xb16093d72af96397L, 0x765fd2d37142cde7L, "de.q60.mps.shadowmodels.runtimelang.structure.ErrorPlaceholder");
  }

  private static final class PROPS {
    /*package*/ static final SProperty message$clQk = MetaAdapterFactory.getProperty(0xbf7bc3bb11d42e4L, 0xb16093d72af96397L, 0x765fd2d37142cde7L, 0x765fd2d37142cde8L, "message");
    /*package*/ static final SProperty stacktrace$nbHX = MetaAdapterFactory.getProperty(0xbf7bc3bb11d42e4L, 0xb16093d72af96397L, 0x765fd2d37142cde7L, 0x765fd2d371498509L, "stacktrace");
  }
}

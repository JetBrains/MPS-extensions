package de.slisson.mps.richtext.runtime.vcs;

/*Generated by MPS */

import de.slisson.mps.editor.multiline.cells.MultilineCellBackgroundPainter;
import jetbrains.mps.logging.Logger;
import de.slisson.mps.editor.multiline.cells.EditorCell_Multiline;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.module.SModule;
import name.fraser.neil.plaintext.diff_match_patch;
import java.util.LinkedList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import de.slisson.mps.richtext.util.RichtextUtil;
import java.util.List;
import jetbrains.mps.openapi.editor.message.SimpleEditorMessage;
import java.lang.reflect.Field;
import java.util.ArrayList;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.slisson.mps.richtext.behavior.Word__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class DiffPainter implements MultilineCellBackgroundPainter {
  private static final Logger LOG = Logger.getLogger(DiffPainter.class);
  private static String SEPARATOR = "#ยง$%&/()=?+*-_:.,;<|>";
  public void paint(EditorCell_Multiline cell, Graphics g, ParentSettings parentSettings) {
    try {
      paintUnsafe(cell, g, parentSettings);
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("", ex);
      }
    }
  }
  public void paintUnsafe(final EditorCell_Multiline cell, final Graphics g, ParentSettings parentSettings) throws Exception {
    if (!(isInDiffView(cell))) {
      return;
    }

    cell.getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
      EditorCell richtextCell = findParentRichtextCell(cell);
      if (richtextCell == null) {
        return;
      }

      final SModel oldModel = getModel(richtextCell, false);
      if (oldModel == null) {
        return;
      }
      final SModel newModel = getModel(richtextCell, true);
      if (newModel == null) {
        return;
      }


      SNode myNode = SNodeOperations.cast(richtextCell.getSNode(), CONCEPTS.Text$bD);
      SModel myModel = SNodeOperations.getModel(myNode);
      if (myModel == null) {
        return;
      }
      SModule myModule = myModel.getModule();
      String myModuleClassName = myModule.getClass().getName();
      boolean iAmOld = "jetbrains.mps.vcs.diff.ui.common.DiffTemporaryModule".equals(myModuleClassName);
      boolean iAmNew = !(iAmOld);
      SNode oldNode = SNodeOperations.cast(((SNode) oldModel.getNode(myNode.getNodeId())), CONCEPTS.Text$bD);
      SNode newNode = SNodeOperations.cast(((SNode) newModel.getNode(myNode.getNodeId())), CONCEPTS.Text$bD);
      String myText = richtextToDiffText(myNode);
      if (iAmNew && (oldNode != null)) {
        String oldText = richtextToDiffText(oldNode);

        diff_match_patch differ = new diff_match_patch();
        LinkedList<diff_match_patch.Diff> diffs = differ.diff_main(oldText, myText);
        differ.diff_cleanupSemantic(diffs);

        for (SNode wordChild : ListSequence.fromList(SLinkOperations.getChildren(myNode, LINKS.words$C8QZ)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.Word$5r))) {
          EditorCell_Multiline wordChildCell = as_ely5eb_a0a0a6a91a0a0c0d(richtextCell.getEditorComponent().findNodeCell(wordChild), EditorCell_Multiline.class);
          if (wordChildCell != cell) {
            continue;
          }

          StringBuilder oldWordText = new StringBuilder();
          boolean startFound = false;
          boolean endFound = false;
          String key = SEPARATOR + wordChild.getNodeId().toString() + SEPARATOR;
          for (diff_match_patch.Diff diff : ListSequence.fromList(diffs)) {
            String diffText = diff.text;

            if (!(startFound)) {
              if (diff.operation == diff_match_patch.Operation.EQUAL) {
                if (diffText.contains(key)) {
                  diffText = RichtextUtil.substringAfter(diffText, key);
                  startFound = true;
                }
              } else if (diff.operation == diff_match_patch.Operation.INSERT) {
                if (diffText.contains(key)) {
                  startFound = true;
                  continue;
                }
              }
            }

            if (startFound) {
              if (diff.operation == diff_match_patch.Operation.EQUAL || diff.operation == diff_match_patch.Operation.INSERT) {
                if (diffText.contains(SEPARATOR)) {
                  diffText = RichtextUtil.substringBefore(diffText, SEPARATOR);
                  endFound = true;
                }
              }
              if (diff.operation == diff_match_patch.Operation.EQUAL || diff.operation == diff_match_patch.Operation.DELETE) {
                oldWordText.append(diffText);
              }
              if (endFound) {
                break;
              }
            }
          }
          cell.paintDiff(g, oldWordText.toString(), cell.getText(), false);
        }
      }

      if (iAmOld && (newNode != null)) {
        String newText = richtextToDiffText(newNode);

        diff_match_patch differ = new diff_match_patch();
        LinkedList<diff_match_patch.Diff> diffs = differ.diff_main(myText, newText);
        differ.diff_cleanupSemantic(diffs);

        for (SNode wordChild : ListSequence.fromList(SLinkOperations.getChildren(myNode, LINKS.words$C8QZ)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.Word$5r))) {
          EditorCell_Multiline wordChildCell = as_ely5eb_a0a0a6a12a0a0c0d(richtextCell.getEditorComponent().findNodeCell(wordChild), EditorCell_Multiline.class);
          if (wordChildCell != cell) {
            continue;
          }

          StringBuilder newWordText = new StringBuilder();
          boolean startFound = false;
          boolean endFound = false;
          String key = SEPARATOR + wordChild.getNodeId().toString() + SEPARATOR;
          for (diff_match_patch.Diff diff : ListSequence.fromList(diffs)) {
            String diffText = diff.text;

            if (!(startFound)) {
              if (diff.operation == diff_match_patch.Operation.EQUAL) {
                if (diffText.contains(key)) {
                  diffText = RichtextUtil.substringAfter(diffText, key);
                  startFound = true;
                }
              } else if (diff.operation == diff_match_patch.Operation.DELETE) {
                if (diffText.contains(key)) {
                  startFound = true;
                  continue;
                }
              }
            }

            if (startFound) {
              if (diff.operation == diff_match_patch.Operation.EQUAL || diff.operation == diff_match_patch.Operation.DELETE) {
                if (diffText.contains(SEPARATOR)) {
                  diffText = RichtextUtil.substringBefore(diffText, SEPARATOR);
                  endFound = true;
                }
              }
              if (diff.operation == diff_match_patch.Operation.EQUAL || diff.operation == diff_match_patch.Operation.INSERT) {
                newWordText.append(diffText);
              }
              if (endFound) {
                break;
              }
            }
          }
          cell.paintDiff(g, cell.getText(), newWordText.toString(), true);
        }

      }
    });

  }
  public boolean isInDiffView(EditorCell cell) {
    List<SimpleEditorMessage> messages = collectMessages(cell);
    for (SimpleEditorMessage message : ListSequence.fromList(messages)) {
      try {
        Class msgClass = message.getClass();
        if (msgClass.getName().equals("jetbrains.mps.vcs.diff.ui.common.ChangeEditorMessage")) {
          Field highlightedField = msgClass.getDeclaredField("myHighlighted");
          highlightedField.setAccessible(true);
          boolean highlighted = (Boolean) highlightedField.get(message);
          if (highlighted) {
            return true;
          }
        }
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
    }
    return false;
  }
  public SModel getModel(EditorCell cell, boolean newModel) {
    List<SimpleEditorMessage> messages = collectMessages(cell);
    List<Object> changes = ListSequence.fromList(messages).select((it) -> tryGetChange(it)).where((it) -> it != null).toList();
    for (Object change : changes) {
      try {
        Object changeSet = change.getClass().getMethod("getChangeSet").invoke(change);
        if (newModel) {
          return (SModel) changeSet.getClass().getMethod("getNewModel").invoke(changeSet);
        } else {
          return (SModel) changeSet.getClass().getMethod("getOldModel").invoke(changeSet);
        }
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
    }

    return null;
  }
  public Object tryGetChange(SimpleEditorMessage message) {
    try {
      Class msgClass = message.getClass();
      if (msgClass.getName().equals("jetbrains.mps.vcs.diff.ui.common.ChangeEditorMessage")) {
        Field myChangeField = msgClass.getDeclaredField("myChange");
        myChangeField.setAccessible(true);
        Object change = myChangeField.get(message);
        return change;
      }
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("", ex);
      }
    }
    return null;
  }
  public List<SimpleEditorMessage> collectMessages(EditorCell cell) {
    List<SimpleEditorMessage> result = ListSequence.fromList(new ArrayList<SimpleEditorMessage>());
    collectMessages(cell, result);
    return result;
  }
  public void collectMessages(EditorCell cell, List<SimpleEditorMessage> accumulator) {
    if (cell == null) {
      return;
    }
    ListSequence.fromList(accumulator).addSequence(ListSequence.fromList(cell.getMessages()));
    EditorCell_Collection collectionCell = as_ely5eb_a0a2a8(cell, EditorCell_Collection.class);
    if (collectionCell == null) {
      return;
    }
    for (EditorCell child : Sequence.fromIterable(collectionCell)) {
      collectMessages(child, accumulator);
    }
  }
  public String richtextToDiffText(SNode textNode) {
    StringBuilder sb = new StringBuilder();
    for (SNode word : ListSequence.fromList(SLinkOperations.getChildren(textNode, LINKS.words$C8QZ))) {
      if (SNodeOperations.isInstanceOf(word, CONCEPTS.Word$5r)) {
        sb.append(SEPARATOR).append(word.getNodeId().toString()).append(SEPARATOR);
        sb.append(Word__BehaviorDescriptor.getText_idehGfXvI_DB.invoke(SNodeOperations.cast(word, CONCEPTS.Word$5r)));
      } else {
        sb.append(SEPARATOR).append(word.getNodeId().toString()).append(SEPARATOR);
      }
    }
    return sb.toString();
  }
  public EditorCell findParentRichtextCell(EditorCell childCell) {
    if (childCell == null) {
      return null;
    }
    if (SNodeOperations.isInstanceOf(((SNode) childCell.getSNode()), CONCEPTS.Text$bD)) {
      return childCell;
    }
    return findParentRichtextCell(childCell.getParent());
  }
  private static <T> T as_ely5eb_a0a0a6a91a0a0c0d(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ely5eb_a0a0a6a12a0a0c0d(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ely5eb_a0a2a8(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Text$bD = MetaAdapterFactory.getConcept(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9e4e61L, "de.slisson.mps.richtext.structure.Text");
    /*package*/ static final SConcept Word$5r = MetaAdapterFactory.getConcept(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9f2e0cL, "de.slisson.mps.richtext.structure.Word");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink words$C8QZ = MetaAdapterFactory.getContainmentLink(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9e4e61L, 0x237c8da86a9e7aeeL, "words");
  }
}

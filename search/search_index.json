{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-mps-extensions","title":"Welcome to MPS Extensions","text":"<p>The MPS extensions aim to ease language development within MPS. They are maintained by itemis, JetBrains and the Open Source community and its development is closely related to the development of MPS.</p>"},{"location":"#mps-extensions-and-the-mbeddr-platform","title":"MPS Extensions and the mbeddr platform","text":"<p>How is the relationship between the mbeddr (platform) and this project?</p> <p>In the past, the mbeddr project developed a set of extensions that where used to allow easier development of languages with MPS. These extensions where not C specific and were called mbeddr platform. This project gives these extensions a new home and also includes some new extensions, to make them more visible but also emphasise that these extensions are independent of mbeddr, and it\u2019s C implementation in MPS. Not all of the existing extenses fit here because some of these are experimental or have too specific use cases. See the migration section of the documentation on what we still plan to migrate and how you could help.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, grab a release from our release page on GitHub. Extract the archive and point a project or global library in MPS to the location where you extracted it.</p> <p>See the documentation regarding the individual extensions above. Documentation-related contributions are always welcome!</p>"},{"location":"#artefacts-on-the-nexus-server","title":"Artefacts on the Nexus server","text":"<p>We also provide the artefacts as a maven repository. Where you can fetch them during your CI build to set up your local development environment.</p> Maven: pom.xml<pre><code>&lt;project&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n          &lt;id&gt;itemis.mps&lt;/id&gt;\n          &lt;url&gt;https://artifacts.itemis.cloud/repository/maven-mps/&lt;/url&gt;\n        &lt;/repository&gt;\n     &lt;/repositories&gt;\n\n     &lt;dependencies&gt;\n         &lt;dependency&gt;\n          &lt;groupId&gt;de.itemis.mps&lt;/groupId&gt;\n          &lt;artifactId&gt;extensions&lt;/artifactId&gt;\n          &lt;version&gt;2023.2&lt;/version&gt;\n          &lt;type&gt;zip&lt;/type&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre> Gradle: build.gradle<pre><code>    repositories {\n        maven { url 'https://artifacts.itemis.cloud/repository/maven-mps/' }\n    }\n\n    configurations {\n        mpsExtensions\n    }\n\n    dependencies {\n        mpsExtensions \"de.itemis.mps:extensions:2024.1.+\"\n    }\n</code></pre>"},{"location":"#artefacts-in-github-packages","title":"Artefacts in GitHub Packages","text":"<p>Open the packages tab for more information. The page Working with the Apache Maven registry explains how this repository can be used instead of the Nexus server.</p>"},{"location":"#versions","title":"Versions","text":"<p>The version number reflects the MPS version the extensions are compatible with. For instance <code>2021.3.X</code> is compatible with MPS 2021.3.2, <code>2021.1.X</code> is compatible with MPS 2021.1.4. We only maintain compatibility with the latest minor release for each major version. While, for example, a <code>2021.1.x</code> version of the extension might work with an on older version than MPS 2021.1.4 we only test it against the latest.</p> <p>A version in maintenance will not get actively new features and is only maintained with bugfixes. We are happy to accept pull request for versions in maintenance with bugfixes but active feature development only happens for the latest MPS version.</p> <p>Versions before MPS 2017.3 might still be available as the mbeddr platform but are not maintained in the repository.</p>"},{"location":"adding/","title":"Adding a new MPS Extension","text":"<p>If you want to add a new (or earlier developed existing) extension to MPS Extensions, the guidelines described here should help you. The process of adding a new plugin is like the process of migrating. This text repeats some of these steps less rigorously and adds all the steps needed for a new plugin. If you add a new extension, all this extension\u2019s code will be licensed under the Apache 2.0 license.</p>"},{"location":"adding/#check-if-a-new-extension-is-needed","title":"Check if a new extension is needed","text":"<p>If you have functionality that may already fit well under an existing extension, consider merging your extension\u2019s functionality into that existing extension. If the functionality of the extension you want to add doesn\u2019t fit under any of the existing extensions, and you know well where and how you want to add the extension, you can just open a pull request that adds your new extension (but please observe the checklist). If you are unsure how or where to start, you can open an issue and discuss/ask via that issue.</p>"},{"location":"adding/#checklist-for-adding-a-new-extension","title":"Checklist for adding a new extension","text":"<p>This checklist explains what you have to do to add a new extension fully and properly to the MPS Extensions.</p>"},{"location":"adding/#copy-your-extension-into-the-repository-and-add-to-the-mps-project","title":"Copy your extension into the repository and add to the MPS project","text":"<p>We assume that you have developed the extension you want to add in its own MPS Project. If not, you should first isolate it and make sure that it can work by itself. If your extension has dependencies to one of the plugins in MPS Extensions, you could either get this dependency from a Maven repository or develop the extension in its entirety in a fork of MPS Extensions. If you want to develop your extension from scratch in a fork, you can just skip this section and add the (plugin) solution(s) and/or language(s) that comprise your extension directly to the MPS project that lives under the <code>code</code> folder.</p> <p>Before you start, make sure that you have clean MPS models (without any classes_gen and source_gen folders). To copy or start your extension in the right place in the repository:</p> <ul> <li>Create a subfolder with the name of your extension under the <code>code</code> directory: <code>code/&lt;extension_name&gt;</code>, e.g. <code>code/plaintextgen</code> for the already existing plaintextgen extension and copy the folders languages (if any) and solutions (if any) of your new extension to <code>code/&lt;name&gt;</code>. See section Move the Files under migration for more detailed instructions.</li> <li>Open the MPS project living under the <code>code</code> folder, add the languages and solutions of your extension to it, and group all the added solutions and/or languages in a virtual folder that has the name of your extension. See section Adding the Files to the Project of migration for more detailed instructions.</li> <li>In order to have proper license information in a custom version of MPS with the MPS Extensions included , add an <code>about.txt</code> file under the root of your extension\u2019s folder (similar like the plaintextgen has an <code>about.txt</code> under <code>code/plaintextgen/about.txt</code>). If your extension doesn\u2019t depend on any external software, you can indicate that in the <code>about.txt</code> (see the example of plaintextgen). If you are using third-party libraries or other software, the <code>about.txt</code> must attribute the licenses of this third-party software (an example of such attribution can be found in the about.txt of MPS itself).</li> </ul>"},{"location":"adding/#add-to-the-build-solution","title":"Add to the build solution","text":"<p>This step is needed so that your extension is built into a plugin and deployed to Maven repositories (like Itemis Nexus or mbeddr GitHub packages), the JetBrains plugin repository, and the MPS download with MPS Extensions included. Detailed instructions can be found in section Adding it to the Build of migrating, but below are some extra steps you need to observe with a new extension:</p> <ul> <li>To allow automatic uploading to the JetBrains plugin repository, make sure you fill in the fields <code>description</code>, <code>version</code>, and <code>vendor</code> properly in the <code>idea plugin</code> section of the build script. Don\u2019t leave them empty!</li> <li>To package the <code>about.txt</code> with the plugin artifact, add a <code>file</code> entry to the <code>plugin</code> section of your extension\u2019s plugin(s). As an example, we show the <code>about.txt</code> file entry of plaintextgen:</li> <li></li> </ul>"},{"location":"adding/#make-a-pull-request","title":"Make a pull request","text":"<p>Please refer of section Sending the Pull Request of migrating for detailed instructions, but skip the last part about the <code>migration</code> label.</p>"},{"location":"building/","title":"Building","text":"<p>The MPS extensions are built using Gradle. To build the source code, all you need on the machine is a Java JDK. You need the following JDK versions depending on the MPS version:</p> <ul> <li>2024.1 and higher: JDK 21</li> <li>2022.2 and higher: JDK 17</li> <li>older versions: JDK 11</li> <li>ancient versions: JDK 8</li> </ul> <p>If you want to contribute to MPS-extensions, you need MPS. The current used MPS version can be found in the build.gradle file under the value <code>ext.mpsMajor</code>.</p> <p>To build the project, run:</p> <pre><code>./gradlew # Mac and Linux\ngradlew.bat # Windows\n</code></pre> <p>This will fetch the required MPS version from the internet, so you need to be online when first execute the build. The default task is <code>build_languages</code>.</p> <p>The default task doesn\u2019t run the test when building if you want to execute the tests then run: </p> <pre><code>./gradlew run_tests # Mac and Linux\ngradlew.bat run_tests # Windows\n</code></pre> <p>The documentation is built using Material for MkDocs and Python 3. It can be previewed by running:</p> <pre><code>./gradlew previewDocs # Mac and Linux\ngradlew.bat previewDocs # Windows\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributes are always welcome, no matter if it\u2019s additional documentation, a bugfix, a new feature to an existing extension or complete new extension that you are adding to the repository. </p> <p>If you are looking for an easy first contribution have a look at this list.</p> <p>Should you not feel comfortable to start with a code contribution: additions to our documentation are always welcome.  Our documentation is in this repository as well. You can edit it in your browser right a way if you like.</p> <p>For bugfixes, documentation and small new features you can open a pull request right away. Bigger features or new extensions should get some discussion in an issue just to make sure we are all on the same page about what will be done. If you are unsure what to do don\u2019t hesitate to open an issue and ask for help.</p> <p>If you want to add a completely new extension, please refer to adding a new extension for more information. Please consider contributing documentation for the new extension.   </p>"},{"location":"migrating/","title":"Migrating an Extension from the mbeddr Platform","text":"<p>No plans exist to migrate more extensions from mbeddr to this repository at the moment.</p> <p>Two different ways of migrating an extension from the mbeddr platform to the MPS-Extensions exist:</p> <ol> <li>The extension already exists as a separate plugin in the mbeddr platform </li> <li>The extension is part of the big <code>com.mbeddr.mpsutil</code> plugin</li> </ol>"},{"location":"migrating/#check-the-dependencies","title":"Check the Dependencies","text":"<p>First, check if all dependencies of the extension to migrate are already migrated to MPS-extensions. If not, you can\u2019t migrate the extension. How do you achieve that? </p> <p>To check whether the target extension already has all its dependencies migrated:</p> <ol> <li>Clone mbeddr.core.</li> <li>Once downloaded, open the <code>com.mbeddr.build</code> project in MPS. <ul> <li>The location should be <code>[your download folder]\\mbeddr.core\\code\\languages\\com.mbeddr.build</code></li> </ul> </li> <li>Get the details of the target extension:<ol> <li>Open the related GitHub issue for the target extension.<ul> <li>For example, for the \u201cquerylist\u201d extension, the URL of the GitHub issue is MPS_EXT-23.</li> </ul> </li> <li>Inside the issue page, click the link that is related to the extension. <ul> <li>The link normally starts with <code>http://127.0.0.1</code>.</li> <li>For this example, the link is this.</li> </ul> </li> <li>Clicking that link will select the corresponding plugin entry in the build script in your open MPS project.</li> </ol> </li> </ol> <p>After doing the steps above, you will see something like the following entry in MPS, in your open <code>com.mbeddr.build</code> project:</p> <pre><code>idea plugin com.mbeddr.mpsutil.jung \n  name com.mbeddr.mpsutil.jung \n  short (folder) name com.mbeddr.mpsutil.jung \n  description &lt;no description&gt; \n  version ${mbeddr.version} \n  &lt;&lt; no vendor &gt;&gt; \n  content: \n    group.jung \n  dependencies: \n    jetbrains.mps.core \n  &lt;&lt; ... &gt;&gt; \n</code></pre> <p>Check the <code>dependencies</code> section of the plugin. If it contains plugins that start with <code>com.mbeddr</code> then it still has dependencies on mbeddr and cannot be moved.</p>"},{"location":"migrating/#move-the-files","title":"Move the Files","text":"<p>If all dependencies are already part of MPS-extensions, we can start with migrating the extension. Follow the reference(s) in the content section. For example: <code>group.jung</code>:</p> <pre><code>mps group group.jung \n  solution com.mbeddr.mpsutil.jung.pluginSolution \n    load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/solutions/pluginSolution/com.mbeddr.mpsutil.jung.pluginSolution.msd \n\n  language com.mbeddr.mpsutil.jung \n    load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/com.mbeddr.mpsutil.jung.mpl \n</code></pre> <p>Both modules above are located under the <code>code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung</code> directory. </p> <p>Steps to create a new extension:</p> <ol> <li>Create a folder in the MPS-extensions repository where we can place these files. <ul> <li>This folder should be placed under the existing <code>code</code> directory of the MPS-Extensions repository. </li> <li>The naming convention is that it shall contain the last name of the namespace. In this case <code>jung</code>. </li> <li>The resulting folders therefore should be: <code>code\\jung</code> and also <code>code\\jung\\languages</code>.</li> </ul> </li> <li> <p>Copy all the files from the mbeddr repository <code>code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung</code> to the new <code>code/jung/languages</code> in the MPS-extensions repository.</p> </li> <li> <p>After copying, check if there is an existing <code>solutions</code> folder to the language you migrated such that you now have a <code>code/jung/languages/solutions</code> folder. If you do, move the files from <code>code/jung/languages/solutions</code> to the <code>code/jung/solutions</code> folder. This is because the structure in the MPS-extensions repository slightly differs from the one in mbeddr. </p> </li> <li> <p>Remember: you are copying from the <code>mbeddr.core</code> folder and pasting them to the <code>MPS-Extensions</code> folder.</p> </li> </ol> <p>Sounds too complicated? Don\u2019t worry we will help you when sent the pull request to get it right.</p>"},{"location":"migrating/#adding-the-files-to-the-project","title":"Adding the Files to the Project","text":"<p>The files need to be part of the MPS project to show up in MPS. This is done by adding them to the project path/modules:</p> <p></p> <p>And then selecting the copied files: </p> <p></p> <p>The files end up in no folder in the project by default. They should be placed in a virtual folder of the project that matches the subfolder under the <code>code</code> folder. In this case <code>jung</code>:</p> <p> </p> <p>After this is done the last step that is missing is adding the plugin to the build.</p>"},{"location":"migrating/#adding-it-to-the-build","title":"Adding it to the Build","text":"<p>To build the plugin that was moved, it needs to be a part of the build scripts. These scripts are located under the <code>build</code> folder of the project. The solution of interest is <code>de.itemis.mps.extensions.build</code>. And then the <code>de.itemis.mps.extensions</code> build project:</p> <p></p> <p>The first thing required is a group where all the implementation modules of the plugin are placed. Tests are placed in a different script. The group is named like the mbeddr group name but the prefix is not <code>com.mbeddr.mpsutil</code> but <code>de.itemis.mps</code>. In this case this results to <code>de.itemis.mps.jung</code>. This group then contains all the solutions and languages of the plugin:</p> <p></p> <p>After the group is created, an <code>idea plugin</code> is required. This plugin references the group and should be placed right above the group in the build script. This is important to keep the build script maintainable. </p> <p></p> <p>The final step is adding the plugin to the layout section of the build project. </p> <p></p> <p>After adding the plugin to the layout it should be possible to build the model but usually an error like this will be shown:</p> <pre><code>cannot build relative path to `wstx-asl-3.2.6.jar': No such path in local layout\n-- -- was input node: [path] BuildSourceMacroRelativePath null[8622958246116067669] in de.itemis.mps.extensions.build@5_1\n-- was template node: r:54537613-52b5-40a8-b223-e87f0960b04f(jetbrains.mps.build.mps.generator.template.main@generator)/4743026300739052425\n</code></pre> <p>This error message means that some jar files that are used by the language or some solutions are missing. The convention here is to create a <code>lib</code> folder in the plugin and include the required <code>jar</code> files. These files are usually contained in a <code>lib</code> folder. </p> <p></p>"},{"location":"migrating/#sending-the-pull-request","title":"Sending the Pull Request","text":"<p>To verify that everything works correctly run:</p> <pre><code>./gradlew test # mac OS / Linux\n\ngradlew.bat test # Windows\n</code></pre> <p>This command should finish successfully. After that please create pull request at our repository and label it with <code>migration</code></p> <p>If something doesn\u2019t work out quite well or you are unsure what to do, don\u2019t worry. You can still send the PR and somebody will guide you through the process.</p>"},{"location":"migrating/#bonus","title":"Bonus","text":"<p>If you are really eager you can send a PR to the mbeddr platform repository to remove the plugin there. </p>"},{"location":"migrating/#grammar-cells-migration","title":"Grammar Cells Migration","text":"<p>Starting from version <code>2018.2.348</code> the MPS extensions also contain Grammar Cells which have been ported over from the mbeddr platform. For users of Grammar Cells this is mostly a transparent change since the mbeddr platform currently repackages the MPS extensions. This means that if you are using the mbeddr platform today you should not have to do much manual work.</p>"},{"location":"migrating/#mbeddr-changes","title":"mbeddr changes","text":"<p>The most obvious change here is that the version of the mbeddr artefacts was incremented by a minor. That means you will have to adjust your build files to get the version <code>1.1+</code> instead of <code>1.0*</code>. Please consult the documentation of your build tool how to configure your dependency resolving.</p> <p>We did this change to ensure that you do not accidentally get the new version. See the last section for the reason.</p> <p>The 1.0+ versions remain in our nexus as they are in the current state but will not get any updates. If you want to get newer versions of the mbeddr platform your have to change your dependency version. If you download your artefacts manually from the mbeddr GitHub page everything is the same as before but the version number is incremented.</p> <p>Other than that the artefacts didn\u2019t change and still contain the repackaged platform. We are planning to add a additional artefact that doesn\u2019t repackaged the MPS-extensions in the future to allow you more flexibility.</p>"},{"location":"migrating/#changes-to-mps-extensions","title":"Changes to MPS Extensions","text":"<p>In the MPS extensions we only have additive changes. We added the mpsutil.grammarcells.* modules in that same state as they were in the mbeddr platform. You shouldn\u2019t observe any changes. Besides that, we kept the language ids to avoid any visible change for existing users of the languages.</p> <p>The MPS Extensions\u2019 version number remain in the normal scheme as documented above.</p>"},{"location":"migrating/#required-changes-for-projects","title":"Required changes for projects","text":"<p>If your project is using Grammar Cells today it is using them through the mbeddr platform. If you do so you simply need to adjust the version number the dependency on the mbeddr platform, and you are good to go.</p> <p>If your build scripts show errors after changing the dependency a simple \u201creload modules from disk\u201d intention should be able to fix them.</p> <p>If you only have a dependency to the mbeddr platform because you want to use Grammar Cells you are now able to drop that dependency. Replace the dependency on the mbeddr platform with a dependency on the correct version of MPS extensions. In this case you need to modify your MPS build scripts to no longer use the mbeddr platform as dependency but the MPS extensions. Afterwards, MPS will complain that it can\u2019t find the dependency on Grammar Cells language in the build. To fix this, invoke the intention *reload modules from disk\u2019 in the affected build script and the errors should go away.</p>"},{"location":"extensions/full_extensions_list/","title":"Full Extension List","text":"<p>This is a full list of all the extensions that are contained in MPS-extensions.</p> <p>Base Language Extensions</p> Name Description de.itemis.mps.structurecheck adds a statement to baselanguage that allows to check the structure of a node com.mbeddr.mpsutil.blutil utilities for baselanguage com.mbeddr.mpsutil.blutil.genutil baselanguage generator utilities <p>Editor</p> Name Description com.mbeddr.mpsutil.editor.querylist enables the definition of editors over smodel queries as opposed to only a fixed concept structure com.mbeddr.mpsutil.treenotations tree-like notation for MPS Editors de.itemis.mps.editor.bool additional editor cells are available to represent Boolean values in the editor with a representation other than \u201ctrue\u201d and \u201cfalse\u201d de.itemis.mps.editor.collapsible additional editor cells that can be colllapsed de.itemis.mps.editor.diagram diagrammatic notation for MPS editors de.itemis.mps.editor.dropdown additional editor cells for displaying a dropdown menu de.itemis.mps.editor.enumeration additional editor cells for displaying a group of checkboxes as an enum de.itemis.mps.editor.math mathematical notation for MPS Editors de.itemis.mps.celllayout celllayout extensions de.itemis.mps.grammarcells A grammar-like abstraction for writing editors for textual patterns such as flags, operations, parentheses, etc. Specifying a grammar cell is compact but has enough semantic richness to automatically generate actions (wrappers, side-transforms, substitutions, and delete actions) for the pattern you specified in the grammar cell. de.slisson.mps.conditionalEditor A conditional editor is almost like an aspect. It can be applied \u201caround\u201d existing editor, and whether it applies or not is determined by a condition and the applicable concept (similar to a pointcut in AO). Using this approach, it is now possible to essentially decorate any editor with any decoration based on arbitrary conditions. de.slisson.mps.editor.multiline an editor component for properties that supports wrapping of long lines and new lines by pressing ENTER de.slisson.mps.richtext an editor component for mixing plain text and MPS nodes de.slisson.mps.tables tabular notation for MPS editors de.itemis.mps.linenumbers line numbers for the editor de.itemis.mps.editor.htmlcell HTML-based editor cells de.itemis.mps.editor.pagination An editor cell for paginating collections of nodes <p>Generator</p> Name Description com.dslfoundry.plaintextflow improved version of plaintextgen com.dslfoundry.plaintextgen this plugin is an alternative text generator for MPS, using the standard model to model generation mechanisms (node macros, loop macros, property macros, etc.) to generate plain text, as opposed to MPS\u2019s programmatical textgens. <p>Other</p> Name Description de.q60.mps.shadowmodels a shadow model is a non-editable model derived from existing models by model-to-model transformations. org.modelix.model alternative model API with better support for persistent data structures de.itemis.mps.changelog a language for creating changelogs and exporting them to markdown <p>Stubs</p> Name Description MPS.ThirdParty jars and stubs used by MPS (it includes the previous standalone Jackson stubs for json serialization) MPS.Kotlin jars and stubs for the Kotlin standard library org.apache.commons jars and their stubs to use Apache Commons Library in MPS de.itemis.stubs.xml jars and their stubs to use the Apache Xerces library in MPS de.itemis.stubs.batik jars and their stubs to use the Apache Batik library in MPS <p>Tools, Views and other Plugins</p> Name Description com.mbeddr.mpsutil.projectview abstraction on top of MPS lower-level API to create custom views in the view tool window (like logical view, file view, etc.) de.itemis.mps.selection with this plugin you can select nodes in MPS using the mouse. It also allows invoking intentions over a selection of nodes in an nlist <p>Utilities</p> Name Description com.mbeddr.mpsutil.intentions enables the grouping of different intentions under one label com.mbeddr.mpsutil.modellisteners Mechanism for installing callbacks that listen to changes in specific parts of models. Use only when you have no other MPS mechanism for achieving what you need, because many listeners can quickly eat performance. com.mbeddr.mpsutil.serializer helper classes that can serialize nodes to xml and deserialize them from xml de.itemis.mps.modelmerger (deprecated) extension that allows to merge models de.itemis.model.merge extension that allows to merge models de.itemis.mps.nodeversioning The node versioning extension gives support for storing different states/versions of a node inside of the model de.itemis.mps.debug A language for debugging editors de.itemis.mps.spellcheck A language for customizing spell checking in the editor de.itemis.mps.statistics A language for collecting usage statistics of languages"},{"location":"extensions/stubs/","title":"Stubs","text":"<p>Stubs are Java libraries that can be used from MPS.</p> <p>Some of the mentioned stubs on this page only exist in older versions of MPS-Extensions. They are now most likely located in the MPS.ThirdParty stub.</p>"},{"location":"extensions/stubs/#apache-commons","title":"Apache Commons","text":"<p>This module contains stubs for the Apache Commons Java library and MigLayout. The following libraries are included:</p> <ul> <li>Apache Commons Primitives</li> <li>Apache Commons CSV</li> <li>Apache Commons IO</li> <li>Apache Commons Lang 3.0</li> <li>Apache Commons Math 3.0</li> </ul>"},{"location":"extensions/stubs/#collections","title":"Collections","text":"<p>The following Java collection libraries are supported:</p> <ul> <li>Guava: Google Core Libraries</li> <li>GNU Trove</li> <li>Vavr</li> <li>Apache Commons Collections</li> </ul>"},{"location":"extensions/stubs/#jackson","title":"Jackson","text":"<p>This stub contains the Java libraries for the Jackson JSON parser.</p>"},{"location":"extensions/stubs/#jdom","title":"JDOM","text":"<p>This module contains the following libraries:</p> <ul> <li>JDOM XML manipulation library</li> <li>jaxen Jaxen XPath Engine library</li> </ul>"},{"location":"extensions/stubs/#apache-batik","title":"Apache Batik","text":"<ul> <li>Apache\u2122 Batik SVG Toolkit library for working with SVG files</li> <li>Apache\u2122 XML Graphics library for conversion of XML formats to graphical output</li> </ul>"},{"location":"extensions/stubs/#xerces","title":"Xerces","text":"<ul> <li>xerces XML parsers</li> <li>xml-apis-ext Apache-hosted set of DOM, SAX, and JAXP interfaces for use in xml-based projects</li> </ul>"},{"location":"extensions/bl-extensions/blutil/","title":"Base Language Util (blutil)","text":"<p>This package contains various Base Language related utility methods:</p>"},{"location":"extensions/bl-extensions/blutil/#blutil","title":"blutil","text":"<p>Language Namespace: <code>com.mbeddr.mpsutil.blutil</code></p>"},{"location":"extensions/bl-extensions/blutil/#concept-switch","title":"Concept Switch","text":"<p>This Base Language statement checks the concept of a node in the form of a switch statement:</p> <pre><code>conceptswitch(node) { \n  case AbstractConceptDeclaration : it [ ] =&gt; { \n    return 10; \n  } \n  default =&gt; { \n    return 5; \n  } \n}\n</code></pre> <p>When you have a case X, the variable <code>it</code> refers to the node as type node&lt;X&gt;. The declaration of the default case is mandatory.</p>"},{"location":"extensions/bl-extensions/blutil/#dispatch","title":"Dispatch","text":"<p>This expression is like conceptswitch. Additionally, it supports matching the children of a concept and calling  itself recursively with <code>#(expression)</code>:</p> <pre><code>public static int example() { \n  node&lt;Expression&gt; node = &lt;10 + 20&gt;; \n  dispatch&lt;int&gt; (node) { \n    + [leftExpression :&lt;=: IntegerLiteral] \u21d2  #(it.leftExpression) \n    IntegerLiteral [] \u21d2  1 \n    default 0 \n  }; \n}                                                                                                                                                            \n</code></pre>"},{"location":"extensions/bl-extensions/blutil/#doc","title":"Doc","text":"<p>BlDoc is a node annotation that adds support for adding documentation using  the richtext language. </p> <p>MethodLineDoc is a node annotation that adds support for  single line text comments for classifier members. Example:</p> <pre><code>/** provides convenient access to the current environment as map&lt;&gt; **/                                      \npublic map&lt;node&lt;&gt;, Object&gt; env { \n  get { \n    ((Map&lt;node&lt;&gt;, Object&gt;) context.getEnvironment()); \n  } \n\n}\n</code></pre>"},{"location":"extensions/bl-extensions/blutil/#log-deprecated","title":"Log (deprecated)","text":"<p>The two log statements log and logctx both print to the standard error stream with some support for labels and contexts. They\u2019re deprecated, use the official logging language instead.</p>"},{"location":"extensions/bl-extensions/blutil/#match","title":"Match","text":"<p>The <code>when matched</code> statement is similar to the light patterns pattern builders. It matches a candidate node against some clauses and executes the block if it matches. There\u2019s also an <code>otherwise</code> block that\u2019s executed when the nodes aren\u2019t matched:</p> <pre><code>node&lt;PlusExpression&gt; plus = &lt;4 + 5&gt;;\nnode&lt;&gt; l = null;\nnode&lt;&gt; r = null;\nwhen matched plus against t /PlusExpression; {\n    l = t.leftExpression;\n    r = t.rightExpression;\n}\n</code></pre> <p>You can use a few different clauses:</p> <ul> <li>t: match with the current node</li> <li>p: match with the parent node</li> <li>link: match with a child or reference node (link)</li> <li>a: match with an ancestor node</li> </ul> <p>Normally, the pattern language should provide enough functionality,  so that you don\u2019t need this language.</p>"},{"location":"extensions/bl-extensions/blutil/#model-access","title":"Model Access","text":"<p>These concepts are safe read and write actions for the same concepts from the access language. These two concepts don\u2019t swallow error messages but print them to the standard output stream.</p> <p>Note: in some MPS versions, write access isn\u2019t enough to modify the model, a command action is needed in those cases.</p>"},{"location":"extensions/bl-extensions/blutil/#profiler","title":"Profiler","text":"<p>This is a simple java performance profiling statement, outputting the initial and final memory usage as well as the execution time of the statements (in milliseconds) to the standard output stream.</p>"},{"location":"extensions/bl-extensions/blutil/#static-imports","title":"Static imports","text":"<p>This is a special static method call that only shows the method name and not the class name of a static method, for example, <code>myMethod()</code> instead of <code>MyClass.myMethod()</code>. Enable it for a static method by using the intention <code>toggle static import view</code>.</p>"},{"location":"extensions/bl-extensions/blutil/#type-switch","title":"Type switch","text":"<p>This is another switch statement, this time for Java types. It supports matching types and giving them aliases. The default case is optional:</p> <pre><code>typeswitch (sourceScope) { \n  case type StageScope as it { \n    return findSiblings(it, engine); \n  } \n  case type NamedScope as it { \n    return findSiblings(it, engine); \n  } \n  case type RootScope as it { \n    return new sequence&lt;IScope&gt;(empty); \n  } \n  default { \n    return new sequence&lt;IScope&gt;(empty); \n  } \n}\n</code></pre>"},{"location":"extensions/bl-extensions/blutil/#ifinstanceof","title":"IfInstanceOf","text":"<p>This concept enhances the same concept from the language <code>jetbrains.mps.lang.smodel</code> with support for else if and else branches. You can give your expression a name for each branch:</p> <pre><code>test withElseIfAndElse { \n  node&lt;ClassConcept&gt; node = new node&lt;ClassConcept&gt;(); \n  int result; \n  ifInstanceOf (node is ClassConcept cls) { \n    result = cls.isNotNull ? 0 : 1; \n\n  } else ifInstanceOf (node is AbstractCatchClause acc) { \n    result = acc.isNotNull ? 2 : 3; \n  } else ifInstanceOf (node is AbstractClassifierReference acr) { \n    result = acr.isNotNull ? 5 : 6; \n  } else { \n    result = 7; \n  } \n\n  assert 0 equals result ; \n}\n</code></pre>"},{"location":"extensions/bl-extensions/blutil/#blutilgenutil","title":"blutil.genutil","text":"<p>This language contains helpful expressions for generators.</p> <ul> <li>is-in-tests checks that the original input model is a node/editor test</li> <li>executeOnce this expression is useful in reduction rules or similar rules to only execute the rule   once. The session object saves the necessary information.</li> <li>mappingHasBeenExecuted: checks if executeOnce already set the flag. It can be used, for example, in a condition block  of a generator rule.</li> <li>setMappingHasBeenExecuted is the same as executeOnce but only saves the information and doesn\u2019t check and returns if the code was already executed.</li> </ul>"},{"location":"extensions/bl-extensions/structure-check/","title":"Structure Check","text":"<p>Language Namespace: <code>de.itemis.mps.structurecheck</code></p> <p>The statement <code>check structure of</code> can check the structure of a node. The statement throws a runtime exception when the check fails. It supports a few different checkers. The expression <code>thisElement</code> always refers to the current element:</p> <ul> <li>composite checker combines multiple checks.</li> <li>condition checks that a boolean condition is true.</li> <li>element checks that one or multiple elements of the same structure match. The default cardinality is one (x1)   which you can set to a different value.</li> <li>property checks a property of the element. It compares the left expression to the right expression.</li> <li>sequence checks that a sequence of elements matches the listed elements.   To match the ordering of the declared elements, set the <code>ordered</code> flag (set to <code>unordered</code> otherwise).   4 supported checker types are available:<ul> <li>all elements must match the declared elements (exactly),</li> <li>all elements must match, but there can be more elements (allOrMore)</li> <li>all elements must match, but there can be fewer elements (allOrLess)</li> <li>none of the elements should match (noneOfThese).</li> </ul> </li> </ul> Example: check the structure of an ArrayList<pre><code>list&lt;Object&gt; root = new arraylist&lt;Object&gt;{\"a\", 2, new arraylist&lt;Integer&gt;{10, 20}, 3}; \n\ncheck structure of root { \n  sequence thisElement contains unordered allOrMore { \n    element x1 of type Integer { \n      property 2 = thisElement \n    } \n    element x1 of type string { \n      condition thisElement != null   \n      property \"a\" = thisElement \n    } \n    element x1 of type list&lt;Integer&gt; { \n      sequence thisElement contains ordered exactly { \n        element x1 of type &lt;no subtype&gt; { \n          property 10 = thisElement \n        } \n        element x1 of type &lt;no subtype&gt; { \n          property 20 = thisElement \n        } \n      } \n    } \n  } \n};\n</code></pre>"},{"location":"extensions/editor/celllayout/","title":"Cell Layout","text":"<p>Language Namespace : <code>de.itemis.mps.editor.celllayout</code></p> <p>In the MPS layout algorithms, the children decide about their width and height, and the parent cell can only arrange the already layouted children. The algorithms from the celllayout language are similar to the ones from the swing layouters where the child is asked for its min/max/preferred size, but the parent decides about the size of the child and the child then has to fit itself into these bounds. The table and diagram language uses this language, but there are also some useful  styles defined in the <code>de.itemis.mps.celllayout</code> language. The language is partially inspired by the Java MigLayout and uses a box model: there\u2019s a content box (the cell itself), a padding box (space between content and border), a border box and a margin box (the space around the border).</p> <p>The layouter is only replaced for cells that use one of the properties mentioned below because the performance is not as good as with the normal layouter.</p> <p>The language also adds some new cells and style properties.</p>"},{"location":"extensions/editor/celllayout/#cells","title":"Cells","text":""},{"location":"extensions/editor/celllayout/#horizontal-line","title":"horizontal-line","text":"<p>A horizontal line cell that has a specific thickness (width) and the parent cell\u2019s width. </p> <p>Supported style properties:</p> <ul> <li>horizontal-line-color (default: black, type: hex color, predefined color or custom query)</li> <li>horizontal-line-width (default: 1, unit: pixel)</li> </ul>"},{"location":"extensions/editor/celllayout/#vertical-line","title":"vertical-line","text":"<p>A vertical line cell that has a specific thickness (width) and the parent cell\u2019s height.</p> <p>Supported style properties:</p> <ul> <li>vertical-line-color default: black, type: hex color, predefined color or custom query</li> <li>vertical-line-width default: 1, unit: pixel</li> </ul>"},{"location":"extensions/editor/celllayout/#properties","title":"Properties","text":""},{"location":"extensions/editor/celllayout/#border","title":"Border","text":"<p>The additional properties are only applied if draw-border is true.</p> <p>Supported style properties:</p> <ul> <li>border-color default: light gray, hex color, predefined color or custom query</li> <li>border-size default: 0, unit: pixel</li> </ul>"},{"location":"extensions/editor/celllayout/#gridlayout-properties","title":"GridLayout properties","text":"<p>When a vertical grid layout is used as the cell layout, some additional properties are supported:</p> <ul> <li>grid-layout-column-span is the number of columns that the cell spans</li> <li>grid-layout-column-row is the number of rows that the cell spans</li> <li>grid-layout-flatten is a boolean flag that tells the layouter that the grid should be flattened. Normally,  the MPS grid layout doesn\u2019t support aligning nested collections in vertical grids. When this property is set, the   collections are first flattened before the alignment takes place.</li> <li>vertical grid (with flatten support) a top-down cell layout with uses a grid layout</li> <li>topDownLayout this layout replaces the MPS layouter. Sometimes problems with the integration into the MPS layouter occur  where you can use the TopDownLayoutCell as a workaround. Normally, the interceptor of the celllayout language is automatically installed recursively when any style property of the language is used.</li> </ul>"},{"location":"extensions/editor/celllayout/#grow-and-push","title":"Grow and Push","text":"<ul> <li>grow-x is a flag that tells the layouter to grow the cell to the with of the parent.</li> <li>push-x is a property that has the same effect as setting <code>grow-x</code> on the cell and all ancestor cells.</li> <li>grow-y is a flag that tells the layouter to grow the cell to the height of the parent.</li> <li>push-y is a property that has the same effect as setting <code>grow-y</code> on the cell and all ancestor cells.</li> <li>overflow-x/overflow-y the position of the line break in the Indent layout is determined by the width of the entire editor. This width is determined by the \u201cText width\u201d setting (vertical gray line at the right margin) and the min/max size values of the cells. If, for example, a large image or a table with many columns is inserted, the entire editor becomes very wide and difficult to read. With overflow-x the width of a cell is ignored when determining the editor width. So the text breaks normally at the vertical line and does not become as wide as the image.</li> </ul>"},{"location":"extensions/editor/celllayout/#margin","title":"Margin","text":"<p>It\u2019s possible to specify the space around the cell by specifying one of the margin properties.</p> <p>Supported style properties:</p> <ul> <li>margin-left is the space to the left of the cell (unit: pixel)</li> <li>margin-top is the space above the cell (unit: pixel)</li> <li>margin-right is the space to the right of the cell (unit: pixel)</li> <li>margin-bottom is the space below the cell (unit: pixel)</li> </ul>"},{"location":"extensions/editor/celllayout/#celllayoutstyles","title":"celllayout.styles","text":"<p>For more control there are style properties in this language that support queries and allow, for example, to set the border size and color not only for the full border but also for a single side such as the left side. Import LayoutStyleAttributes as a dependency. All style attributes start with an underline.</p>"},{"location":"extensions/editor/celllayout/#debugging-for-developers","title":"Debugging (for developers)","text":"<p>If you suspect that a bug is caused by this language, try to open the MPS-extensions project first and disable the layout interceptor. Then open your project and check if it makes a difference. A common issue is also to only use the <code>grow</code> or <code>push</code> property alone instead of using both properties simultaneously. If an editor cell is rendered in the wrong location or doesn\u2019t update correctly, it is very likely that</p>"},{"location":"extensions/editor/conditional-editor/","title":"Conditional Editor","text":"<p>Language Namespace : <code>de.slisson.mps.conditionalEditor</code></p> <p>A conditional editor allows overriding the editor of any concept. First, a priority can be set. The editor with the highest priority is used, normal editors have a priority of 0. The condition is mandatory and can be set to true if the editor should always be applicable. There\u2019s a special cell called <code>next-editor</code> that can be used to embed the original editor. If multiple conditional editors with the same or different priorities exist, <code>next-editor</code> will show the next editor according to the priorities. That means that you can also have multiple editors with the same priorities, that will be nested if you use this cell in every one of those editors.</p> <p>To be able to reference a concept to override, import the concept itself (= add dependency to structure aspect of the concept) in the editor but also change the scope of the import language to Extends in the language properties.</p> <p></p>"},{"location":"extensions/editor/diagrams/","title":"Diagrams","text":"<p>Language Namespace : <code>de.itemis.mps.editor.diagram</code></p>"},{"location":"extensions/editor/diagrams/#general","title":"General","text":"<p>The <code>de.itemis.mps.editor.diagram</code> language enables graphical editing of models in JetBrains MPS. It allows users to visualize textual models as diagrams, providing a more intuitive way to interact with data. Diagrams consist of blocks (boxes) and connectors (lines), which represent nodes and relationships in the underlying model.</p>"},{"location":"extensions/editor/diagrams/#diagram-cells","title":"Diagram Cells","text":"<p>Add a new <code>diagram</code> cell to the editor to add a new diagram to the editor. The cell supports the following properties:</p> <ul> <li>id is an identifier for the diagram. It can be node or a string. In the first case, the identifier is derived from the     node ID. The identifier is necessary in cases where you have multiple (sub-)diagrams for the same node.</li> <li>content allows defining the actual content of the diagrams (boxes, edges, attributes etc.). It is explained in the next section.</li> <li>connection creators are used to create connections between diagram elements like ports and boxes. A list of type <code>IConnectionType</code> has to be returned from this method. The default implementation is <code>SNodeConnectionType</code> which has two   methods <code>canCreate(node&lt;&gt; fromNode,string fromPort,node&lt;&gt; toNode,string toPort)</code> and <code>create(node&lt;&gt; fromNode,string fromPort,node&lt;&gt; toNode,string toPort)</code> which have to be overridden.</li> <li>palette entries creates the entries for the <code>Diagram Palette</code> tool located on the right side of the editor.</li> <li>palette folder creates the folder inside the <code>Diagram Palette</code> tool</li> <li>buttons creates the buttons that are visible at the upper left corner of the diagram and when selecting edges/boxes.</li> <li>layout algorithm selects the layout algorithm to be used by the auto layouting functionality.</li> <li>default shape declares the default shape of boxes.</li> <li>owner change handler are invoked when diagram elements should be moved to a different sub-diagram. The can change methods checks if the element can move and the change method is responsible for moving the elements.</li> <li>autolayout on init runs the ELK layouter on the diagram when the editor containing the diagram is opened and no layout is saved in the model.</li> <li>autolayout on change runs the auto layouter whenever the diagram model changes (e.g. connecting two ports, adding a new item from the palette). The only exception are manual layout changes like resizing or moving a box that don\u2019t trigger it.</li> <li>fit size on init changes the size of all boxes in the diagram to only take up the minimum required size when the diagram is opened.</li> <li>save subdiagram layout in this diagram stores the layout information in the root diagram instead of the node of the sub-diagram. save layout data saves the layout data (position/siz/visibility of diagram elements) in the node of the diagram inside the attribute layoutMap. If you disable this option you might want to enable autolayout on init instead.</li> <li>connect boxes without dummy ports: boxes are connected directly without invisible ports. This option could have an effect on the layouting of the diagram related to hyperedges. Those are edges that are created when multiple edges are merged into one edge.</li> <li>disable node editing removes the ability to edit MPS cells inside diagrams when you double-click on them.</li> <li>synchronize diagram with model only on opening makes the diagram not update itself automatically based on the model. The new diamond-shaped button has to be used to do this. The only time when the diagram is synchronized is when the diagram is initially initialized e.g. when creating the editor for a root node. The use case for this feature is that sometimes you want to edit the model in bulk before updating the diagram which can take a lot of time and disturb the editing experience.</li> <li>ignore elements\u2019 minimum size restriction (indent layout) allows boxes to set a new required minimum size through the style attribute diagram-layout-node-size-minimum.</li> <li>show grid lays a grid over the diagram that can be used for aligning and snapping elements to the grid.</li> <li>grid size defines the size of the grid in pixels.</li> <li>grid color defines the color of the grid.</li> <li>grid style sets the style of the grid: cross, dashed, dot or line.</li> <li>arrow key move defines the amount an element is moved when pressing an arrow key.</li> <li>arrow key move amount (slow) defines the amount an element is moved when pressing shift and an arrow key.</li> <li>arrow key pan amount defines the amount the diagram is panned when pressing an arrow key.</li> <li>arrow key pan amount (slow) defines the amount the diagram is panned when pressing shift and an arrow key.</li> <li>minimum scale: sets the minimum scaling factor when zooming out of the diagram.</li> <li>use grid snapping activates automatically aligning elements to the grid.</li> </ul> <p>To use the node of the editor itself somewhere, use the expression <code>thisNode</code>. Diagrams can also be embedded into collapsible cells of the language de.itemis.mps.editor.collapsible.</p>"},{"location":"extensions/editor/diagrams/#shapes","title":"Shapes","text":"<p>Shapes specify how diagram elements are rendered (excluding the MPS editor cells). Create a new shape definition. It supports the following options:</p> <ul> <li>default size: returns the size of the shape in pixels if the size is not calculated through other means such as contained editor cells.</li> <li>parameters are additional variables than can be set when instantiating a shape and used inside shape definitions.</li> <li>draw(graphics,bounds, style) is the method that draws the shape.   The shape has to be inside the dimensions of the bounds parameter.   In case it is used as the end of an edge, the edge always points from left to right and is connected to the shape at the left center of the bounds. Read the Oracle 2D Graphics documentation to learn more about painting with Java Swing. The style parameter are internal shape style classes that implement IShapeStyle_Internal. The default implementation is BasicShapeStyle but there are special classes for diagram elements like edges or markers.</li> <li>draw shadow draws a drop shadow around the shape by default. It can be customized through this method.</li> <li>get shape can be used instead of the draw and draw shadow methods to customize the drawing even further.</li> </ul>"},{"location":"extensions/editor/diagrams/#diagram-palette","title":"Diagram Palette","text":"<p>You can drag elements from the palette to the diagram. The tool itself also supports folders similar to the context actions tool.</p> <p></p> <p>Palette entries can be fined inside diagram cells. You have to return a <code>SubstituteInfo</code> instance that can be created through the helper variable <code>factory</code> that has various methods for creating substitute info instances such as for children of a concept.</p> <p>The palette folder can be declared at the same place. The parameter <code>node</code> refers to the node of the editor itself, <code>concept</code> and <code>targetNode</code> come from the created substitute info instance.</p>"},{"location":"extensions/editor/diagrams/#buttons","title":"Buttons","text":"<p>There are many different buttons that are either visible in the upper left corner of the diagram or when boxes/edges are selected. Some buttons are not visible in sub-diagrams. By default, all buttons are enabled. There are two ways to customize the buttons. In button configurations the predefined buttons can be toggled and in custom configurations you can create your own buttons. The following buttons are available:</p> <ul> <li>Layout Diagram runs the auto layouter for the diagram.</li> <li>Maximize Diagram maximizes th diagram to the full size of the editor.</li> <li>Reset View resets all changes to the diagram view like zooming and translations.</li> <li>Zoom In zooms into the diagram (shortcut: alt+shift+minus).</li> <li>Zoom Out zooms out of the diagram (shortcut: alt+shift++).</li> <li>Fit Size All changes the size of all boxes in the diagram to only take up the minimum required size.</li> <li>Show Ports Label toggles showing the name of the port next to the port itself.</li> <li>Show All Edges makes all invisible edges visible again.</li> <li>Translate To Origin moves all diagram elements so that they align with the upper left corner of the diagram.</li> <li>Show Grid lays a grid over the diagram that can be used for aligning and snapping elements to the grid.</li> <li>Use Grid Snapping activates the feature that diagram elements are automatically placed at the grid intersections-</li> <li>PNG Export exports the diagram as a PNG image.</li> <li>SVG Export exports the diagram as an SVG image.</li> <li>Clear Layout Info removes the stored layout information from the model which means that all manually placements of diagram elements and auto layout runs are not persisted anymore.</li> </ul>"},{"location":"extensions/editor/diagrams/#export-diagrams-as-svgpng","title":"Export Diagrams as SVG/PNG","text":"<p>Use the two buttons to export the diagram as an SVG or PNG. A notification will give you more options to interact with the exported image:</p> <p></p>"},{"location":"extensions/editor/diagrams/#clear-stored-layout-information","title":"Clear Stored Layout Information","text":"<p>When you store the layout data in the diagram, this button will delete the information from the model. Depending on your settings regarding auto-layout on init, the diagram will be auto-layouted the next time it is initialised or the layout information will just be gone:</p> <p></p>"},{"location":"extensions/editor/diagrams/#synchronize-diagram-with-model-only-on-opening","title":"Synchronize diagram with model only on opening","text":"<p>When the option <code>synchronize diagram with model only on opening</code> is enabled, the diagram is not updated automatically based on the model. The new diamond-shaped button has to be used to do this. The only time when the diagram is synchronized is when the diagram is initially initialized e.g. when creating the editor for a root node. The use case for this feature is that sometimes you want to edit the model in bulk before updating the diagram which can take a lot of time and disturb the editing experience.</p> <p></p>"},{"location":"extensions/editor/diagrams/#editor-context-actions-menu-show-diagram-actions","title":"Editor Context Actions Menu: Show Diagram Actions","text":"<p>Some of the MPS actions that are available in diagrams, can also be found in a separate menu that can be opened from the editor context menu:</p> <p></p>"},{"location":"extensions/editor/diagrams/#layout-algorithms","title":"Layout Algorithms","text":"<p>The language provides different layout algorithm options for diagram. Each algorithm computes the graph with specialized edges, routing and direction styles.</p> <p>The diagram languages uses the Eclipse Layout Kernel for layouting diagrams. Please read the page Algorithms - Eclipse Layout Kernel\u2122 for more information about each single algorithm. The following algorithms are implemented:</p> <ul> <li>ELK Box<ul> <li>Algorithm for packing of unconnected boxes, i.e. graphs without edges.</li> </ul> </li> <li>ELK DisCo <ul> <li>Arranges unconnected subgraphs while preserving their original layout. The subgraphs themselves are not automatically laid out.</li> <li>Ideal for scenarios where you need to organize separate components without altering their internal structure.</li> </ul> </li> <li>ELK Fixed<ul> <li>Keeps the current layout unchanged, allowing optional coordinates for nodes and edge bend points.</li> <li>Useful when you want to maintain a fixed arrangement or manually specify positions.</li> </ul> </li> <li>ELK Force<ul> <li>A force-based algorithm that simulates attractive and repulsive forces to balance node positions. Supports the Eades and Fruchterman-Reingold models.</li> <li>Great for achieving visually balanced layouts based on physical analogies.</li> </ul> </li> <li>ELK Layered<ul> <li>A layer-based algorithm for hierarchical graphs. Arranges nodes into layers, emphasizing edge direction. Supports various routing styles.</li> <li>Suitable for node-link diagrams with ports and hierarchical structures.</li> </ul> </li> <li>ELK Mr. Tree<ul> <li>Computes a spanning tree of the input graph and arranges nodes based on the resulting parent-children hierarchy.</li> <li>Perfect for tree-like structures, emphasizing regularity in acyclic graphs.</li> </ul> </li> <li>ELK Radial<ul> <li>Arranges nodes in concentric circles around a central point. Useful for radial diagrams or circular hierarchies.</li> <li>Provides a clear visual representation of relationships.</li> </ul> </li> <li>ELK Randomizer<ul> <li>Introduces randomness to node positions. Useful for exploring different layout variations.</li> <li>Can be handy during experimentation or visualization exploration.</li> </ul> </li> <li>ELK Rectangle Packing<ul> <li>Packs rectangles (representing nodes) into a container (graph canvas) while minimizing overlaps.</li> <li>Ensures efficient use of available space.</li> </ul> </li> <li>ELK SPOrE Compaction<ul> <li>A compaction algorithm that optimizes node placement within a layer.</li> <li>Helps reduce wasted space and improve readability.</li> </ul> </li> <li>ELK SPOrE Overlap Removal<ul> <li>Removes overlaps between nodes within a layer. Enhances clarity and aesthetics.</li> <li>Useful for improving the visual quality of layered layouts.</li> </ul> </li> <li>ELK Stress<ul> <li>Minimizes stress by adjusting node positions based on graph-theoretic distances. Useful for consistent geometric layouts.</li> <li>Balances edge lengths and maintains readability.</li> </ul> </li> <li>ELK Top-down Packing<ul> <li>Arranges nodes in a top-down manner, suitable for hierarchical structures. Supports aspect ratio control.</li> <li>Ensures a clear hierarchy with minimal edge crossings.</li> </ul> </li> </ul> <p>Note that not all algorithms support sub-diagrams, self-loops, ports or even boxes. The default algorithm is ELK Layered which is sufficient for most use cases. Each page contains a section Support options that explains the available options, e.g. Cycle Breaking Strategy. The Applies To block explains where the option is available. The parents option means that the style attribute must be set in the inspector of (sub-)diagrams cells, nodes options must be set in diagram.box definitions and cell options must be set in diagram.edge cells. Example: The style attribute of the cycle breaking strategy option of the layered algorithm is called diagram-layout-layered-cycle-breaking-strategy and needs to be set in the inspector of the diagram cell.</p>"},{"location":"extensions/editor/diagrams/#content","title":"Content","text":"<p>There are different types of contents you can add to the diagram: children, generic box queries, generic edge queries and nodesQuery.</p>"},{"location":"extensions/editor/diagrams/#diagram-box","title":"Diagram Box","text":"<p>Boxes are the building blocks of diagrams. They can be connected with each other or their ports through edges. They support the following options:</p> <ul> <li>id is the identifier that can be necessary if you have multiple boxes for the same node. You can create new IDs for a node through <code>EndpointUtil.createIdForSNode(thisNode)</code>.</li> <li>ports defines the connectable small boxes that are located at the edge of the box.</li> <li>preserve port order instructs the layouter to not change the port order.</li> <li>editor sets some MPS cells as the content of the box.</li> <li>shape defines how the box is rendered in the diagram.</li> <li>allow connections to box enables connections with the box itself without the need for ports.</li> <li>content can be populated like the content of diagrams.</li> <li>delete is called when the box is deleted.</li> <li>navigation targets are nodes that can be opened through buttons in the box\u2019s buttons menu. They are meant as references of the current box that can be navigated to.</li> <li>allow scaling enables changes the size of the box (default: true).</li> <li>annotation external fetches annotations and create separate boxes for them.</li> <li>drop handler is a handler that checks if elements can be dropped on this element (can drop(data)). This handler also contains a method drop(data) that is execution when the drop happens.</li> </ul>"},{"location":"extensions/editor/diagrams/#additional-box-actions","title":"Additional Box Actions","text":"<ul> <li>The <code>Fit size</code> action is available when a box is selected.</li> <li>A second button <code>Create connection</code> contains a submenu with all the defined connection creators. Use those buttons to create new connections.</li> <li>When the box has ports, there is an action \u201cReorder ports\u201d, to save the new port order in the model. Each port gets a port assigned based on the position at the box.</li> </ul>"},{"location":"extensions/editor/diagrams/#generic-box-query","title":"Generic Box Query","text":"<p>They are used to add boxes to the diagram based on a list of parameters and support the following options:</p> <ul> <li>parameter type sets the type of the list of parameters.</li> <li>query returns a list of parameters or a single parameter.</li> <li>id is the identifier that can be necessary if you have multiple boxes for the same node. You can create new IDs for a node through <code>EndpointUtil.createIdForSNode(thisNode)</code>.</li> <li>shape defines how the box is rendered in the diagram.</li> <li>ports defines the connectable small boxes that are located at the edge of the box.</li> <li>buttons sets the context buttons that are visible when the box is selected.</li> <li>preserve port order instructs the layouter to not change the port order. </li> <li>editor sets some MPS cells as the content of the box.</li> <li>allow connections to box enables connections with the box itself without the need for ports.</li> <li>delete is called when the box is deleted.</li> <li>navigation targets are nodes that can be opened through buttons in the box\u2019s buttons menu. They are meant as references of the current box that can be navigated to.</li> <li>allow scaling enables changes the size of the box (default: true).</li> <li>drop handler is a handler that checks if elements can be dropped on this element (can drop(data)). This handler also contains a method drop(data) that is execution when the drop happens.</li> </ul> <p>The current object from the query is available through <code>parameterObject</code>.</p>"},{"location":"extensions/editor/diagrams/#edges","title":"Edges","text":"<p>Edges are used to connect boxes or ports with each other. They support the following options:</p> <ul> <li>id is the identifier that can be necessary if you have multiple edges for the same node.</li> <li>from sets the source of the edge.</li> <li>to sets the target of the edge.</li> <li>reverse sets the source as the target of the edge and vice versa.</li> <li>label sets the text that describes the edge.</li> <li>use annotations from parent in label: If a model node had an attribute annotation and is used as an edge in a diagram, the attribute editor is added as an external box in the diagram. With this setting, the annotation is part of the edge label and thus also automatically layouted.</li> <li>delete is called when the edge is deleted.</li> <li>can split controls if the edge can be split and a new box be inserted.</li> <li>curved changes the style of the edge to curved. This information is considered by the auto layouter.</li> <li>edge style (experimental) changes the style of the edge to one of the predefined ELK edge types. Note: Setting this option currently breaks some functionality related to moving edges.</li> <li>navigation targets are nodes that can be opened through buttons in the box\u2019s buttons menu. They are meant as references of the current box that can be navigated to.</li> <li>drop handler is a handler that checks if elements can be dropped on this element (can drop(data)). This handler also contains a method drop(data) that is execution when the drop happens.</li> <li>content can be populated like the content of diagrams.</li> </ul>"},{"location":"extensions/editor/diagrams/#generic-edge-query","title":"Generic Edge Query","text":"<p>They are used to add edges to the diagram based on a list of parameters and support the following options:</p> <ul> <li>parameter type sets the type of the list of parameters.</li> <li>query returns a list of parameters or a single parameter.</li> <li>id is the identifier that can be necessary if you have multiple edges for the same node. You can use <code>parameterObject</code> to create an identifier if it is of type string.</li> <li>from sets the source of the edge.</li> <li>to sets the target of the edge.</li> <li>reverse sets the source as the target of the edge and vice versa.</li> <li>label sets the text that describes the edge.</li> <li>use annotations from parent in label: If a model node had an attribute annotation and is used as an edge in a diagram, the attribute editor is added as an external box in the diagram. With this setting, the annotation is part of the edge label and thus also automatically layouted.</li> <li>delete is called when the edge is deleted.</li> <li>can split controls if the edge can be split and a new box be inserted.</li> <li>split is the method that is called when the split happens. You can access the node to insert through boxToInsert.getSNode().</li> <li>curved changes the style of the edge to curved. This information is considered by the auto layouter.</li> <li>edge style (experimental) changes the style of the edge to one of the predefined ELK edge types. Note: Setting this option currently breaks some functionality related to moving edges.</li> <li>navigation targets are nodes that can be opened through buttons in the box\u2019s buttons menu. They are meant as references of the current box that can be navigated to.</li> <li>drop handler is a handler that checks if elements can be dropped on this element (can drop(data)). This handler also contains a method drop(data) that is execution when the drop happens.</li> </ul> <p>The current object from the query is available through <code>parameterObject</code>.</p>"},{"location":"extensions/editor/diagrams/#additional-edge-actions","title":"Additional Edge Actions","text":"<p>Edges can be hidden by clicking on the button in the edge menu or by hiding all edges by clicking the Hide All Edges button in the box menu. There is a separate button Show All Edges to show all edges of a box again. The information about the visibility of an edge is saved in the model (in the layout annotation).</p> <p> </p>"},{"location":"extensions/editor/diagrams/#from-and-to-declaration","title":"From and To Declaration","text":"<p>Those two declarations set the point where the edge begins (from) and ends (to). They have the following options:</p> <ul> <li>target sets the end point. It can be a box, a port or a conditional if expression.</li> <li>can set target checks if the target is valid. The parameter targetDNode refers to the internal representation of the target box in the diagramming library. The parameter port refers to the name of the target port and can be empty.</li> <li>set target is called to set the target.</li> <li>shape sets the shape of the endpoint of the connection.</li> <li>shape size (px) defines the size of the shape.</li> <li>auto layout: allow any size (deprecated, unused) tells the layouter, if the edge can be connected on any side of a box.</li> <li>role cell: sets the MPS cell used to visualize the endpoint.</li> </ul>"},{"location":"extensions/editor/diagrams/#child-and-nodesquery","title":"Child and nodesQuery","text":"<p>Existing children can be added through the code completion menu. They should have editors containing diagram box, diagram edge or diagram cells. To include arbitrary nodes, use a nodesQuery and return a sequence of nodes that serve as the content of the diagram.</p>"},{"location":"extensions/editor/diagrams/#ports","title":"Ports","text":"<p>Ports can be declared statically or through a port query where you can return a list of objects/nodes in the query itself. The information can be used in the port declaration itself through <code>portObject</code>. A port has the following options:</p> <ul> <li>label declares a text next to the port that describes it.</li> <li>shape defines how the port is rendered in the diagram.</li> <li>positionX declares the horizontal position of the port. The value can go from 0 (left) to 1 (right). The default value is 0.</li> <li>positionY declares the vertical position of the port. The value can go from 0 (top) to 1 (bottom). The default value is 0.5 (center).</li> <li>width sets the width of the port.</li> <li>height sets the height of the port.</li> <li>tooltip is a tooltip with an embedded MPS cell that is shown when the mouse hovers over the port.</li> </ul>"},{"location":"extensions/editor/diagrams/#additional-features","title":"Additional features","text":""},{"location":"extensions/editor/diagrams/#compartment-cells","title":"Compartment cells","text":"<p>Compartment cells can be used as separators in diagram boxes and labels and have a size of 2x2.</p>"},{"location":"extensions/editor/diagrams/#cross-navigation","title":"Cross-Navigation","text":"<p>The editor of the diagram cell now has a new option disable node editing which makes it possible to disable the MPS editor that opens when you double-click a node in the diagram. Do customize the click event when clicking an MPS cell in the editor (e.g. the box\u2019s content or the label of an edge), you can register a custom mouse listener for the GlobalDiagramMPSCellClickListener extension point. To register a global diagram mouse listener, use the extension point GlobalDiagramMouseListener instead:</p> <p></p> <p>In the demo, a notification is created, when you single-click an entity box:</p> <p></p> <p>To customize the click into the MPS cell, use the extension point GlobalDiagramMPSCellClickListener and implement the class MPSCellMouseListener.</p>"},{"location":"extensions/editor/diagrams/#action-switch-all-ports-side","title":"Action: Switch All Port\u2019s Side","text":"<p>There are two actions <code>Switch All Port's Side Clockwise</code> and <code>Switch All Port's Side Counter-Clockwise</code> to move the ports to the next side of the box.</p>"},{"location":"extensions/editor/diagrams/#action-flip-all-ports-side-vertically","title":"Action: Flip All Port\u2019s Side Vertically","text":"<p>Use the actions <code>Diagram: Flip All Port's Side Vertically</code> and <code>Diagram: Flip All Port's Side Horizontally</code> to switch all ports to be on the opposite side (east-west, north-south).</p>"},{"location":"extensions/editor/diagrams/#smart-guide","title":"Smart Guide","text":"<p>When you move boxes, green guidelines will help you with aligning the boxes with other diagram elements.</p>"},{"location":"extensions/editor/diagrams/#example-from-mbeddr","title":"Example from Mbeddr","text":"<p>The following screenshots show component wiring and state machines that can be edited graphically.</p> <p></p> <p>This screenshot shows a few interesting features: you can embed diagrams anywhere in \u201ctext\u201d, you can use different shapes (at this point drawn by custom Java code), you can use various line styles, the framework supports ports (i.e., connection endpoints on the boxes), inside boxes you can use arbitrary MPS text (or other) editors, and the system also supports edge and endpoint labels. Port labels are also supported, but they are only shown if the mouse is \u201cin the vicinity\u201d of the port to not clutter the diagram. Below is a second screenshot of a bigger diagram:</p> <p></p> <p>This one illustrates that the approach scales to reasonable sizes, shows that zooming is supported and also demonstrates the auto layouting capability. The graphical notation also integrates with things such as tooltips. Below is another example diagram that shows a different language:</p> <p></p> <p>The definition of a graphical editor is based on the same \u201ccell\u201d abstraction used in other MPS editors: the language for defining editors contains additional cells that are then rendered as a diagram (diagram, diagram.box, diagram.edge). Similar to tables, these abstractions for defining graphical editors rely on queries to make sure that the structure of the graphical editor does not have to directly correspond to the structure of the AST (for example, in terms of ownership). The language also supports hierarchical diagrams, for example, in state machines.</p> <p>To see example code, check out InstanceConfiguration and Statemachine in the mbeddr repository.</p>"},{"location":"extensions/editor/diagrams/#sandboxes","title":"Sandboxes","text":"<p>The MPS-extensions project comes with a few sandboxes including the sandbox <code>de.itemis.mps.editor.diagram.demo.elk.sandbox</code>. You can find all the style sheet declarations by importing the corresponding style sheet: DiagramCoreAttributes, DiagramMPSAttributes, DiagramAlgorithmAttributes</p> <p>To play around with ELK features in general, you can visit: https://rtsys.informatik.uni-kiel.de/elklive/examples.html</p> <p>Please note that not all algorithms make sense with all diagrams. Most of the time, you still want to use the ELK layered algorithm because it has the most options and has support for self-loops, inside self-loops, multi-edges, edge labels, parts, compound nodes, and clusters. Some of them need manual layouting first. Please consult the ELK algorithms documentation for more information.</p> <p></p> <p></p>"},{"location":"extensions/editor/diagrams/#interacting-with-diagrams-programmatically","title":"Interacting with diagrams programmatically:","text":"<p>Most diagram actions that can be executed from buttons can be found in DiagramActionsUtil. Diagram functionalities can be tested in editor tests. It is important to disable the synchronizer, so that changes are not written to the original model. When comparing positions and dimensions of diagram elements, keep in mind that they might change a bit because the auto-layouter is not fully deterministic. Example:</p> <pre><code>RootDiagramECell diagramECell = EditorUtil.descendants(editor component.getRootCell(), RootDiagramECell.class).get(0); \nJGraphModelSynchronizer synchronizer = JGraphModelSynchronizer.getSynchronizer(diagramECell.getDiagramModel()); \nsynchronizer.suspend({ =&gt; \n  mxCell diagramDCell = diagramECell.getDCell(diagramECell.getGraph()); \n  BoxDCell box1 = diagramDCell.getChildrenx().first as BoxDCell; \n  Bounds originalBounds = new  Bounds(44.0, 12.0, 68.0, 33.0); \n  TestUtils.boundsAreApproximatelyEqual(originalBounds, box1.getBoundsx()); \n  ThreadUtils.runInUIThreadAndWait({ =&gt; synchronizer.suspend({ =&gt; box1.setSizex(100, 100); }); }); \n  TestUtils.boundsAreApproximatelyEqual(new  Bounds(44.0, 12.0, 100.0, 100.0), box1.getBoundsx()); \n  ThreadUtils.runInUIThreadAndWait({ =&gt; synchronizer.suspend({ =&gt; box1.setPositionx(200, 200); }); }); \n  TestUtils.boundsAreApproximatelyEqual(new  Bounds(200, 200, 100.0, 100.0), box1.getBoundsx()); \n  ThreadUtils.runInUIThreadAndWait({ =&gt; synchronizer.suspend({ =&gt; diagramECell.getDiagramModel().getLayouter().layout(diagramECell.getGraph(), new  EmptyProgressIndicator()); }); }); \n  TestUtils.boundsAreApproximatelyEqual(originalBounds, box1.getBoundsx()); \n});\n</code></pre>"},{"location":"extensions/editor/diagrams/#issues","title":"Issues","text":"<p>There\u2019s a meta issue for known issues.</p>"},{"location":"extensions/editor/diagrams/#blog-posts","title":"Blog posts","text":"<ul> <li>JetBrains MPS: The Diagram Language | tillschallau.de</li> </ul>"},{"location":"extensions/editor/grammar-cells/","title":"Grammar Cells","text":"<p>Language Namespace : <code>com.mbeddr.mpsutil.grammarcells</code></p> <p>Grammar Cells are an alternative approach to the MPS transformation language for declaratively specifying textual notations and their interactions for the MPS editor:</p> <ul> <li>paper</li> <li>video introduction</li> </ul> <p>The following editor cells are available:</p>"},{"location":"extensions/editor/grammar-cells/#grammarflag","title":"grammar.flag","text":"<p>A cell that represents a boolean flag. It can be used for boolean properties.  The creation of the node is triggered when the matching text is entered (substitution). When the cursor is placed at the   right position in the editor, the text can also be entered when the node already exists. In this cases, the text of the   flag is shown in the editor and the boolean property is set (side transformation). The flag can be deleted with the normal MPS delete shortcuts.</p> <p></p>"},{"location":"extensions/editor/grammar-cells/#supported-properties","title":"Supported properties","text":"<ul> <li>text: the text to match</li> <li>inverted: invert the semantic of the boolean flag (for example: entering the text changes the boolean flag to false)</li> <li>substitute condition: activate substitutions only when a custom condition is met</li> <li>side transform condition: activate side transformations only when a custom condition is met</li> <li>do not generate node substitute action: disable the substitution action completely</li> <li>description: the text that\u2019s shown in the code completion menu on the right side</li> </ul>"},{"location":"extensions/editor/grammar-cells/#grammarconstant","title":"grammar.constant","text":"<p>A dynamic constant text: this cell supports displaying dynamic text similar to the read only model accessor. It\u2019s most popular use case is as the alias cell for the operator of an expression such as a binary expression.</p> <p></p>"},{"location":"extensions/editor/grammar-cells/#grammaroptional","title":"grammar.optional","text":"<p>A cell that supports entering an optional text to add an optional containment link of a node such as  an optional child. The same way the grammar.flag cell works, node substitutions and side transformations are supported.</p>"},{"location":"extensions/editor/grammar-cells/#supported-properties_1","title":"Supported properties","text":"<ul> <li>transformation text: the text that must be matched. When the optional cell contains a collection cell, it\u2019s assumed   that the first cell is a constant cell and its text is used as the transformation text.</li> <li>generate insert action: TODO</li> <li>post process: a function that\u2019s executed after the invocation of the side transformation/node substitution.</li> <li>description: a text that\u2019s shown in the code completion menu on the right side</li> </ul>"},{"location":"extensions/editor/grammar-cells/#grammarwrap","title":"grammar.wrap","text":"<p>A cell that lets you enter a child in a context where a parent is expected (e.g. enter the type of a   variable declaration to create the declaration itself). The editor cell of th child is wrapped and the instantiation of the  child is triggered. It can be used for containment links of children with mandatory (1) or optional (0..1) cardinality.</p>"},{"location":"extensions/editor/grammar-cells/#supported-properties-side-transformations","title":"Supported properties (side transformations)","text":"<ul> <li>condition: the trigger condition of the side transformation (default: true)</li> <li>remove: a list of concepts where the side transformation should not be added</li> <li>left text: the text of the left side transformation</li> <li>right text: the text of the right side transformation</li> <li>post process: a function that\u2019s executed after the invocation of the side transformation</li> </ul>"},{"location":"extensions/editor/grammar-cells/#supported-properties-node-substitution","title":"Supported properties (node substitution)","text":"<ul> <li>condition: the trigger condition of node substitution</li> <li>focus wrapped: set the focus to the newly created node (default: false)</li> <li>post process: a function that\u2019s executed after the invocation of the side transformation</li> <li>description: the text that\u2019s shown in the code completion menu on the right side</li> </ul>"},{"location":"extensions/editor/grammar-cells/#grammarsubstitute","title":"grammar.substitute","text":"<p>a cell that surrounds a constant cell to support substitution of the underlying concept with  another one. When there\u2019s a need to customize the completion menu, use the cell <code>grammar.nodeSubstitution</code> instead. </p>"},{"location":"extensions/editor/grammar-cells/#supported-properties_2","title":"Supported properties","text":"<ul> <li>description: a text that\u2019s shown in the code completion menu on the right side</li> </ul>"},{"location":"extensions/editor/grammar-cells/#grammarbrackets","title":"grammar.brackets","text":"<p>A cell for implementing brackets such as braces or parenthesis. The opening and closing symbols must be provided. You can enter the opening symbol and then the closing symbol or vice versa to create a new instance of the concept that uses this cell e.g. 1+2*3 -&gt; (1+2*3 -&gt; (1+2*3). The PlusExpression is now surrounded by a ParenthesesExpression.</p> <p></p>"},{"location":"extensions/editor/grammar-cells/#grammarrules","title":"grammar.rules","text":"<p>Grammar cells can be surrounded by these cells to handle precedence and associativity. Structural changes in the cell trigger   linearization, parsing, and reshuffling of the AST (more info can be found in the paper). The contained cell structure will  be processed using the built-in parser. In the properties of this cell, the subconcept can be referenced by the   variable with the same name.</p>"},{"location":"extensions/editor/grammar-cells/#supported-properties_3","title":"Supported properties","text":"<ul> <li>left associative: enable left associativity</li> <li>priority: the precedence of this concept.</li> <li>grammar.splittable: this cell wraps a child whose value can be split by typing specific characters. There  are builtin tokenizers for number literals and strings. Don\u2019t forget to define a property constraint. The tokenizer is  only invoked if the entered text isn\u2019t a valid property value. Example: <code>12</code> -&gt; type \u201c+\u201d between the two numbers -&gt; the node  gets transformed into a plus expression: <code>1 + 2</code>.</li> </ul>"},{"location":"extensions/editor/grammar-cells/#general-notes","title":"General notes","text":"<p>The side transformations are implemented with custom concept in this language: <code>grammar.sideTransform0</code>, <code>grammar.sideTransformation</code>,  <code>grammar.sideTransformation3</code>, and <code>SideTransformationCell4</code>. They can be used instead of the MPS transformation language   when the provided cells don\u2019t handle a specific scenario.</p>"},{"location":"extensions/editor/linenumbers/","title":"Line Numbers","text":"<p>This plugin enables line numbers in the left gutter of the editor:</p> <p></p> <p>Right-click the gutter and click <code>Disable/Enable Line Numbers</code> to toggle this feature.</p>"},{"location":"extensions/editor/math/","title":"Math languages","text":""},{"location":"extensions/editor/math/#math","title":"Math","text":"<p>Language Namespace : <code>de.itemis.mps.editor.math</code></p> <p>This language provides a math cell that is used for all math based concepts. It can also be used for creating complex  layout that can\u2019t be achieved with the normal Editor cells.</p> <p></p> <p>First you have to add some child cells. The need to have a name and a scale from 0 to 1. Next, some symbols can be added. A symbol is a node that basically contains a paint method where you can draw anything within the bounds. The paint method uses a swing Graphics object to draw on. For more information about Swing, visit The Oracle 2D Graphics page, especially the section  Drawing Geometric Primitives. The method update dimension can be used to set the size of the symbol. The symbols can be painted by calling the <code>paint</code> method.</p> <p>Example: <pre><code>symbol ArrowLeft { \n  paint: (g, bounds)-&gt;void { \n    double triangleWidth = bounds.getHeight() * 2; \n    triangleWidth = Math.min(triangleWidth, bounds.getWidth() / 2); \n\n    g.draw(new Line2D.Double(bounds.getMinX(), bounds.getCenterY(), bounds.getMaxX() - triangleWidth, bounds.getCenterY())); \n\n    Path2D.Double triangle = new Path2D.Double(); \n    triangle.moveTo(bounds.getMaxX(), bounds.getCenterY()); \n    triangle.lineTo(bounds.getMaxX() - triangleWidth, bounds.getMinY()); \n    triangle.lineTo(bounds.getMaxX() - triangleWidth, bounds.getMaxY()); \n    g.fill(triangle); \n  } \n\n  update dimension: (dimension)-&gt;void { \n    dimension.height = Math.pow(dimension.width, 0.4); \n    dimension.height = Math.max(dimension.height, 5); \n  } \n}\n</code></pre></p> <p>After settings some variables and initializing the cell in the <code>init</code> method, the cells have to be placed in the <code>layout</code> method. The dimensions of the child cells should fit into the bounds of the math cells. The <code>paint</code>method can be used. The <code>getCenterY</code> method should specify the vertical center of the math cell.</p> <p>Example: generator for an editor of a fraction expression:</p> <pre><code>math { \n  child cells: upper $COPY_SRC$&lt;constant&gt; 1.0 \n               lower $COPY_SRC$&lt;constant&gt; 1.0 \n  symbols: &lt;&lt; ... &gt;&gt; \n\n  variables: &lt;&lt; ... &gt;&gt; \n\n  init: &lt;no initFunction&gt; \n\n  layout: (childCells, cell, symbols)-&gt;void { \n    cell.setWidth(Math.max(upper.getWidthInt(), lower.getWidthInt())); \n    upper.setX((cell.getWidthInt() - upper.getWidthInt()) / 2); \n    lower.setX((cell.getWidthInt() - lower.getWidthInt()) / 2); \n    upper.setY(0); \n    lower.setY(upper.getHeightInt() + 3); \n  } \n\n  paint: (g, childCells, cell, symbols)-&gt;void { \n    int x = Math.min(lower.getXInt(), upper.getXInt()); \n    int x2 = Math.max(lower.getXInt() + lower.getWidthInt(), upper.getXInt() + upper.getWidthInt()); \n    g.setStroke(new BasicStroke(2.0f)); \n    g.drawLine(x, lower.getYInt() - 2, x2, lower.getYInt() - 2); \n  } \n\n  getCenterY: (childCells, cell)-&gt;int { \n    upper.getHeightInt(); \n  } \n}                     \n</code></pre> <p>The math cell supports two style attributes:</p> <ul> <li>math-symbol-color: the color of the math symbol</li> <li>side-tranformation-helper-cells: cells are added to the left and right side of the math cell so that side transformations  work. The default value is true.</li> </ul>"},{"location":"extensions/editor/math/#math-notations","title":"Math Notations","text":"<p>Language Namespace : <code>de.itemis.mps.editor.math.notations</code></p> <p></p> <p>This language implements standard math cells that can be used in any editor:</p> <ul> <li>math.above: cell with a symbol above another cell (e.g. the vector symbol)</li> <li>math.abs: vertical lines to the left and right of the cell (e.g. absolute value: |x|)</li> <li>math.abstract-loop: base cell for loop cells such as product and sum signs</li> <li>math.loop: base cell for loop cells such as sum signs</li> <li>math.overreachingLoop: overreaching loop cell</li> <li>math.brackets: cell that can draw brackets. The left and right bracket has to be provided as symbols.</li> <li>math.curly-brackets: curly brackets: { x }</li> <li>math.parentheses: parentheses: ( x )</li> <li>math.square-brackets: square brackets: [ x ]</li> <li>math.overreachingBrackets: overreaching brackets cell</li> <li>math.integral-custom: custom integral symbol with optional upper/lower limit and variable and a custom symbol</li> <li>math.integral an integral symbol with optional parentheses </li> <li>math.division: an upper and lower cell separated by a line</li> <li>math.nroot: cell for nth root expressions</li> <li>math.sqrt: cell for root expressions </li> <li>math.superscript: cell for superscript text, also known as exponential expression in math: 2^3</li> <li>math.subscript: cell for subscript text</li> <li>math.product: cell for the math sigma notation</li> <li>math.subscripted-function: cell for functions that have a subscripted text (e.g. logN)</li> <li>math.sum: cell for the math pi notation</li> </ul>"},{"location":"extensions/editor/math/#java-math","title":"Java Math","text":"<p>Language Namespace : <code>de.itemis.mps.editor.math.java</code></p> <p>This language implements some common math symbols as Base language expressions</p> <ul> <li>abs: absolute value expression</li> <li>cosine: cosine expression</li> <li>{: an expression surrounded by curly brackets</li> <li>frac: fractional expression</li> <li>integral: definite integral expression</li> <li>nroot: nth root expression</li> <li>pi: pi constant</li> <li>pow: exponential expression</li> <li>product: pi notation expression</li> <li>sin: sine expression</li> <li>sqrt: square root expression</li> <li>[: an expression surrounded by square brackets</li> <li>sum sigma notation expression</li> </ul>"},{"location":"extensions/editor/mouse-selection/","title":"Intentions for custom selections","text":"<p>Language Namespace : <code>de.itemis.mps.selection.intentions</code></p> <p>This language adds support for adding intentions for selections. Normally, you want to use the class NodeRangeSelection which is the default type of selection in MPS. If you have implemented a custom selection, you can of course use it instead (example: TableRangeSelection in tables). Use one of the <code>get</code> methods of the selection variable to return the selected  nodes or cells. There are some other methods in the class AbstractMultipleSelection that you may find useful as well.</p>"},{"location":"extensions/editor/mouse-selection/#example","title":"Example","text":"<pre><code>intention SurroundListWithIndent for selection NodeRangeSelection {                                                                                                                                                                                       \n    description(selection)-&gt;string { \n      \"Surround with Indent Collection\"; \n    }                                                                                                                                                                                                                                           \n    isApplicable(selection)-&gt;boolean { \n      selection.getFirstNode().isInstanceOfConcept(concept/IText/); \n    }                                                                                                                                \n    execute(selection)-&gt;void { \n      nlist&lt;IText&gt; nodes = (nlist&lt;IText&gt;) selection.getSelectedNodes(); \n      node&lt;IText&gt; ile = nodes.first; \n      node&lt;SpaceIndentedText&gt; parent = ile.replace with new(SpaceIndentedText); \n      nodes.forEach({~it =&gt; parent.lines.add(it); }); \n\n}\n</code></pre>"},{"location":"extensions/editor/multiline/","title":"Multiline","text":"<p>Language Namespace : <code>de.slisson.mps.editor.multiline</code></p> <p>The <code>multiline</code>cell adds support for text blocks that spans multiple lines. Line breaks are saved as new line characters (\\n) in the backing property. The richtext language uses this language.</p> <p>The language implements two editor cells: EditorCell_Multiline and EditorCell_Word with special handling for navigation, text selection (MultilineSelection), and copy and pasting the text to the clipboard.</p>"},{"location":"extensions/editor/pagination/","title":"Pagination","text":"<p>This language adds a new editor cell <code>paginate</code> that can split up list of nodes into pages that can be shown individually in the editor:</p> <p></p>"},{"location":"extensions/editor/pagination/#features","title":"Features","text":"<ul> <li>Use the up and down arrows to navigate to the next page or enter a page number directly.</li> <li>You can search for elements directly through the search bar.<ul> <li>Match Case activates case-sensitive matching of terms</li> <li>Regex activates regular expression support in the search bar.</li> <li>Words activates search for a whole word within the element.</li> </ul> </li> </ul>"},{"location":"extensions/editor/pagination/#editor-cell","title":"Editor Cell","text":"<p>The editor cell itself needs a reference to the list of node and additionaly supports to set the size of an individual page through with page size. The default size is 1.</p>"},{"location":"extensions/editor/querylist/","title":"Query List","text":"<p>Language Namespace : <code>de.itemis.mps.editor.querylist</code></p> <p>The querylist cell allows displaying arbitrary nodes in the editor.</p>"},{"location":"extensions/editor/querylist/#supported-properties","title":"Supported properties","text":"<ul> <li>query: a list of nodes that are shown in the editor</li> <li>elements concept: the concept of the queried nodes</li> <li>duplicates safe: there might be issues with displaying the same node multiple times in the editor. Enabling or disabling   this flag can help with this issue.</li> <li>insert new: a function that\u2019s called when the insert action is invoked.</li> <li>delete element: a function that\u2019s called when the delete/backspace action is invoked</li> <li>substitute info: a custom completion menu entry</li> <li>uses braces: use braces around the collection</li> <li>uses folding: use folding provided by the collection cell</li> <li>collapse by default: a function that decided if the cell should be collapsed by default</li> <li>disable model checking: don\u2019t show model check errors</li> </ul> <p>The editor is set to readonly by default. The language supports nodes that can be edited but be aware that you might run into issues when the same node is shown multiple times in the same editor.</p> <p></p>"},{"location":"extensions/editor/querylist/#known-limitations","title":"Known limitations","text":"<p>Some issues arise, when you try to show the same node multiple times in the same editor: folding buttons might disappear, the cursor might jump to the wrong part of the editor etc. You can play around with the duplicates safe flag but this is a limitation of MPS that can\u2019t be fixed at the moment.</p>"},{"location":"extensions/editor/querylist/#blog-posts","title":"Blog posts","text":"<ul> <li>Using the diagram editor and querylist: let\u2019s build a graphical structure editor for MPS | dslgroundry.com</li> </ul>"},{"location":"extensions/editor/richtext/","title":"Richtext","text":"<p>Language Namespace : <code>de.slisson.mps.richtext</code></p> <p>This language adds support for non-structured, multi-line text editing cells. Nodes can be embedded inside the text. A checking rule enforces that the text is normalized: there has to be at least one child, it must start with a Word and a Word must always be between two embedded nodes and there are can\u2019t be two consecutive Words. There is also the language <code>jetbrains.mps.lang.text</code> which is an official JetBrains language and works a bit differently. It is line-based and has built-in support for paragraphs, bullet points, urls and other features. The richtext language uses the multiline language to allow editing of multiline text with nodes that can be inserted between these text cells. The The language should be considered a building block for other concepts such as paragraphs and consists of three concepts.</p> <p>The base interface <code>IWord</code> is used for text and embeddable nodes. Implement the method <code>toTextString()</code> to make it possible to copy the node as text to the clipboard. For multiline text there\u2019s already the concept <code>Word</code>. </p> <p>The following screenshot shows a simple example from the mbeddr documentation language.</p> <p></p> <p>All the different looking strings (e.g. @sect, @node, footnode) are implemented as concepts that implement IWord.</p>"},{"location":"extensions/editor/richtext/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>This languages add additional keyboard shortcuts to the editor:</p>"},{"location":"extensions/editor/richtext/#windowslinux","title":"Windows/Linux","text":"Shortcut Description Ctrl+A select the full text Ctrl+Backspace delete text until the start of the word Ctrl+Del delete text until the end of the word Ctrl+Shift+Backspace delete text until the start of the line Ctrl+Shift+Del delete text until end of the line Shift+Left increase selection to the character to the left Shift+Right increase selection to the character to the right Alt+Shift+Left increase selection to the start of the word Alt+Shift+Right increase selection to the end of the word Ctrl+Shift+Home increase selection to the start of the full text Ctrl+Shift+End increase selection to the end of the full text"},{"location":"extensions/editor/richtext/#mac","title":"Mac","text":"Shortcut Description Cmd+A select the full text Cmd+Backspace delete text until the start of the word Cmd+Del delete text until the end of the word Cmd+Shift+Backspace delete text until the start of the line Cmd+Shift+Del delete text until end of the line Shift+Left increase selection to the character to the left Shift+Right increase selection to the character to the right Alt+Shift+Left increase selection to the start of the word Alt+Shift+Right increase selection to the end of the word Cmd+Shift+Fn+Left increase selection to the start of the full text Cmd+Shift+Fn+Right increase selection to the end of the full text"},{"location":"extensions/editor/richtext/#compatibility-with-the-text-language-jetbrainsmpslangtext","title":"Compatibility with the Text language( jetbrains.mps.lang.text)","text":"<p>Both languages have similar goals but are not compatible with each other. The text language is line based and has builtin support for some formatting options like bold, italic, underlined and some  other features such as bullet and numbered lines. The Richtext language doesn\u2019t have those features but was built with extensibility in mind. Some mentioned features are implemented in the mbeddr.doc language instead. While the text language looks to have all necessary features to replace the richtext language, it can\u2019t be extended that easily. Before you try to migrate to it, please keep that in mind and do some experiments to check if the switch is possible.</p>"},{"location":"extensions/editor/tables/","title":"Tables","text":"<p>Language Namespace : <code>de.slisson.mps.tables</code></p> <p>As the name already implies, this cell adds support for tables. The table is internally represented with objects of the interface ITableGrid. The supported contents of the cell are explained in the following sections. The table doesn\u2019t have to be declared in the editor of one single concept: the declaration of vertical or horizontal rows can also be done in other editors by using the <code>partial table</code> cell.</p> <p></p>"},{"location":"extensions/editor/tables/#supported-properties","title":"Supported properties","text":"<ul> <li>header alignment disabled: don\u2019t align the headers with the rest of the table</li> <li>grid post processor: a function that\u2019s invoked after the editor cells of this language were created. It can be used,  for example, to set some additional cells, or add some dynamic row or column headers.</li> <li>disable left row end cells: there\u2019s a special cell to the left of table rows that\u2019s used, for example, for inserting  new table rows. This flag can disable this cell (default: false).</li> <li>disable right row end cells: there\u2019s a special cell to the left of table rows that\u2019s used, for example, for inserting     new table rows. This flag can disable this cell (default: false).</li> <li>row UI actions (experimental): add actions to the MPS toolbar to add a new row above/below the current row or to delete the current row. These actions only work for simple tables that are based on rows (default: false).</li> </ul>"},{"location":"extensions/editor/tables/#cell","title":"Cell","text":"<p>A cell is the smallest unit of a table. It contains the content and can contain a column (<code>c&lt;&gt;</code>) or row header (<code>r&lt;&gt;</code>). The <code>show if</code> property in the inspector can be used to tie the visibility of the cell to a condition.</p>"},{"location":"extensions/editor/tables/#horizontal-and-vertical","title":"Horizontal and Vertical","text":"<p>The <code>horizontal%</code>/<code>vertical%</code> cell can be used to display children in the editor. The link declaration must be set. The row and column headers can also be set. To specify the horizontal/vertical content in a dynamic way, use the cell <code>horizontal</code>/<code>vertical</code>. They support the same content as the table cell itself.</p>"},{"location":"extensions/editor/tables/#query","title":"Query","text":"<p>A table cell query is the easiest way to create a full table.</p>"},{"location":"extensions/editor/tables/#supported-parameters","title":"Supported parameters","text":"<ul> <li>shared variables: variables that can be accessed by the other parameters</li> <li>initialize: a function that initialized the shared variables or other code</li> <li>column count: the number of columns to display</li> <li>row count: the number of rows to display</li> <li>cell: a function that creates the cell itself. Cells can be created automatically by providing a node or a string   property. The cell or a list of cells can also be created by creating an instance of one of the <code>EditorCell</code> classes. If you want to create a cell dynamically and want to use the normal editors for creating editor, you can invoke the method  <code>editorContext.createCell</code> which takes a node as a parameter and a suitable editor declaration for the provided node.  At the end, the type of collection must be specified (vertical list/cells, horizontal list/cells).</li> <li>substitute node: the concept or a link declaration can be selected for the substitution menu. The function must perform  the substitution itself e.g. replacing an old node in the table with the new node.</li> <li>can create: a query that specifies if the cell at the column and row index can be created. Alternatively, only a row or column  can be allowed to be created.</li> <li>column header: a query for creating the column headers</li> <li>row header: a query for creating the row headers</li> </ul>"},{"location":"extensions/editor/tables/#grid-query","title":"Grid query","text":"<p>The grid query is an even lower level form of declaration a table. It works by setting the cells directely in the grid object of type <code>ITableGrid</code>. There are various set methods that can be used to create the table such as <code>grid.setCell()</code>  or <code>grid.setColumnHeader</code>. To support code completion, the substitution info must be set by calling <code>grid.setSubstituteInfo</code> for every cell by using its column and row index as a substitute info node as parameters. The substitute info node can be created manually or by using one of the methods of the <code>substituteInfoFactory</code> method (e.g. forChild() or forEmptyList()).</p>"},{"location":"extensions/editor/tables/#header","title":"Header","text":"<p>The header cells can also be created in different ways:</p> <ul> <li>\u201c: a constant text</li> <li>#: a reference to an existing header node </li> <li>[: an editor cell</li> <li>{: a list of header nodes</li> <li>query: this option gives the most flexibility. The headers can be created the same way as in the table cell query.</li> </ul> <p>Header cells are automatically merged together when they have the same content.</p> <p>To work around this issue with custom cells, set the cell ID\u2019s manually depending on the current cell index. Example:</p> <pre><code>EditorCell cell = editorContext.createCell(node2, -&gt; ...); \ncell.setCellId(cell.getCellId() + \"_\" + rowIndex);\n</code></pre>"},{"location":"extensions/editor/tables/#patterns","title":"Patterns","text":"<p>As can be seen in the previous description, many ways exist to create tables. This section shows some common ways to achieve it:</p> <p>Variant 1: one editor for a table with rows (vertical), columns (horizontal) + query for selecting the nodes for the cells.</p> <pre><code>table {\n    vertical c&lt;query{}&gt; {\n        horizontal r&lt;query{} &gt; {\n            query {}\n        }\n    }\n}\n</code></pre> <p>The queried node contains a partial table:</p> <pre><code>partial table {\n cell c&lt;&gt; r&lt;&gt;\n}\n</code></pre> <p>Variant 2: one editor for a table with rows</p> <pre><code>table {\n    vertical% r&lt;&gt; c&lt;&gt;\n}\n</code></pre> <p>The row itself contains a partial table that creates the columns with special cells for the column headers. The first column is created using a table-cell cell, the others using a grid query.</p> <pre><code>partial table {\n  cell {name} c&lt;ID&gt; r&lt;&gt;\n  gridquery {}\n\n}\n</code></pre> <p>Variant 3: one editor for a table with column headers</p> <pre><code>table {\n    column headers { ... }\n    cells:\n        vertical%rows r&lt;&gt; c&lt;&gt;\n}\n</code></pre> <p>There\u2019s a specific concept for rows with the following editor:</p> <pre><code>partial table {\n    horizontal r&lt;&gt; {\n        cell {name}\n        query {\n\n        } \n    }\n}\n</code></pre> <p>For the cell there is also an extra node which just holds the content itself:</p> <pre><code>[&gt; % value % &lt;]\n</code></pre> <p>Variant 4: a completely dynamically created table using grid query</p> <pre><code>table {\n    gridquery {}\n}\n</code></pre>"},{"location":"extensions/editor/tables/#alternatives","title":"Alternatives","text":"<p>For simple instances, you might consider using a MPS collection with a <code>vertical</code> grid layout instead. It has a much better performance and can be easier to use.</p>"},{"location":"extensions/editor/tables/#blog-posts","title":"Blog posts","text":"<ul> <li>Tabular projections in Jetbrains MPS: let\u2019s start building an accounting system | strumenta.com</li> <li>Using the diagram editor and querylist: let\u2019s build a graphical structure editor for MPS | dslgroundry.com</li> </ul>"},{"location":"extensions/editor/tree-notation/","title":"Tree Notation","text":"<p>Language Namespace : <code>com.mbeddr.mpsutil.treenotation</code></p> <p>The tree notation language adds support for cells that can render tree-like structures. Add a new <code>treeCell</code> to the editor. The root of the tree is a cell that should be declared above the \u201c/|\" text. Below, the child cells can be added. There can be an unlimited number of levels of tree cells with children.</p> <p>The following layouts are supported:</p> <ul> <li>default tree layout layouts the tree from top to bottom unless tree-left-to-right is set. The lines from the root take the direct paths to the children.</li> <li>orthogonal tree layout is the same as the default layout but the lines from the root to the children are drawn orthogonally</li> <li>compact tree layout extends the orthogonal tree layout and adds a button for expanding and collapsing the tree</li> </ul> <p></p> <p>The following style attributes are supported:</p> <ul> <li>tree-left-to-right layouts the tree from left to right instead of top to bottom.</li> <li>tree-node-spacing is the space between child nodes (default: 10, unit: pixel).</li> <li>tree-node-spacing is the space between different levels of the tree (default: 35, unit: pixel).</li> <li>tree-incoming-line-color is the color of the line from the root cell to the child cell (default: black).</li> <li>tree-incoming-line-width is the thickness of the line from the root cell to the child cell (default: 1, unit: pixel).</li> <li>tree-incoming-shape is the space at the end of the line from the root cell to the child cell.</li> <li>tree-transparent-collection: when a <code>TreeCell</code> is queried from the editor, and the current cell is a collection,   consider the collection as transparent and return the first not null child cell instead.</li> <li>tree-button-opacity is the opacity of buttons in the tree. It\u2019s a function with the signature <code>{double =&gt; double}</code>. It  receives the euclidean distance from the mouse position to the upper left corner of the button as an argument and should  return a transparency value from 0 to 1 where 0 is invisible and 1 is opaque.</li> <li>tree-show-delete-icon is a flag that decided if the delete icon should be shown for the displayed cell (default: true).</li> </ul> <p>There are also some settings in the inspector of the TreeCell:</p> <ul> <li>delete: a handler that\u2019s invoked when the delete action is invoked.</li> <li>insert child: a handler that\u2019s invoke when the insert button is used to insert a child.</li> <li>outgoing shape: the shape at the start of lines that start from this cell</li> <li>incoming shape the shape at the end of lines that end at this cell</li> <li>collapse by default: collapse all child tree cells by default</li> </ul>"},{"location":"extensions/editor/widgets/","title":"Widgets","text":""},{"location":"extensions/editor/widgets/#bool","title":"Bool","text":"<p>Language Namespace : <code>de.itemis.mps.editor.bool</code></p> <p>This language adds support for manipulating boolean values. When using the <code>checkbox</code> cell, the value can be toggled by clicking on the image. When using the <code>bool</code>cell, a custom text can be set and the values can be toggled by typing the  corresponding text or using the code completion menu.</p> <p></p>"},{"location":"extensions/editor/widgets/#collapsible","title":"Collapsible","text":"<p>Language Namespace : <code>de.itemis.mps.editor.collapsible</code></p> <p>This language adds more folding functionality that the MPS collection cll folding mechanism doesn\u2019t offer. Two cells have to be added to the <code>collapsible</code> cell: the collapsed cell which is shown in the collapsed state and the expanded cell which is only shown when the cell isn\u2019t in the collapsed state. The following style properties can be set:</p> <ul> <li>show collapsed always: always show the collapsed cell even when the cell is expanded (default: true)</li> <li>collapsed by default: start in the collapsed state (default: true)</li> <li>bracket line: draw brackets around the cell (default: true)</li> <li>group: if multiple collapsible cells have the same group, edges are drawn between these cells.</li> <li>node size: the size of the toggle button (unit: pixel)</li> <li>paint node: a custom paint method for the toggle button</li> <li>paint edge: a custom painted edge starting from the end of the line to the expanded cell</li> <li>paint line: a custom painted line starting at the node and ending at the height of the full collapsible cell</li> </ul> <p></p>"},{"location":"extensions/editor/widgets/#dropdown","title":"Dropdown","text":"<p>Language Namespace : <code>de.itemis.mps.editor.dropdown</code></p> <p>A simple cell that makes a containing displays a cell as a dropdown menu: it surrounds a cell with a border and an icon  to the right side of it that opens the code completion menu.</p> <p></p>"},{"location":"extensions/editor/widgets/#enumeration","title":"Enumeration","text":"<p>Language Namespace : <code>de.itemis.mps.editor.enumeration</code></p> <p>The cell <code>enum_checkbox</code> can be seen as an extension of the boolean language for more than two states. Select a enumeration property that should be used for the states of the checkbox. A quickfix automatically adds the enumeration values to the possible states section (if not: press F5 in the editor). Then an icon and the next state have to be declared. Declare the  icons by using the <code>IconCollection</code> concept. To avoid hard-coded paths, use path variables to set the path to the icon e.g. <code>${extensions.home}/code/widgets/languages/de.itemis.mps.editor.bool.demolang/icons/dialog-ok-3.png</code>. Set the scale of  the individual icons. The overall scaling of the checkbox icons can be influenced by setting the property <code>scale with editor font size</code> in the inspector.</p> <p></p>"},{"location":"extensions/generator/plaintext-gen/","title":"Text Generator Plugin","text":"<p>Language Namespace : <code>com.dslfoundry.plaintextgen</code></p> <p>This extension is an alternative text generator for MPS, using the standard model to model generation mechanisms (node macros, loop macros, property macros, etc.) to generate plain text, as opposed to MPS\u2019s programmatic text generation.</p> <p>It allows you to:</p> <ul> <li>generate directly to plain text without modeling your generation target language</li> <li>target multiple text formats in the same generator run</li> <li>create multiple textgens that obey generator priority rules</li> </ul> <p>The plugin also enables copy/pasting an existing piece of text and parameterizing parts of this text using macros.</p> <p>For fine-grained control of whitespaces and indent-characters, the plaintextflow extension is available. It can be imported as a separate language (extending the plaintextgen language), so it doesn\u2019t disrupt existing plaintextgen functionality.</p>"},{"location":"extensions/generator/plaintext-gen/#quickstart","title":"Quickstart","text":"<p>The quickest way to install the plaintextgen plugin is to add it from the JetBrains plugins repository:</p> <ul> <li>in MPS, select <code>File</code> -&gt; <code>Settings</code> -&gt; <code>Plugins</code> -&gt; <code>Browse repositories...</code></li> <li>search for <code>plaintextgen</code></li> <li>press <code>Install</code></li> </ul> <p>After installation, add <code>com.dslfoundry.plaintextgen</code> to the <code>Used Languages</code> of your generator (<code>main@generator</code> model) and create a <code>TextgenText</code> template in your generator. There\u2019s a test language in this repository that demonstrates this language.</p>"},{"location":"extensions/generator/plaintext-gen/#presentations-and-tutorials","title":"Presentations and tutorials","text":"<p>A tutorial on plaintextgen is available on the DSLFoundry blog.</p> <p>A presentation that was held at the 27 February 2019 meeting of MPS Power Users Group that can be found at the DSLFoundry [MPS-teaching](https://youtrack.jetbrains.com/issue/MPS-teaching) repository.</p>"},{"location":"extensions/generator/plaintext-gen/#main-features","title":"Main features","text":"<ul> <li>Group and layout your content using horizontal, vertical, and indented collections</li> <li>Split plain text into various cells to apply MPS generator macros to them</li> <li>Paste unstructured text from a buffer to MPS. The structure of this text (indentations, new lines, tabs) will be automatically analyzed and converted into a <code>TextgenText</code> structure which you can then parameterize at your convenience.</li> </ul>"},{"location":"extensions/generator/plaintext-gen/#advantages-of-this-plugin-over-the-default-textgen","title":"Advantages of this plugin over the default textgen","text":"<p>In short, this plugin brings MPS -&gt; plaintext connectivity in a pretty usable way to MPS.</p> <ul> <li>Text generation can be part of your normal generator chain and can thus have a place in the generator priorities</li> <li>The language looks similar to the MPS editor language, which helps you to structure/layout your text, including indentation</li> <li>Different use cases are accommodated:</li> <li>Pasting in larger amounts of text from the clipboard and parametrizing some of it</li> <li>Making text from scratch and parameterizing some of it</li> </ul>"},{"location":"extensions/generator/plaintext-gen/#differences-to-standard-textgen-mechanism","title":"Differences to standard textgen mechanism","text":"<p>The standard textgen approach assumes that you model your target language (e.g. XML, or C in mbeddr) as an MPS language with all its concepts. Concept textgens provide a simple translation from concept to text. This approach is great for language extensibility, but requires that you model concepts of your target language, which sometimes is too large an investment.</p> <p>This plugin allows you to write a text template and fill in the gaps using standard macros. For example: You generate from your DSL directly to VHDL, but VHDL has not yet been modeled in MPS.</p> <p>Additionally, because text is now also an MPS model, all standard generator mechanisms (including reductions and generator priorities) apply. This is not the case for the default textgens, which are only triggered after all model to model transformations are complete. Also, this approach enables you to implement the textgen as a language extension (and therefore define multiple textgens for the same concept).</p>"},{"location":"extensions/other/changelog/","title":"Changelog","text":"<p>This language allows to create changelogs in the Markdown format. They can be written in the semantic versioning format: </p> <p>A month and year based format is also supported:</p> <p></p> <p>Changes itself are written in the keepachangelog format. The following types of changes exist:</p> <ul> <li>Added for new features</li> <li>Changed for changes in existing functionality</li> <li>Deprecated for soon-to-be removed features</li> <li>Removed for now removed features</li> <li>Fixed for any bug fixes</li> <li>Security in case of vulnerabilities</li> </ul> <p>The following special nodes can be used in the descriptions:</p> <ul> <li>@node reference a node</li> <li>@model reference a model</li> <li>@module reference a module</li> </ul> <p>Due to the limitation of the text language, there is a separate intention <code>Combine Multiple Elements Without Spaces</code> to remove spaces between elements. Select multiple elements to make this intention visible.</p>"},{"location":"extensions/other/langvis/","title":"Language Visualizer","text":"<p>Language Namespace : <code>com.dslfoundry.langvis</code></p> <p>A JetBrains MPS plugin to visualize the structure of a language.</p> <p>The visualization shows in an integrated toolwindow, but the visualization can also be viewed using an image viewer which refreshes on file change.</p> <p>Check the Readme for the current MPS version of mps-langvis on master. Other versions can be found in the <code>maintenance/</code> branches.</p> <p>An integrated tool window is shown when visualizing (parts of) a language.</p> <p>It was tested with Linux, Windows, and Mac.</p> <p> </p>"},{"location":"extensions/other/langvis/#installation","title":"Installation","text":"<p>The following installation instructions assume an <code>apt-get</code> package manager on Linux and the Chocolatey package manager (https://chocolatey.org/) on Windows.</p> <p>Runtime prerequisites:</p> <ol> <li>Install the latest Oracle JDK.</li> <li>Download PlantUML jar file from the plantuml website and store it into your home directory (<code>%HOME%</code> on Windows or <code>$HOME</code> on linux), for instance <code>/Users/mpsuser</code>.</li> <li>Install GraphViz to satisfy the PlantUML dependency (e.g. <code>sudo apt-get install graphviz</code> or <code>choco install graphviz</code>)</li> <li>For Windows: make sure your <code>JAVA_HOME</code> environment variable points to your JDK (e.g. <code>set JAVA_HOME=\"c:\\Program Files\\Java\\jdk-11.0.5\"</code>)</li> <li>(Optional) If you prefer an alternative to the integrated panel or the PlantUML viewer, install the auto-refreshing image viewer of your choice (e.g. <code>sudo apt-get install eog</code> or <code>choco install irfanview</code>)</li> </ol> <p>Build prerequisites:</p> <ol> <li>Install above Runtime prerequisites</li> <li>Download and install ant (e.g. using <code>sudo apt-get install ant</code> or <code>choco install apache.ant</code>)</li> <li>Clone this git repository</li> </ol>"},{"location":"extensions/other/langvis/#install-plugin","title":"Install plugin","text":"<p>Install the plugin from the JetBrains Marketplace.</p>"},{"location":"extensions/other/langvis/#usage-of-the-plugin","title":"Usage of the plugin","text":"<p>You can create the following types of visualizations:</p> <ul> <li>Full structure of a language (right click <code>structure</code> of the language and select <code>Visualize Language Structure</code>) - hotkey: Ctrl+Shift+M</li> <li>Concept structure showing the children and inheritance hierarchy of a concept (Right-click concept and select <code>Visualize Concept Context</code>)</li> </ul> <p></p> <p>When visualizing the structure, a tool window automatically opens on the side.</p> <p>The tool window allows you to select the following options using check boxes:</p> <ul> <li>Structure shows relations (lines) between children and descendants (the composition structure) of the concept.</li> <li>Hierarchy shows concept extension and interface implementation/extension relations (the inheritance hierarchy) of the vizualized concepts.</li> <li>Cardinality shows the cardinalities (e.g. <code>1</code>, <code>0..1</code>, <code>0..n</code>) of the visualized relations.</li> <li>Role names show the names of the child/descendant next to the line.</li> <li>Flatten namespaces: do not group items from the same namespace, but show fully qualified names of the items instead.</li> </ul> <p>After adjusting the options, you need to press the <code>refresh icon</code> to apply the changes.</p> <p>If the provided tool panel isn\u2019t to your liking, two alternative methods of viewing the visualizations exist.</p>"},{"location":"extensions/other/langvis/#optional-viewing-the-visualization-with-plantumls-auto-refreshing-viewer","title":"(Optional) Viewing the visualization with PlantUML\u2019s auto-refreshing viewer","text":"<ol> <li>From your home directory start <code>java -jar ~/plantuml.jar</code>. This will monitor the home directory for plantuml files and generate png files.</li> <li>Double-click on the <code>mps-metamodel.txt</code> file, and you will have a picture that autorefreshes every time you call the visualizer in MPS.</li> </ol>"},{"location":"extensions/other/langvis/#optional-viewing-the-visualization-with-your-favorite-image-viewer","title":"(Optional) Viewing the visualization with your favorite image viewer","text":"<ol> <li>Start your image viewer (e.g. <code>eog ~/mps-metamodel.png</code>)</li> <li>If your viewer automatically refreshes, you can leave it open and keep on creating visualizations.</li> </ol>"},{"location":"extensions/other/project-view/","title":"Project View","text":"<p>Language Namespace : <code>com.mbeddr.mpsutil.projectview</code></p> <p>For many applications (and their end users), the default MPS Project Explorer (aka Logical View) is too complicated.  It shows too much \u201cunnecessary\u201d stuff. Also, depending on the use case and the stakeholder, the structure of the primary  navigation device must be different, adapted for the use case or stakeholder.</p> <p>The platform contains a DSL to describe the structure of arbitrary alternative tree views in the project explorer. MPS  already provides a drop-down menu to select from various views, and the DSL can contribute additional ones.</p> <p>The DSL supports the definition of arbitrary structures, labels, icons and actions and also lets you add additional nodes that are useful for structuring the tree. To see how this DSL works, checkout the custom views defined in the <code>com.mbeddr.mpsutil.projectview.demo</code> solution as well as the mbeddr favourites view in the <code>com.mbeddr.mpsutil.favourites.plugin</code> plugin solution. Below is a screenshot of that favourites view.</p> <p></p> <p>The language must be used in a plugin solution and supports the following properties:</p> <ul> <li>label: the name of the project view</li> <li>icon: the icon that\u2019s displayed to the left of the label</li> <li>priority: this value is used for sorting purposes of the project views. There are some predefined project views that   have a priority (in IntelliJ terms: weight) that can\u2019t be used. The following IntelliJ/MPS project views exist: project view(prio: 0),  scope view (prio: 4), file view (prio: 5) (TODO: priorities). The standard priority for new custom views is 10000.  The language automatically increments the priority until  it can find an unused priority.</li> <li>refresh on filesystem change: default: true</li> <li>refresh on make: default: true</li> <li>refresh on repository change: default: true</li> <li>refresh on class reload: default: true</li> <li>data provider: the keys of the data provider can be used as context parameters in actions.</li> <li>toolbar action group ID: the ID of an existing action group</li> </ul> <p>The project view can also extend another view. The content of the preview has to implement the interface <code>IViewElement</code>. The default implementation is the <code>treeNode</code>. It can extend other elements and accepts the following parameters:</p> <ul> <li>parent: the parent element in the project view</li> <li>type: a type for the query. The result can be accessed through the variable that has the same name as  the tree nodes name.</li> <li>load children lazy: default: <code>true</code></li> <li>load children async: default: <code>false</code></li> <li>auto update children: automatically update the child tree node when the parent changes</li> <li>label: the text of the current node</li> <li>icon: the icon that is displaced to the left of the label</li> <li>text attributes: style attributes for the label such as bold, italic or a boder. The expression must return an instance   of the class SimpleTextAttributes.</li> <li>action group ID: the ID of an existing action group that should be shown when right-clicking the node</li> <li>folder path: the virtual folder of the node</li> <li>folder action group ID: the ID of an existing action group that should be shown when right-click the virtual folder.</li> </ul> <p>The current mps project can be accessed through the variable <code>mpsProject</code>. A project view can be reference by typing <code>projectView</code> and the name of the project view.</p>"},{"location":"extensions/other/shadow-models/","title":"Shadow Models","text":"<p>Language Namespace : <code>de.q60.mps.shadowmodels</code></p> <p>A shadow model is a non-editable model derived from existing models by model-to-model transformations. It\u2019s incrementally maintained while editing the input model.</p> <p>A special language describes the transformations, designed to support incremental updates of the output model. Dynamic dependency tracking is used during the executing of the transformations which remove the need for a declarative language. Base Language expressions with all its extensions are supported inside the transformation rules.</p>"},{"location":"extensions/other/shadow-models/#examples","title":"Examples","text":"<p>There\u2019s a separate <code>Shadow Models (Examples)</code> plugin that contains some example languages and transformation implementations to show you how to build your own shadow models. The languages and input models can be found in the namespace <code>de.q60.mps.shadowmodels.examples</code>. The transformations are implemented in the transformation aspect.</p>"},{"location":"extensions/other/shadow-models/#transformations","title":"Transformations","text":"<p>The transformation language is similar to the MPS generator language. It has transformation rules with a left side that describes the input it applies to and a right side that creates the output.</p> <p>The right side is similar to light quotations instead of using the concrete syntax of the target language.</p>"},{"location":"extensions/other/shadow-models/#repository-meta-model","title":"Repository Meta Model","text":"<p>When you implement transformations there\u2019s an important difference when working with modules and models. In the world of shadow models there\u2019s only one root node concept <code>Repository</code>. Modules and models are descendants of this single root node. What in MPS is a root node is here just a child of a node of concept <code>Model</code>. When you ask a root node for its parent, you get the <code>Model</code> node.</p> <p>This has the advantage that you can define transformations on modules and models in the same way as on any other node. You can query them using the more convenient smodel language instead of the Java API.</p> <p>You have to keep in mind that asking a node for its root node always returns the repository. If you need to know the model of a node, you have to write <code>node.ancestor&lt;Model&gt;</code> instead. <code>node.getModel()</code> always returns null.</p> <p>You can find the whole meta model in the language <code>de.q60.mps.shadowmodels.runtimelang</code>. Here is a summary of it:</p> <pre><code>Repository\n  modules: Module[0..n]\n\nModule implements INamedConcept\n  id: string\n  models: Model[0..n]\n\nModel implements INamedConcept\n  rootNodes: BaseConcept[0..n]\n</code></pre>"},{"location":"extensions/other/shadow-models/#shadow-repository","title":"Shadow Repository","text":"<p>You can make the output of your transformations appear in the project explorer as shown in the image below.</p> <p></p> <p>By default, this is disabled. You can activate it by choosing <code>Tools &gt; Activate Shadow Repository</code> in the main menu.</p> <p>To add your own output, you have to define a transformation that contributes to the predefined transformation <code>ShadowRepository.Repository</code> in the transformations aspect of the language de.q60.mps.shadowmodels.repository.</p> <p>Here is an example that you can find in the language de.q60.mps.shadowmodels.examples.statemachine: <pre><code>transformation t1 contributes to ShadowRepository.Repository (i0: Repository)\n-&gt; o0: Repository {\n         modules: Module {\n           name: \"examples.statemachines\" \n           models: map _.modules.models.where(...) -&gt; call outputModel _  \n         } \n       }\n</code></pre></p> <p>It\u2019s important to know that the whole shadow repository is executed inside a fork. This makes sure that references are updated to point to nodes inside the shadow repository. You can, of course, create additional sub forks.</p>"},{"location":"extensions/other/shadow-models/#forks","title":"Forks","text":"<p>Shadow models allow you to write transformations in two different styles. You can write them like functions and call everything explicitly, or you can use forks. Forks basically allow you to write transformations similar to how you would do it in the MPS generator.</p> <p>In MPS, the unit of transformation is a model. You can\u2019t generate a single class (in case of baseLanguage code) inside a model,  and you can\u2019t generate classes from different models together. Shadow model forks can have any node as the root of the fork. If you decide to make a model the root of your fork, then you have the equivalent to MPS. But often the single root nodes inside the model are a better choice for the fork root. In case of baseLanguage classes, there\u2019s no difference if two classes are in the same or in different models.</p> <p>Forks also have support for mapping labels as you know them from MPS. They can only work if the map is filled before mappings are queried from them. Forks execute all transformations (which fill the map) before any reference is resolved (which queries mapping). As in MPS where mapping labels only work inside the same model, here they only work inside the same fork.</p> <p>Luckily, both have a solution for that. MPS introduced cross model generation where you define special checkpoints inside the generation plan. In shadow models you can define fork dependencies. If a transformation or mapping can\u2019t be found in the same fork, they are searched in all forks that are defined as a dependency. You can add dependencies in the upper part of any transformation that\u2019s part of the fork.</p> <p>As all transformations, forks are executed on demand. You don\u2019t have to take care of generating your models in the correct order. If you define a fork dependency, the transformation engine makes sure that the target fork exists when it\u2019s needed.</p> <p>A fork can specify a list of transformations that are automatically applied to the input, just like reduction rules in MPS. By default, there\u2019s only one attempt to apply transformations on all nodes that you copy using the <code>transform</code> keyword. If there are nodes in the output where one of the transformations was applicable, nothing would happen unless  you enable the fixpoint mode. Then the fork is applied again on the output of the previous execution. For performance reasons, a fork is by default not in fixpoint mode.</p> <p>The identity of a fork is composed of the fork name and the parameter values of the fork call. You can use this to create multiple copies of the same input node. Just add an extra (string) parameter to the fork and use a different value for each copy. The fork identity is part of the node identity of all its output nodes.</p>"},{"location":"extensions/other/shadow-models/#reference-resolution","title":"Reference Resolution","text":""},{"location":"extensions/other/shadow-models/#differences-for-forks","title":"Differences for Forks","text":"<p>All transformations inside a fork are executed before any reference resolution happens. You will get an exception when the reference target was not created in this first phase. If you are not inside a fork, there aren\u2019t these two phases. Transformations are executed independent of whether you access it through a parent-child relation or a reference. You won\u2019t get an exception in this case.</p>"},{"location":"extensions/other/shadow-models/#identity-of-a-node","title":"Identity of a Node","text":"<p>A node in the output is identified by the transformation name and the parameter values of the transformation call.  If you call a fork then the identity of the fork (fork name + parameter values) will be part of all it\u2019s output nodes.</p> <p>For references, it\u2019s often enough to specify the transformation call that creates the target. It will then be resolved in the same fork, its dependencies or the parent fork. If you need to, you can also specify the exact fork of the reference target. </p>"},{"location":"extensions/other/shadow-models/#references-to-non-shadow-nodes","title":"References to Non-Shadow Nodes","text":"<p>If you want to generate code against an existing runtime library, you can just write a baseLanguage expression that returns an <code>SNode</code> or <code>SNodeReference</code> to set a reference to a fixed target. No resolution will happen in this case.</p> <p>In the statemachines example, you can find the following transformation: <pre><code>transformation enumConst overrides ... [i0: INamedConcept]\n-&gt; o0: EnumConstantDeclaration {\n         name: _.name\n         constructor -&gt; *[node-ptr/Object-&gt;Object/]\n       }\n</code></pre> The constructor reference is pointing to the constructor of the Object class in the JDK stub models.</p>"},{"location":"extensions/other/shadow-models/#traceback","title":"Traceback","text":"<p>For debugging the output in the shadow repository, you show the transformations that produced a given output node. Right-click on an output node and choose Language Debug &gt; Shadow Models: Traceback from the context menu.</p> <p></p>"},{"location":"extensions/other/shadow-models/#reduction-rules-and-generation-plans","title":"Reduction rules and generation plans","text":"<p>There are some use cases that are easier to implement with the MPS generator language than with the explicit transformation calls of the shadow models language. That\u2019s why there are now similar abstractions in the shadow models language.</p>"},{"location":"extensions/other/shadow-models/#mappings-cnfigurations-and-goals","title":"Mappings Cnfigurations and Goals","text":"<p>A mapping configuration in MPS is a container for reduction/weaving/\u2026 rules. You can define rules to specify the order in which the mappings configuration are applied on the input model.</p> <p>In shadow models there\u2019s now also a \u201cmapping configuration\u201d concept. You can specify reduction and weaving rules inside of it. The following example shows a concept that doesn\u2019t exist in MPS: goals.</p> <pre><code>goal toJava\nmapping configuration mc1 {\n    goal: toJava\n}\n</code></pre> <p>A goal specifies what should happen with the input model. All mapping configurations that contribute to the same goal are applied when the goal is called on some input. While in MPS you always execute the same generators on a model, goals enable you to produce multiple outputs by executing different goals on the same input.</p>"},{"location":"extensions/other/shadow-models/#generation-plans","title":"Generation plans","text":"<p>When you invoke a goal all mapping configurations that contribute to that goal are collected and sorted into a generation plan. A generation plan is dynamically computed from a set of rules. The rules are the same as known from MPS. A before/after rule will separate the generation into two steps where the output of the first is the input of the second one.</p> <pre><code>goal toJava\nmapping configuration mc1 { ... }\nmapping configuration mc2 { ... }\ngenplan rule: mc1 before mc3\n</code></pre>"},{"location":"extensions/other/shadow-models/#reduction-rules","title":"Reduction Rules","text":"<p>Reduction rules are automatically applied to any applicable node on the input including its descendants. Rules are repeatedly applied on the output up to 10 times. If rules are then still applicable, the generation fails.</p> <p>Conflicting reduction rules don\u2019t cause the generation to fail. They behave in the same way as in the MPS generator. The first applicable rule is used. If they are part of the same mapping configuration, the order of the rules is relevant. If they are part of different mappings configurations, it\u2019s undefined which rule is used.</p>"},{"location":"extensions/other/shadow-models/#weaving-rules","title":"Weaving Rules","text":"<p>Weaving rules are used to insert an additional node as a child into an output node. The target node is specified in the same way as in references, but it has to be part of the output of the current goal execution.</p> <p>Weaving rules are applied only on the initial input or on output nodes of a transformation. If a node was copied without any change between sub steps, weaving rules aren\u2019t applied. This prevents them from being reapplied on the same node again and again.  </p>"},{"location":"extensions/other/shadow-models/#property-rules","title":"Property Rules","text":"<p>Property rules can change a value without doing any structural change to the model. They are applied on the output after executing reduction and weaving rules.</p>"},{"location":"extensions/other/shadow-models/#reference-rules","title":"Reference Rules","text":"<p>Reference rules are the same as property rules except that they change a reference target instead of a property value. The target is resolved in the scope of the output node.</p>"},{"location":"extensions/other/shadow-models/#scopes","title":"Scopes","text":"<p>Scopes can be used to resolve conflicts during reference resolution. If the same node is copied multiple times into the output and you want to reference one of them, you can put the source and the target node into the same scope.</p>"},{"location":"extensions/utils/debug/","title":"Debug","text":"<p>When you import the language, two new actions are available when you right-click and select <code>Language Debug</code>:</p> <ul> <li>Copy Cell Reference creates a reference to the current selected editor cell that can be pasted into the MPS console.</li> <li>Copy Editor Component Reference creates a reference to the editor component of the currently opened editor</li> </ul> <p>The current opened editor component is also available on the MPS console via <code>#currentEditorComponent</code>. Both types of referenced get invalid when the editor is closed.</p>"},{"location":"extensions/utils/hacks/","title":"Hacks","text":"<p>Language Namespace : <code>de.slisson.mps.hacks</code></p>"},{"location":"extensions/utils/hacks/#editor-hacks","title":"Editor Hacks","text":"<p>This module contains editor-related helper classes:</p> <ul> <li>AbstractEditorRegistry/ConceptEditorRegistry/ConceptEditorUtil: utility methods for getting editors for concepts</li> <li>DummyReferenceLink: reference link implementation with just a name without any other functionality implemented except  equality comparison to other links.</li> <li>EditorCacheHacks.noCaching: the MPS editor is normally cached. With this method, a random cell context hint is added,  so that the provided runnable runs with an editor that isn\u2019t cached.</li> <li>EditorCellCreator: returns a new editor cell for a node with some initial editor hint. It uses a headless editor component  to achieve this.</li> <li>EditorComponentHacks: find all editor components in every window and tool</li> <li>SavedCaretPosition: class for saving and restoring the caret position in the editor. This class can be useful, for example,  to find a new cell for the caret after a cell is removed from the editor.</li> <li>SubstituteUtil: create substitute entries for children of a node by creating a SubstituteInfo instance. There are languages  where this could be useful, for example, when creating a completely dynamic table with the table language where you have  to set the substitution info yourself.</li> </ul>"},{"location":"extensions/utils/hacks/#reflection","title":"Reflection","text":"<p>This language bypasses some restrictions of the Java access modifiers by providing language concepts for the Java reflection API. It can access fields, static fields, methods and static fields that are normally not accessible because of the used modifiers such as the protected  and private modifier. </p> <p>Always try to find a public API before using this language. When using internal fields or methods, there\u2019s always the possibility  that the code will break in the feature because the class design changed. It was initially developed to overcome some  limitations in MPS.</p>"},{"location":"extensions/utils/intentions-menu/","title":"Intentions Menu","text":"<p>Language Namespace : <code>com.mbeddr.mpsutil.intentions</code></p> <p>A language that adds support for grouping intentions. Invoke the intention <code>Toggle Group Annotation</code> to add it to a group. The intentions will be grouped together if they use the same label in the annotation.</p> <p>Additionally, it adds support for enabling intentions in read-only cells when the style attribute <code>intentions-in-read-only-cell</code> of the stylesheet <code>IntentionStyles</code> is set to true.</p> <p></p>"},{"location":"extensions/utils/model-listener/","title":"Model Listener","text":"<p>Language Namespace : <code>com.mbeddr.mpsutil.modellisteners</code></p> <p>The language adds a new aspect called <code>listeners</code> where listeners can be created that react to various changes in the model: <code>instance</code> refers to the node from which the model listeners received the event, <code>child</code> is the child node, <code>role</code>is link of a child or reference.</p> <p>To listen for events in any node, select <code>BaseConcept</code> as the target of the model listeners. Be careful when choosing this approach as it can be slow when many events happen. Model listener can be used, for example, to calculate values when something changes or execute an additional action when a root node is removed. When a node is replaced with another one or a node is created, you might want to use node factories  or concept constructors instead.</p> <p>Example for an empty model listener:</p> <pre><code>model listeners for RootConcept {\n    child added in role original (instance, child)-&gt;void {\n    }\n    before child removed in role original (instance, child)-&gt;void {\n    }\n    reference added in role reference1 (instance, target, role)-&gt;void {\n    }\n    reference removed in role reference1 (instance, target, role)-&gt;void {\n    }\n    property changed of property property1 (instance, propertyName, oldValue, newValue)-&gt;void {\n    }\n    root added (instance, model)-&gt;void {\n    }\n    before root removed (instance, model)-&gt;void {\n    }\n    root removed (instance, model)-&gt;void {\n    }\n}\n</code></pre> <p>The listeners are called synchronously. Since they are operating on the models itself, there is no access to the opened editors. That means that the cursor might jump in the editor when a node is added or removed. The listeners also might make changes to the models unpredictable and not easily revertible, so think twice before using them.</p>"},{"location":"extensions/utils/model-merger/","title":"Model merger","text":"<p>Language Namespace : <code>de.itemis.model.merge</code></p> <p>Integration of MPS models with external data poses some challenges. One step is to write a custom importer which converts the external data to a fresh MPS model. But what about an old MPS-Model which you have imported before? From the same external data source! \u2018ModelMerger\u2019 aims to facilitate this task by providing a DSL for defining Merge-Actions across the Concepts of languages. It can then be used to automatically merge an imported model from external data into an already present model.</p> <p>Two model merger languages exist. <code>de.itemis.model.merge</code> is the new one and is explained in this document. The old language is deprecated.</p> <p>This language allows merging models based on merging policies. In the following explanations the term left refers to  one aspect of the first model that should be merged, the term right to the same aspect in a second model.</p> <p>To get started:</p> <ul> <li>In your solution, create a model named plugin</li> <li>Add <code>de.itemis.model.merge</code> to the used languages of this model.</li> <li>Right click the solution containing the plugin model &gt; select Module properties</li> <li>Open the Java tab and unfold the section  Regular MPS module contributing extensions to MPS</li> <li>Set Contributes to MPS extension to <code>Yes</code></li> </ul>"},{"location":"extensions/utils/model-merger/#creating-merging-policies","title":"Creating merging policies","text":"<p>Create a new root node of concept ModelMergingPolicy inside the plugin model. The main language has to be defined. If there are additional languages involved, they can be specified as well. Now, merge policies can be defined for different concepts. The concepts need to be identifiable by a unique ID, for example, by an ID property. The scope of the uniqueness property depends on the context where the model merger is used. Normally, it\u2019s the project scope but there are cases where the ID needs to be globally unique. All concepts defined in those languages used in the merging policy shall have a <code>ConceptMergingPolicy</code> defined in the <code>ModelMergingPolicy</code>. For prototyping purpose or for big languages, there is an option to set the flag <code>Partial policy</code> to <code>true</code> so that some check for the ModelMerging are relaxed. However models used in the merging shall not contain concepts wihtout policies otherwise an exception will be throw.</p> <p>Each <code>ConceptMergingPolicy</code> is composed of an identification function and policies for Properties, Children, and Reference, as described bellow.</p>"},{"location":"extensions/utils/model-merger/#properties","title":"Properties","text":"<p>For properties, three options are possible: </p> <ul> <li>Left: use the value of the left property, and discard the value of the right property.</li> <li>Right: use the value of the right property, and discard the value of the right property.</li> <li>Manual: a custom merger that must return a value of the same type as the property</li> </ul>"},{"location":"extensions/utils/model-merger/#children","title":"Children","text":"<p>For child nodes a policy container can be added.</p> <ul> <li>Elements exists only on left side <ul> <li>Keep: keep the element</li> <li>Drop: drop item</li> </ul> </li> <li>New element on the right: <ul> <li>Add: add the element</li> <li>Drop: drop item</li> </ul> </li> <li>Element on both sides<ul> <li>Drop: drop item if conflicts occur</li> <li>Left: keep the left node, and discard the right node</li> <li>Right: keep the right node and discard the left node</li> <li>Auto: use the existing merge policies of the children</li> <li>ManualColl: a custom merger that must return a node of the same type as the concept</li> </ul> </li> </ul>"},{"location":"extensions/utils/model-merger/#references","title":"References","text":"<p>For references, three options are possible:</p> <ul> <li>Left: use the reference of the left node, and discard the reference of the right node.</li> <li>Right: use the reference of the right node and discard the reference of the left node.</li> <li>Manual: a custom merger that must return a node of the same type as the referenced node\u2019s concept</li> </ul>"},{"location":"extensions/utils/model-merger/#running-model-merging","title":"Running model merging","text":"<p>The model merge can be executed by creating a ModelMergingConfiguration node in a model with dependencies to the models being merged and mde<code>de.itemis.model.merge</code> language. The following parameters must be defined in the configuraiton: </p> <ul> <li>Left: a model pointer to the first model</li> <li>Right: a model pointer to the second model</li> <li>Result: a model pointer to a model where the results should be saved. When no model is referenced, the left model  will be overridden.</li> <li>Merge Policy: the policy that should be applied to the left and right model</li> </ul> <p>In order to execute the merging one can use the intention <code>Run Model Merge</code> or call the <code>execute</code> method programmatically. Additonaly one can use the ModelMerger directly to control which root-nodes shall be provided for merging. Use the following code snippet for inspiration: </p> <pre><code>private void mergeRoots(concept&lt;&gt; usingConcept)  { \n  list&lt;node&lt;&gt;&gt; leftRootNodes = leftModel.roots(&lt;all&gt;).where({it =&gt; it.descendants&lt;concept = # usingConcept&gt;.isNotEmpty; }).toList; \n  list&lt;node&lt;IVariabilityContainer&gt;&gt; rightRootNodes = rightModel.roots(&lt;all&gt;).where({it =&gt; it.descendants&lt;concept = # usingConcept&gt;.isNotEmpty; }).toList;\n\n  ModelMerger merger = ModelMerger.create(policy); \n  merger.outputModel = targetModel; \n  merger.merge(leftRootNodes, rightRootNodes); \n}\n</code></pre>"},{"location":"extensions/utils/node-versioning/","title":"Node Versioning","text":"<p>Language Namespace : <code>de.itemis.mps.nodeversioning</code></p> <p>The node versioning extension gives support for storing different states/versions of a node inside of the model. It is not a replacement for version control systems like <code>git</code>.</p> <p>An example use case might be a model is used to describe an API and the users wants to detect changes between different releases of the API. This API has a version number that follows semVer associated with it. Now when users wants check what changes happened since the last release the information stored by this extension can be used to diff the current state against the last released one.</p> <p>The scope of this extension is to provide a way to store the versions of a node and do change detection. It does intentionally not provide ways how to semantically reason about a change as this is highly domain specific. It might be used in conjunction with the <code>nodecomparator</code> to do structural diffs between versions.</p> <p>State: Incubating </p> <p>This extension is currently incubating and might under go substantial changes in the future. Currently it only supports storing of the version information and change detection. For future feature ideas see the potential features section.</p>"},{"location":"extensions/utils/node-versioning/#what-is-a-node","title":"What is a Node","text":"<p>When we speak of a node in this document we mean the node and all of its children but not of the referenced nodes. Sometimes this is also called subtree.</p> <p>When we speak of the dependencies of a node we mean all nodes that are referenced by either node itself or it children. </p>"},{"location":"extensions/utils/node-versioning/#meta-model","title":"Meta Model","text":"<p>The version information is stored on the node that is versioned as a <code>NodeAttribute</code> called <code>NodeVersion</code>. The <code>NodeVersion</code> contains a copy of the node at point in time when the version was created. In addition to the copy it also stores a VersionNumber which is a simple integer incremented with each version that is created. The VersionNumber has no other semantics than to provide ordering to the versions. To be able to detect changes of a node it also stores a hash of the node. The <code>NodeVersion</code> also contains a list of all the dependencies (reference targets) of the node and its version, these are called <code>LinkVersion</code>. </p>"},{"location":"extensions/utils/node-versioning/#change-detection","title":"Change Detection","text":"<p>On first glance change detection looks pretty straight forward. A node has changed when either the node itself has changed or one of the dependencies:</p> <p></p> <p>But if we at MPS models they are not simple tree but graphs that allow reference cycles. In this cases we cannot simply traverse the complete graph over the edges since we would end up in a cycle. Imagine model like this:</p> <p></p> <p>In this case the change detection has to take into account that there is a cycle from <code>5 --&gt; 4 --&gt; 6 --&gt; 5</code>. The change detection algorithm detects this cycle and handles them appropriately. If none of the participants in a cycle have local changes then the whole cycle is assumed to be unchanged.</p> <p>Technically the detection if a node has changed since the last time it has been versioned is done via hashing. If the hash differs from the hash calculated for the last version then the node has changed. The current implementation uses SHA 1 hashes to verify if the node has changed. </p>"},{"location":"extensions/utils/node-versioning/#potential-features","title":"Potential Features","text":"<ul> <li>time travel: Getting the model back into the exact same state as it was when a specific version on a node was created. Most likely as some kind of transient model that is not visible to the user. </li> <li>Referencing nodes in a specific version. While this to some degree already happens behind the scenes. It might be useful for the user to implement an API in specific version.</li> <li>Delete handling. At the moment when the user deletes a node that is still referenced from some other node in an older version (that is potentially not visible to the user) the model is in a broken state.</li> </ul>"},{"location":"extensions/utils/node-versioning/#usage","title":"Usage","text":"<p>The general pattern that all functionally of the <code>nodeversioning</code> extension that all parts follow is that it will never mutate the model during its execution. It will collect changes or calculate a new set of <code>NodeVersions</code> but its up to the user of the extension to actually mutate the model. This behaviour is due to the fact that the domain requires human interaction to review the changes and allow to veto based on that review. </p> <p>First of all models that should get versioned need to use the <code>de.itemis.mps.nodeversioning</code> language. Most probably you want to expose this to the end user through a DevKit. This language does not add anything the user can see or interact with but adds the <code>NodeAttribute</code>s required for the versioning.</p> <p>In order to version a model or otherwise interact with the versions stored in the nodes use the <code>de.itemis.mps.nodeversioning.runtime</code> solution. The class you want to have a look at is <code>VersioningHelper</code> it provides the methods to version a node or check if something has changed. For more details see the JavaDoc on that class.</p>"},{"location":"extensions/utils/serializer/","title":"Utils","text":""},{"location":"extensions/utils/serializer/#serializer","title":"Serializer","text":"<p>Language Namespace : <code>de.itemis.mps.utils.serializer.xml</code></p> <p>This solutions contains two classes: NodeSerializer for serializing nodes to XML and NodeDeserializer for deserializing nodes from XML. It uses the JDOM Java library.</p>"},{"location":"extensions/utils/spellcheck/","title":"Spell check","text":"<p>This plugin adds a new entry <code>Dictionary</code> to the intentions menu where you can add unknown words to the MPS dictionary or replace the current selected text with a known word from the dictionary:</p> <p></p> <p>You can also add words to the dictionary by creating a new dictionary root node and adding entries to it. A second type of root node predefined dictionary allows to install existing dictionaries in the hunspell format. Some existing dictionaries for different languages can be found at https://github.com/wooorm/dictionaries</p>"},{"location":"extensions/utils/statistics/","title":"Statistics","text":"<p>Use the action <code>Collect used languages</code> to generate a file dependencies.txt` in the root directory of the project that contains all module dependencies in the current project. The idea is to get a list of all the used languages in the current project. The own languages of MPS are automatically excluded.</p>"}]}
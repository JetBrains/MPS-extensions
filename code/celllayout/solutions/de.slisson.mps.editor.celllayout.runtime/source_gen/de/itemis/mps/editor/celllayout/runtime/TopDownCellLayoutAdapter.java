package de.itemis.mps.editor.celllayout.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellLayout.AbstractCellLayout;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import de.itemis.mps.editor.celllayout.layout.ILayouter;
import org.jetbrains.annotations.NotNull;
import de.itemis.mps.editor.celllayout.layout.ILayoutableContainer;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.TextBuilderImpl;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class TopDownCellLayoutAdapter extends AbstractCellLayout implements CellLayout {

  private ILayouter myLayouter;
  private LayoutableCollectionAdapter myAdapter;

  public TopDownCellLayoutAdapter(@NotNull ILayouter layouter) {
    myLayouter = layouter;
  }

  public ILayouter getLayouter() {
    return myLayouter;
  }

  protected ILayoutableContainer getLayoutable(EditorCell_Collection collection) {
    if (myAdapter == null || myAdapter.getEditorCell() != collection) {
      myAdapter = new LayoutableCollectionAdapter(collection, myLayouter);
    }
    return myAdapter;
  }

  @Override
  public void doLayout(EditorCell_Collection collectionCell) {
    new LayoutEngine().layoutCell(collectionCell);
  }

  @Override
  public TextBuilder doLayoutText(Iterable<EditorCell> collectionCell) {
    if (collectionCell instanceof EditorCell_Collection) {
      return getLayoutable(((EditorCell_Collection) collectionCell)).toText();
    } else {
      TextBuilder text = new TextBuilderImpl();
      boolean first = true;
      for (EditorCell cell : Sequence.fromIterable(collectionCell)) {
        text.appendToTheRight(cell.renderText(), !(first));
        first = false;
      }
      return text;
    }
  }

  @Override
  public int getAscent(final EditorCell_Collection collection) {
    final Wrappers._int ascent = new Wrappers._int(0);
    LayoutWatchdog.enterIfRequired(LayoutWatchdog.DEFAULT_MAX_LAYOUTING_OPERATIONS, () -> ascent.value = getLayoutable(collection).getAscent());
    return ascent.value;
  }

  @Override
  public int getDescent(EditorCell_Collection collection) {
    ILayoutableContainer layoutable = getLayoutable(collection);
    return layoutable.getHeight() - layoutable.getAscent();
  }

  @Override
  public List<Rectangle> getSelectionBounds(EditorCell_Collection collection) {
    return CellLayoutUtil.closeGaps(Sequence.fromIterable(myLayouter.getCellsForSelectionPainting(getLayoutable(collection))).select((it) -> GeometryUtil.getBounds(CellLayoutUtil.getEditorCell(it))).toList());
  }

  @Override
  public List<? extends EditorCell> getSelectionCells(final EditorCell_Collection collection) {
    List<EditorCell> cells = Sequence.fromIterable(myLayouter.getCellsForSelectionPainting(getLayoutable(collection))).select((it) -> CellLayoutUtil.getEditorCell(it)).where((it) -> it != collection).toList();
    return (ListSequence.fromList(cells).isEmpty() ? null : cells);
  }

  @Override
  public String toString() {
    return "TopDownCellLayoutAdapter[" + myLayouter + "]";
  }

  @Override
  public void move(EditorCell_Collection editorCells, int deltaX, int deltaY) {
    super.move(editorCells, deltaX, deltaY);

    ILayoutableContainer layoutable = getLayoutable(editorCells);
    if (layoutable instanceof LayoutableCollectionAdapter) {
      ((LayoutableCollectionAdapter) layoutable).cellAndDescendantsWereMoved();
    }
  }
}

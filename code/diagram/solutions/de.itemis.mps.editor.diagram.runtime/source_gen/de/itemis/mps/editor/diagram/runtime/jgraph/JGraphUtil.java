package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import de.itemis.mps.editor.diagram.runtime.model.Point;
import com.mxgraph.view.mxGraphView;
import com.mxgraph.util.mxPoint;
import com.mxgraph.util.mxRectangle;
import java.awt.geom.Rectangle2D;
import com.mxgraph.model.mxICell;
import com.mxgraph.model.mxGeometry;
import com.mxgraph.view.mxCellState;
import java.util.Map;
import com.mxgraph.util.mxUtils;
import com.mxgraph.util.mxConstants;
import com.mxgraph.model.mxIGraphModel;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.mxgraph.model.mxCell;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import java.awt.geom.Line2D;
import de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods;
import org.eclipse.elk.graph.ElkGraphElement;
import org.eclipse.elk.core.util.IElkProgressMonitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.eclipse.elk.graph.properties.IProperty;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.Objects;

public class JGraphUtil {
  public static Point convertFromView(mxGraphView view, Point point) {
    double dX = point.getX();
    dX /= view.getScale();
    dX -= view.getTranslate().getX();
    double dY = point.getY();
    dY /= view.getScale();
    dY -= view.getTranslate().getY();
    return new Point(dX, dY);
  }

  public static Point convertToView(mxGraphView view, Point point) {
    double dX = point.getX();
    dX += view.getTranslate().getX();
    dX *= view.getScale();
    double dY = point.getY();
    dY += view.getTranslate().getY();
    dY *= view.getScale();
    return new Point(dX, dY);
  }

  public static mxPoint convertFromView(mxGraphView view, mxPoint point) {
    Point p = convertFromView(view, new Point(point.getX(), point.getY()));
    return new mxPoint(p.getX(), p.getY());
  }

  public static mxPoint convertToView(mxGraphView view, mxPoint point) {
    Point p = convertToView(view, new Point(point.getX(), point.getY()));
    return new mxPoint(p.getX(), p.getY());
  }

  public static mxRectangle convertToView(mxGraphView view, mxRectangle rect) {
    mxPoint leftTop = new mxPoint(rect.getX(), rect.getY());
    mxPoint bottomRight = new mxPoint(rect.getX() + rect.getWidth(), rect.getY() + rect.getHeight());
    leftTop = convertToView(view, leftTop);
    bottomRight = convertToView(view, bottomRight);
    return new mxRectangle(leftTop.getX(), leftTop.getY(), bottomRight.getX() - leftTop.getX(), bottomRight.getY() - leftTop.getY());
  }

  public static mxRectangle convertFromView(mxGraphView view, mxRectangle rect) {
    mxPoint leftTop = new mxPoint(rect.getX(), rect.getY());
    mxPoint bottomRight = new mxPoint(rect.getX() + rect.getWidth(), rect.getY() + rect.getHeight());
    leftTop = convertFromView(view, leftTop);
    bottomRight = convertFromView(view, bottomRight);
    return new mxRectangle(leftTop.getX(), leftTop.getY(), bottomRight.getX() - leftTop.getX(), bottomRight.getY() - leftTop.getY());
  }

  public static int toInt(double value) {
    return ((int) Math.round(value));
  }

  public static Rectangle2D.Double toRectangle2D(mxRectangle rect) {
    return new Rectangle2D.Double(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight());
  }

  public static Rectangle2D.Double extend(Rectangle2D rect, double amount) {
    return extend(rect, amount, amount);
  }

  public static Rectangle2D.Double extend(Rectangle2D rect, double amountX, double amountY) {
    return new Rectangle2D.Double(rect.getX() - amountX, rect.getY() - amountY, rect.getWidth() + amountX * 2, rect.getHeight() + amountY * 2);
  }

  public static double distance(double x1, double y1, double x2, double y2) {
    double dx = x1 - x2;
    double dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }

  public static mxPoint getAbsolutePosition(mxICell cell) {
    if (cell == null) {
      return new mxPoint(0, 0);
    }
    mxGeometry geometry = cell.getGeometry();
    if (geometry == null) {
      return new mxPoint(0, 0);
    }

    mxICell parent = cell.getParent();
    mxPoint parentPos = getAbsolutePosition(parent);
    mxPoint offset = geometry.getOffset();
    double x = geometry.getX();
    double y = geometry.getY();
    if (geometry.isRelative() && parent != null) {
      x *= check_sofulf_a0a0j0w(parent.getGeometry());
      y *= check_sofulf_a0b0j0w(parent.getGeometry());
    }
    x = parentPos.getX() + x + check_sofulf_a0a01a22(offset);
    y = parentPos.getY() + y + check_sofulf_a0a11a22(offset);
    return new mxPoint(x, y);
  }

  public static float getMarkerSize(mxCellState state, boolean source) {
    Map<String, Object> style = state.getStyle();
    float size = (mxUtils.getFloat(style, ((source) ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE), mxConstants.DEFAULT_MARKERSIZE));
    return size;
  }

  public static void visitCells(mxIGraphModel model, _FunctionTypes._return_P1_E0<? extends Boolean, ? super mxCell> visitor) {
    visitCells(model, (mxCell) model.getRoot(), visitor);
  }

  public static void visitAllCells(mxIGraphModel model, final _FunctionTypes._void_P1_E0<? super mxCell> visitor) {
    visitCells(model, (mxCell) model.getRoot(), (mxCell cell) -> {
      visitor.invoke(cell);
      return false;
    });
  }

  public static boolean visitCells(mxIGraphModel model, mxCell root, _FunctionTypes._return_P1_E0<? extends Boolean, ? super mxCell> visitor) {
    boolean stop = visitor.invoke(root);
    if (stop) {
      return true;
    }
    for (int i = model.getChildCount(root) - 1; i >= 0; i--) {
      stop = visitCells(model, (mxCell) model.getChildAt(root, i), visitor);
      if (stop) {
        return true;
      }
    }
    return false;
  }

  public static MPSCell findMPSCell(mxIGraphModel model, final EditorCell editorCell) {
    final Wrappers._T<MPSCell> result = new Wrappers._T<MPSCell>(null);
    JGraphUtil.visitCells(model, (mxCell cell) -> {
      if (cell instanceof IMPSCellContainer) {
        for (MPSCell m : ListSequence.fromList(((IMPSCellContainer) cell).getMPSCells())) {
          if (m.getEditorCell() == editorCell) {
            result.value = m;
            return true;
          }
        }
      }
      return false;
    });

    return result.value;
  }

  public static List<mxCell> getChildCells(mxICell parent) {
    List<mxCell> result = ListSequence.fromList(new ArrayList<mxCell>());
    if (parent != null) {
      for (int i = 0; i < parent.getChildCount(); i++) {
        ListSequence.fromList(result).addElement((mxCell) parent.getChildAt(i));
      }
    }
    return result;
  }

  public static List<mxCell> getSiblings(final mxICell cell) {
    return ListSequence.fromList(getChildCells(cell.getParent())).where((it) -> it != cell).toList();
  }

  public static boolean isAncestor(mxCell ancestor, mxCell descendant) {
    if (ancestor == descendant) {
      return true;
    }
    if (descendant.getParent() == null) {
      return false;
    }
    return isAncestor(ancestor, ((mxCell) descendant.getParent()));
  }

  @Nullable
  public static <T extends mxCell> T getAncestor(@NotNull mxCell descendant, @NotNull Class<T> type) {
    for (mxCell parent = (mxCell) descendant.getParent(); parent != null; parent = (mxCell) parent.getParent()) {
      if (type.isInstance(parent)) {
        return (T) parent;
      }
    }
    return null;
  }

  private static <T> void getDescendants(mxCell parent, Class<T> type, List<T> result) {
    for (mxCell child : ListSequence.fromList(getChildCells(parent))) {
      if (type.isInstance(child)) {
        ListSequence.fromList(result).addElement((T) child);
      }
      getDescendants(child, type, result);
    }
  }

  public static <T> List<T> getDescendants(mxCell parent, Class<T> type) {
    List<T> result = ListSequence.fromList(new ArrayList<T>());
    getDescendants(parent, type, result);
    return result;
  }

  public static <T> List<T> getDescendantsAndMe(mxCell parent, Class<T> type) {
    List<T> result = ListSequence.fromList(new ArrayList<T>());
    if (type.isInstance(parent)) {
      ListSequence.fromList(result).addElement((T) parent);
    }
    getDescendants(parent, type, result);
    return result;
  }


  public static double distanceLinePoint(Vector2D x, Line2D r) {
    Vector2D p = projectPointOnLine(x, r, true);
    return x.distance(p);
  }

  public static Vector2D projectPointOnLine(Vector2D x, Line2D r) {
    return projectPointOnLine(x, r, false);
  }

  public static Vector2D projectPointOnLine(Vector2D x, Line2D r, boolean limitPoint) {
    // https://de.wikipedia.org/wiki/Orthogonalprojektion#Herleitung
    Vector2D r0 = VectorExtensions.toVector2D(ExtensionMethods.toPoint(r.getP1()));
    Vector2D r1 = VectorExtensions.toVector2D(ExtensionMethods.toPoint(r.getP2()));
    Vector2D u = r1.subtract(r0);
    double lambda = x.subtract(r0).dotProduct(u) / u.dotProduct(u);
    if (limitPoint) {
      // P = r0 + lambda * u is the projection of x on the line r.
      // The line through P and x is perpendicular to the line r and therefore the distance between P and x the
      // shortest distance between r and x.
      // We want to constraint P to be between the two points of the line r. We can do that by limiting lambda to [0;1]
      lambda = Math.max(0.0, Math.min(1.0, lambda));
    }
    Vector2D p = r0.add(lambda, u);
    return p;
  }

  public static void dumpOptions(ElkGraphElement element, String zlass, IElkProgressMonitor progressMonitor) {
    progressMonitor.log(String.format("Options for node of class '%s':", zlass));
    for (IMapping<IProperty<?>, Object> property : MapSequence.fromMap(element.getAllProperties())) {
      IProperty<?> key = property.key();
      Object value = property.value();
      if (!(Objects.equals(key.getDefault(), value))) {
        progressMonitor.log(String.format("\t - %s (%s-%s) = %s (default:%s)", key.getId(), key.getLowerBound(), key.getUpperBound(), value, key.getDefault()));
      }
    }
  }
  private static double check_sofulf_a0a0j0w(mxGeometry checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getWidth();
    }
    return 0;
  }
  private static double check_sofulf_a0b0j0w(mxGeometry checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getHeight();
    }
    return 0;
  }
  private static double check_sofulf_a0a01a22(mxPoint checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getX();
    }
    return 0;
  }
  private static double check_sofulf_a0a11a22(mxPoint checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getY();
    }
    return 0;
  }
}

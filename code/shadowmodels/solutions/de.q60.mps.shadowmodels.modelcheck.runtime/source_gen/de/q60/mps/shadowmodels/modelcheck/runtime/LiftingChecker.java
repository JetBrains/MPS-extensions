package de.q60.mps.shadowmodels.modelcheck.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.checking.UpdateResult;
import jetbrains.mps.util.Cancellable;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Objects;
import jetbrains.mps.nodeEditor.HighlighterMessage;

public class LiftingChecker extends BaseEditorChecker {

  private Map<EditorComponent, Long> changeCounts = MapSequence.fromMap(new WeakHashMap<EditorComponent, Long>());
  private SRepository repository;

  public LiftingChecker(SRepository repository) {
    this.repository = repository;
  }

  @NotNull
  @Override
  public UpdateResult update(EditorComponent component, boolean incremental, boolean applyQuickFixes, Cancellable cancellable) {
    SNode rootNode = component.getEditedNode();
    List<EditorMessage> liftedMessages = ListSequence.fromList(new ArrayList<EditorMessage>());
    List<LiftedReportItem> messages;
    long time;
    {
      Tuples._2<Long, List<LiftedReportItem>> _tmp_nxyelr_e0g = LiftedMessagesCache.getInstance().getChangeCountAndMessages();
      time = _tmp_nxyelr_e0g._0();
      messages = _tmp_nxyelr_e0g._1();
    }
    for (LiftedReportItem message : ListSequence.fromList(messages)) {
      SNode messageTarget = message.getNode().resolve(repository);
      if (messageTarget == null) {
        continue;
      }
      if (!(Objects.equals(messageTarget.getContainingRoot(), rootNode))) {
        continue;
      }
      ListSequence.fromList(liftedMessages).addElement(new HighlighterMessage(this, message, messageTarget));
    }
    MapSequence.fromMap(changeCounts).put(component, time);
    return new UpdateResult.Completed(true, liftedMessages);
  }

  @Override
  public boolean needsUpdate(EditorComponent editorComponent) {
    return !(Objects.equals(LiftedMessagesCache.getInstance().getChangeCount(), MapSequence.fromMap(changeCounts).get(editorComponent)));
  }
}

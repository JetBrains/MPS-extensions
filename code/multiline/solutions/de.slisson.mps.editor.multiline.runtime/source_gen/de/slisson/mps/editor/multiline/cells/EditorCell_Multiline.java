package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.openapi.editor.cells.CellConditions;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.model.SNode;
import de.itemis.mps.editor.celllayout.runtime.TopDownCellLayoutAdapter;
import de.slisson.mps.editor.multiline.runtime.MultilineUtil;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import de.slisson.mps.editor.multiline.runtime.CellUtils;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Graphics;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import java.awt.Color;
import jetbrains.mps.openapi.editor.message.SimpleEditorMessage;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import jetbrains.mps.nodeEditor.EditorMessage;
import name.fraser.neil.plaintext.diff_match_patch;
import jetbrains.mps.vcs.diff.ui.common.ChangeColors;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.SortedSet;
import jetbrains.mps.internal.collections.runtime.SortedSetSequence;
import java.awt.Shape;
import java.util.TreeSet;
import org.jetbrains.annotations.NotNull;
import java.util.Iterator;

public class EditorCell_Multiline extends EditorCell_Collection {
  private static final Logger LOG_212570738 = Logger.getLogger(EditorCell_Multiline.class);
  private static final CellAction LOCAL_END_ACTION = new AbstractCellAction() {
    @Override
    public boolean executeInCommand() {
      return false;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCellLabelSelection selection = getSelection(context);
      if (selection == null) {
        return false;
      }
      if (selection.getSelectionEnd() != selection.getEditorCellLabel().getText().length()) {
        return false;
      }
      EditorCell nextLeaf = getNextLabel(selection);
      if (nextLeaf == null) {
        return false;
      }
      return true;
    }
    public void execute(EditorContext context) {
      EditorCellLabelSelection selection = getSelection(context);
      if (selection == null) {
        return;
      }
      EditorCell_Label nextLabel = getNextLabel(selection);
      context.getSelectionManager().setSelection(nextLabel, nextLabel.getText().length());
    }
    public EditorCellLabelSelection getSelection(EditorContext context) {
      return as_v798xa_a0a0d0a0b(context.getSelectionManager().getSelection(), EditorCellLabelSelection.class);
    }
    public EditorCell_Label getNextLabel(EditorCellLabelSelection selection) {
      return as_v798xa_a0a0e0a0b(CellTraversalUtil.getNextLeaf(selection.getEditorCell(), CellConditions.SELECTABLE), EditorCell_Label.class);
    }
  };

  private ModelAccessor myModelAccessor;
  private MultilineText myMultilineText;
  private String myPlaceholderText = "";
  private List<WordCellInitializer> myWordCellInitializers = new ArrayList<WordCellInitializer>();
  private List<MultilineCellBackgroundPainter> myBackgroundPainters = new ArrayList<MultilineCellBackgroundPainter>();
  private boolean diffPaintingDisabled = false;
  private List<Integer> recentCursorPosition = ListSequence.fromList(new LinkedList<Integer>());


  protected EditorCell_Multiline(EditorContext context, ModelAccessor accessor, SNode node) {
    super(context, node, new TopDownCellLayoutAdapter(new MultilineLayout()), null);
    myModelAccessor = accessor;
    myMultilineText = new MultilineText(MultilineUtil.unescapeText(accessor.getText()));
    bindModel();

    setAction(CellActionType.LOCAL_END, LOCAL_END_ACTION);
  }

  public void setPlaceholderText(String placeholderText) {
    myPlaceholderText = (placeholderText == null ? "" : placeholderText);
    modelToView();
  }

  public void bindModel() {
    myMultilineText.addListener(MultilineText.PROPERTY_TEXT, new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent e) {
        final String newText = ((String) e.getNewValue());
        if (getContext().getOperationContext().getProject().getModelAccess().canWrite()) {
          textToProperty(newText);
        } else {
          getContext().getOperationContext().getProject().getModelAccess().executeCommand(() -> textToProperty(newText));
        }
      }
    });
    myMultilineText.addListener(MultilineText.PROPERTY_WORDS, new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent e) {
        ModelAccess modelAccess = getEditorComponent().getEditorContext().getRepository().getModelAccess();
        if (modelAccess.canWrite()) {
          modelToView();
        } else {
          modelAccess.executeCommand(() -> modelToView());
        }
      }
    });
    modelToView();
  }
  @Override
  public void synchronizeViewWithModel() {
    myMultilineText.setTextSilently(MultilineUtil.unescapeText(myModelAccessor.getText()));
    modelToView();
  }
  protected void modelToView() {
    Iterable<String[]> lines = Sequence.fromArray(myMultilineText.getWords());
    int totalWords = myMultilineText.getTotalWords();

    setNumberOfWordCells(totalWords);
    List<EditorCell_Word> wordCells = Sequence.fromIterable(getWordCells()).toList();
    int wordNum = -1;

    for (String[] line : lines) {
      for (String word : line) {
        ++wordNum;
        EditorCell_Word wordCell = ListSequence.fromList(wordCells).getElement(wordNum);
        wordCell.setText(word);
        wordCell.setNewLine(false);
      }
      ListSequence.fromList(wordCells).getElement(wordNum).setNewLine(true);
    }
    ListSequence.fromList(wordCells).last().setNewLine(false);

    EditorCell_Word firstWordCell = firstCell();
    firstWordCell.setDefaultText((isEmptyString(myMultilineText.getText()) ? myPlaceholderText : ""));
  }
  public void textToProperty(String newText) {
    String oldText = myModelAccessor.getText();
    if (!(Objects.equals(oldText, newText))) {
      myModelAccessor.setText(MultilineUtil.escapeText(newText));
    }
  }
  public void setNumberOfWordCells(int count) {
    while (getCellsCount() > count) {
      removeCell(Sequence.fromIterable(Sequence.fromArray(getCells())).last());
    }
    while (getCellsCount() < count) {
      addEditorCell(this.newWordCell(getCellsCount()));
    }
  }
  @Override
  public String toString() {
    String shortText = getText();
    if (check_v798xa_a0b0u(shortText) > 30) {
      shortText = shortText.substring(0, 30);
    }
    return getClass().getSimpleName() + "[" + shortText + "]";
  }
  public int getCaretPosition() {
    int pos = 0;
    EditorCell selectedCell = getContext().getSelectedCell();
    if (selectedCell instanceof EditorCell_Word) {
      EditorCell_Word selectedWordCell = (EditorCell_Word) selectedCell;
      if (selectedWordCell.getParent() != this) {
        return 0;
      }
      pos = Sequence.fromIterable(getCellsBefore(selectedWordCell)).foldLeft(0, (Integer s, EditorCell_Word it) -> s + it.getTextIncludingSeparator().length());
      pos += selectedWordCell.getCaretPosition();
    }
    return pos;
  }
  public boolean isCaretAtLineStart() {
    return getTextBeforeCaret().endsWith("\n") || getCaretPosition() == 0;
  }
  public boolean isCaretAtWordStart() {
    boolean result = false;
    EditorCell selectedCell = getContext().getSelectedCell();
    if (selectedCell instanceof EditorCell_Word) {
      EditorCell_Word selectedWordCell = (EditorCell_Word) selectedCell;
      result = selectedWordCell.getCaretPosition() == 0;
    }
    return result;
  }
  public boolean isCaretAtWordEnd() {
    boolean result = false;
    EditorCell selectedCell = getContext().getSelectedCell();
    if (selectedCell instanceof EditorCell_Word) {
      EditorCell_Word selectedWordCell = (EditorCell_Word) selectedCell;
      result = selectedWordCell.getCaretPosition() == selectedWordCell.getText().length();
    }
    return result;
  }
  public void setCaretPosition(int pos) {
    setCaretPosition(pos, false);
  }
  public EditorCell_Word getWordCellContainingPos(int pos) {
    int remainingPos = pos;
    for (EditorCell_Word wordCell : Sequence.fromIterable(getWordCells())) {
      int textLen = wordCell.getText().length();
      if (remainingPos <= textLen) {
        return wordCell;
      }
      remainingPos -= textLen + 1;
    }
    return Sequence.fromIterable(getWordCells()).last();
  }
  public void setCaretPosition(int pos, boolean enforceSelection) {
    // If the EditorComponent is rebuild after a model modification, this cell might not be part of the component
    // anymore. Therefor, we search for the new multiline cell and forward the call to that one.
    getEditor().getUpdater().flushModelEvents();
    check_v798xa_a3a72(((EditorCell_Multiline) getCellInfo().findCell(getEditor())), pos, enforceSelection, this);
  }
  private void setCaretPosition_(int pos, boolean enforceSelection) {
    int remainingPos = pos;
    for (EditorCell_Word wordCell : Sequence.fromIterable(getWordCells())) {
      int textLen = wordCell.getText().length();
      if (remainingPos <= textLen) {
        if (enforceSelection || Sequence.fromIterable(Sequence.fromArray(getCells())).contains((jetbrains.mps.nodeEditor.cells.EditorCell) getContext().getSelectedCell())) {
          CellUtils.setSelection(wordCell, getContext());
        }
        wordCell.setCaretPositionIfPossible(remainingPos);
        break;
      }
      remainingPos -= textLen + 1;
    }
  }
  public void insertText(String text) {
    int caretPos = getCaretPosition();
    myMultilineText.setText(getTextBeforeCaret() + text + getTextAfterCaret());
    setCaretPosition(caretPos + text.length(), true);
  }
  public String getTextBefore(EditorCell_Word wordCell, int pos) {
    StringBuffer textBefore = new StringBuffer();
    Iterable<EditorCell_Word> cellsBefore = getCellsBefore(wordCell);
    if (Sequence.fromIterable(cellsBefore).isNotEmpty()) {
      textBefore.append(IterableUtils.join(Sequence.fromIterable(cellsBefore).select((it) -> it.getTextIncludingSeparator()), ""));
    }
    textBefore.append(wordCell.getTextBefore(pos));

    return textBefore.toString();
  }
  public int getCellStartPosition(EditorCell_Word wordCell) {
    return getAbsoluteTextPosition(wordCell, 0);
  }
  public int getAbsoluteTextPosition(EditorCell_Word wordCell, int relativePos) {
    return check_v798xa_a0a23(getTextBefore(wordCell, relativePos), this);
  }
  public Iterable<EditorCell_Word> getCellsBefore(EditorCell_Word cell) {
    if (cell.getParent() != this) {
      throw new RuntimeException("word cell is not part of this multiline cell");
    }
    List<EditorCell_Word> result = ListSequence.fromList(new ArrayList<EditorCell_Word>());
    int cellNum = indexOf(cell);
    if (cellNum >= 0) {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(getWordCells()).take(cellNum));
    }
    return result;
  }
  public String getTextBeforeCaret() {
    return myMultilineText.getText().substring(0, getCaretPosition());
  }
  public String getTextAfterCaret() {
    return myMultilineText.getText().substring(getCaretPosition());
  }
  public Iterable<EditorCell_Word> getWordCells() {
    return Sequence.fromIterable(Sequence.fromArray(getCells())).select((it) -> (EditorCell_Word) it);
  }
  public String getText() {
    return myMultilineText.getText();
  }
  public void setText(String newText) {
    newText = check_v798xa_a0a0mb(newText);
    myMultilineText.setText(newText);
    modelToView();
  }
  public void deleteWords(int from, int to) {
    myMultilineText.deleteWords(from, to);
  }
  public EditorCell_Word newWordCell(int wordNum) {
    EditorCell_Word wordCell = EditorCell_Word.create(getContext(), new WordModelAccessor(wordNum, myMultilineText), getSNode(), wordNum);
    wordCell.setCellContext(getCellContext());
    for (WordCellInitializer initializer : ListSequence.fromList(myWordCellInitializers)) {
      initializer.initialize(wordCell);
    }
    return wordCell;
  }
  @Override
  public EditorCell_Word firstCell() {
    return (EditorCell_Word) super.firstCell();
  }

  public EditorCell_Word lastCell() {
    return (EditorCell_Word) super.lastCell();
  }

  public int getTextLength() {
    return check_v798xa_a0a54(getText(), this);
  }
  public void addWordCellInitializer(WordCellInitializer initializer) {
    myWordCellInitializers.add(initializer);
    for (EditorCell_Word wordCell : Sequence.fromIterable(getWordCells())) {
      initializer.initialize(wordCell);
    }
  }
  public void removeWordCellInitializer(WordCellInitializer initializer) {
    myWordCellInitializers.remove(initializer);
  }
  public List<WordCellInitializer> getWordCellInitializers() {
    return new ArrayList<WordCellInitializer>(myWordCellInitializers);
  }
  public Rectangle getCharacterBounds(int charNum) {
    EditorCell_Word wordCell = getWordCellContainingPos(charNum);
    int relativeNum = charNum - getAbsoluteTextPosition(wordCell, 0);
    relativeNum = Math.max(relativeNum, 0);
    relativeNum = Math.min(relativeNum, wordCell.getTextLengthIncludingSeparator() - 1);
    return wordCell.getCharacterBounds(relativeNum);
  }
  @Override
  public ParentSettings fillBackground(Graphics g, ParentSettings parentSettings) {
    if (!(parentSettings.isSkipBackground()) && getStyle().isSpecified(StyleAttributes.BACKGROUND_COLOR)) {
      Color bc = getStyle().get(StyleAttributes.BACKGROUND_COLOR);
      if (bc != null) {
        g.setColor(bc);
        List<Rectangle> selection = myCellLayout.getSelectionBounds(this);
        for (Rectangle part : selection) {
          g.fillRect(part.x, part.y, part.width, part.height);
        }
      }
    }
    boolean hasMessages = false;
    Iterable<SimpleEditorMessage> messages = getMessages();
    for (SimpleEditorMessage message : messages) {
      if (message == null) {
        continue;
      }

      // I have no idea how to tell MPS that I need classes from the VCS plugin at compile- and runtime.
      // If I just import the models and use the classes I get errors when I try to compile this model.
      // Using the reflection API removes the need of having access to VCS plugin classes.
      try {
        Class msgClass = message.getClass();
        if (msgClass.getName().equals("jetbrains.mps.vcs.diff.ui.common.ChangeEditorMessage")) {
          if (diffPaintingDisabled) {
            continue;
          }

          Field myChangeField = msgClass.getDeclaredField("myChange");
          myChangeField.setAccessible(true);
          Object change = myChangeField.get(message);
          if (change.getClass().getName().equals("jetbrains.mps.vcs.diff.changes.SetPropertyChange")) {
            Field highlightedField = msgClass.getDeclaredField("myHighlighted");
            highlightedField.setAccessible(true);
            boolean highlighted = (Boolean) highlightedField.get(message);
            if (highlighted && !(diffPaintingDisabled)) {
              Class changeClass = change.getClass();
              Object opposite = changeClass.getMethod("getOppositeChange").invoke(change);
              Method getValue = changeClass.getMethod("getNewValue");
              String newValue = (String) getValue.invoke(change);
              newValue = MultilineUtil.unescapeText(newValue);
              String oldValue = (String) getValue.invoke(opposite);
              oldValue = MultilineUtil.unescapeText(oldValue);
              boolean iAmOld = !(Objects.equals(getText(), newValue));
              paintDiff(g, oldValue, newValue, iAmOld);
              hasMessages = true;
              continue;
            }
          }
        }
      } catch (Exception ex) {
        if (LOG_212570738.isErrorLevel()) {
          LOG_212570738.error("", ex);
        }
      }

      if (check_v798xa_a7a3a05(as_v798xa_a0a7a3a15(message, EditorMessage.class))) {
        ((EditorMessage) message).paint(g, getEditor(), this);
        hasMessages = true;
      }
    }

    for (MultilineCellBackgroundPainter painter : ListSequence.fromList(myBackgroundPainters)) {
      painter.paint(this, g, parentSettings);
    }

    ParentSettings settings = isSelectionPaintedOnAncestor(parentSettings);
    if (!(settings.isSelectionPainted())) {
      if (!(parentSettings.isSkipBackground()) && getStyle().isSpecified(StyleAttributes.BACKGROUND_COLOR)) {
        // BACKGROUND_COLOR is always present as it's inherited from EC defaults; here we need to paint cell background
        // only in case it was explicitly specified in the cell settings.
        // PS.isSkipBackground seems to still make sense as it reflects EditorMessage aspect rather than BG inheritable defaults.
        Color backgroundColor = getStyle().get(StyleAttributes.BACKGROUND_COLOR);
        if (backgroundColor != null) {
          g.setColor(backgroundColor);
          paintBackground(g);
        }
      }
      settings = ParentSettings.createBackgroundlessSetting(hasMessages).combineWith(parentSettings);
    }
    paintSelectionIfRequired(g, parentSettings);
    return settings;

  }

  @Override
  public void paintSelection(Graphics g, Color c, boolean drawBorder, ParentSettings parentSettings) {
    paintRange(g, 0, getTextLength(), c, drawBorder);
  }

  public void paintDiff(Graphics g, String oldText, String newText, boolean iAmOld) {
    diff_match_patch differ = new diff_match_patch();
    LinkedList<diff_match_patch.Diff> diffsLL = (iAmOld ? differ.diff_main(newText, oldText) : differ.diff_main(oldText, newText));
    differ.diff_cleanupSemantic(diffsLL);
    Color colorInsert = ChangeColors.getInstance().getDiffColor(ChangeType.ADD);
    Color colorDelete = ChangeColors.getInstance().getDiffColor(ChangeType.DELETE);
    Color colorChange = ChangeColors.getInstance().getDiffColor(ChangeType.CHANGE);

    List<diff_match_patch.Diff> diffs = new ArrayList<diff_match_patch.Diff>(diffsLL);
    int start = 0;
    for (int i = 0; i < diffs.size(); i++) {
      diff_match_patch.Diff prevDiff = (i > 0 ? diffs.get(i - 1) : null);
      diff_match_patch.Diff diff = diffs.get(i);
      diff_match_patch.Diff nextDiff = (i < diffs.size() - 1 ? diffs.get(i + 1) : null);
      switch (diff.operation) {
        case EQUAL:
          start += diff.text.length();
          break;
        case DELETE:
          if (nextDiff != null && nextDiff.operation == diff_match_patch.Operation.INSERT) {
            continue;
          }
          Rectangle rect2 = getCharacterBounds(start);
          rect2.width = 4;
          rect2.y -= 1;
          rect2.height += 3;
          rect2.x -= 2;
          g.setColor((iAmOld ? colorInsert : colorDelete));
          g.fillRect(rect2.x, rect2.y, rect2.width, rect2.height);
          break;
        case INSERT:
          Color color = (iAmOld ? colorDelete : colorInsert);
          if (prevDiff != null && prevDiff.operation == diff_match_patch.Operation.DELETE) {
            color = colorChange;
          }
          paintRange(g, start, start + diff.text.length() - 1, color, true);
          start += diff.text.length();
          break;
        default:
      }
    }
  }
  public void paintRange(Graphics g, int start, int end, Color color, boolean border) {
    final Wrappers._int _start = new Wrappers._int(start);
    final Wrappers._int _end = new Wrappers._int(end);
    if (_start.value > _end.value) {
      int temp = _start.value;
      _start.value = _end.value;
      _end.value = temp;
    }
    SortedSet<Integer> lineEnds = findAllLineEnds();
    SortedSetSequence.fromSet(lineEnds).addElement(_end.value);

    int lineStart = _start.value;
    for (int lineEnd : SortedSetSequence.fromSet(lineEnds).where((it) -> _start.value <= it && it <= _end.value)) {
      paintLine(g, lineStart, lineEnd, color, border);
      lineStart = lineEnd + 1;
    }
  }
  /**
   * precondition: the characters at 'start' and 'end' have to be on the same line
   */
  public void paintLine(Graphics g, int start, int end, Color color, boolean border) {
    Rectangle rect = getCharacterBounds(start).union(getCharacterBounds(end));
    g.setColor(color);
    g.fillRect(rect.x, rect.y, rect.width, rect.height);
    if (border) {
      g.setColor(color.darker());
      g.drawRect(rect.x, rect.y, rect.width, rect.height);
    }

    Shape originalClip = g.getClip();
    g.setClip(rect);
    int wordStartPos = 0;
    for (EditorCell_Word word : Sequence.fromIterable(getWordCells())) {
      int wordEndPos = wordStartPos + word.getTextLengthIncludingSeparator();
      if (wordEndPos >= start && wordStartPos <= end) {
        word.paintCell(g, ParentSettings.createSelectedSetting(true));
        word.paintDecorations(g);
      }
      wordStartPos = wordEndPos;
    }
    g.setClip(originalClip);


  }
  public SortedSet<Integer> findAllLineEnds() {
    SortedSet<Integer> result = SortedSetSequence.fromSet(new TreeSet<Integer>());
    List<EditorCell_Word> wordCells = Sequence.fromIterable(getWordCells()).toList();
    int start = 0;
    for (int i = 0; i < ListSequence.fromList(wordCells).count(); i++) {
      EditorCell_Word cell = ListSequence.fromList(wordCells).getElement(i);
      EditorCell_Word nextCell = (i < ListSequence.fromList(wordCells).count() - 1 ? ListSequence.fromList(wordCells).getElement(i + 1) : null);
      int textLen = cell.getTextIncludingSeparator().length();
      if (nextCell == null) {
        SortedSetSequence.fromSet(result).addElement(start + textLen - 1);
      } else {
        if (cell.getY() != nextCell.getY()) {
          SortedSetSequence.fromSet(result).addElement(start + textLen - 1);
        }
      }
      start += textLen;
    }
    return result;
  }
  public void addBackgroundPainter(MultilineCellBackgroundPainter painter) {
    myBackgroundPainters.add(painter);
  }
  public void disabledDiffPainting() {
    diffPaintingDisabled = true;
  }
  public void rememberCursorPosition() {
    rememberCursorPosition(getCaretPosition());
  }
  public void rememberCursorPosition(int pos) {
    ListSequence.fromList(recentCursorPosition).insertElement(0, pos);
    while (ListSequence.fromList(recentCursorPosition).count() > 10) {
      ListSequence.fromList(recentCursorPosition).removeLastElement();
    }
  }
  public int getRecentCursorPosition(int age) {
    if (ListSequence.fromList(recentCursorPosition).count() == 0) {
      return 0;
    } else if (age < 0) {
      return ListSequence.fromList(recentCursorPosition).first();
    } else if (age >= ListSequence.fromList(recentCursorPosition).count()) {
      return ListSequence.fromList(recentCursorPosition).last();
    } else {
      return ListSequence.fromList(recentCursorPosition).getElement(age);
    }
  }
  public static EditorCell_Multiline create(EditorContext context, ModelAccessor accessor, SNode node) {
    EditorCell_Multiline result = new EditorCell_Multiline(context, accessor, node);
    return result;
  }

  public int indexOf(EditorCell_Word cell) {
    // TODO: I removed assertion concerning validating actual index of this cell from here. Should we return it back?
    return cell.getWordNum();
  }

  @Override
  @NotNull
  public Iterator<EditorCell> iterator() {
    final Iterator<EditorCell> original = super.iterator();
    if (getCellsCount() > 300) {
      return new Iterator<EditorCell>() {
        private EditorCell last;
        public boolean hasNext() {
          if (check_v798xa_a0a1a0a0a1a76(as_v798xa_a0a0a1a0a0a1a86(last, EditorCell_Word.class))) {
            // CellFinder.getCellForProperty is slow for large collections. Here we detect that and stop the search.
            return false;
          }
          return original.hasNext();
        }
        public EditorCell next() {
          EditorCell next = original.next();
          check_v798xa_a1a2a0a0a1a76(as_v798xa_a0a1a2a0a0a1a86(next, EditorCell_Word.class));
          last = next;
          return next;
        }
        public void remove() {
          original.remove();
        }
      };
    }
    return original;
  }
  private static int check_v798xa_a0b0u(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }
  private static void check_v798xa_a3a72(EditorCell_Multiline checkedDotOperand, Integer pos, Boolean enforceSelection, EditorCell_Multiline checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      checkedDotOperand.setCaretPosition_(pos, enforceSelection);
    }

  }
  private static int check_v798xa_a0a23(String checkedDotOperand, EditorCell_Multiline checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }
  private static String check_v798xa_a0a0mb(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.replace("\\n", "\n");
    }
    return null;
  }
  private static int check_v798xa_a0a54(String checkedDotOperand, EditorCell_Multiline checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }
  private static boolean check_v798xa_a7a3a05(EditorMessage checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isBackground();
    }
    return false;
  }
  private static boolean check_v798xa_a0a1a0a0a1a76(EditorCell_Word checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.wasModelAccessorRequested();
    }
    return false;
  }
  private static boolean check_v798xa_a1a2a0a0a1a76(EditorCell_Word checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.wasModelAccessorRequested();
    }
    return false;
  }
  private static <T> T as_v798xa_a0a0d0a0b(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_v798xa_a0a0e0a0b(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static boolean isEmptyString(String str) {
    return str == null || str.isEmpty();
  }
  private static <T> T as_v798xa_a0a7a3a15(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_v798xa_a0a0a1a0a0a1a86(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_v798xa_a0a1a2a0a0a1a86(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

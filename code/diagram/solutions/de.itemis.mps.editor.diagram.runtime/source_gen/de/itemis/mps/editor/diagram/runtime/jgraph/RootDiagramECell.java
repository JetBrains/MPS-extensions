package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorCell_WithComponent;
import de.itemis.mps.tooltips.runtime.ITooltipProvider;
import jetbrains.mps.logging.Logger;
import java.awt.Color;
import com.intellij.ui.JBColor;
import javax.swing.Timer;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.SwingUtilities;
import com.mxgraph.util.mxEventSource;
import com.mxgraph.util.mxEventObject;
import com.mxgraph.model.mxGraphModel;
import jetbrains.mps.openapi.editor.selection.SelectionListener;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.openapi.editor.selection.Selection;
import java.awt.Component;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.nodeEditor.selection.EditorCellSelection;
import java.awt.KeyboardFocusManager;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.openapi.editor.EditorContext;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import de.itemis.mps.editor.diagram.runtime.ContextVariables;
import javax.swing.BorderFactory;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.CellAction;
import javax.swing.JScrollPane;
import javax.swing.JViewport;
import java.awt.Rectangle;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.plugins.projectplugins.ProjectPluginManager;
import de.itemis.mps.editor.diagram.runtime.plugin.Diagram_Palette_Tool;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import java.util.Comparator;
import jetbrains.mps.nodeEditor.cells.collections.Entry;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Graphics2D;
import java.awt.BasicStroke;
import de.itemis.mps.editor.diagram.runtime.model.ScalableEditorCell;
import java.awt.Dimension;
import com.mxgraph.view.mxGraphView;
import com.mxgraph.util.mxPoint;
import de.itemis.mps.editor.diagram.runtime.EditorUtil;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import com.mxgraph.util.mxEvent;
import java.awt.event.ActionEvent;
import jetbrains.mps.nodeEditor.NodeEditorComponent;
import javax.swing.JComponent;
import com.mxgraph.view.mxGraph;
import de.itemis.mps.editor.diagram.runtime.coordinates.ICoordinateSystem;
import de.itemis.mps.editor.diagram.runtime.coordinates.AffineTransformCoordinateSystem;
import de.itemis.mps.editor.diagram.runtime.coordinates.GlobalCoordinateSystem;
import java.awt.geom.AffineTransform;
import de.itemis.mps.tooltips.runtime.ITooltip;
import com.mxgraph.model.mxCell;
import java.awt.Point;
import jetbrains.mps.nodeEditor.EditorSettings;
import org.jetbrains.annotations.Nullable;
import de.slisson.mps.editor.multiline.cells.EditorCell_Multiline;
import jetbrains.mps.nodeEditor.cells.ConstantModelAccessor;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.nodeEditor.MPSFonts;
import java.awt.Container;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class RootDiagramECell extends BaseDiagramECell implements EditorCell_WithComponent, ITooltipProvider {
  private static final Logger LOG_25670992 = Logger.getLogger(RootDiagramECell.class);
  public static final Color DEFAULT_BACKGROUND_COLOR = new JBColor(new Color(240, 240, 240), new Color(240, 240, 240));

  protected MyGraph myGraph;
  protected MyGraphComponent myGraphComponent;
  private Timer myFocusTimer;
  private boolean myIsUpdatingMaximized = false;

  private MyVertexHandler lastVertexHandler = null;
  private MyEdgeHandler lastEdgeHandler = null;

  private ChangeListener myViewportChangeListener = new ChangeListener() {
    public void stateChanged(ChangeEvent event) {
      // added as a workaround in case listener doesn't get removed properly in a cell not contained in the tree
      if (!(isInTree())) {
        SwingUtilities.invokeLater(() -> getScrollPane().getViewport().removeChangeListener(myViewportChangeListener));
        return;
      }
      if (myIsUpdatingMaximized) {
        return;
      }
      try {
        myIsUpdatingMaximized = true;
        updateMaximizedState();
      } finally {
        myIsUpdatingMaximized = false;
      }

    }
  };

  private mxEventSource.mxIEventListener myGraphModelChangeListener = new mxEventSource.mxIEventListener() {
    public void invoke(Object sender, mxEventObject event) {
      if (((mxGraphModel) sender).getUpdateLevel() == 0) {
        requestRelayout();
      }
    }
  };

  private SelectionListener mySelectionListener = new SelectionListener() {
    public void selectionChanged(EditorComponent component, Selection oldSelection, Selection newSelection) {
      if (((jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent()).isSearchPanelVisible()) {
        // The search panel sets the selection to the search result. Stealing the focus will cause an unintended change
        // of the cell text.
        return;
      }
      Component newFocus = null;
      boolean allowStealingFocus = false;
      if (newSelection instanceof SingularSelection && !(newSelection instanceof GraphSelection)) {
        SingularSelection singularSelection = ((SingularSelection) newSelection);
        EditorCell editorCell = singularSelection.getEditorCell();
        if (editorCell == RootDiagramECell.this) {
          return;
        }
        MPSCell mpsCell = myGraph.getMPSCellRegistry().findAncestor(editorCell);
        if (mpsCell == null) {
          mpsCell = myGraph.getMPSCellRegistry().findAncestor(CellTraversalUtil.getFirstLeaf(editorCell));
        }
        if (mpsCell != null) {
          Style style = mpsCell.getEditorCell().getStyle();
          boolean readOnly = style.get(StyleAttributes.READ_ONLY);
          if (!(readOnly)) {
            myGraphComponent.startEdit(mpsCell);
            newFocus = myGraphComponent;
            allowStealingFocus = true;
          }
        } else {
          myGraphComponent.stopEditing(true);
        }
      }


      if (check_l91fln_a0g0a0a0o(as_l91fln_a0a0g0a0a0p(oldSelection, GraphSelection.class)) == RootDiagramECell.this) {
        newFocus = (jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent();
      }
      if (check_l91fln_a0h0a0a0o(as_l91fln_a0a0h0a0a0p(oldSelection, EditorCellSelection.class)) == RootDiagramECell.this) {
        newFocus = (jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent();
      }
      if (check_l91fln_a0i0a0a0o(as_l91fln_a0a0i0a0a0p(newSelection, GraphSelection.class)) == RootDiagramECell.this) {
        newFocus = myGraphComponent.getGraphControl();
      }
      if (newFocus != null && !(newFocus.hasFocus())) {
        Component currentFocus = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
        if (allowStealingFocus || !(currentFocus instanceof EditorComponent && getEditorComponent() != currentFocus)) {
          newFocus.requestFocusInWindow();
        }
      }
    }

  };

  public void runAutoLayouterOnInit(SNode node, boolean runLayouter) {
    if ((new IAttributeDescriptor.NodeAttribute(CONCEPTS.LayoutMap$4m).get(node) == null) && runLayouter && DiagramControls.enableAutoLayoutOnInit) {
      BaseDiagramDCell dcell = ((BaseDiagramDCell) this.getDCell());
      if (dcell == null) {
        return;
      }

      dcell.runLayouter();
    }
  }

  public void fitToSizeOnInit(SNode node, boolean fitToSize) {
    if ((new IAttributeDescriptor.NodeAttribute(CONCEPTS.LayoutMap$4m).get(node) == null) && fitToSize) {
      DiagramActionsUtil.fitSizeAll(getGraph(), false);
    }
  }

  public RootDiagramECell(final EditorContext context, SNode node, final DiagramModel model) {
    super(context, node, model);
    ContextVariables.withValue("editorComponent", context.getEditorComponent(), () -> myGraph = JGraphModelSynchronizer.getGraph(model));
    DiagramCreationContext.setRootGraph(myGraph);
    BaseDiagramECell.withContextGraph(myGraph, () -> {
      if (!(myModel.getDiagramAccessor().syncWithModelOnlyOnOpening()) || (myModel.getDiagramAccessor().syncWithModelOnlyOnOpening() && myModel.isNewInstance()) || model.isForceReadFromModel()) {
        myModel.synchronizeRead(RootDiagramECell.this);
        myModel.setForceReadFromModel(false);
      }

      myGraphComponent = myGraph.getGraphComponent();
      if (myGraphComponent == null) {
        myGraphComponent = new MyGraphComponent(myGraph);
      }
      myGraphComponent.setDiagramCell(RootDiagramECell.this);
      myGraphComponent.setBorder(BorderFactory.createEmptyBorder());

      myModel.setContextHints(context.getEditorComponent().getUpdater().getCurrentUpdateSession().getCellFactory().getCellContext().getHints());

      getSynchronizer().model2Graph();
      myGraph.getSelectionModel().setDiagramCell(RootDiagramECell.this);
      myGraph.getView().revalidate();
    });

    setAction(CellActionType.LEFT, new PanAction(-myModel.getDiagramAccessor().getPanAmount(), 0));
    setAction(CellActionType.RIGHT, new PanAction(myModel.getDiagramAccessor().getPanAmount(), 0));
    setAction(CellActionType.UP, new PanAction(0, -myModel.getDiagramAccessor().getPanAmount()));
    setAction(CellActionType.DOWN, new PanAction(0, myModel.getDiagramAccessor().getPanAmount()));

    setAction(CellActionType.SELECT_LEFT, new PanAction(-myModel.getDiagramAccessor().getPanAmountSlow(), 0));
    setAction(CellActionType.SELECT_RIGHT, new PanAction(myModel.getDiagramAccessor().getPanAmountSlow(), 0));
    setAction(CellActionType.SELECT_PREVIOUS, new PanAction(0, -myModel.getDiagramAccessor().getPanAmountSlow()));
    setAction(CellActionType.SELECT_NEXT, new PanAction(0, myModel.getDiagramAccessor().getPanAmountSlow()));
  }

  private class PanAction implements CellAction {
    private final double dx;
    private final double dy;

    public PanAction(double dx, double dy) {
      this.dx = dx;
      this.dy = dy;
    }

    @Override
    public String getDescriptionText() {
      return "pan graph by " + dx + ", " + dy;
    }

    @Override
    public boolean executeInCommand() {
      return false;
    }

    @Override
    public boolean canExecute(EditorContext context) {
      Selection selection = context.getSelectionManager().getSelection();
      if (!(selection instanceof EditorCellSelection)) {
        return false;
      }

      // Only react if this cell, and not some child cell, is selected
      return ((EditorCellSelection) selection).getEditorCell() == RootDiagramECell.this;
    }

    @Override
    public void execute(EditorContext p1) {
      myGraphComponent.panView(dx, dy);
    }
  }

  protected boolean isMaximizedMode() {
    return myGraphComponent.isMaxmimizedMode();
  }

  public void maximizedModeChanged(boolean newValue) {
    final JScrollPane scrollPane = getScrollPane();
    JViewport viewport = scrollPane.getViewport();
    if (newValue) {
      viewport.addChangeListener(myViewportChangeListener);
    } else {
      viewport.removeChangeListener(myViewportChangeListener);
    }
    updateMaximizedState();
  }

  protected JScrollPane getScrollPane() {
    return getAncestor(((Component) getEditorComponent()), JScrollPane.class);
  }

  public void updateMaximizedState() {
    if (!(isMaximizedMode())) {
      myGraphComponent.setFixedSize(null);
    }
    requestRelayout();
    ((jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent()).relayout();
    if (isMaximizedMode()) {
      ((jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent()).scrollRectToVisible(new Rectangle(getX(), getY() - 1, getWidth() + 2, getHeight() + 3));
    } else {
    }
  }

  public void readModel() {
    getSynchronizer().model2Graph();
  }

  public void focusTimer() {
    // The graph component loses the focus for some unknown reason.
    // As a workaround we check the focus every 200 ms and set it back to the graph, if it should have the focus.

    jetbrains.mps.nodeEditor.EditorComponent editorComponent = ((jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent());
    Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
    if (!(isAncestor(editorComponent, focusOwner))) {
      return;
    }

    SelectionManager selectionManager = check_l91fln_a0h0ib(getEditorComponent(), this);
    if (selectionManager == null) {
      return;
    }
    GraphSelection selection = as_l91fln_a0a9a53(selectionManager.getSelection(), GraphSelection.class);
    if (selection == null) {
      return;
    }
    MyGraphComponent graphComponent = selection.getDiagramCell().getGraph().getGraphComponent();
    if (graphComponent != myGraphComponent) {
      return;
    }
    if (graphComponent.hasFocus()) {
      return;
    }
    graphComponent.requestFocusInWindow();
  }

  public static boolean isAncestor(Component ancestor, Component descendant) {
    for (Component current = descendant; current != null; current = current.getParent()) {
      if (current == ancestor) {
        return true;
      }
    }
    return false;
  }

  public MyGraph getGraph() {
    return myGraph;
  }

  public Palette getPalette() {
    Project ideaProject = ProjectHelper.toIdeaProject(getContext().getOperationContext().getProject());
    return ProjectPluginManager.getInstance(ideaProject).getTool(Diagram_Palette_Tool.class).getPaletteComponent();
  }

  public void sortChildCellsByPosition() {
    List<EditorCell> children = ListSequence.fromList(new ArrayList<EditorCell>());
    for (EditorCell childCell : Sequence.fromIterable(this)) {
      ListSequence.fromList(children).addElement(childCell);
    }
    if (ListSequence.fromList(children).isEmpty()) {
      return;
    }
    Collections.sort(children, new Comparator<EditorCell>() {
      public int compare(EditorCell c1, EditorCell c2) {
        int deltaY = LayoutDependencies.getY(c1) - LayoutDependencies.getY(c2);
        if (deltaY != 0) {
          return deltaY;
        } else {
          return LayoutDependencies.getX(c1) - LayoutDependencies.getX(c2);
        }
      }
    });

    // TODO: implement custom (sorting) collection?
    Entry lastEntry = null;
    for (EditorCell child : ListSequence.fromList(children)) {
      Entry current = (Entry) child;
      if (lastEntry == null) {
        Entry prev = (Entry) ListSequence.fromList(children).getElement(ListSequence.fromList(children).count() - 1);
        current.setPrev(prev);
        prev.setNext(null);
      } else {
        current.setPrev(lastEntry);
        lastEntry.setNext(current);
      }
      lastEntry = current;
    }
  }

  @Override
  public void paintContent(Graphics g_, ParentSettings settings) {
    Graphics2D g = ((Graphics2D) g_.create());
    try {
      g.setColor(getStyle().get(StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.diagram.styles", "diagram-background-color")));
      g.fillRect(getX(), getY(), getWidth(), getHeight());

      g.setColor(JBColor.LIGHT_GRAY);
      g.drawRect(getX(), getY(), getWidth(), getHeight());

      if (Palette.isActive(this)) {
        g.setColor(Palette.DIAGRAM_HIGHLIGHT_COLOR);
        g.setStroke(new BasicStroke(Palette.DIAGRAM_HIGHLIGHT_WIDTH));
        g.drawRect(getX() + 2, getY() + 2, getWidth() - 4, getHeight() - 4);
      }
    } finally {
      g.dispose();
    }
  }

  @Override
  public boolean isDrawBorder() {
    return false;
  }

  @Override
  public void setX(int x) {
    myGraphComponent.setLocation(x + 1, myGraphComponent.getY());
    super.setX(x);
    LayoutDependencies.getInstance(this).update();
  }

  @Override
  public void setY(int y) {
    myGraphComponent.setLocation(myGraphComponent.getX(), y + 1);
    super.setY(y);
    LayoutDependencies.getInstance(this).update();
  }

  @Override
  public void moveTo(int x, int y) {
    myX = x;
    myY = y;
    myGraphComponent.setLocation(myX + 1, myY + 1);
    LayoutDependencies.getInstance(this).update();
  }

  @Override
  public void relayoutImpl() {
    LayoutDependencies.getInstance(this).layoutAndRecordDependencies(new LayoutDependencies.EditorCellLayoutable(this) {
      @Override
      public void layout() {
        getSynchronizer().suspend(() -> ScalableEditorCell.withScalingDisabled(() -> BaseDiagramECell.withContextGraph(myGraph, () -> {
          Dimension componentSize = myGraphComponent.getPreferredSize();
          int w = componentSize.width + myGapLeft + myGapRight + 2;
          int h = componentSize.height + 2;
          if (isMaximizedMode()) {
            final JScrollPane scrollPane = getScrollPane();
            w = scrollPane.getViewport().getSize().width - 2;
            h = scrollPane.getViewport().getSize().height - 3;
            myGraphComponent.setFixedSize(new Dimension(w, h));
          } else {
            myGraphComponent.setFixedSize(null);
          }
          setWidth(w);
          setHeight(h);

          mxGraphView view = myGraph.getView();
          mxPoint origin = myGraph.getOrigin();
          double scale = view.getScale();

          for (ScalableEditorCell scalable : ListSequence.fromList(EditorUtil.descendants(RootDiagramECell.this, ScalableEditorCell.class))) {
            scalable.setScale(scale);
          }

          view.validate();

          myModel.setLayouterWasExecuted(false);
        })));
        setAscent(LayoutDependencies.getHeight(RootDiagramECell.this));
        setDescent(0);

        Iterable<EditorCell> descendantCells = CellTraversalUtil.iterateTree(RootDiagramECell.this, RootDiagramECell.this, true);
        Sequence.fromIterable(descendantCells).ofType(EditorCell_Label.class).where((it) -> it.wasRelayoutRequested() || isNotEmptyString(it.getText()) && (it.getHeight() == 0 || it.getRenderedTextLine().getHeight() == 0)).visitAll((it) -> it.relayout());
        Sequence.fromIterable(descendantCells).ofType(EditorCell_Basic.class).visitAll((it) -> it.unrequestLayout());
      }
    });
    LayoutDependencies.getInstance(this).update();
  }

  @Override
  public void onAdd() {
    super.onAdd();
    getEditor().getCellTracker().addComponentCell(this);
    myGraph.getModel().addListener(mxEvent.END_UPDATE, myGraphModelChangeListener);
    getEditorComponent().getSelectionManager().addSelectionListener(mySelectionListener);

    myFocusTimer = new Timer(200, (ActionEvent e) -> focusTimer());
    myFocusTimer.start();

    // make palette available
    try {
      Project ideaProject = ProjectHelper.toIdeaProject(getContext().getOperationContext().getProject());
      if (ideaProject != null) {
        if (ProjectPluginManager.getInstance(ideaProject).getTool(Diagram_Palette_Tool.class) != null) {
          ProjectPluginManager.getInstance(ideaProject).getTool(Diagram_Palette_Tool.class).makeAvailableLater();
        } else {
          if (LOG_25670992.isWarningLevel()) {
            LOG_25670992.warning("Diagram palette not found in the project");
          }
        }
      }
    } catch (Exception ex) {
      if (LOG_25670992.isWarningLevel()) {
        LOG_25670992.warning("Cannot open palette", ex);
      }
    }

    // relayout after scrolling
    if (isMaximizedMode()) {
      final JScrollPane scrollPane = getScrollPane();
      scrollPane.getViewport().addChangeListener(myViewportChangeListener);
    }
    myGraphComponent.showPortLabelsIfNecessary();
  }

  @Override
  public void onRemove() {
    if (myFocusTimer != null) {
      myFocusTimer.stop();
    }

    if (!(isInTree())) {
      return;
    }
    myGraph.getModel().removeListener(myGraphModelChangeListener, mxEvent.END_UPDATE);
    getEditor().getCellTracker().removeComponentCell(this);
    getEditorComponent().getSelectionManager().removeSelectionListener(mySelectionListener);
    super.onRemove();

    if (isMaximizedMode()) {
      final JScrollPane scrollPane = getScrollPane();
      scrollPane.getViewport().removeChangeListener(myViewportChangeListener);
    }
  }

  public void setShowInViewer(boolean flag) {
    getSNode().putUserObject("showInViewer", flag);
  }

  public boolean showInViewer() {
    if (getSNode().getUserObject("showInViewer") != null && getEditorComponent() instanceof NodeEditorComponent) {
      return true;
    }
    return false;
  }

  @Override
  public JComponent getComponent() {
    // prevent the editor to scroll to the top of the diagram component when clicking into the diagram
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    if (stackTrace.length >= 3) {
      StackTraceElement traceElement = stackTrace[2];
      if (jetbrains.mps.nodeEditor.EditorComponent.class.getName().equals(traceElement.getClassName()) && "findCellForComponent".equals(traceElement.getMethodName())) {
        return null;
      }
    }

    return myGraphComponent;
  }


  @Override
  public void paintSelection(Graphics graphics, Color color, boolean drawBorder, ParentSettings settings) {
    Graphics2D g = (Graphics2D) graphics.create();
    try {
      g.setColor(color);
      g.setStroke(new BasicStroke(3.0f));
      g.drawRect(getX(), getY(), getWidth(), getHeight());
    } finally {
      g.dispose();
    }
  }
  @Override
  public RootDiagramECell getRootDiagramCell() {
    return this;
  }

  @Override
  public RootDCell getDCell(mxGraph graph) {
    return (RootDCell) graph.getDefaultParent();
  }

  @Override
  public ICoordinateSystem getCoordinateSystem() {
    return new AffineTransformCoordinateSystem(GlobalCoordinateSystem.INSTANCE) {
      @Override
      protected AffineTransform getTransformation() {
        return AffineTransform.getTranslateInstance(-getX(), -getY());
      }
    };
  }


  @Override
  public void requestRelayout() {
    if (!(wasRelayoutRequested())) {
      for (Object cell : myGraph.getView().getStates().keySet()) {
        if (cell instanceof IMPSCellContainer) {
          EditorCell_Basic editorCell = as_l91fln_a0a0a0a0a0a67(((IMPSCellContainer) cell).getBigCell(), EditorCell_Basic.class);
          if (editorCell != null) {
            if (editorCell.wasRelayoutRequested()) {
              myGraph.getView().invalidate(cell);
            }
          }
        }
      }
    }
    super.requestRelayout();

  }

  public ITooltip getTooltipAt(final int x, final int y) {
    mxCell dcell = (mxCell) myGraphComponent.getCellAt(x - getX(), y - getY());

    if (dcell instanceof PortDCell) {
      PortDCell portCell = ((PortDCell) dcell);
      EditorCell tooltipCell = portCell.getPort().getTooltipCell();
      if (tooltipCell != null) {
        return new PortTooltip(this, portCell);
      }
    } else if (dcell instanceof EdgeDCell) {
      final EdgeDCell edgeCell = ((EdgeDCell) dcell);
      final String toolTipText = edgeCell.getTooltipText();
      if ((toolTipText != null && toolTipText.length() > 0)) {
        return new ITooltip() {
          @Override
          public Point getCenter() {
            return new Point(x, y);
          }

          @Override
          public int getHeight() {
            return EditorSettings.getInstance().getFontSize();
          }

          @Override
          public void setMarkOpacity(float opacity) {
          }

          @Nullable
          @Override
          public EditorCell getTooltipCell() {
            EditorCell bigCell = edgeCell.getBigCell();
            return EditorCell_Multiline.create(bigCell.getContext(), new ConstantModelAccessor(toolTipText), bigCell.getSNode());
          }
        };

      }
    }

    EditorCell editorCell = getGraph().getGraphComponent().findLeafAtPosition(x, y);
    if (editorCell == null) {
      editorCell = check_l91fln_a0a0f0zc(getGraph().getGraphComponent().findMPSCell(x, y), this);
    }
    if (editorCell == null) {
      if (dcell instanceof BoxBaseDCell) {
        editorCell = check_l91fln_a0a0a0g0zc(ListSequence.fromList(((BoxBaseDCell) dcell).getMPSCells()).first());
      }
    }
    if (editorCell != null) {
      for (EditorCell c = editorCell; c != null; c = c.getParent()) {
        if (c == this) {
          break;
        }
        if (c instanceof ITooltipProvider) {
          ITooltipProvider provider = (ITooltipProvider) c;
          ITooltip tooltip = provider.getTooltipAt(x, y);
          if (tooltip != null) {
            return tooltip;
          }
        } else if (c instanceof ITooltip) {
          return (ITooltip) c;
        }
      }
    }
    MyVertexHandler vertexHandler = as_l91fln_a0a8a87(getGraph().getGraphComponent().getSelectionCellsHandler().getHandler(dcell), MyVertexHandler.class);
    MyEdgeHandler edgeHandler = as_l91fln_a0a9a87(getGraph().getGraphComponent().getSelectionCellsHandler().getHandler(dcell), MyEdgeHandler.class);

    List<ContextButtonContainer> buttonContainers = ListSequence.fromListWithValues(new ArrayList<ContextButtonContainer>(), getGraph().getContextButtonContainers());
    if (vertexHandler != null) {
      lastVertexHandler = vertexHandler;
    }

    if (lastVertexHandler != null) {
      ListSequence.fromList(buttonContainers).addElement(lastVertexHandler.getButtonContainer());
    }

    if (edgeHandler != null) {
      lastEdgeHandler = edgeHandler;
    }

    if (lastEdgeHandler != null) {
      ListSequence.fromList(buttonContainers).addElement(lastEdgeHandler.getButtonContainer());
    }

    for (ContextButtonContainer buttonContainer : ListSequence.fromList(buttonContainers)) {
      final int relativeX = x - this.getX();
      final int relativeY = y - this.getY();
      final String toolTipText = buttonContainer.getToolTipText(relativeX, relativeY);
      if (toolTipText != null) {
        return new ITooltip() {
          @Override
          public Point getCenter() {
            return new Point(x, y);
          }

          @Override
          public int getHeight() {
            return EditorSettings.getInstance().getFontSize();
          }

          @Override
          public void setMarkOpacity(float opacity) {
          }

          @Nullable
          @Override
          public EditorCell getTooltipCell() {
            EditorCell_Constant constant = new EditorCell_Constant(RootDiagramECell.this.getContext(), RootDiagramECell.this.getSNode(), toolTipText);
            constant.getStyle().set(StyleAttributes.FONT_STYLE, MPSFonts.PLAIN);
            return constant;
          }
        };
      }
    }

    return null;
  }

  @Override
  public List<ITooltip> getTooltips() {
    return null;
  }

  public static <T extends Container> T getAncestor(Component descendant, Class<T> type) {
    if (descendant == null) {
      return null;
    }
    if (type.isInstance(descendant.getParent())) {
      return ((T) descendant.getParent());
    }
    return getAncestor(descendant.getParent(), type);
  }
  private static RootDiagramECell check_l91fln_a0g0a0a0o(GraphSelection checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDiagramCell();
    }
    return null;
  }
  private static EditorCell check_l91fln_a0h0a0a0o(EditorCellSelection checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static RootDiagramECell check_l91fln_a0i0a0a0o(GraphSelection checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDiagramCell();
    }
    return null;
  }
  private static SelectionManager check_l91fln_a0h0ib(EditorComponent checkedDotOperand, RootDiagramECell checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSelectionManager();
    }
    return null;
  }
  private static EditorCell check_l91fln_a0a0f0zc(MPSCell checkedDotOperand, RootDiagramECell checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static EditorCell check_l91fln_a0a0a0g0zc(MPSCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static <T> T as_l91fln_a0a0g0a0a0p(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_l91fln_a0a0h0a0a0p(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_l91fln_a0a0i0a0a0p(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_l91fln_a0a9a53(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
  private static <T> T as_l91fln_a0a0a0a0a0a67(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_l91fln_a0a8a87(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_l91fln_a0a9a87(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept LayoutMap$4m = MetaAdapterFactory.getConcept(0x8ca79d43eb454791L, 0xbdd40d6130ff895bL, 0x7c646f09bb3f148eL, "de.itemis.mps.editor.diagram.layout.structure.LayoutMap");
  }
}

package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.selection.AbstractSelection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import java.util.List;
import com.mxgraph.model.mxCell;
import java.util.Map;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import java.util.Set;
import de.itemis.mps.editor.diagram.runtime.model.IDiagramElement;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.itemis.mps.editor.diagram.runtime.model.Box;
import de.itemis.mps.editor.diagram.runtime.model.EndpointUtil;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.CellInfo;
import jetbrains.mps.openapi.editor.selection.SelectionStoreException;
import jetbrains.mps.nodeEditor.selection.SelectionRestoreException;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import java.util.Collections;
import jetbrains.mps.openapi.editor.selection.SelectionInfo;
import jetbrains.mps.nodeEditor.selection.SelectionInfoImpl;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.openapi.editor.selection.Selection;
import java.util.Iterator;
import java.util.Objects;
import jetbrains.mps.nodeEditor.cells.DefaultCellInfo;
import org.jetbrains.mps.openapi.model.SNodeReference;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import com.mxgraph.view.mxGraphSelectionModel;
import com.mxgraph.model.mxGraphModel;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class GraphSelection extends AbstractSelection implements SingularSelection {
  private static final String PROPERTY_NUMBER_OF_CELLS = "numberOfCells";
  private static final String PROPERTY_ACCESSOR_KEY = "accessorKey";
  private static final String PROPERTY_CELL_ID = "cellId";

  private RootDiagramECell myDiagramCell;
  private List<mxCell> mySelectedCells;

  private Map<CellActionType, _FunctionTypes._void_P0_E0> myActions = MapSequence.fromMap(new HashMap<CellActionType, _FunctionTypes._void_P0_E0>());

  private void moveBy(final double dx, final double dy) {
    if (myDiagramCell.getEditorComponent().isReadOnly()) {
      return;
    }
    Object[] cellsToMove = ListSequence.fromList(mySelectedCells).select((it) -> {
      Bounds newBounds = CellExtensions.getAbsoluteBounds(it);
      newBounds.setX(newBounds.getX() + dx);
      newBounds.setY(newBounds.getY() + dy);
      return (it.getParent() instanceof SubDiagramDCell && !(CellExtensions.getAbsoluteBounds(it.getParent()).contains(newBounds)) ? ((SubDiagramDCell) it.getParent()).getECell() : it);
    }).toGenericArray(Cloneable.class);
    myDiagramCell.getGraph().moveCells(cellsToMove, dx, dy);
    myDiagramCell.getGraph().updateViewOrigin();
  }

  {
    MapSequence.fromMap(myActions).put(CellActionType.DELETE, () -> {
      if (DiagramModel.ALLOW_DELETE_DURING_SYNC) {
        Object[] removedCells = getDiagramCell().getGraph().removeCells();
      } else {
        myDiagramCell.getEditor().getEditorContext().getRepository().getModelAccess().executeCommand(() -> {
          final Set<IDiagramElement> elementsToDelete = SetSequence.fromSetWithValues(new HashSet<IDiagramElement>(), Sequence.fromIterable(Sequence.fromArray(getDiagramCell().getGraph().getSelectionCells())).ofType(IDiagramDCell.class).select((it) -> it.getDiagramElement()));
          SetSequence.fromSet(elementsToDelete).addSequence(Sequence.fromIterable(getDiagramCell().getModel().getEdges()).where((it) -> {
            Box fromBox = EndpointUtil.getBox(it.getResolvedEndpointFrom());
            Box toBox = EndpointUtil.getBox(it.getResolvedEndpointTo());
            return SetSequence.fromSet(elementsToDelete).contains(fromBox) || SetSequence.fromSet(elementsToDelete).contains(toBox);
          }));
          SetSequence.fromSet(elementsToDelete).removeElement(null);
          SetSequence.fromSet(elementsToDelete).visitAll((it) -> it.delete());
        });
      }
    });
    MapSequence.fromMap(myActions).put(CellActionType.BACKSPACE, MapSequence.fromMap(myActions).get(CellActionType.DELETE));

    MapSequence.fromMap(myActions).put(CellActionType.LEFT, () -> moveBy(-myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmount(), 0));
    MapSequence.fromMap(myActions).put(CellActionType.RIGHT, () -> moveBy(myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmount(), 0));
    MapSequence.fromMap(myActions).put(CellActionType.UP, () -> moveBy(0, -myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmount()));
    MapSequence.fromMap(myActions).put(CellActionType.DOWN, () -> moveBy(0, myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmount()));

    MapSequence.fromMap(myActions).put(CellActionType.SELECT_LEFT, () -> moveBy(-myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmountSlow(), 0));
    MapSequence.fromMap(myActions).put(CellActionType.SELECT_RIGHT, () -> moveBy(myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmountSlow(), 0));
    MapSequence.fromMap(myActions).put(CellActionType.SELECT_PREVIOUS, () -> moveBy(0, -myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmountSlow()));
    MapSequence.fromMap(myActions).put(CellActionType.SELECT_NEXT, () -> moveBy(0, myDiagramCell.myModel.getDiagramAccessor().getArrowKeyMoveAmountSlow()));
  }

  public GraphSelection(EditorComponent editorComponent, Map<String, String> properties, CellInfo cellInfo) throws SelectionStoreException, SelectionRestoreException {
    super(editorComponent);
    if (cellInfo == null) {
      throw new SelectionStoreException("Required cellInfo parameter is null");
    }
    myDiagramCell = as_7stibj_a0a2a31(findCell(cellInfo, editorComponent), RootDiagramECell.class);
    if (myDiagramCell == null) {
      throw new SelectionRestoreException();
    }
    mySelectedCells = getCells(properties, editorComponent);
  }

  public GraphSelection(EditorComponent editorComponent, RootDiagramECell diagramCell, List<mxCell> selectedCells) {
    super(editorComponent);
    myDiagramCell = diagramCell;

    mySelectedCells = new ArrayList<mxCell>(selectedCells);
    validate();
  }

  public RootDiagramECell getDiagramCell() {
    return myDiagramCell;
  }

  private void validate() {
    if (mySelectedCells == null || ListSequence.fromList(mySelectedCells).count() == 0) {
      throw new RuntimeException("list of selected cells is empty");
    }
  }

  private MyGraphSelectionModel getGraphSelectionModel() {
    return myDiagramCell.getGraph().getSelectionModel();
  }

  public void activate() {
    getGraphSelectionModel().setFromMPS(ListSequence.fromList(mySelectedCells).toGenericArray(mxCell.class));
  }

  public void deactivate() {
    getGraphSelectionModel().clearFromMPS();
  }

  public void ensureVisible() {
  }

  public boolean canExecuteAction(CellActionType type) {
    return MapSequence.fromMap(myActions).containsKey(type);
  }

  public void executeAction(CellActionType type) {
    check_7stibj_a0a13(MapSequence.fromMap(myActions).get(type));
  }

  @NotNull
  public List<EditorCell> getSelectedCells() {
    if (ListSequence.fromList(mySelectedCells).count() > 0) {
      final Wrappers._T<List<EditorCell>> cells = new Wrappers._T<List<EditorCell>>(ListSequence.fromList(mySelectedCells).select((it) -> extractEditorCell(it)).where((it) -> it != null).toList());
      if (ListSequence.fromList(cells.value).any((it) -> {
        SNode node = it.getSNode();
        return SNodeOperations.isInstanceOf(node, CONCEPTS.Attribute$g1);
      })) {
        myDiagramCell.getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> cells.value = ListSequence.fromList(cells.value).select((cell) -> {
          SNode node = cell.getSNode();
          if (SNodeOperations.isInstanceOf(node, CONCEPTS.Attribute$g1)) {
            SNode attributedNode = SNodeOperations.getParent(node);
            for (EditorCell c : Sequence.fromIterable(CellTraversalUtil.iterateTree(cell, cell, true))) {
              if (c.getSNode() == attributedNode) {
                return c;
              }
            }
          }
          return cell;
        }).toList());
      }
      return cells.value;
    } else {
      return Collections.singletonList((EditorCell) myDiagramCell);
    }
  }

  @NotNull
  public List<SNode> getSelectedNodes() {
    List<EditorCell> selectedCells = getSelectedCells();
    return ListSequence.fromList(selectedCells).select((it) -> it.getSNode()).distinct().toList();
  }

  public SelectionInfo getSelectionInfo() throws SelectionStoreException {
    SelectionInfoImpl selectionInfo = new SelectionInfoImpl(this.getClass().getName(), PersistenceFacade.getInstance().createModuleReference("fa13cc63-c476-4d46-9c96-d53670abe7bc(de.itemis.mps.editor.diagram)"));
    selectionInfo.setCellInfo(myDiagramCell.getCellInfo());
    Map<String, String> propertiesMap = selectionInfo.getPropertiesMap();
    putCellInfos(propertiesMap, mySelectedCells);
    return selectionInfo;
  }

  public boolean isSame(Selection selection) {
    if (!(selection instanceof GraphSelection)) {
      return false;
    }
    GraphSelection other = ((GraphSelection) selection);

    if (myDiagramCell != other.myDiagramCell) {
      return false;
    }

    if (ListSequence.fromList(mySelectedCells).count() != ListSequence.fromList(other.mySelectedCells).count()) {
      return false;
    }

    {
      Iterator<mxCell> cell1_it = ListSequence.fromList(mySelectedCells).iterator();
      Iterator<mxCell> cell2_it = ListSequence.fromList(other.mySelectedCells).iterator();
      mxCell cell1_var;
      mxCell cell2_var;
      while (cell1_it.hasNext() && cell2_it.hasNext()) {
        cell1_var = cell1_it.next();
        cell2_var = cell2_it.next();
        if ((cell1_var == null) != (cell2_var == null)) {
          return false;
        }
        if (cell1_var == cell2_var) {
          continue;
        }
        if (!(Objects.equals(cell1_var.getId(), cell2_var.getId()))) {
          return false;
        }
      }
    }

    return true;
  }

  public void putCellInfos(Map<String, String> properties, List<mxCell> cells) {
    properties.put(PROPERTY_NUMBER_OF_CELLS, Integer.toString(cells.size()));

    int index = 0;
    for (mxCell cell : ListSequence.fromList(cells)) {
      if (cell == null) {
        continue;
      }
      properties.put(PROPERTY_CELL_ID + index, cell.getId());
      index++;
    }
  }

  public List<mxCell> getCells(Map<String, String> properties, EditorComponent editorComponent) throws SelectionStoreException {
    int numCells = SelectionInfoImpl.Util.getIntProperty(properties, PROPERTY_NUMBER_OF_CELLS);
    List<mxCell> result = new ArrayList<mxCell>(numCells);
    for (int i = 0; i < numCells; i++) {
      String cellId = properties.get(PROPERTY_CELL_ID + i);
      mxCell cell = (mxCell) myDiagramCell.getGraph().getModel().getCell(cellId);
      if (cell != null) {
        result.add(cell);
      }
    }
    return result;
  }

  public EditorCell findCell(CellInfo cellInfo, EditorComponent editorComponent) {
    if (cellInfo instanceof DefaultCellInfo) {
      DefaultCellInfo defaultInfo = ((DefaultCellInfo) cellInfo);
      SNode node = ((SNodeReference) ReflectionUtil.readField(DefaultCellInfo.class, defaultInfo, "myNodeReference")).resolve(editorComponent.getEditorContext().getRepository());
      return findCell(node, ((String) ReflectionUtil.readField(DefaultCellInfo.class, defaultInfo, "myCellId")), editorComponent);
    }
    return cellInfo.findCell(editorComponent);
  }

  public EditorCell findCell(final SNode node, final String cellId, final EditorComponent editorComponent) {
    // try to find the usual way
    EditorCell cell = editorComponent.findCellWithId(node, cellId);
    if (cell != null) {
      return cell;
    }

    if (myDiagramCell != null) {
      cell = findInVisibleCells(cellId, node);
      if (cell != null) {
        return cell;
      }
    }
    cell = findCellInTree(node, cellId, editorComponent, true);
    if (cell != null) {
      return cell;
    }
    cell = findCellInTree(node, cellId, editorComponent, false);
    if (cell != null) {
      return cell;
    }

    return null;
  }

  public EditorCell findCellInTree(final SNode node, final String cellId, final EditorComponent editorComponent, boolean checkCellNode) {
    SNode currentNode = node;
    do {
      // try to find in the descendants
      EditorCell nodeCell = editorComponent.findNodeCell(currentNode);
      if (nodeCell != null) {
        EditorCell found = findDescendantCell(nodeCell, cellId, node);
        if (found != null) {
          return found;
        }
      }

      currentNode = SNodeOperations.getParent(currentNode);
    } while ((currentNode != null));

    if (myDiagramCell != null) {
      EditorCell found = findDescendantCell(myDiagramCell, cellId, node);
      if (found != null) {
        return found;
      }
    }

    return null;
  }

  public EditorCell findInVisibleCells(@NotNull final String cellId, @Nullable final SNode snode) {
    Map<EditorCell, mxCell> map = collectEditorCell2GraphCell(myDiagramCell.getGraph().getModel());
    EditorCell found = SetSequence.fromSet(MapSequence.fromMap(map).keySet()).where((it) -> it != null).findFirst((it) -> Objects.equals(it.getCellId(), cellId) && (snode == null || Objects.equals(snode, it.getSNode())));
    if (found != null) {
      return found;
    }
    return null;
  }

  public EditorCell findDescendantCell(@NotNull final EditorCell parentCell, @NotNull final String cellId, @Nullable final SNode snode) {
    if (Objects.equals(parentCell.getCellId(), cellId)) {
      if (snode == null || Objects.equals(parentCell.getSNode(), snode)) {
        return parentCell;
      }
    }

    if (parentCell instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) parentCell))) {
        EditorCell found = findDescendantCell(child, cellId, snode);
        if (found != null) {
          return found;
        }
      }
    }

    return null;
  }

  @NotNull
  public EditorCell getEditorCell() {
    return getSelectedCells().get(0);
  }

  public SingularSelection.SideSelectDirection getSideSelectDirection() {
    return SingularSelection.SideSelectDirection.NONE;
  }

  public void setSideSelectDirection(SingularSelection.SideSelectDirection direction) {
  }

  public static List<EditorCell> extractSelectedCells(mxGraphSelectionModel selectionModel) {
    List<EditorCell> result;
    result = new ArrayList<EditorCell>();
    for (Object graphCell : selectionModel.getCells()) {
      EditorCell editorCell = extractEditorCell(graphCell);
      if (editorCell != null) {
        result.add(editorCell);
      }
    }
    return result;
  }

  public static EditorCell extractEditorCell(Object mxCell) {
    if (mxCell instanceof IMPSCellContainer) {
      return ((IMPSCellContainer) mxCell).getBigCell();
    }
    if (mxCell instanceof PortDCell) {
      return ((PortDCell) mxCell).getPort().getDummyCell();
    }
    return null;
  }

  public static Map<EditorCell, mxCell> collectEditorCell2GraphCell(mxGraphModel graphModel) {
    Map<EditorCell, mxCell> result = MapSequence.fromMap(new HashMap<EditorCell, mxCell>());
    for (Object graphCell : graphModel.getCells().values()) {
      if (graphCell instanceof IMPSCellContainer) {
        EditorCell editorCell = ((IMPSCellContainer) graphCell).getBigCell();
        MapSequence.fromMap(result).put(editorCell, (mxCell) graphCell);
      }
    }
    return result;
  }

  public void switchPortsSideClockwise() {
    for (Object cell : myDiagramCell.getGraph().getSelectionCells()) {
      if (cell instanceof BoxDCell) {
        BoxDCell boxCell = ((BoxDCell) cell);
        boxCell.getBox().rotatePortSideClockwise();
      }
    }
    myDiagramCell.getModel().synchronizeWrite(myDiagramCell);
  }

  public void switchPortsSideCounterClockwise() {
    for (Object cell : myDiagramCell.getGraph().getSelectionCells()) {
      if (cell instanceof BoxDCell) {
        BoxDCell boxCell = ((BoxDCell) cell);
        boxCell.getBox().rotatePortSideCounterClockwise();
      }
    }
    myDiagramCell.getModel().synchronizeWrite(myDiagramCell);
  }

  public void flipPortsSideHorizontally() {
    for (Object cell : myDiagramCell.getGraph().getSelectionCells()) {
      if (cell instanceof BoxDCell) {
        BoxDCell boxCell = ((BoxDCell) cell);
        boxCell.getBox().flipPortSideHorizontally();
      }
    }
    myDiagramCell.getModel().synchronizeWrite(myDiagramCell);
  }

  public void flipPortsSideVertically() {
    for (Object cell : myDiagramCell.getGraph().getSelectionCells()) {
      if (cell instanceof BoxDCell) {
        BoxDCell boxCell = ((BoxDCell) cell);
        boxCell.getBox().flipPortSideVertically();
      }
    }
    myDiagramCell.getModel().synchronizeWrite(myDiagramCell);
  }

  private static void check_7stibj_a0a13(_FunctionTypes._void_P0_E0 checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.invoke();
    }

  }
  private static <T> T as_7stibj_a0a2a31(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
  }
}

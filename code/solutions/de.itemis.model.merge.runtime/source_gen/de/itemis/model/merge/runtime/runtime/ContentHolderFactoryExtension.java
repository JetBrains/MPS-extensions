package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import java.util.List;
import com.google.common.collect.Lists;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.google.common.collect.Maps;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import java.util.Objects;
import de.itemis.model.merge.behavior.ModelMergingPolicy__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.apache.commons.lang3.tuple.Pair;
import de.itemis.model.merge.behavior.DeclarationPolicy__BehaviorDescriptor;
import jetbrains.mps.lang.structure.behavior.LinkDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.structure.behavior.PropertyDeclaration__BehaviorDescriptor;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class ContentHolderFactoryExtension implements ContentHolderFactory {

  private List<ConceptChildMerger> conceptChildMergers = Lists.newLinkedList();
  private List<PropertyMerger> propertyMergers = Lists.newLinkedList();
  private List<ConceptRefMerger> refMergers = Lists.newLinkedList();
  private Map<SAbstractConcept, Identity> identities = Maps.newHashMap();

  public ContentHolderFactoryExtension(final SNode mergingPolicy) {
    MergePolicySpec spec = Sequence.fromIterable(new ExtensionPoint<MergePolicySpec>("de.itemis.model.merge.ModelMergeExt").getObjects()).findFirst((it) -> Objects.equals(it.id(), (ModelMergingPolicy__BehaviorDescriptor.globalId_id28CFLxJaWOS.invoke(mergingPolicy))));
    if (spec != null) {
      ListSequence.fromList(this.conceptChildMergers).addSequence(CollectionSequence.fromCollection(spec.conceptMergeSpecs()).translate((it) -> it.childMergers()));
      ListSequence.fromList(this.propertyMergers).addSequence(CollectionSequence.fromCollection(spec.conceptMergeSpecs()).translate((it) -> it.propertyMergers()));
      ListSequence.fromList(this.refMergers).addSequence(CollectionSequence.fromCollection(spec.conceptMergeSpecs()).translate((it) -> it.referenceMergers()));
      for (Pair<SAbstractConcept, Identity> e : CollectionSequence.fromCollection(spec.conceptMergeSpecs()).select((final ConceptMergeSpec it) -> pairingConceptIdentity(it))) {
        this.identities.put(e.getKey(), e.getValue());
      }
    } else {
      System.out.println("---> No MergePolicySpec found!");
    }
  }
  @Override
  public ContentHolder<ConceptChildMerger> childMerger(SNode itemPolicy, SAbstractConcept inheritedFrom) {
    final SNode childLink = DeclarationPolicy__BehaviorDescriptor.childLink_id1VmHfRx_0K2.invoke(itemPolicy);
    ConceptChildMerger merger = ListSequence.fromList(this.conceptChildMergers).findFirst((it) -> (boolean) LinkDeclaration__BehaviorDescriptor.is_id4MKjpUYniHA.invoke(childLink, it.link()));
    return ContentHolderFactory.makeContentHolder(merger, itemPolicy, inheritedFrom);
  }
  @Override
  public ContentHolder<PropertyMerger> propertyMerger(SNode propertyPolicy, SAbstractConcept inheritedFrom) {
    final SNode property = SLinkOperations.getTarget(propertyPolicy, LINKS.property$IQvu);
    PropertyMerger merger = ListSequence.fromList(this.propertyMergers).findFirst((it) -> (boolean) PropertyDeclaration__BehaviorDescriptor.is_id4MKjpUYnih4.invoke(property, it.property()));
    return new SimpleActionContentHolder<PropertyMerger>(merger, SLinkOperations.getTarget(propertyPolicy, LINKS.action$i__H), inheritedFrom);
  }
  @Override
  public ContentHolder<ConceptRefMerger> refMerger(SNode refPolicy, SAbstractConcept inheritedFrom) {
    final SNode childLink = DeclarationPolicy__BehaviorDescriptor.childLink_id1VmHfRx_0K2.invoke(refPolicy);
    ConceptRefMerger merger = ListSequence.fromList(this.refMergers).findFirst((it) -> (boolean) LinkDeclaration__BehaviorDescriptor.is_id4MKjpUYniHA.invoke(childLink, it.reference()));
    return ContentHolderFactory.makeContentHolder(merger, refPolicy, inheritedFrom);
  }



  private Pair<SAbstractConcept, Identity> pairingConceptIdentity(final ConceptMergeSpec cms) {
    return ImmutablePair.<SAbstractConcept,Identity>of(cms.concept(), new Identity() {
      @Override
      public String get(SNode node) {
        return cms.id(node);
      }
    });
  }
  @Override
  public Identity idOf(SNode idFunction, SAbstractConcept concept) {
    return this.identities.get(concept);
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink property$IQvu = MetaAdapterFactory.getReferenceLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42e44628L, 0x68dab8ecba09e939L, "property");
    /*package*/ static final SContainmentLink action$i__H = MetaAdapterFactory.getContainmentLink(0x539e893908ef497cL, 0xa5fd25dd10137a55L, 0x1a8b8d3e42e44628L, 0x1a8b8d3e42e44bcdL, "action");
  }
}

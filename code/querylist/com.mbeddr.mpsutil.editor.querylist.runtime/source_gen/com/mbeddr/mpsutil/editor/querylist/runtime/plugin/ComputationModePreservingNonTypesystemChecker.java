package com.mbeddr.mpsutil.editor.querylist.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.typesystemEngine.checker.NonTypesystemChecker;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Set;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.typechecking.TypecheckingSession;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.typechecking.TypecheckingQueries;
import jetbrains.mps.typesystem.LegacyTypecheckingQueries;
import java.util.Collections;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.newTypesystem.context.typechecking.IncrementalTypechecking;
import jetbrains.mps.util.Pair;
import java.util.List;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.errors.item.TypesystemReportItemAdapter;

public class ComputationModePreservingNonTypesystemChecker extends NonTypesystemChecker {

  /**
   * Copy of {@link jetbrains.mps.typesystemEngine.checker.NonTypesystemChecker#getErrors(SNode, SRepository)} 
   */
  public Set<NodeReportItem> getErrors(final SNode root, SRepository repository) {
    return TypecheckingFacade.getFromContext().computeIsolated(TypecheckingSession.Flags.forRoot(root).incremental(), (TypecheckingSession session) -> {

      Set<NodeReportItem> errors = SetSequence.fromSet(new HashSet<NodeReportItem>());

      TypecheckingQueries typecheckingQueries = session.getQueries(root);
      // FIXME  assuming it's safe to access the underlying legacy provider
      LegacyTypecheckingQueries legacyTypecheckingQueries = session.getQueries(LegacyTypecheckingQueries.class);
      if (typecheckingQueries == null || legacyTypecheckingQueries == null) {
        return Collections.emptySet();
      }
      TypeCheckingContext context = legacyTypecheckingQueries.getTypeCheckingContext();
      IncrementalTypechecking typesComponent = context.getBaseNodeTypesComponent();

      // update the types first
      typecheckingQueries.checkRecursively(root, (NodeReportItem nodeReportItem) -> {
        /*
          NOP

        */

      });

      try {
        // !!! Change starts here
        // !!! Change ends here
        typesComponent.applyNonTypesystemRulesToRoot(context);
      } finally {
        context.setNonTypesystemComputationMode(TypeCheckingContext.NonTypesystemComputationMode.OFF);
      }

      Set<Pair<SNode, List<IErrorReporter>>> nodesWithErrors = context.getNodesWithErrors(false);
      for (Pair<SNode, List<IErrorReporter>> p : nodesWithErrors) {
        for (IErrorReporter ier : p.o2) {
          SetSequence.fromSet(errors).addElement(new TypesystemReportItemAdapter(ier));
        }
      }

      return errors;
    });
  }

}

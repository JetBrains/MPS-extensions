package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import java.util.List;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.HashMap;
import java.util.Arrays;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Objects;

public class RulesCache {

  protected static Map<SModel, RulesCache> ourInstances = MapSequence.fromMap(new WeakHashMap<SModel, RulesCache>());

  public static RulesCache getInstance(SModel contextModel) {
    RulesCache instance = MapSequence.fromMap(ourInstances).get(contextModel);
    if (instance == null || !(instance.isValid())) {
      instance = new RulesCache(contextModel);
      MapSequence.fromMap(ourInstances).put(contextModel, instance);
    }
    return instance;
  }

  public static void invalidateAll() {
    MapSequence.fromMap(ourInstances).clear();
  }

  private SModel myModel;
  private List<IRule> myRules;
  private SModuleReference[] myVisibleLanguages;
  private Map<ConceptKey, IRule> myRuleForConcept = MapSequence.fromMap(new HashMap<ConceptKey, IRule>());

  public RulesCache(SModel contextModel) {
    myModel = contextModel;
  }

  protected boolean isValid() {
    if (myVisibleLanguages == null) {
      return true;
    }
    return Arrays.equals(myVisibleLanguages, visibleLanguageReferences());
  }

  protected SModuleReference[] visibleLanguageReferences() {
    return VisibleLanguagesCache.getInstance().getVisibleLanguageReferences(myModel);
  }

  protected List<IRule> getRules() {
    if (myRules == null) {
      myVisibleLanguages = visibleLanguageReferences();
      List<IGrammarActionsDescriptor> visibleDescriptors = GrammarCellsUtil.getVisibleDescriptors(myModel);
      List<IRule> allRules = ListSequence.fromList(visibleDescriptors).translate((it) -> it.getRules(myModel)).toList();
      List<IRule> filtered = filterOverridenRules(allRules);
      filtered = ListSequence.fromList(filtered).where((it) -> ListSequence.fromList(it.getSymbols()).isNotEmpty()).toList();
      myRules = ListSequence.fromList(filtered).sort((it) -> it.getPriority(), true).toList();
    }
    return myRules;
  }

  protected List<IRule> filterOverridenRules(List<IRule> unfiltered) {
    // Use the rule defined for the most specific concept
    final Map<SAbstractConcept, SAbstractConcept> mostSpecificConcept = MapSequence.fromMap(new HashMap<SAbstractConcept, SAbstractConcept>());
    for (IRule rule : ListSequence.fromList(unfiltered)) {
      SAbstractConcept existing = MapSequence.fromMap(mostSpecificConcept).get(rule.getOutputConcept());
      if (existing == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(rule.getDefinedForConcept()), SNodeOperations.asSConcept(existing))) {
        MapSequence.fromMap(mostSpecificConcept).put(rule.getOutputConcept(), rule.getDefinedForConcept());
      }
    }

    return ListSequence.fromList(unfiltered).where((it) -> Objects.equals(MapSequence.fromMap(mostSpecificConcept).get(it.getOutputConcept()), it.getDefinedForConcept())).toList();
  }

  public IRule getRule(SAbstractConcept concept) {
    if (concept == null) {
      return null;
    }
    ConceptKey key = new ConceptKey(concept);
    if (MapSequence.fromMap(myRuleForConcept).containsKey(key)) {
      return MapSequence.fromMap(myRuleForConcept).get(key);
    }

    IRule rule = calcRule(concept);
    MapSequence.fromMap(myRuleForConcept).put(key, rule);
    return rule;
  }

  protected IRule calcRule(final SAbstractConcept concept) {
    List<IRule> rules = ListSequence.fromList(getRules()).where((it) -> SConceptOperations.isExactly(SNodeOperations.asSConcept(it.getOutputConcept()), SNodeOperations.asSConcept(concept))).toList();
    if (ListSequence.fromList(rules).count() > 1) {
      // Use the rule defined for the most specific concept
      rules = ListSequence.fromList(rules).sort((a, b) -> {
        SAbstractConcept c1 = a.getDefinedForConcept();
        SAbstractConcept c2 = b.getDefinedForConcept();
        return (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(c1), SNodeOperations.asSConcept(c2)) ? 1 : (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(c2), SNodeOperations.asSConcept(c1)) ? -1 : 0));
      }, false).toList();

    }
    IRule result = ListSequence.fromList(rules).first();
    if (result == null || ListSequence.fromList(result.getSymbols()).isEmpty()) {
      return null;
    }
    return result;
  }


}

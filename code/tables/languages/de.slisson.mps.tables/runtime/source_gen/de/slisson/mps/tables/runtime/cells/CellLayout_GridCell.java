package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.util.Deque;
import java.util.LinkedList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;
import jetbrains.mps.nodeEditor.cellLayout.PunctuationUtil;

public class CellLayout_GridCell extends CellLayout_Horizontal {

  public CellLayout_GridCell() {
  }

  @Override
  public void doLayout(EditorCell_Collection collection) {
    super.doLayout(collection);
    updateAlignment(((EditorCell_GridCell) collection));
  }

  public void updateAlignment(EditorCell_GridCell gridCell) {
    gridCell.assertWrapped();
    EditorCell wrapped = gridCell.getWrappedCell();
    int x;
    int y;
    switch (gridCell.getHorizontalAlignment()) {
      case LEFT:
        x = gridCell.getX();
        x += gridCell.getWrappedCellOffsetX();
        break;
      case RIGHT:
        x = gridCell.getX() + gridCell.getWidth();
        x -= wrapped.getWidth();
        x -= 4;
        break;
      case CENTER:
        x = gridCell.getX() + gridCell.getWidth() / 2;
        x -= wrapped.getWidth() / 2;
        break;
      default:
        throw new RuntimeException("Unknown alignment: " + gridCell.getHorizontalAlignment());
    }
    switch (gridCell.getVerticalAlignment()) {
      case TOP:
        y = gridCell.getY();
        y += gridCell.getWrappedCellOffsetY();
        break;
      case BOTTOM:
        y = gridCell.getY() + gridCell.getHeight();
        y -= wrapped.getHeight();
        break;
      case CENTER:
        y = gridCell.getY() + gridCell.getHeight() / 2;
        y -= wrapped.getHeight() / 2;
        break;
      default:
        throw new RuntimeException("Unknown alignment: " + gridCell.getVerticalAlignment());
    }
    moveCell(wrapped, x, y);
  }

  private void moveCell(EditorCell cell, int x, int y) {
    int deltaX = x - cell.getX();
    int deltaY = y - cell.getY();
    Deque<EditorCell> cellsToMove = new LinkedList<EditorCell>();
    cellsToMove.add(cell);
    while (!(cellsToMove.isEmpty())) {
      EditorCell nextCell = cellsToMove.removeFirst();
      nextCell.setX(nextCell.getX() + deltaX);
      nextCell.setY(nextCell.getY() + deltaY);
      if (nextCell instanceof EditorCell_Collection) {
        for (EditorCell childCell : Sequence.fromIterable(((EditorCell_Collection) nextCell))) {
          cellsToMove.add(childCell);
        }
      }
    }

  }

  @Override
  public TextBuilder doLayoutText(Iterable<EditorCell> editorCells) {
    TextBuilder result = new TextBuilderImpl();
    for (EditorCell editorCell : editorCells) {
      result = result.appendToTheRight(editorCell.renderText(), PunctuationUtil.hasLeftGap(editorCell));
    }
    return result;
  }

}

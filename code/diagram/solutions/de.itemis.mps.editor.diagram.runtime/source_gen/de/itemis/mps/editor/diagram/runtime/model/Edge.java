package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import de.itemis.mps.editor.diagram.runtime.shape.IShape;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Objects;
import java.util.Collections;
import de.itemis.mps.editor.diagram.runtime.shape.ShapeUtil;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import de.itemis.mps.editor.diagram.runtime.jgraph.VectorExtensions;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public class Edge extends DiagramElement {
  private static final double SQRT_2 = Math.sqrt(2);

  private boolean myVisible = true;

  @Nullable
  private IConnectionEndpoint_Internal myFromEndpoint;
  @Nullable
  private IConnectionEndpoint_Internal myToEndpoint;
  @NotNull
  private List<Point> myAnchorPoints = ListSequence.fromList(new ArrayList<Point>());
  @Nullable
  private IShape myStartShape;
  @Nullable
  private IShape myEndShape;
  private Double myStartShapeSize;
  private Double myEndShapeSize;
  private boolean myAnySideAllowedFrom = false;
  private boolean myAnySideAllowedTo = false;
  private boolean myCurved;
  private String myEdgeStyle;

  private Point myLastStartPoint;
  private Point myLastEndPoint;
  private boolean myTerminalPointsChanged = false;
  private boolean myAnchorPointsChanged = false;
  private boolean myIsNew = false;
  private List<SNode> myNavigationTargets = ListSequence.fromList(new ArrayList<SNode>());

  private Map<EdgeLabelType, EdgeLabel> myLabels = MapSequence.fromMap(new HashMap<EdgeLabelType, EdgeLabel>());

  public Edge() {
  }

  public Edge(SNode snode) {
    super(snode);
  }

  public boolean isVisible() {
    return myVisible;
  }

  public void setVisible(boolean flag) {
    myVisible = flag;
  }

  public void handleTerminalPointUpdate(Point startPoint, Point endPoint) {
    boolean significantStartChange = true;
    boolean significantEndChange = true;
    if (myLastStartPoint != null && startPoint != null) {
      significantStartChange = startPoint.toVector2D().distance(myLastStartPoint.toVector2D()) > 3.0;
      if (significantStartChange) {
        myTerminalPointsChanged = true;
      }
    }
    if (myLastEndPoint != null && endPoint != null) {
      significantEndChange = endPoint.toVector2D().distance(myLastEndPoint.toVector2D()) > 3.0;
      if (significantEndChange) {
        myTerminalPointsChanged = true;
      }
    }
    if (significantStartChange) {
      myLastStartPoint = startPoint;
    }
    if (significantEndChange) {
      myLastEndPoint = endPoint;
    }
  }

  public boolean isTerminalPointsChanged() {
    return myTerminalPointsChanged;
  }

  public boolean isAnchorPointsChanged() {
    return myAnchorPointsChanged;
  }

  public void setAnchorPoints(@NotNull List<Point> points) {
    if (points.size() != ListSequence.fromList(myAnchorPoints).count()) {
      myAnchorPointsChanged = true;
    } else {
      {
        Iterator<Point> p1_it = ListSequence.fromList(myAnchorPoints).iterator();
        Iterator<Point> p2_it = ListSequence.fromList(points).iterator();
        Point p1_var;
        Point p2_var;
        while (p1_it.hasNext() && p2_it.hasNext()) {
          p1_var = p1_it.next();
          p2_var = p2_it.next();
          if (!(Objects.equals(p1_var, p2_var))) {
            myAnchorPointsChanged = true;
            break;
          }
        }
      }
    }
    myAnchorPoints = ListSequence.fromListWithValues(new ArrayList<Point>(), points);
  }

  @NotNull
  public List<Point> getAnchorPoints() {
    return Collections.unmodifiableList(myAnchorPoints);
  }

  public void setEndpointFrom(@Nullable IConnectionEndpoint_Internal endpoint) {
    myFromEndpoint = endpoint;
  }

  public void setEndpointTo(@Nullable IConnectionEndpoint_Internal endpoint) {
    myToEndpoint = endpoint;
  }

  @Nullable
  public IConnectionEndpoint_Internal getUnresolvedEndpointFrom() {
    return myFromEndpoint;
  }
  @Nullable
  public IConnectionEndpoint_Internal getUnresolvedEndpointTo() {
    return myToEndpoint;
  }
  @Nullable
  public IConnectionEndpoint_Internal getResolvedEndpointFrom() {
    return getModel().resolveEndpointGlobal(getUnresolvedEndpointFrom(), false);
  }
  @Nullable
  public IConnectionEndpoint_Internal getResolvedEndpointTo() {
    return getModel().resolveEndpointGlobal(getUnresolvedEndpointTo(), true);
  }

  @Nullable
  public IShape getStartShape() {
    return myStartShape;
  }

  public void setStartShape(@Nullable IShape shape) {
    myStartShape = shape;
  }

  @Nullable
  public IShape getEndShape() {
    return myEndShape;
  }

  public void setEndShape(@Nullable IShape shape) {
    myEndShape = shape;
  }

  @NotNull
  public EdgeLabel getLabel(@NotNull EdgeLabelType type) {
    if (type == null) {
      throw new NullPointerException("type is null");
    }
    EdgeLabel label = MapSequence.fromMap(myLabels).get(type);
    if (label == null) {
      label = new EdgeLabel(type, this);
      MapSequence.fromMap(myLabels).put(type, label);
    }
    return label;
  }

  public List<Point> getFullPath() {
    List<Point> result = ListSequence.fromList(new ArrayList<Point>());
    ListSequence.fromList(result).addSequence(ListSequence.fromList(getAnchorPoints()));
    return result;
  }

  public double getShapeSize(boolean source) {
    return (source ? ShapeUtil.calcShapeSize(myStartShape, myStartShapeSize) : ShapeUtil.calcShapeSize(myEndShape, myEndShapeSize));
  }

  @Nullable
  public Point calcLabelReferencePoint(EdgeLabelType type) {

    Point result;
    List<Point> fullPath = getFullPath();
    if (ListSequence.fromList(fullPath).count() < 2) {
      return null;
    }
    switch (type) {
      case START_ROLE:
        {
          Point pos1 = ListSequence.fromList(fullPath).getElement(0);
          Point pos2 = ListSequence.fromList(fullPath).getElement(1);

          Vector2D direction = VectorExtensions.normalizeSafe(new Vector2D(pos2.getX() - pos1.getX(), pos2.getY() - pos1.getY()));
          double markerSize = getShapeSize(true);

          Vector2D pos = new Vector2D(pos1.getX(), pos1.getY());
          pos = pos.add(direction.scalarMultiply(markerSize * SQRT_2 + 6.0));

          result = new Point(pos.getX(), pos.getY());
        }
        break;
      case END_ROLE:
        {
          Point pos1 = ListSequence.fromList(fullPath).getElement(ListSequence.fromList(fullPath).count() - 1);
          Point pos2 = ListSequence.fromList(fullPath).getElement(ListSequence.fromList(fullPath).count() - 2);

          Vector2D direction = VectorExtensions.normalizeSafe(new Vector2D(pos2.getX() - pos1.getX(), pos2.getY() - pos1.getY()));
          double markerSize = getShapeSize(false);
          Vector2D pos = new Vector2D(pos1.getX(), pos1.getY());

          pos = pos.add(direction.scalarMultiply(markerSize * SQRT_2 + 6.0));

          result = new Point(pos.getX(), pos.getY());
        }
        break;
      case LABEL:
        {
          // place the label at the center of the edge line

          double edgeLength = 0.0;
          Vector2D lastPoint = new Vector2D(ListSequence.fromList(fullPath).getElement(0).getX(), ListSequence.fromList(fullPath).getElement(0).getY());
          for (int i = 1; i < ListSequence.fromList(fullPath).count(); i++) {
            Vector2D point = new Vector2D(ListSequence.fromList(fullPath).getElement(i).getX(), ListSequence.fromList(fullPath).getElement(i).getY());
            edgeLength += lastPoint.distance(point);
            lastPoint = point;
          }

          double remainingLength = edgeLength / 2;
          lastPoint = new Vector2D(ListSequence.fromList(fullPath).getElement(0).getX(), ListSequence.fromList(fullPath).getElement(0).getY());
          Vector2D defaultPos = lastPoint;
          for (int i = 1; i < ListSequence.fromList(fullPath).count(); i++) {
            Vector2D point = new Vector2D(ListSequence.fromList(fullPath).getElement(i).getX(), ListSequence.fromList(fullPath).getElement(i).getY());
            double distance = lastPoint.distance(point);
            if (remainingLength > distance) {
              remainingLength -= distance;
              lastPoint = point;
            } else {
              defaultPos = lastPoint.add(VectorExtensions.normalizeSafe(point.subtract(lastPoint)).scalarMultiply(remainingLength));
              break;
            }
          }

          result = new Point(defaultPos.getX(), defaultPos.getY());
        }
        break;
      default:
        throw new RuntimeException("Unknown type: " + type);
    }

    return result;
  }

  @Nullable
  public EditorCell getLabelCell(@NotNull EdgeLabelType type) {
    return getLabel(type).getCell();
  }

  public void setLabelCell(@NotNull EdgeLabelType type, @Nullable EditorCell cell) {
    getLabel(type).setCell(cell);
  }

  @Override
  public void resetModificationFlags() {
    myTerminalPointsChanged = false;
    myAnchorPointsChanged = false;
    for (EdgeLabelType type : EdgeLabelType.values()) {
      getLabel(type).setPositionChanged(false);
    }
  }

  @Override
  public IEdgeAccessor getAccessor() {
    return (IEdgeAccessor) super.getAccessor();
  }

  @Override
  public boolean isAccessorAllowed(@NotNull IDiagramElementAccessor accessor) {
    return accessor instanceof IEdgeAccessor;
  }

  @Nullable
  public RelativePosition getLabelPosition(EdgeLabelType type) {
    return getLabel(type).getPosition();
  }

  @NotNull
  public RelativePosition getOrCreateLabelPosition(EdgeLabelType type) {
    RelativePosition labelPosition = getLabelPosition(type);
    if (labelPosition == null) {
      labelPosition = new RelativePosition();
      setLabelPosition(type, labelPosition);
    }
    return labelPosition;
  }

  public void setLabelPosition(EdgeLabelType type, @Nullable RelativePosition position) {
    getLabel(type).setPosition(position);
  }

  public boolean canSplit(final SAbstractConcept concept) {
    return getAccessor().canSplit(concept);
  }

  public void split(final Box boxToInsert) {
    getAccessor().split(boxToInsert);
  }

  @Nullable
  public Double getEndShapeSize() {
    return myEndShapeSize;
  }
  public void setEndShapeSize(@Nullable Double endShapeSize) {
    myEndShapeSize = endShapeSize;
  }
  @Nullable
  public Double getStartShapeSize() {
    return myStartShapeSize;
  }
  public void setStartShapeSize(@Nullable Double startShapeSize) {
    myStartShapeSize = startShapeSize;
  }

  public void setNew(boolean isNew) {
    myIsNew = isNew;
  }

  public boolean isNew() {
    return myIsNew;
  }

  @NotNull
  public List<SNode> getNavigationTargets() {
    return ListSequence.fromListWithValues(new ArrayList<SNode>(), myNavigationTargets);
  }

  public void setNavigationTargets(List<SNode> targets) {
    myNavigationTargets = ListSequence.fromListWithValues(new ArrayList<SNode>(), targets);
  }

  public boolean isAnySideAllowedFrom() {
    return myAnySideAllowedFrom;
  }

  public void setAnySideAllowedFrom(boolean anySideAllowedFrom) {
    myAnySideAllowedFrom = anySideAllowedFrom;
  }

  public boolean isAnySideAllowedTo() {
    return myAnySideAllowedTo;
  }

  public void setAnySideAllowedTo(boolean anySideAllowedTo) {
    myAnySideAllowedTo = anySideAllowedTo;
  }

  public boolean isCurved() {
    return myCurved;
  }

  public void setCurved(boolean curved) {
    myCurved = curved;
  }

  public String getEdgeStyle() {
    return myEdgeStyle;
  }

  public void setEdgeStyle(String style) {
    myEdgeStyle = style;
  }

  public boolean canDrop(Object data) {
    return getAccessor().canDrop(data);
  }

  public void drop(Object data) {
    getAccessor().drop(data);
  }
}

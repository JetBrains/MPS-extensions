package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import java.util.Map;
import com.mxgraph.view.mxGraph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import de.itemis.mps.editor.celllayout.runtime.TopDownCellLayoutAdapter;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import com.mxgraph.view.mxGraphView;
import com.mxgraph.util.mxPoint;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.annotations.Nullable;
import de.itemis.mps.editor.diagram.runtime.coordinates.ICoordinateSystem;
import de.itemis.mps.editor.diagram.runtime.coordinates.GlobalCoordinateSystem;
import de.itemis.mps.editor.celllayout.layout.AbstractLayout;
import de.itemis.mps.editor.celllayout.layout.ILayoutableContainer;
import de.itemis.mps.editor.celllayout.boxmodel.Size;
import org.jetbrains.annotations.NotNull;
import de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods;
import com.mxgraph.model.mxICell;

public class SubDiagramECell extends BaseDiagramECell {
  private static final int PADDING = 10;


  private Map<mxGraph, SubDiagramDCell> myDCell = MapSequence.fromMap(new WeakHashMap<mxGraph, SubDiagramDCell>());
  private Tuples._2<Double, Double> myFixedSize;

  public SubDiagramECell(EditorContext context, SNode node, DiagramModel model) {
    super(context, node, model);
    this.myCellLayout = new TopDownCellLayoutAdapter(new Layout());
    getStyle().set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_push-x"), true);
    getStyle().set(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_push-y"), true);

    MyGraph graph = DiagramCreationContext.getRootGraph();
    if (graph == null) {
      throw new RuntimeException("Subdiagram is not inside a diagram");
    }
    myModel.synchronizeRead(this);
  }

  public void setDCell(SubDiagramDCell dcell, mxGraph graph) {
    MapSequence.fromMap(myDCell).put(graph, dcell);
  }

  @Override
  public SubDiagramDCell getDCell(mxGraph graph) {
    return MapSequence.fromMap(myDCell).get(graph);
  }

  public RootDiagramECell getRootDiagramCell() {
    for (EditorCell ancestor = getParent(); ancestor != null; ancestor = ancestor.getParent()) {
      if (ancestor instanceof RootDiagramECell) {
        return ((RootDiagramECell) ancestor);
      }
    }
    return null;
  }

  protected void updateDCellPosition(final MyGraph graph) {
    if (MapSequence.fromMap(myDCell).get(graph) == null) {
      return;
    }
    if (graph == null) {
      return;
    }
    final MyGraphModel model = graph.getModel();
    graph.getSynchronizer().suspend(() -> {
      model.beginUpdate();
      try {
        MPSCell layoutedCell = graph.getMPSCellRegistry().findAncestor(SubDiagramECell.this);
        if (layoutedCell != null) {
          mxGraphView view = graph.getView();
          double scale = view.getScale();

          // the distance of the subdiagram cell to the embedded cell
          int eDeltaX = LayoutDependencies.getX(SubDiagramECell.this) - LayoutDependencies.getX(layoutedCell.getEditorCell());
          int eDeltaY = LayoutDependencies.getY(SubDiagramECell.this) - LayoutDependencies.getY(layoutedCell.getEditorCell());

          mxPoint parentPos = JGraphUtil.getAbsolutePosition(check_1g5xe2_a0a7a1a1a0a0d0o(MapSequence.fromMap(myDCell).get(graph)));
          mxPoint parentDScreen = JGraphUtil.convertToView(view, parentPos);
          // the distance of the embedded cell to its parent box
          double dDeltaX = layoutedCell.getStateRelativeX();
          double dDeltaY = layoutedCell.getStateRelativeY();

          CellExtensions.setPosition(MapSequence.fromMap(myDCell).get(graph), eDeltaX + dDeltaX / scale, eDeltaY + dDeltaY / scale);
        }
      } finally {
        model.endUpdate();
      }
    });
  }

  @Override
  public void setX(int x) {
    super.setX(x);
    updateDCellPosition(getContextGraph());
  }
  @Override
  public void setY(int y) {
    super.setY(y);
    updateDCellPosition(getContextGraph());
  }
  @Override
  public void moveTo(int x, int y) {
    super.moveTo(x, y);
    updateDCellPosition(getContextGraph());
  }

  @Override
  public void setFixedSize(double width, double height) {
    myFixedSize = MultiTuple.<Double,Double>from(width, height);
    requestRelayout();
  }

  @Override
  public void clearFixedSize() {
    if (myFixedSize != null) {
      myFixedSize = null;
      requestRelayout();
    }
  }

  @Override
  @Nullable
  public Tuples._2<Double, Double> getFixedSize() {
    return myFixedSize;
  }

  public Tuples._2<Double, Double> getPreferredSize(mxGraph graph) {
    double w = 0;
    double h = 0;
    if (MapSequence.fromMap(myDCell).get(graph) != null) {
      Tuples._2<Double, Double> s = MapSequence.fromMap(myDCell).get(graph).getPreferredSize();
      w = (double) s._0();
      h = (double) s._1();
    } else {
      requestRelayout();
    }
    w = Math.max(w, 50);
    h = Math.max(h, 50);
    return MultiTuple.<Double,Double>from(w, h);
  }

  public ICoordinateSystem getCoordinateSystem() {
    return GlobalCoordinateSystem.INSTANCE;
  }

  public class Layout extends AbstractLayout {
    public int getAscent(ILayoutableContainer container, Size sizeConstraint) {
      return 0;
    }
    @NotNull
    public Size getMaxInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint) {
      return Size.UNLIMITED_SIZE;
    }
    @NotNull
    public Size getMinInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint) {
      return new Size(10, 10);
    }
    @NotNull
    public Size getPreferredInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint) {
      Tuples._2<Double, Double> preferredSize = getPreferredSize(getContextGraph());
      return new Size(ExtensionMethods.toInt((double) preferredSize._0()), ExtensionMethods.toInt((double) preferredSize._1()));
    }
    public void layout(ILayoutableContainer container, @NotNull Size sizeConstraint) {
      MyGraph graph = getContextGraph();
      int newWidth = sizeConstraint.getWidth();
      int newHeight = sizeConstraint.getHeight();

      if (MapSequence.fromMap(myDCell).get(graph) != null) {
        CellExtensions.setSize(MapSequence.fromMap(myDCell).get(graph), newWidth, newHeight);
      } else {
        requestRelayout();
      }

      updateDCellPosition(graph);
    }
  }
  private static mxICell check_1g5xe2_a0a7a1a1a0a0d0o(SubDiagramDCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getParent();
    }
    return null;
  }
}

package de.q60.mps.shadowmodels.runtime.mpslike;

/*Generated by MPS */

import org.modelix.model.api.IConcept;
import org.modelix.model.api.INode;
import de.q60.mps.shadowmodels.runtime.engine.IScope;
import de.q60.mps.shadowmodels.runtime.engine.IOutputWrapper;
import de.q60.mps.shadowmodels.runtime.engine.ISubgraphStage;
import de.q60.mps.shadowmodels.runtime.engine.IReferenceTarget;
import de.q60.mps.shadowmodels.runtime.engine.IOutputNodeReference;
import de.q60.mps.shadowmodels.runtime.engine.AbstractOutputNodeReference;
import de.q60.mps.shadowmodels.runtime.engine.IUniqueContainmentTarget;
import org.jetbrains.annotations.Nullable;
import de.q60.mps.shadowmodels.runtime.engine.IStageReference;
import de.q60.mps.shadowmodels.runtime.engine.ITransformationEngine;
import de.q60.mps.shadowmodels.runtime.engine.IOutputNode;
import java.util.Objects;
import de.q60.mps.shadowmodels.runtime.engine.IContainment;

public abstract class ReferenceRule implements IOutputWrapperRule {

  private IConcept concept;
  private String role;

  public ReferenceRule(IConcept concept, String role) {
    this.concept = concept;
    this.role = role;
  }

  public IConcept getInputConcept() {
    return concept;
  }

  public boolean isApplicable(INode inputNode, IScope scope) {
    return true;
  }

  public IOutputWrapper apply(ISubgraphStage stage, INode outputNode) {
    return new Wrapper(getTarget(outputNode));
  }

  public abstract IReferenceTarget getTarget(INode outputNode);

  public class Wrapper implements IOutputWrapper {
    private IReferenceTarget target;

    public Wrapper(IReferenceTarget value) {
      this.target = value;
    }

    public IOutputNodeReference wrap(IOutputNodeReference node) {
      return new OutputRef(node);
    }

    /**
     * 
     * @deprecated  Wrapper should be applied during IOutputNode resolution, instead of changing the ref.
     */
    @Deprecated
    public class OutputRef extends AbstractOutputNodeReference implements IOutputNodeReference {
      private IOutputNodeReference nodeRef;

      @Deprecated
      public OutputRef(IOutputNodeReference node) {
        this.nodeRef = node;
      }

      public IOutputNodeReference unwrap() {
        return this.nodeRef;
      }

      @Override
      public Iterable<INode> getInputNodes() {
        return nodeRef.getInputNodes();
      }

      @Override
      public IUniqueContainmentTarget getOriginalContainmentTarget() {
        return nodeRef.getOriginalContainmentTarget();
      }

      @Nullable
      @Override
      public IStageReference getStageRef() {
        return nodeRef.getStageRef();
      }

      @Override
      public IScope getScope(ITransformationEngine engine) {
        return nodeRef.getScope(engine);
      }

      @Override
      public IOutputNode resolve(ITransformationEngine engine) {
        return new OutputNode(nodeRef.resolve(engine), engine);
      }

      public ReferenceRule getRule() {
        return ReferenceRule.this;
      }

      private transient int _cachedHashCode;
      private transient boolean _hashCodeInitialized = false;
      @Override
      public int hashCode() {
        if (!(_hashCodeInitialized)) {
          int c = 0;
          c = 31 * c + Objects.hashCode(nodeRef);
          c = 31 * c + Objects.hashCode(getRule());
          _cachedHashCode = c;
          _hashCodeInitialized = true;
        }
        return _cachedHashCode;
      }
      @Override
      public boolean equals(Object o) {
        if (this == o) {
          return true;
        }
        if (o == null || this.getClass() != o.getClass()) {
          return false;
        }
        OutputRef that = (OutputRef) o;
        if (!(Objects.equals(nodeRef, that.nodeRef))) {
          return false;
        }
        if (!(Objects.equals(getRule(), that.getRule()))) {
          return false;
        }
        return true;
      }

      public class OutputNode implements IOutputNode {
        private IOutputNode node;
        private ITransformationEngine engine;

        public OutputNode(IOutputNode node, ITransformationEngine engine) {
          this.node = node;
          this.engine = engine;
        }

        @Override
        public IOutputNodeReference getOutputNodeReference() {
          return OutputRef.this;
        }
        @Override
        public IConcept getConcept() {
          return node.getConcept();
        }
        @Override
        public IContainment getContainment() {
          return node.getContainment();
        }
        @Override
        public Iterable<IOutputNodeReference> getChildren(String role) {
          return node.getChildren(role);
        }
        @Override
        public Iterable<IOutputNodeReference> getAllChildren() {
          return node.getAllChildren();
        }
        @Override
        public void addNewChild(String role, int index, @Nullable IConcept concept) {
          node.addNewChild(role, index, concept);
        }
        @Override
        public IOutputNodeReference getReferenceTarget(String r) {
          if (!(Objects.equals(r, role))) {
            return node.getReferenceTarget(r);
          }
          if (target == null) {
            return null;
          }
          return target.resolve(nodeRef.getScope(engine), engine);
        }
        @Override
        public void setReferenceTarget(String role, INode target) {
          node.setReferenceTarget(role, target);
        }
        @Override
        public String getPropertyValue(String role) {
          return node.getPropertyValue(role);
        }
        @Override
        public void setPropertyValue(String role, String value) {
          node.setPropertyValue(role, value);
        }

        @Override
        public boolean equals(Object o) {
          if (this == o) {
            return true;
          }
          if (o == null || this.getClass() != o.getClass()) {
            return false;
          }

          OutputNode that = (OutputNode) o;
          if (!(Objects.equals(getOutputNodeReference(), that.getOutputNodeReference()))) {
            return false;
          }
          if (!(Objects.equals(node, that.node))) {
            return false;
          }

          return true;
        }

        @Override
        public int hashCode() {
          int result = 0;
          result = 31 * result + ((node != null ? ((Object) node).hashCode() : 0));
          result = 31 * result + ((getOutputNodeReference() != null ? ((Object) getOutputNodeReference()).hashCode() : 0));
          return result;
        }
      }

    }

  }
}

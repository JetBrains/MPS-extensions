package com.mbeddr.mpsutil.projectview.runtime;

/*Generated by MPS */

import jetbrains.mps.classloading.DeployListener;
import java.util.Set;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Map;
import com.mbeddr.mpsutil.projectview.runtime.tree.CustomProjectView;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.module.ReloadableModule;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.util.Objects;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.ide.projectView.ProjectView;
import org.jdom.Element;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import com.intellij.ide.projectView.impl.ProjectViewImpl;
import com.intellij.ide.projectView.impl.AbstractProjectViewPane;
import com.intellij.openapi.util.Disposer;
import jetbrains.mps.core.platform.Platform;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.IMapping;

public class ProjectViewManager implements DeployListener {

  private static ProjectViewManager ourInstance = new ProjectViewManager();

  public static ProjectViewManager getInstance() {
    return ourInstance;
  }

  private Set<Project> myProjects = SetSequence.fromSet(new HashSet<Project>());
  private Map<Project, Map<ViewId, CustomProjectView>> myViewInstances = MapSequence.fromMap(new HashMap<Project, Map<ViewId, CustomProjectView>>());
  private boolean myIsDisposed = false;

  public CustomProjectView getView(Project project, ViewId id) {
    Map<ViewId, CustomProjectView> views = MapSequence.fromMap(myViewInstances).get(project);
    if (views == null) {
      return null;
    }
    return MapSequence.fromMap(views).get(id);
  }

  public void registerProject(Project project) {
    SetSequence.fromSet(myProjects).addElement(project);
    syncViews(project);
  }

  @Override
  public void onLoaded(@NotNull Set<ReloadableModule> loadedModules, @NotNull ProgressMonitor monitor) {
    for (ReloadableModule module : SetSequence.fromSet(loadedModules)) {
      loadModule(module);
    }
    syncViews();
  }

  @Override
  public void onUnloaded(@NotNull Set<ReloadableModule> unloadedModules, @NotNull ProgressMonitor monitor) {
    for (ReloadableModule module : SetSequence.fromSet(unloadedModules)) {
      // In PluginLoaderRegistry.unloadPlugins/loadPlugins the plugin are unloaded/loaded asynchronously.
      // That means, the dispose method if this class is called after the modules are reloaded
      // (afterClassLoaded is called).
      // While the new descriptors already use the new classes from this module, the listener is still an old
      // class. This causes ClassCastExceptions. To fix this, we detect the reload of this module on our own.
      if (Objects.equals(module.getModuleReference(), PersistenceFacade.getInstance().createModuleReference("732373f1-0d48-4122-bb43-c1606db4baca(com.mbeddr.mpsutil.projectview.runtime)"))) {
        dispose();
        return;
      }

      unloadModule(module);
    }
    ThreadUtils.runInUIThreadNoWait(() -> syncViews());
  }

  public void unregisterProject(Project project) {
    SetSequence.fromSet(myProjects).removeElement(project);
    syncViews(project);
  }

  public void syncViews() {
    SetSequence.fromSet(myProjects).visitAll((it) -> syncViews(it));
  }

  protected void syncViews(final Project project) {
    final Wrappers._T<Map<ViewId, CustomProjectView>> activeViews = new Wrappers._T<Map<ViewId, CustomProjectView>>(MapSequence.fromMap(myViewInstances).get(project));
    if (activeViews.value == null) {
      activeViews.value = MapSequence.fromMap(new HashMap<ViewId, CustomProjectView>());
      MapSequence.fromMap(myViewInstances).put(project, activeViews.value);
    }

    final Wrappers._T<Set<ViewId>> registeredViews = new Wrappers._T<Set<ViewId>>(Collections.emptySet());
    if (SetSequence.fromSet(myProjects).contains(project)) {
      registeredViews.value = SetSequence.fromSetWithValues(new HashSet<ViewId>(), Sequence.fromIterable(ViewRegistry.getInstance().getVisibleDescriptors()).select((it) -> it.getId()));
    }

    ThreadUtils.runInUIThreadNoWait(() -> {
      for (ViewId activeView : ListSequence.fromList(SetSequence.fromSet(MapSequence.fromMap(activeViews.value).keySet()).toList())) {
        if (!(SetSequence.fromSet(registeredViews.value).contains(activeView))) {
          deactivateView(activeView, project);
        }
      }

      for (ViewId registeredView : SetSequence.fromSet(registeredViews.value)) {
        if (!(MapSequence.fromMap(activeViews.value).containsKey(registeredView))) {
          activateView(registeredView, project);
        }
      }
    });

    if (MapSequence.fromMap(activeViews.value).isEmpty()) {
      MapSequence.fromMap(myViewInstances).removeKey(project);
    }
  }

  public void activateView(ViewId viewId, Project project) {
    final com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(project);
    final ProjectView projectView = ProjectView.getInstance(ideaProject);

    final CustomProjectView pane = new CustomProjectView(ProjectHelper.toIdeaProject(project), viewId);
    MapSequence.fromMap(MapSequence.fromMap(myViewInstances).get(project)).put(viewId, pane);

    Element paneState = ((Map<String, Element>) ReflectionUtil.readField(ProjectViewImpl.class, ((ProjectViewImpl) projectView), "myUninitializedPaneState")).get(pane.getId());
    if (paneState != null) {
      pane.readExternal(paneState);
    }
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      public void run() {
        Element paneState = ((Map<String, Element>) ReflectionUtil.readField(ProjectViewImpl.class, ((ProjectViewImpl) projectView), "myUninitializedPaneState")).get(pane.getId());
        if (paneState != null) {
          pane.readExternal(paneState);
        }
        projectView.addProjectPane(pane);
        AbstractProjectViewPane.EP.getPoint(ideaProject).registerExtension(pane, Disposer.newDisposable());
      }
    });
  }

  public void deactivateView(ViewId viewId, Project project) {
    CustomProjectView pane = MapSequence.fromMap(MapSequence.fromMap(myViewInstances).get(project)).get(viewId);

    MapSequence.fromMap(MapSequence.fromMap(myViewInstances).get(project)).removeKey(viewId);
    com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(project);
    if (!(project.isDisposed())) {
      ProjectView projectView = ProjectView.getInstance(ideaProject);
      projectView.removeProjectPane(pane);
    }
    AbstractProjectViewPane.EP.getPoint(ideaProject).unregisterExtension(pane);

    pane.dispose();
  }

  public void removeView(CustomProjectView pane, Project project) {
    MapSequence.fromMap(MapSequence.fromMap(myViewInstances).get(project)).removeKey(new ViewId(pane.getId()));
    com.intellij.openapi.project.Project ideaProject = ProjectHelper.toIdeaProject(project);
    if (!(project.isDisposed())) {
      ProjectView projectView = ProjectView.getInstance(ideaProject);
      projectView.removeProjectPane(pane);
    }
    pane.dispose();
  }

  public void install() {
    Platform platform = MPSCoreComponents.getInstance().getPlatform();
    ClassLoaderManager clsLoaderManager = platform.findComponent(ClassLoaderManager.class);
    if (clsLoaderManager == null) {
      return;
    }
    MPSCoreComponents.getInstance().getPlatform().findComponent(ClassLoaderManager.class).addListener(this);
    final MPSModuleRepository moduleRepository = MPSCoreComponents.getInstance().getPlatform().findComponent(MPSModuleRepository.class);
    if (moduleRepository == null) {
      return;
    }

    moduleRepository.getModelAccess().runReadAction(() -> {
      for (SModule module : Sequence.fromIterable(moduleRepository.getModules())) {
        if (module instanceof ReloadableModule) {
          loadModule((ReloadableModule) module);
        }
      }
    });
  }

  public void dispose() {
    if (myIsDisposed) {
      return;
    }

    ClassLoaderManager clsLoaderManager = MPSCoreComponents.getInstance().getPlatform().findComponent(ClassLoaderManager.class);
    if (clsLoaderManager == null) {
      return;
    }

    MPSCoreComponents.getInstance().getPlatform().findComponent(ClassLoaderManager.class).removeListener(this);

    ThreadUtils.runInUIThreadNoWait(() -> {
      for (IMapping<Project, Map<ViewId, CustomProjectView>> projectInstances : ListSequence.fromList(MapSequence.fromMap(myViewInstances).toList())) {
        for (IMapping<ViewId, CustomProjectView> instance : ListSequence.fromList(MapSequence.fromMap(projectInstances.value()).toList())) {
          deactivateView(instance.key(), projectInstances.key());
        }
      }
    });

    myIsDisposed = true;
  }

  public void loadModule(ReloadableModule module) {
    IProjectViewDescriptor descriptor = getDescriptor(module);
    if (descriptor != null) {
      loadDescriptor(descriptor);
    }
  }

  public void unloadModule(ReloadableModule module) {
    IProjectViewDescriptor descriptor = getDescriptor(module);
    if (descriptor != null) {
      unloadDescriptor(descriptor);
    }
  }

  public Class<IProjectViewDescriptor> getDescriptorClass(ReloadableModule module) {
    String className = module.getModuleName() + ".plugin." + IProjectViewDescriptor.CLASS_NAME;
    try {
      return ((Class<IProjectViewDescriptor>) module.getOwnClass(className));
    } catch (Exception e) {
    }
    return null;
  }

  public IProjectViewDescriptor getDescriptor(ReloadableModule module) {
    Class<IProjectViewDescriptor> descriptorClass = getDescriptorClass(module);
    if (descriptorClass == null) {
      return null;
    }
    return ((IProjectViewDescriptor) ReflectionUtil.readField(descriptorClass, null, "INSTANCE"));
  }

  public void loadDescriptor(IProjectViewDescriptor descriptor) {
    Sequence.fromIterable(descriptor.getViewDescriptors()).visitAll((it) -> ViewRegistry.getInstance().register(it));
  }

  public void unloadDescriptor(IProjectViewDescriptor descriptor) {
    Sequence.fromIterable(descriptor.getViewDescriptors()).visitAll((it) -> ViewRegistry.getInstance().unregister(it));
  }
}

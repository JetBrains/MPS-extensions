package de.itemis.mps.linenumbers.plugin;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public abstract class AbstractLineList implements ILineList {
  protected int expandedSize = -1;
  @Override
  public void setExpandedSize(int size) {
    expandedSize = size;
  }
  @Override
  public int getExpandedSize() {
    return (expandedSize != -1 ? expandedSize : getSize());
  }

  @Override
  public int getExpandedDelta() {
    return getExpandedSize() - getSize();
  }

  @Override
  public void setExpandedDelta(int delta) {
    setExpandedSize(getSize() + delta);
  }

  @Override
  public boolean overlaps(ILineList other) {
    int minY = getMinY();
    int otherMinY = other.getMinY();
    int maxY = getMaxY();
    int otherMaxY = other.getMaxY();
    if (minY == otherMaxY || maxY == otherMinY) {
      return false;
    }
    if (otherMinY <= minY && minY <= otherMaxY) {
      return true;
    }
    if (otherMinY <= maxY && maxY <= otherMaxY) {
      return true;
    }
    if (minY <= otherMinY && otherMinY <= maxY) {
      return true;
    }
    if (minY <= otherMaxY && otherMaxY <= maxY) {
      return true;
    }
    return false;
  }

  @Override
  public ILineList merge(ILineList other) {
    Iterable<Line> allLines = Sequence.fromIterable(getLines()).concat(Sequence.fromIterable(other.getLines())).sort((it) -> it.getMinY(), true).alsoSort((it) -> it.getMaxY(), true);
    List<ILineList> mergedLines = ListSequence.fromList(new ArrayList<ILineList>());
    for (Line line : Sequence.fromIterable(allLines)) {
      if (ListSequence.fromList(mergedLines).isEmpty() || !(ListSequence.fromList(mergedLines).last().overlaps(line))) {
        ListSequence.fromList(mergedLines).addElement(line);
      }
    }
    return LineList.create(mergedLines);
  }
}

package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import de.itemis.mps.editor.diagram.runtime.model.EdgeLabelType;
import org.eclipse.elk.core.options.EdgeLabelPlacement;
import java.util.HashMap;
import org.eclipse.elk.core.data.LayoutMetaDataService;
import org.eclipse.elk.core.options.CoreOptions;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.eclipse.elk.graph.ElkEdge;
import org.eclipse.elk.graph.ElkLabel;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.eclipse.elk.graph.ElkNode;
import org.eclipse.elk.graph.ElkPort;
import com.mxgraph.view.mxGraph;
import org.eclipse.elk.alg.layered.options.LayeredOptions;
import org.eclipse.elk.core.options.Direction;
import org.eclipse.elk.core.options.HierarchyHandling;
import org.eclipse.elk.core.options.EdgeRouting;
import org.eclipse.elk.core.math.ElkPadding;
import org.eclipse.elk.core.math.KVector;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.EnumSet;
import org.eclipse.elk.core.options.SizeConstraint;
import org.eclipse.elk.core.options.SizeOptions;
import org.eclipse.elk.core.options.PortConstraints;
import org.eclipse.elk.core.options.NodeLabelPlacement;
import org.eclipse.elk.core.options.PortLabelPlacement;
import org.eclipse.elk.core.options.Alignment;
import org.eclipse.elk.core.math.ElkMargin;
import org.eclipse.elk.core.options.PortAlignment;
import org.eclipse.elk.core.options.EdgeType;
import org.eclipse.elk.core.options.PortSide;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.baseLanguage.logging.rt.LogContext;
import org.eclipse.elk.core.util.BasicProgressMonitor;
import java.nio.file.Path;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import org.eclipse.elk.core.RecursiveGraphLayoutEngine;
import org.eclipse.elk.core.util.IElkProgressMonitor;
import org.eclipse.elk.graph.util.ElkGraphUtil;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.mxgraph.model.mxICell;
import com.mxgraph.model.mxGraphModel;
import de.itemis.mps.editor.diagram.runtime.model.Box;
import de.itemis.mps.editor.diagram.runtime.model.IConnectionEndpoint_Internal;
import de.itemis.mps.editor.diagram.runtime.model.EndpointUtil;
import org.eclipse.elk.graph.ElkEdgeSection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.annotations.NotNull;
import org.eclipse.elk.graph.ElkConnectableShape;
import de.itemis.mps.editor.diagram.runtime.model.IAccessorKey;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.eclipse.elk.graph.ElkShape;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.List;
import com.mxgraph.util.mxPoint;
import java.util.ArrayList;
import org.eclipse.elk.graph.ElkBendPoint;
import de.itemis.mps.editor.diagram.runtime.model.Edge;

public abstract class ElkLayouter implements ILayouter {
  private static final Logger LOG_274928513 = Logger.getLogger(ElkLayouter.class);

  protected static final com.intellij.openapi.diagnostic.Logger LOG = com.intellij.openapi.diagnostic.Logger.getInstance(ElkLayouter.class);

  private static final Map<EdgeLabelType, EdgeLabelPlacement> labelType2Placement = new HashMap<EdgeLabelType, EdgeLabelPlacement>();
  static {
    labelType2Placement.put(EdgeLabelType.LABEL, EdgeLabelPlacement.CENTER);
    labelType2Placement.put(EdgeLabelType.START_ROLE, EdgeLabelPlacement.TAIL);
    labelType2Placement.put(EdgeLabelType.END_ROLE, EdgeLabelPlacement.HEAD);

    LayoutMetaDataService.getInstance().registerLayoutMetaDataProviders(new CoreOptions());
  }

  public static EdgeLabelPlacement toLabelPlacement(EdgeLabelType type) {
    EdgeLabelPlacement placement = labelType2Placement.get(type);
    if (placement == null) {
      throw new RuntimeException("Unknown EdgeLabelType: " + type);
    }
    return placement;
  }

  private Set<EdgeDCell> edgesNotToLayout = SetSequence.fromSet(new HashSet<EdgeDCell>());
  private Map<EdgeDCell, ElkEdge> edgesMap;
  private Map<ElkLabel, Tuples._2<EdgeDCell, EdgeLabelType>> labelEdgeMap;
  private Map<BoxDCell, ElkNode> boxesMap;
  private Map<Tuples._2<BoxDCell, String>, ElkPort> portsMap;
  private Map<Tuples._2<BoxDCell, String>, PortDCell> portsInBox;
  private Map<BoxDCell, ElkPort> inputDummyPorts;
  private Map<BoxDCell, ElkPort> outputDummyPorts;
  private mxGraph myGraph;
  protected boolean myWriteBackNodes = true;
  protected boolean myWriteBackEdges = true;
  protected String myAlgorithm = LayeredOptions.ALGORITHM_ID;
  protected Direction myDirection = Direction.DOWN;
  protected HierarchyHandling myHierarchyHandling = HierarchyHandling.SEPARATE_CHILDREN;
  protected EdgeRouting myEdgeRouting = EdgeRouting.UNDEFINED;
  protected ElkPadding myDefaultPadding = CoreOptions.PADDING.getDefault();
  private boolean myPortReorderingDisabled = false;
  private boolean connectBoxesWithoutDummyPort = false;
  private ElkPadding myNodeSizePadding = new ElkPadding(5);

  protected ElkPadding padding;
  protected Boolean interactive;
  protected Boolean interactiveLayout;

  protected Map<Object, KVector> myNodeSizeMinimum = MapSequence.fromMap(new HashMap<Object, KVector>());
  protected Map<Object, EnumSet<SizeConstraint>> myNodeSizeConstraints = MapSequence.fromMap(new HashMap<Object, EnumSet<SizeConstraint>>());
  protected Map<Object, EnumSet<SizeOptions>> myNodeSizeOptions = MapSequence.fromMap(new HashMap<Object, EnumSet<SizeOptions>>());
  protected Map<Object, ElkPadding> myNodePaddings = MapSequence.fromMap(new HashMap<Object, ElkPadding>());

  protected Map<Object, PortConstraints> myPortConstraints = MapSequence.fromMap(new HashMap<Object, PortConstraints>());
  protected Map<Object, EnumSet<NodeLabelPlacement>> myNodeLabelPlacements = MapSequence.fromMap(new HashMap<Object, EnumSet<NodeLabelPlacement>>());
  protected Map<Object, EnumSet<PortLabelPlacement>> myPortLabelPlacements = MapSequence.fromMap(new HashMap<Object, EnumSet<PortLabelPlacement>>());
  protected Map<Object, Integer> myNodePriorities = MapSequence.fromMap(new HashMap<Object, Integer>());
  protected Map<Object, Boolean> myActivateInsideSelfLoops = MapSequence.fromMap(new HashMap<Object, Boolean>());
  protected Map<Object, Alignment> myAlignments = MapSequence.fromMap(new HashMap<Object, Alignment>());
  protected Map<Object, Boolean> myCommentBoxes = MapSequence.fromMap(new HashMap<Object, Boolean>());
  protected Map<Object, HierarchyHandling> myHierarchyHandlings = MapSequence.fromMap(new HashMap<Object, HierarchyHandling>());
  protected Map<Object, Boolean> myHyperNodes = MapSequence.fromMap(new HashMap<Object, Boolean>());
  protected Map<Object, Integer> myLayoutPartitions = MapSequence.fromMap(new HashMap<Object, Integer>());
  protected Map<Object, ElkMargin> myMargins = MapSequence.fromMap(new HashMap<Object, ElkMargin>());
  protected Map<Object, PortAlignment> myPortAlignments = MapSequence.fromMap(new HashMap<Object, PortAlignment>());
  protected Map<Object, PortAlignment> myPortAlignmentsEast = MapSequence.fromMap(new HashMap<Object, PortAlignment>());
  protected Map<Object, PortAlignment> myPortAlignmentsNorth = MapSequence.fromMap(new HashMap<Object, PortAlignment>());
  protected Map<Object, PortAlignment> myPortAlignmentsSouth = MapSequence.fromMap(new HashMap<Object, PortAlignment>());
  protected Map<Object, PortAlignment> myPortAlignmentsWest = MapSequence.fromMap(new HashMap<Object, PortAlignment>());
  protected Map<Object, Double> myPortSpacings = MapSequence.fromMap(new HashMap<Object, Double>());
  protected Map<Object, Boolean> myNoLayoutNodes = MapSequence.fromMap(new HashMap<Object, Boolean>());

  protected Map<Object, Boolean> myInlineEdgeLabels = MapSequence.fromMap(new HashMap<Object, Boolean>());
  protected Map<Object, EnumSet<NodeLabelPlacement>> myNodeLabelPlacements2 = MapSequence.fromMap(new HashMap<Object, EnumSet<NodeLabelPlacement>>());
  protected Map<Object, Integer> myEdgePriorities = MapSequence.fromMap(new HashMap<Object, Integer>());
  protected Map<Object, Boolean> myInsideSelfLoops = MapSequence.fromMap(new HashMap<Object, Boolean>());
  protected Map<Object, Double> myEdgeThicknesses = MapSequence.fromMap(new HashMap<Object, Double>());
  protected Map<Object, Boolean> myNoLayoutEdges = MapSequence.fromMap(new HashMap<Object, Boolean>());
  protected Map<Object, EdgeType> myEdgeTypes = MapSequence.fromMap(new HashMap<Object, EdgeType>());
  protected Map<Object, String> myFontNames = MapSequence.fromMap(new HashMap<Object, String>());
  protected Map<Object, Integer> myFontSizes = MapSequence.fromMap(new HashMap<Object, Integer>());

  protected Map<Object, KVector> myPortAnchorOffsets = MapSequence.fromMap(new HashMap<Object, KVector>());
  protected Map<Object, Double> myPortBorderOffsets = MapSequence.fromMap(new HashMap<Object, Double>());
  protected Map<Object, Integer> myPortIndices = MapSequence.fromMap(new HashMap<Object, Integer>());
  protected Map<Object, PortSide> myPortSides = MapSequence.fromMap(new HashMap<Object, PortSide>());
  protected Map<Object, Boolean> myNoLayoutPorts = MapSequence.fromMap(new HashMap<Object, Boolean>());

  protected Map<Object, Boolean> myNoLayoutLabels = MapSequence.fromMap(new HashMap<Object, Boolean>());

  public ElkLayouter() {
    this(Direction.RIGHT);
  }

  public ElkLayouter(Direction direction) {
    this(direction, false);
  }

  public ElkLayouter(Direction direction, boolean interactive) {
    if (direction != null) {
      myDirection = direction;
    }
  }

  public void toggleConnectBoxesWithoutDummyPort(boolean flag) {
    connectBoxesWithoutDummyPort = flag;
  }

  public boolean preservePortOrder(BoxDCell box) {
    return myPortReorderingDisabled || box.getBox().isPreservePortOrder();
  }

  public void setParentsStyle(Style style) {
    padding = style.get(StyleAttributes.getInstance().<ElkPadding>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-padding"));
    interactive = style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-interactive"));
    interactiveLayout = style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-interactive"));

    myHierarchyHandling = style.get(StyleAttributes.getInstance().<HierarchyHandling>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-hierarchy-handling"));
    myEdgeRouting = style.get(StyleAttributes.getInstance().<EdgeRouting>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-edge-routing"));
    myNodeSizePadding = style.get(StyleAttributes.getInstance().<ElkPadding>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-node-size-minimum-padding"));
  }

  public void addNodesStyle(Style style, Object key) {
    MapSequence.fromMap(myNodeSizeMinimum).put(key, style.get(StyleAttributes.getInstance().<KVector>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-node-size-minimum")));
    MapSequence.fromMap(myNodeSizeConstraints).put(key, style.get(StyleAttributes.getInstance().<EnumSet<SizeConstraint>>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-node-size-constraints")));
    MapSequence.fromMap(myNodeSizeOptions).put(key, style.get(StyleAttributes.getInstance().<EnumSet<SizeOptions>>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-node-size-options")));
    MapSequence.fromMap(myNodePaddings).put(key, style.get(StyleAttributes.getInstance().<ElkPadding>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-padding")));
    MapSequence.fromMap(myNodePriorities).put(key, style.get(StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-priority")));
    MapSequence.fromMap(myActivateInsideSelfLoops).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-activate-inside-self-loops")));
    MapSequence.fromMap(myAlignments).put(key, style.get(StyleAttributes.getInstance().<Alignment>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-alignment")));
    MapSequence.fromMap(myCommentBoxes).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-comment-box")));
    MapSequence.fromMap(myHierarchyHandlings).put(key, style.get(StyleAttributes.getInstance().<HierarchyHandling>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-hierarchy-handling")));
    MapSequence.fromMap(myHyperNodes).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-hypernode")));
    MapSequence.fromMap(myLayoutPartitions).put(key, style.get(StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-layout-partition")));
    MapSequence.fromMap(myMargins).put(key, style.get(StyleAttributes.getInstance().<ElkMargin>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-margins")));
    MapSequence.fromMap(myPortAlignments).put(key, style.get(StyleAttributes.getInstance().<PortAlignment>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-alignment")));
    MapSequence.fromMap(myPortAlignmentsEast).put(key, style.get(StyleAttributes.getInstance().<PortAlignment>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-alignment-east")));
    MapSequence.fromMap(myPortAlignmentsNorth).put(key, style.get(StyleAttributes.getInstance().<PortAlignment>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-alignment-north")));
    MapSequence.fromMap(myPortAlignmentsSouth).put(key, style.get(StyleAttributes.getInstance().<PortAlignment>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-alignment-south")));
    MapSequence.fromMap(myPortAlignmentsWest).put(key, style.get(StyleAttributes.getInstance().<PortAlignment>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-alignment-west")));
    MapSequence.fromMap(myPortSpacings).put(key, style.get(StyleAttributes.getInstance().<Double>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-spacing")));

    MapSequence.fromMap(myPortConstraints).put(key, style.get(StyleAttributes.getInstance().<PortConstraints>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-constraints")));
    MapSequence.fromMap(myNodeLabelPlacements).put(key, style.get(StyleAttributes.getInstance().<EnumSet<NodeLabelPlacement>>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-node-label-placement")));
    MapSequence.fromMap(myPortLabelPlacements).put(key, style.get(StyleAttributes.getInstance().<EnumSet<PortLabelPlacement>>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-label-placement")));

    MapSequence.fromMap(myNoLayoutNodes).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-no-layout")));
  }

  public void addEdgesStyle(Style style, Object key) {
    MapSequence.fromMap(myEdgePriorities).put(key, style.get(StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-priority")));
    MapSequence.fromMap(myInsideSelfLoops).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-inside-self-loop")));
    MapSequence.fromMap(myEdgeThicknesses).put(key, style.get(StyleAttributes.getInstance().<Double>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-edge-thickness")));
    MapSequence.fromMap(myNoLayoutEdges).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-no-layout")));
    MapSequence.fromMap(myEdgeTypes).put(key, style.get(StyleAttributes.getInstance().<EdgeType>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-edge-type")));
    MapSequence.fromMap(myFontNames).put(key, style.get(StyleAttributes.getInstance().<String>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-font-name")));
    MapSequence.fromMap(myFontSizes).put(key, style.get(StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-layout-font-size")));
  }

  public void addPortsStyle(Style style, Object key) {
    MapSequence.fromMap(myPortAnchorOffsets).put(key, style.get(StyleAttributes.getInstance().<KVector>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-anchor-offset")));
    MapSequence.fromMap(myPortBorderOffsets).put(key, style.get(StyleAttributes.getInstance().<Double>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-border-offset")));
    MapSequence.fromMap(myPortIndices).put(key, style.get(StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-index")));
    MapSequence.fromMap(myPortSides).put(key, style.get(StyleAttributes.getInstance().<PortSide>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-port-side")));
    MapSequence.fromMap(myNoLayoutPorts).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-no-layout")));
  }

  public void addLabelsStyle(Style style, Object key) {
    MapSequence.fromMap(myInlineEdgeLabels).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-inline-edge-labels")));
    MapSequence.fromMap(myNodeLabelPlacements2).put(key, style.get(StyleAttributes.getInstance().<EnumSet<NodeLabelPlacement>>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-node-label-placement")));
    MapSequence.fromMap(myNoLayoutLabels).put(key, style.get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram", "diagram-layout-no-layout")));
  }

  public void dontLayout(EdgeDCell edge) {
    SetSequence.fromSet(edgesNotToLayout).addElement(edge);
  }

  public void dontLayout(Iterable<EdgeDCell> edges) {
    SetSequence.fromSet(edgesNotToLayout).addSequence(Sequence.fromIterable(edges));
  }

  @Override
  public void layout(mxGraph model, @Nullable ProgressIndicator progress) {
    myGraph = model;
    if (progress != null && progress.isCanceled()) {
      return;
    }
    layoutOnce(true);
    if (progress != null && progress.isCanceled()) {
      return;
    }
    if (ApplicationManager.getApplication().isDisposed()) {
      return;
    }
    ApplicationManager.getApplication().invokeAndWait(() -> {
      myGraph.getModel().beginUpdate();
      try {
        applyPortReordering();
      } catch (Exception ex) {
        LogContext.with(ElkLayouter.class, ex, null, null).error("Layouting failed");
      } finally {
        MyGraphView view = (MyGraphView) myGraph.getView();
        view.setWasAutoLayout(true);
        myGraph.getModel().endUpdate();
      }
    });

    if (progress != null && progress.isCanceled()) {
      return;
    }
    layoutOnce(false);
    if (progress != null && progress.isCanceled()) {
      return;
    }
    ApplicationManager.getApplication().invokeAndWait(() -> {
      myGraph.getModel().beginUpdate();
      try {
        layoutToModel();
      } catch (Exception ex) {
        if (LOG_274928513.isErrorLevel()) {
          LOG_274928513.error("Layouting failed", ex);
        }
      } finally {
        MyGraphView view = (MyGraphView) myGraph.getView();
        view.setWasAutoLayout(true);
        myGraph.getModel().endUpdate();
      }
    });
  }

  protected synchronized void layoutOnce(boolean reorderPorts) {
    myPortReorderingDisabled = !(reorderPorts);
    BasicProgressMonitor monitor = new BasicProgressMonitor().withLogging(LOG.isDebugEnabled()).withLogPersistence(LOG.isDebugEnabled());
    if (LOG_274928513.isInfoLevel()) {
      LOG_274928513.info("A debug log for the diagram layouting is available at " + ((Path) ReflectionUtil.callMethod(BasicProgressMonitor.class, monitor, "retrieveLogFilePath", new Class[]{}, new Object[]{})));
    }
    ElkNode graph = buildKGraph(monitor);
    new RecursiveGraphLayoutEngine().layout(graph, monitor);
  }

  public void runPortLayouter() {
    for (BoxDCell box : SetSequence.fromSet(MapSequence.fromMap(boxesMap).keySet())) {
      PortLayouter.layoutPortCells(box);
    }
  }

  public Direction getDirection() {
    return myDirection;
  }

  /**
   * 
   * @deprecated 
   */
  @Deprecated(since = "7.2022")
  protected void doLayout(ElkNode kgraph, IElkProgressMonitor monitor) {
  }

  private Map<BaseDCell, ElkNode> dcell2knode;
  protected ElkNode buildElementIfRequired(BaseDCell dcell, IElkProgressMonitor progressMonitor) {
    ElkNode knode = MapSequence.fromMap(dcell2knode).get(dcell);
    if (knode == null) {
      knode = buildElement(dcell, progressMonitor);
      MapSequence.fromMap(dcell2knode).put(dcell, knode);
    }
    return knode;
  }

  protected ElkNode buildElement(BaseDCell dcell, IElkProgressMonitor progressMonitor) {
    ElkNode knode = ElkGraphUtil.createNode(null);
    if (dcell.getParent() instanceof BaseDCell) {
      ElkNode parent = buildElementIfRequired(((BaseDCell) dcell.getParent()), progressMonitor);
      parent.getChildren().add(knode);
    }
    if (dcell instanceof BoxDCell) {
      BoxDCell box = ((BoxDCell) dcell);
      MapSequence.fromMap(boxesMap).put(box, knode);
      BoxDCell parent = findParentBox(box);
      if (parent != null && MapSequence.fromMap(boxesMap).get(parent) != null) {
        MapSequence.fromMap(boxesMap).get(parent).getChildren().add(knode);
      }

      addLayoutInformationToNode(knode, box, progressMonitor);
      for (PortDCell port : Sequence.fromIterable(box.getPorts())) {
        MapSequence.fromMap(portsInBox).put(MultiTuple.<BoxDCell,String>from(box, port.getPort().getName()), port);
        ElkPort kport = ElkGraphUtil.createPort(knode);
        MapSequence.fromMap(portsMap).put(MultiTuple.<BoxDCell,String>from(box, port.getPort().getName()), kport);
        addLayoutInformationToPort(knode, kport, box, port, progressMonitor);
      }
      if (Sequence.fromIterable(box.getPorts()).isEmpty()) {
        createDummyPort(knode, box, true);
        createDummyPort(knode, box, false);
      }
    } else if (dcell instanceof SubDiagramDCell) {
      addLayoutInformationToSubdiagram(knode, ((SubDiagramDCell) dcell), progressMonitor);
    } else if (dcell instanceof RootDCell) {
    } else {
      throw new UnsupportedOperationException("Unknown cell type: " + dcell);
    }
    return knode;
  }

  protected BoxDCell findParentBox(BoxDCell cell) {
    mxICell currentCell = cell.getParent();
    while (currentCell instanceof BaseDCell) {
      if (currentCell instanceof BoxDCell) {
        return ((BoxDCell) currentCell);
      }
      currentCell = currentCell.getParent();
    }
    return null;
  }

  protected ElkNode buildKGraph(IElkProgressMonitor progressMonitor) {
    boxesMap = MapSequence.fromMap(new HashMap<BoxDCell, ElkNode>());
    portsMap = MapSequence.fromMap(new HashMap<Tuples._2<BoxDCell, String>, ElkPort>());
    portsInBox = MapSequence.fromMap(new HashMap<Tuples._2<BoxDCell, String>, PortDCell>());
    inputDummyPorts = MapSequence.fromMap(new HashMap<BoxDCell, ElkPort>());
    outputDummyPorts = MapSequence.fromMap(new HashMap<BoxDCell, ElkPort>());
    edgesMap = MapSequence.fromMap(new HashMap<EdgeDCell, ElkEdge>());
    labelEdgeMap = MapSequence.fromMap(new HashMap<ElkLabel, Tuples._2<EdgeDCell, EdgeLabelType>>());
    dcell2knode = MapSequence.fromMap(new HashMap<BaseDCell, ElkNode>());

    Iterable<Object> allMxCells = ((mxGraphModel) myGraph.getModel()).getCells().values();
    final Map<Box, BoxDCell> box2dcell = MapSequence.fromMap(new HashMap<Box, BoxDCell>());
    Sequence.fromIterable(allMxCells).ofType(BoxDCell.class).visitAll((it) -> MapSequence.fromMap(box2dcell).put(it.getBox(), it));

    ElkNode graph = buildElementIfRequired(((RootDCell) myGraph.getDefaultParent()), progressMonitor);
    addLayoutInformationToGraph(graph, progressMonitor);

    for (BoxDCell box : Sequence.fromIterable(allMxCells).ofType(BoxDCell.class)) {
      buildElementIfRequired(box, progressMonitor);
    }
    for (BaseDiagramDCell box : Sequence.fromIterable(allMxCells).ofType(BaseDiagramDCell.class)) {
      buildElementIfRequired(box, progressMonitor);
    }

    for (EdgeDCell edge : Sequence.fromIterable(allMxCells).ofType(EdgeDCell.class)) {
      IConnectionEndpoint_Internal resolvedEndpointFrom = check_v3bawt_a0a0t0le(edge.getEdge());
      IConnectionEndpoint_Internal resolvedEndpointTo = check_v3bawt_a0b0t0le(edge.getEdge());
      if (resolvedEndpointFrom == null || resolvedEndpointTo == null) {
        continue;
      }

      Box boxFrom_ = EndpointUtil.getBox(resolvedEndpointFrom);
      Box boxTo_ = EndpointUtil.getBox(resolvedEndpointTo);
      if (boxFrom_ == null) {
        continue;
      }
      if (boxTo_ == null) {
        continue;
      }
      BoxDCell boxFrom = MapSequence.fromMap(box2dcell).get(boxFrom_);
      BoxDCell boxTo = MapSequence.fromMap(box2dcell).get(boxTo_);
      if (boxFrom == null) {
        continue;
      }
      if (boxTo == null) {
        continue;
      }

      String portFrom = EndpointUtil.getPortName(resolvedEndpointFrom);
      String portTo = EndpointUtil.getPortName(resolvedEndpointTo);

      if (filterEdge(edge, boxFrom, boxTo)) {
        continue;
      }

      ElkNode fromKNode = MapSequence.fromMap(boxesMap).get(boxFrom);
      if (fromKNode == null) {
        continue;
      }
      ElkPort fromKPort;
      if (portFrom != null) {
        fromKPort = MapSequence.fromMap(portsMap).get(MultiTuple.<BoxDCell,String>from(boxFrom, portFrom));
        if (fromKPort == null) {
          continue;
        }
      } else {
        fromKPort = (useDummyPort(edge, false) ? MapSequence.fromMap(outputDummyPorts).get(boxFrom) : null);
      }
      ElkNode toKNode = MapSequence.fromMap(boxesMap).get(boxTo);
      if (toKNode == null) {
        continue;
      }
      ElkPort toKPort;
      if (portTo != null) {
        toKPort = MapSequence.fromMap(portsMap).get(MultiTuple.<BoxDCell,String>from(boxTo, portTo));
        if (toKPort == null) {
          continue;
        }
      } else {
        toKPort = (useDummyPort(edge, true) ? MapSequence.fromMap(inputDummyPorts).get(boxTo) : null);
      }

      ElkEdge kedge = ElkGraphUtil.createSimpleEdge((fromKPort == null ? fromKNode : fromKPort), (toKPort == null ? toKNode : toKPort));
      ElkEdgeSection edgeSection = ElkGraphUtil.firstEdgeSection(kedge, true, true);
      edgeSection.setIncomingShape((fromKPort == null ? fromKNode : fromKPort));
      if (fromKPort == null) {
        KVector position = getNodeConnectionPosition(fromKNode, true);
        edgeSection.setStartLocation(position.x, position.y);
      }
      edgeSection.setOutgoingShape((toKPort == null ? toKNode : toKPort));
      if (toKPort == null) {
        KVector position = getNodeConnectionPosition(toKNode, false);
        edgeSection.setEndLocation(position.x, position.y);
      }

      MapSequence.fromMap(edgesMap).put(edge, kedge);
      addLayoutInformationToEdge(kedge, edge, progressMonitor);

      // labels
      if (canLayoutLabels()) {
        for (EdgeLabelType type : EdgeLabelType.values()) {
          EditorCell labelCell = check_v3bawt_a0a0a0mb0t0le(edge.getEdge(), type);
          if (labelCell != null) {
            ElkLabel klabel = ElkGraphUtil.createLabel(kedge);
            MapSequence.fromMap(labelEdgeMap).put(klabel, MultiTuple.<EdgeDCell,EdgeLabelType>from(edge, type));
            addLayoutInformationToEdgeLabel(kedge, klabel, edge, type, progressMonitor);
          }
        }
      }
    }

    return graph;
  }

  protected boolean useDummyPort(EdgeDCell edge, boolean isTarget) {
    return !(connectBoxesWithoutDummyPort);
  }

  protected boolean filterEdge(@NotNull EdgeDCell edge, @NotNull BoxDCell fromBox, @NotNull BoxDCell toBox) {
    return false;
  }

  protected void addLayoutInformationToGraph(ElkNode graph, IElkProgressMonitor progressMonitor) {
    ElkNode layout = graph;
    layout.setProperty(LayeredOptions.DEBUG_MODE, true);
    layout.setProperty(CoreOptions.ALGORITHM, myAlgorithm);
    layout.setProperty(CoreOptions.HIERARCHY_HANDLING, myHierarchyHandling);
    layout.setProperty(CoreOptions.EDGE_ROUTING, myEdgeRouting);

    layout.setProperty(CoreOptions.PADDING, padding);
    layout.setProperty(CoreOptions.INTERACTIVE, interactive);
    layout.setProperty(CoreOptions.INTERACTIVE_LAYOUT, interactiveLayout);

    if (LOG.isDebugEnabled()) {
      JGraphUtil.dumpOptions(graph, "graph", progressMonitor);
    }
  }

  protected void addLayoutInformationToNode(ElkNode knode, BoxDCell box, IElkProgressMonitor progressMonitor) {
    ElkConnectableShape layout = knode;
    IAccessorKey ID = box.getBox().getAccessor().getId();
    Bounds bounds = CellExtensions.getBounds(box);
    layout.setDimensions(bounds.getWidth(), bounds.getHeight());
    layout.setLocation(bounds.getX(), bounds.getY());
    PortConstraints portConstraints = MapSequence.fromMap(myPortConstraints).get(ID);

    if (portConstraints != null) {
      layout.setProperty(LayeredOptions.PORT_CONSTRAINTS, portConstraints);
    } else if (preservePortOrder(box)) {
      layout.setProperty(LayeredOptions.PORT_CONSTRAINTS, PortConstraints.FIXED_POS);
    } else {
      layout.setProperty(LayeredOptions.PORT_CONSTRAINTS, PortConstraints.FIXED_SIDE);
      layout.setProperty(LayeredOptions.SPACING_PORT_PORT, PortLayouter.SPACE_BETWEEN_PORTS);
    }

    EnumSet<SizeConstraint> nodeSizeConstraint = MapSequence.fromMap(myNodeSizeConstraints).get(ID);
    if (nodeSizeConstraint != null) {
      layout.setProperty(LayeredOptions.NODE_SIZE_CONSTRAINTS, nodeSizeConstraint);
    } else {
      layout.setProperty(LayeredOptions.NODE_SIZE_CONSTRAINTS, EnumSet.of(SizeConstraint.PORTS));
    }

    Tuples._2<Double, Double> minSize = ListSequence.fromList(box.getMPSCells()).select((it) -> it.getMinSize()).first();
    if (minSize != null) {
      KVector nodeSizeMinimum = MapSequence.fromMap(myNodeSizeMinimum).get(ID);

      if (nodeSizeMinimum != null) {
        knode.setProperty(LayeredOptions.NODE_SIZE_MINIMUM, nodeSizeMinimum);
      } else {
        knode.setProperty(LayeredOptions.NODE_SIZE_MINIMUM, new KVector((double) minSize._0() + myNodeSizePadding.left + myNodeSizePadding.right, (double) minSize._1() + myNodeSizePadding.top + myNodeSizePadding.bottom));
      }

      if (nodeSizeConstraint != null) {
        layout.setProperty(LayeredOptions.NODE_SIZE_CONSTRAINTS, nodeSizeConstraint);
      } else {
        layout.setProperty(LayeredOptions.NODE_SIZE_CONSTRAINTS, SizeConstraint.minimumSizeWithPorts());
      }
    }

    EnumSet<SizeOptions> nodeSizeOptions = MapSequence.fromMap(myNodeSizeOptions).get(ID);
    if (nodeSizeOptions != null) {
      layout.setProperty(LayeredOptions.NODE_SIZE_OPTIONS, nodeSizeOptions);
    }

    Iterable<SubDiagramDCell> subdiagrams = ListSequence.fromList(CellExtensions.getChildren(box)).ofType(SubDiagramDCell.class);
    Bounds subdiagramBounds = Sequence.fromIterable(subdiagrams).select((it) -> CellExtensions.getBounds(it)).reduceLeft((a, b) -> ExtensionMethods.toBounds(ExtensionMethods.toRectangle2D(a).createUnion(ExtensionMethods.toRectangle2D(b))));
    ElkPadding padding = MapSequence.fromMap(myNodePaddings).get(ID);

    if (subdiagramBounds != null) {
      if (padding == null) {
        padding = myDefaultPadding;
      }
      double top = subdiagramBounds.getMinY() + padding.getTop();
      double left = subdiagramBounds.getMinX() + padding.getLeft();
      double right = bounds.getWidth() - subdiagramBounds.getMaxX() + padding.getRight();
      double bottom = bounds.getHeight() - subdiagramBounds.getMaxY() + padding.getBottom();
      ElkPadding calculatedPadding = new ElkPadding(top, right, bottom, left);
      if (top < 0 || left < 0 || right < 0 || bottom < 0) {
        if (LOG_274928513.isWarningLevel()) {
          LOG_274928513.warning("Negative padding: " + calculatedPadding);
        }
      } else {
        layout.setProperty(LayeredOptions.PADDING, calculatedPadding);
      }
    } else if (padding != null) {
      layout.setProperty(LayeredOptions.PADDING, padding);
    }

    EnumSet<NodeLabelPlacement> nodeLabelPlacement = MapSequence.fromMap(myNodeLabelPlacements).get(ID);
    if (nodeLabelPlacement != null) {
      layout.setProperty(CoreOptions.NODE_LABELS_PLACEMENT, nodeLabelPlacement);
    }

    EnumSet<PortLabelPlacement> portLabelPlacement = MapSequence.fromMap(myPortLabelPlacements).get(ID);
    if (portLabelPlacement != null) {
      layout.setProperty(CoreOptions.PORT_LABELS_PLACEMENT, portLabelPlacement);
    }

    Integer priority = MapSequence.fromMap(myNodePriorities).get(ID);
    if (priority != null) {
      layout.setProperty(CoreOptions.PRIORITY, priority);
    }

    Boolean activateInsideSelfLoops = MapSequence.fromMap(myActivateInsideSelfLoops).get(ID);
    if (activateInsideSelfLoops != null) {
      layout.setProperty(CoreOptions.INSIDE_SELF_LOOPS_ACTIVATE, activateInsideSelfLoops);
    }

    Alignment alignment = MapSequence.fromMap(myAlignments).get(ID);
    if (alignment != null) {
      layout.setProperty(CoreOptions.ALIGNMENT, alignment);
    }

    Boolean commentBox = MapSequence.fromMap(myCommentBoxes).get(ID);
    if (commentBox != null) {
      layout.setProperty(CoreOptions.COMMENT_BOX, commentBox);
    }

    HierarchyHandling hierarchyHandling = MapSequence.fromMap(myHierarchyHandlings).get(ID);
    if (hierarchyHandling != null) {
      layout.setProperty(CoreOptions.HIERARCHY_HANDLING, hierarchyHandling);
    }

    Boolean hypernode = MapSequence.fromMap(myHyperNodes).get(ID);
    if (hypernode != null) {
      layout.setProperty(CoreOptions.HYPERNODE, hypernode);
    }

    Integer layoutPartition = MapSequence.fromMap(myLayoutPartitions).get(ID);
    if (layoutPartition != null) {
      layout.setProperty(CoreOptions.PARTITIONING_PARTITION, layoutPartition);
    }

    ElkMargin margin = MapSequence.fromMap(myMargins).get(ID);
    if (margin != null) {
      layout.setProperty(CoreOptions.MARGINS, margin);
    }

    PortAlignment portAlignment = MapSequence.fromMap(myPortAlignments).get(ID);
    if (portAlignment != null) {
      layout.setProperty(CoreOptions.PORT_ALIGNMENT_DEFAULT, portAlignment);
    }

    PortAlignment portAlignmentEast = MapSequence.fromMap(myPortAlignmentsEast).get(ID);
    if (portAlignmentEast != null) {
      layout.setProperty(CoreOptions.PORT_ALIGNMENT_EAST, portAlignmentEast);
    }

    PortAlignment portAlignmentNorth = MapSequence.fromMap(myPortAlignmentsNorth).get(ID);
    if (portAlignmentNorth != null) {
      layout.setProperty(CoreOptions.PORT_ALIGNMENT_NORTH, portAlignmentNorth);
    }

    PortAlignment portAlignmentSouth = MapSequence.fromMap(myPortAlignmentsSouth).get(ID);
    if (portAlignmentSouth != null) {
      layout.setProperty(CoreOptions.PORT_ALIGNMENT_SOUTH, portAlignmentSouth);
    }

    PortAlignment portAlignmentWest = MapSequence.fromMap(myPortAlignmentsWest).get(ID);
    if (portAlignmentWest != null) {
      layout.setProperty(CoreOptions.PORT_ALIGNMENT_WEST, portAlignmentWest);
    }

    Double portSpacing = MapSequence.fromMap(myPortSpacings).get(ID);
    if (portSpacing != null) {
      layout.setProperty(CoreOptions.SPACING_PORT_PORT, portSpacing);
    }

    Boolean noLayout = MapSequence.fromMap(myNoLayoutNodes).get(ID);
    if (noLayout != null) {
      layout.setProperty(CoreOptions.NO_LAYOUT, noLayout);
    }

    if (LOG.isDebugEnabled()) {
      JGraphUtil.dumpOptions(layout, "node", progressMonitor);
    }
  }

  protected void addLayoutInformationToSubdiagram(ElkNode knode, SubDiagramDCell dcell, IElkProgressMonitor progressMonitor) {
    double d = 200.0;
    knode.setProperty(CoreOptions.NODE_SIZE_MINIMUM, new KVector(d, d));
    knode.setProperty(LayeredOptions.NODE_SIZE_MINIMUM, new KVector(d, d));

    if (LOG.isDebugEnabled()) {
      JGraphUtil.dumpOptions(knode, "subdiagram", progressMonitor);
    }
  }

  protected KVector getNodeConnectionPosition(ElkNode knode, boolean input) {
    KVector east = new KVector(knode.getX() + knode.getWidth(), knode.getY() + knode.getHeight() / 2);
    KVector west = new KVector(knode.getX(), knode.getY() + knode.getHeight() / 2);
    KVector north = new KVector(knode.getX() + knode.getWidth() / 2, knode.getY());
    KVector south = new KVector(knode.getX() + knode.getWidth() / 2, knode.getY() + knode.getHeight());

    switch (myDirection) {
      case UNDEFINED:
      case RIGHT:
        return (input ? east : west);

      case LEFT:
        return (input ? west : east);

      case DOWN:
        return (input ? north : south);

      case UP:
        return (input ? south : north);
      default:
        throw new RuntimeException("Unknown direction: " + myDirection);
    }
  }

  protected void createDummyPort(ElkNode knode, BoxDCell node, boolean input) {
    Bounds bounds = CellExtensions.getBounds(node);
    ElkPort dummyPort = ElkGraphUtil.createPort(knode);
    ElkConnectableShape dummyLayout = dummyPort;
    dummyLayout.setDimensions(0.0001, 0.0001);
    dummyLayout.setLocation((bounds.getWidth() / 2), (bounds.getHeight() / 2));
    switch (myDirection) {
      case UNDEFINED:
      case RIGHT:
        dummyLayout.setProperty(LayeredOptions.PORT_SIDE, (input ? PortSide.WEST : PortSide.EAST));
        break;
      case LEFT:
        dummyLayout.setProperty(LayeredOptions.PORT_SIDE, (input ? PortSide.EAST : PortSide.WEST));
        break;
      case DOWN:
        dummyLayout.setProperty(LayeredOptions.PORT_SIDE, (input ? PortSide.NORTH : PortSide.SOUTH));
        break;
      case UP:
        dummyLayout.setProperty(LayeredOptions.PORT_SIDE, (input ? PortSide.SOUTH : PortSide.NORTH));
        break;
      default:
        throw new RuntimeException("Unknown direction: " + myDirection);
    }
    if (input) {
      MapSequence.fromMap(inputDummyPorts).put(node, dummyPort);
    } else {
      MapSequence.fromMap(outputDummyPorts).put(node, dummyPort);
    }
  }

  protected void addLayoutInformationToPort(ElkNode knode, ElkPort kport, BoxDCell node, PortDCell port, IElkProgressMonitor progressMonitor) {
    ElkConnectableShape layout = kport;
    IAccessorKey ID = node.getBox().getAccessor().getId();
    layout.setProperty(LayeredOptions.PORT_SIDE, getPortSide(port.getPort().getTransformedRelativeX(), port.getPort().getTransformedRelativeY()));
    Bounds bounds = CellExtensions.getBounds(port);
    layout.setDimensions(bounds.getWidth(), bounds.getHeight());
    layout.setX(bounds.getX());
    layout.setY(bounds.getY());

    KVector anchorOffset = MapSequence.fromMap(myPortAnchorOffsets).get(ID);
    if (anchorOffset != null) {
      layout.setProperty(CoreOptions.PORT_ANCHOR, anchorOffset);
    }

    Double borderOffset = MapSequence.fromMap(myPortBorderOffsets).get(ID);
    if (borderOffset != null) {
      layout.setProperty(CoreOptions.PORT_BORDER_OFFSET, borderOffset);
    }

    Integer index = MapSequence.fromMap(myPortIndices).get(ID);
    if (index != null) {
      layout.setProperty(CoreOptions.PORT_INDEX, index);
    }

    PortSide side = MapSequence.fromMap(myPortSides).get(ID);
    if (side != null) {
      layout.setProperty(CoreOptions.PORT_SIDE, side);
    }

    Boolean noLayout = MapSequence.fromMap(myNoLayoutPorts).get(ID);
    if (noLayout != null) {
      layout.setProperty(CoreOptions.NO_LAYOUT, noLayout);
    }

    if (LOG.isDebugEnabled()) {
      JGraphUtil.dumpOptions(layout, "port", progressMonitor);
    }
  }

  protected void addLayoutInformationToEdge(ElkEdge kedge, EdgeDCell edge, IElkProgressMonitor progressMonitor) {
    IAccessorKey ID = edge.getEdge().getAccessor().getId();

    if (SetSequence.fromSet(edgesNotToLayout).contains(edge)) {
      kedge.setProperty(ElkCustomLayoutOptions.DISABLE_ROUTING, true);
    }

    Integer priority = MapSequence.fromMap(myEdgePriorities).get(ID);
    if (priority != null) {
      kedge.setProperty(CoreOptions.PRIORITY, priority);
    }

    Boolean insideSelfLoop = MapSequence.fromMap(myInsideSelfLoops).get(ID);
    if (insideSelfLoop != null) {
      kedge.setProperty(CoreOptions.INSIDE_SELF_LOOPS_YO, insideSelfLoop);
    }

    Double edgeThickness = MapSequence.fromMap(myEdgeThicknesses).get(ID);
    if (edgeThickness != null) {
      kedge.setProperty(CoreOptions.EDGE_THICKNESS, edgeThickness);
    }

    Boolean noLayout = MapSequence.fromMap(myNoLayoutEdges).get(ID);
    if (noLayout != null) {
      kedge.setProperty(CoreOptions.NO_LAYOUT, noLayout);
    }

    EdgeType edgeType = MapSequence.fromMap(myEdgeTypes).get(ID);
    if (edgeType != null) {
      kedge.setProperty(CoreOptions.EDGE_TYPE, edgeType);
    }

    String fontName = MapSequence.fromMap(myFontNames).get(ID);
    if (fontName != null) {
      kedge.setProperty(CoreOptions.FONT_NAME, fontName);
    }

    Integer fontSize = MapSequence.fromMap(myFontSizes).get(ID);
    if (fontSize != null) {
      kedge.setProperty(CoreOptions.FONT_SIZE, fontSize);
    }

    if (LOG.isDebugEnabled()) {
      JGraphUtil.dumpOptions(kedge, "edge", progressMonitor);
    }
  }
  protected void addLayoutInformationToEdgeLabel(ElkEdge kedge, ElkLabel klabel, EdgeDCell edge, EdgeLabelType type, IElkProgressMonitor progressMonitor) {
    IAccessorKey ID = edge.getEdge().getAccessor().getId();
    EditorCell labelCell = check_v3bawt_a0b0ef(edge.getEdge(), type);
    LabelDCell labelDCell = edge.getLabelCell(type);
    if (labelCell == null || labelDCell == null) {
      return;
    }

    // Labels without text are not layouted
    klabel.setText("L");

    Bounds labelBounds = CellExtensions.getBounds(labelDCell);

    ElkShape layout = klabel;
    layout.setDimensions(labelBounds.getWidth(), labelBounds.getHeight());

    layout.setX(labelBounds.getX());
    layout.setY(labelBounds.getY());
    layout.setProperty(CoreOptions.EDGE_LABELS_PLACEMENT, toLabelPlacement(type));

    Boolean inlineEdgeLabels = MapSequence.fromMap(myInlineEdgeLabels).get(ID);
    if (inlineEdgeLabels != null) {
      layout.setProperty(CoreOptions.EDGE_LABELS_INLINE, inlineEdgeLabels);
    }

    EnumSet<NodeLabelPlacement> nodeLabelPlacement = MapSequence.fromMap(myNodeLabelPlacements2).get(ID);
    if (nodeLabelPlacement != null) {
      layout.setProperty(CoreOptions.NODE_LABELS_PLACEMENT, nodeLabelPlacement);
    }

    Boolean noLayout = MapSequence.fromMap(myNoLayoutLabels).get(ID);
    if (noLayout != null) {
      layout.setProperty(CoreOptions.NO_LAYOUT, noLayout);
    }

    if (LOG.isDebugEnabled()) {
      JGraphUtil.dumpOptions(kedge, "edge label", progressMonitor);
    }
  }

  protected PortSide getPortSide(double relativeX, double relativeY) {
    if (Math.abs(relativeX - 0.0) < 0.001) {
      return PortSide.WEST;
    }
    if (Math.abs(relativeX - 1.0) < 0.001) {
      return PortSide.EAST;
    }
    if (Math.abs(relativeY - 0.0) < 0.001) {
      return PortSide.NORTH;
    }
    if (Math.abs(relativeY - 1.0) < 0.001) {
      return PortSide.SOUTH;
    }
    return PortSide.UNDEFINED;
  }

  protected synchronized void applyPortReordering() {
    if (myWriteBackNodes) {
      Set<BoxDCell> boxesWithPorts = SetSequence.fromSet(new HashSet<BoxDCell>());
      for (IMapping<Tuples._2<BoxDCell, String>, ElkPort> entry : MapSequence.fromMap(portsMap)) {
        BoxDCell box = entry.key()._0();
        if (preservePortOrder(box)) {
          continue;
        }

        SetSequence.fromSet(boxesWithPorts).addElement(box);
        ElkPort kport = entry.value();
        PortDCell port = MapSequence.fromMap(portsInBox).get(entry.key());

        ElkShape layoutData = kport;
        double centerX = layoutData.getX() + CellExtensions.getBounds(port).getWidth() / 2;
        double centerY = layoutData.getY() + CellExtensions.getBounds(port).getHeight() / 2;
        double relX = centerX / CellExtensions.getBounds(box).getWidth();
        double relY = centerY / CellExtensions.getBounds(box).getHeight();
        relX = Math.min(Math.max(0.0, relX), 1.0);
        relY = Math.min(Math.max(0.0, relY), 1.0);
        port.getPort().setOrdinal((int) ((relX + relY) * (Integer.MAX_VALUE / 2)));
      }

      for (BoxDCell box : SetSequence.fromSet(boxesWithPorts)) {
        PortLayouter.layoutPortCells(box);
      }
    }
  }

  protected synchronized void layoutToModel() {
    if (myWriteBackNodes) {
      for (IMapping<BoxDCell, ElkNode> entry : MapSequence.fromMap(boxesMap)) {
        BoxDCell box = entry.key();
        ElkNode knode = entry.value();
        ElkNode layoutData = knode;
        Bounds bounds = new Bounds(layoutData.getX() - getXOffset(box), layoutData.getY() - getYOffset(box), layoutData.getWidth(), layoutData.getHeight());
        CellExtensions.setBounds(box, bounds);
      }
    }

    if (myWriteBackEdges) {
      for (IMapping<EdgeDCell, ElkEdge> entry : MapSequence.fromMap(edgesMap)) {
        EdgeDCell edge = entry.key();
        if (SetSequence.fromSet(edgesNotToLayout).contains(edge)) {
          continue;
        }
        ElkEdge kedge = entry.value();
        List<mxPoint> points = new ArrayList<mxPoint>();
        if (kedge.getSections().size() > 1) {
          throw new RuntimeException("Edge has " + kedge.getSections().size() + " sections");
        }
        for (ElkBendPoint bendPoint : ListSequence.fromList(kedge.getSections().get(0).getBendPoints())) {
          points.add(new mxPoint(bendPoint.getX() - getXOffset(edge), bendPoint.getY() - getYOffset(edge)));
        }
        edge.getGeometry().setPoints(points);
      }

      for (IMapping<ElkLabel, Tuples._2<EdgeDCell, EdgeLabelType>> entry : MapSequence.fromMap(labelEdgeMap)) {
        EdgeDCell edge = null;
        ElkLabel klabel = entry.key();
        EdgeLabelType type = null;
        {
          Tuples._2<EdgeDCell, EdgeLabelType> _tmp_v3bawt_d0c0c0kf = entry.value();
          edge = _tmp_v3bawt_d0c0c0kf._0();
          type = _tmp_v3bawt_d0c0c0kf._1();
        }
        LabelDCell labelDCell = edge.getLabelCell(type);

        // There is a bug for labels of loop edges
        boolean isLoop = edge.getEdge().getResolvedEndpointFrom() == edge.getEdge().getResolvedEndpointTo();

        if (canLayoutLabels() && !(isLoop)) {
          CellExtensions.setPosition(labelDCell, klabel.getX() - getXOffset(labelDCell), klabel.getY() - getYOffset(labelDCell));
        }
      }
    }
  }

  private double getXOffset(BaseDCell cell) {
    mxICell currentCell = cell.getParent();
    while (currentCell instanceof BaseDCell) {
      if (currentCell instanceof SubDiagramDCell) {
        return CellExtensions.getBounds(currentCell).getX();
      }
      currentCell = currentCell.getParent();
    }
    return 0.0;
  }
  private double getYOffset(BaseDCell cell) {
    mxICell currentCell = cell.getParent();
    while (currentCell instanceof BaseDCell) {
      if (currentCell instanceof SubDiagramDCell) {
        return CellExtensions.getBounds(currentCell).getY();
      }
      currentCell = currentCell.getParent();
    }
    return 0.0;
  }
  private static IConnectionEndpoint_Internal check_v3bawt_a0a0t0le(Edge checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getResolvedEndpointFrom();
    }
    return null;
  }
  private static IConnectionEndpoint_Internal check_v3bawt_a0b0t0le(Edge checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getResolvedEndpointTo();
    }
    return null;
  }
  private static EditorCell check_v3bawt_a0a0a0mb0t0le(Edge checkedDotOperand, EdgeLabelType type) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLabelCell(type);
    }
    return null;
  }
  private static EditorCell check_v3bawt_a0b0ef(Edge checkedDotOperand, EdgeLabelType type) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLabelCell(type);
    }
    return null;
  }
}

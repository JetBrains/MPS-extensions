package de.itemis.mps.modelmerger.runtime.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SConcept;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class ModelMerger {

  private static SModel mdlSource;
  /**
   * nodeMap provides a map of nodes from imported model to the original model in order to handle reference resolutions after merging
   */
  private static HashMap<SNode, SNode> nodeMap;

  /**
   * 
   * @author For typical usage, look at basicTests inside tests.de.itemis.mps.modelmerger
   * @param mdlSrc Original Model
   * @param mdlDest Imported Model
   * @param identityCalculatorReg Points to the classes implementing the IdentityCalculator Interface. This is generally obtained from the extensions generated by the IdentityCalculatorRegistry node
   */
  public static void matchModelsInto(final SModel mdlSrc, final SModel mdlDest, final Map<SConcept, IdentityCalculator> identityCalculatorReg) {
    mdlSource = mdlSrc;
    nodeMap = new HashMap<SNode, SNode>();
    mdlSrc.getRepository().getModelAccess().runWriteAction(() -> {
      List<SNode> nodesToRemove = new ArrayList<SNode>();

      // Case when a root node in the source  does not exist in the destination it needs to be removed from the source
      for (SNode rootNodeSrc : ListSequence.fromList(SModelOperations.roots(mdlSrc, null))) {
        SNode correspondingNode = findNodeIn(rootNodeSrc, SModelOperations.roots(mdlDest, null), identityCalculatorReg);
        if (correspondingNode == null) {
          nodesToRemove.add(rootNodeSrc);
        } else {
          nodeMap.put(correspondingNode, rootNodeSrc);
          matchInto(rootNodeSrc, correspondingNode, identityCalculatorReg);
        }
      }
      for (SNode nodeToRemove : ListSequence.fromList(nodesToRemove)) {
        SNodeOperations.deleteNode(((SNode) nodeToRemove));
      }

      for (SNode rootNodeDest : ListSequence.fromList(SModelOperations.roots(mdlDest, null))) {
        SNode correspondingNode = findNodeIn(rootNodeDest, SModelOperations.roots(mdlSrc, null), identityCalculatorReg);
        if (correspondingNode == null) {
          // Case when a node in the destination is not present in the source, it needs to be considered as to be added o the source
          SNode destCopy = SNodeOperations.copyNode(rootNodeDest);
          nodeMap.put(rootNodeDest, destCopy);
          SModelOperations.addRootNode(mdlSrc, destCopy);
        }
      }

      // Resolving the node references once the map is ready
      ListSequence.fromList(SModelOperations.nodes(mdlSrc, null)).visitAll((nodeSrc) -> {
        for (SReference ref : Sequence.fromIterable(nodeSrc.getReferences())) {
          if (nodeMap.containsKey(ref.getTargetNode())) {
            nodeSrc.setReferenceTarget(ref.getLink(), nodeMap.get(ref.getTargetNode()));
          }
        }
      });
    });

  }


  private static void matchInto(SNode origNode, SNode importedNode, Map<SConcept, IdentityCalculator> identityCalculatorReg) {
    // Same as above mentioned matchModelsInto but for nodes. For usage refer to matchModelsInto

    // matching properties
    ModelMerger.matchProperties(origNode, importedNode);

    // matching references
    ModelMerger.matchReferences(origNode, importedNode, identityCalculatorReg);

    // matching children
    ModelMerger.matchChildren(origNode, importedNode, identityCalculatorReg);

  }

  private static void matchChildren(SNode origNode, SNode importedNode, Map<SConcept, IdentityCalculator> identityCalculatorReg) {
    List<SNode> childrenToRemove = new ArrayList<SNode>();

    // Case when a node in the source does not exist in the destination it needs to be removed from the source
    for (SNode origNodeChild : Sequence.fromIterable(origNode.getChildren())) {
      SNode correspondingRoot = findNodeIn(origNodeChild, importedNode.getChildren(), identityCalculatorReg);
      if (correspondingRoot == null) {
        childrenToRemove.add(origNodeChild);
      } else {
        nodeMap.put(correspondingRoot, origNodeChild);
        matchInto(origNodeChild, correspondingRoot, identityCalculatorReg);
      }
    }
    for (SNode nodeToRemove : ListSequence.fromList(childrenToRemove)) {
      SNodeOperations.deleteNode(((SNode) nodeToRemove));
    }

    // Find whether there is any matching imported node in the original node, used for an edge case in the insertion later
    boolean hasMatchInOrigNode = false;
    for (SNode importedNodeChild : Sequence.fromIterable(importedNode.getChildren())) {
      if (findNodeIn(importedNodeChild, origNode.getChildren(), identityCalculatorReg) != null) {
        hasMatchInOrigNode = true;
        break;
      }
    }

    // Case when a node in the destination is not present in the source, it needs to be added to the source
    SNode lastMatchInOrigNode = null;
    // The lastMatchInOrigNode is an anchor to the node in the source that was the last found match.
    // This helps ensure that insertions of node from the model being merged from happens at the correct position
    for (SNode importedNodeChild : Sequence.fromIterable(importedNode.getChildren())) {
      SContainmentLink childContainmentLink = importedNodeChild.getContainmentLink();
      if (childContainmentLink == null) {
        throw new IllegalStateException("Child Containment link cannot be null");
      }

      SNode correspondingNode = findNodeIn(importedNodeChild, origNode.getChildren(), identityCalculatorReg);
      if (correspondingNode == null) {
        SNode importedChildAsNode = importedNodeChild;
        SNode copy = SNodeOperations.copyNode(importedChildAsNode);
        nodeMap.put(importedChildAsNode, copy);
        if (lastMatchInOrigNode != null) {
          origNode.insertChildAfter(childContainmentLink, copy, lastMatchInOrigNode);
        } else {
          // If lastMatchInOriginNode is null, then no match was found/copy was made before. The correspondingNode was 
          // null too, so if there are any matching nodes, this must be before the first matching node.
          if (hasMatchInOrigNode) {
            SNode firstChildInOrigNode = origNode.getChildren().iterator().next();
            origNode.insertChildBefore(childContainmentLink, copy, firstChildInOrigNode);
          } else {
            // Add it to the end of the merged children list
            origNode.addChild(childContainmentLink, copy);
          }
        }
        lastMatchInOrigNode = copy;
      } else {
        lastMatchInOrigNode = correspondingNode;
      }
    }
  }

  private static void matchReferences(SNode origNode, SNode importedNode, Map<SConcept, IdentityCalculator> identityCalculatorReg) {
    for (SReference origRef : Sequence.fromIterable(origNode.getReferences())) {
      boolean correspondingRefFound = isReferenceTargetIn(origRef, origNode, importedNode, importedNode.getReferences(), identityCalculatorReg);
      if (!(correspondingRefFound)) {
        origNode.setReference(origRef.getLink(), (SReference) null);
      }
    }

    for (SReference importedRef : Sequence.fromIterable(importedNode.getReferences())) {
      boolean correspondingRefFound = isReferenceTargetIn(importedRef, importedNode, origNode, origNode.getReferences(), identityCalculatorReg);
      if (!(correspondingRefFound)) {
        origNode.setReferenceTarget(findRefLink(origNode, importedRef), findNodeIn(importedRef.getTargetNode(), SModelOperations.nodes(mdlSource, null), identityCalculatorReg));
      }
    }
  }

  private static void matchProperties(SNode origNode, SNode importedNode) {
    // Equality of property is defined as the properties having the same name and the same owning concept.
    for (SProperty origProperty : CollectionSequence.fromCollection(origNode.getConcept().getProperties())) {
      SProperty importedProperty = findPropertyIn(origProperty, importedNode.getConcept().getProperties());
      if (importedProperty != null) {
        String importedPropertyVal = importedNode.getProperty(importedProperty);
        if (!(Objects.equals(origNode.getProperty(origProperty), importedPropertyVal))) {
          origNode.setProperty(origProperty, importedPropertyVal);
        }
      } else {
        origNode.setProperty(origProperty, null);
      }
    }

    for (SProperty importedProperty : CollectionSequence.fromCollection(importedNode.getConcept().getProperties())) {
      SProperty origProperty = findPropertyIn(importedProperty, origNode.getConcept().getProperties());
      String importedPropertyVal = importedNode.getProperty(importedProperty);
      if (origProperty == null) {
        origNode.setProperty(importedProperty, importedPropertyVal);
      }
    }
  }

  private static SNode findNodeIn(SNode nodToFind, Iterable<? extends SNode> nodeList, Map<SConcept, IdentityCalculator> identityCalculatorReg) {
    for (SNode nd : Sequence.fromIterable(nodeList)) {
      IdentityCalculator identityCalc = identityCalculatorReg.get(nodToFind.getConcept());
      if (Objects.equals(nd.getConcept(), nodToFind.getConcept())) {
        if (identityCalc != null) {
          if (Objects.equals(identityCalc.getIdentity(nd), identityCalc.getIdentity(nodToFind))) {
            return nd;
          }

        }
      }
    }
    return null;
  }

  private static SProperty findPropertyIn(SProperty propToFind, Iterable<SProperty> properties) {
    // TODO: Should we have a more sophisticated logic to decide if properties are equal??
    for (SProperty prop : Sequence.fromIterable(properties)) {
      if (Objects.equals(propToFind.getName(), prop.getName()) && Objects.equals(prop.getOwner(), propToFind.getOwner())) {
        return prop;
      }
    }
    return null;
  }

  private static boolean isReferenceTargetIn(SReference refToFind, SNode origNode, SNode destNode, Iterable<? extends SReference> refs, Map<SConcept, IdentityCalculator> identityCalculatorReg) {
    // Returns true if refToFind from origNode is available in destNode, with refs representing the universe of references to search from.
    SNode origTarget = origNode.getReferenceTarget(refToFind.getLink());
    for (SReference ref : Sequence.fromIterable(refs)) {
      SNode destTarget = destNode.getReferenceTarget(ref.getLink());
      if (destTarget != null && origTarget != null) {
        if (Objects.equals(origTarget.getConcept(), destTarget.getConcept())) {
          IdentityCalculator identityCalc = identityCalculatorReg.get(destTarget.getConcept());
          if (identityCalc != null) {
            if (Objects.equals(identityCalc.getIdentity(origTarget), identityCalc.getIdentity(destTarget))) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }

  private static SReferenceLink findRefLink(SNode origNode, SReference refToFind) {
    for (SReferenceLink origRefLink : CollectionSequence.fromCollection(origNode.getConcept().getReferenceLinks())) {
      if (Objects.equals(origRefLink, refToFind.getLink())) {
        return origRefLink;
      }
    }
    return null;
  }
}

package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSideTransformTransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.util.PatternUtil;
import jetbrains.mps.openapi.editor.menus.transformation.ActionItem;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public abstract class MultiTextActionItem extends GrammarCellsSideTransformTransformationMenuItem {

  private Iterable<String> myMatchingTexts;
  private TransformationMenuContext myContext;

  public MultiTextActionItem(Iterable<String> matchingTexts, TransformationMenuContext context) {
    super(context);
    myMatchingTexts = Sequence.fromIterable(matchingTexts).sort((a, b) -> check_yppa47_a0a0a0a0b0e(a) - b.length(), true);
    myContext = context;
  }

  @Nullable
  @Override
  public String getShortDescriptionText(@NotNull String pattern) {
    String description = getOutputConcept().getShortDescription();
    return ((description != null && description.length() > 0) ? description : getOutputConcept().getName());
  }

  public String getMatchingText(String pattern) {
    return getBestMatchingText(pattern);
  }

  protected String getBestMatchingText(String pattern) {
    if (Sequence.fromIterable(myMatchingTexts).isEmpty()) {
      return null;
    }
    if (Sequence.fromIterable(myMatchingTexts).count() == 1) {
      return Sequence.fromIterable(myMatchingTexts).first();
    }
    if ((pattern != null && pattern.length() > 0)) {
      for (String matchingText : myMatchingTexts) {
        if (matchingText.charAt(0) != pattern.charAt(0)) {
          continue;
        }
        if (matchingText.startsWith(pattern)) {
          return matchingText;
        }
        if (matchingText.matches(PatternUtil.getExactItemPatternBuilder(pattern, false, false).toString() + ".*")) {
          return matchingText;
        }
      }
    }
    return Sequence.fromIterable(myMatchingTexts).first();
  }

  public Iterable<ActionItem> getMultipleActions() {
    return Sequence.fromIterable(myMatchingTexts).select((it) -> {
      ActionItem action = new SingleAction(it);
      return action;
    });
  }

  public Iterable<ActionItem> getMultipleOrSingleAction(boolean multiple) {
    return (multiple ? getMultipleActions() : Sequence.<ActionItem>singleton(this));
  }

  public class SingleAction extends GrammarCellsSideTransformTransformationMenuItem {
    private String myMatchingText;
    public SingleAction(String matchingText) {
      super(myContext);
      myMatchingText = matchingText;
    }
    public String getMatchingText(String pattern) {
      return myMatchingText;
    }
    public String getDescriptionText(String string) {
      return MultiTextActionItem.this.getShortDescriptionText(myMatchingText);
    }
    @Override
    public void execute(@NotNull String pattern) {
      MultiTextActionItem.this.execute(myMatchingText);
    }
    @Override
    public SAbstractConcept getOutputConcept() {
      return MultiTextActionItem.this.getOutputConcept();
    }
  }
  private static int check_yppa47_a0a0a0a0b0e(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.length();
    }
    return 0;
  }
}

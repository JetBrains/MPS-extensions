package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.modelapi.behavior.ModelIdentity__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.generator.impl.CloneUtil;
import java.util.Collection;
import com.google.common.collect.Lists;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ModelMergingRunner {

  /**
   * Merges left and right model according to modelMerge into resultModel
   * 
   * @param resultModel resultModel
   * @param modelMerge modelMerge
   * @param left left
   * @param right right
   */
  public static void run(SModel resultModel, SNode modelMerge, SNode left, SNode right) {
    SModel smodelL = resolveModel(modelMerge, left);
    SModel smodelR = resolveModel(modelMerge, right);

    ModelMergingRunner.run(smodelL, smodelR, modelMerge, resultModel);
  }

  private static SModel resolveModel(SNode modelMerge, SNode left) {
    SRepository repository = modelMerge.getModel().getRepository();
    return ModelIdentity__BehaviorDescriptor.toModelReference_id1Bs_61$mvvu.invoke((SLinkOperations.getTarget(left, LINKS.modelRef$l8tE))).resolve(repository);
  }

  public static void runLeftMerge(SNode left, SNode right, SNode modelMerge) {
    ModelMergingRunner.runLeftMerge(resolveModel(modelMerge, left), resolveModel(modelMerge, right), modelMerge);
  }

  public static void runLeftMerge(SModel leftModel, SModel rightModel, SNode modelMerge) {
    SModel mergedModel = ModelMergingRunner.run(modelMerge, leftModel, rightModel);
    for (SNode delNode : ListSequence.fromList(SModelOperations.nodes(leftModel, null))) {
      SNodeOperations.deleteNode(delNode);
    }
    new CloneUtil(mergedModel, leftModel).cloneModelWithImports();
  }

  public static void run(SModel smodelL, SModel smodelR, SNode modelMerge, SModel resultModel) {
    Collection<SNode> leftRootNodes = Lists.newLinkedList(smodelL.getRootNodes());
    Collection<SNode> rightRootNodes = Lists.newLinkedList(smodelR.getRootNodes());

    List<MergedNode> mergedNodes = Sequence.fromIterable((Sequence.fromIterable(ModelMerger.create(modelMerge).merge(leftRootNodes, rightRootNodes)).distinct())).toList();

    for (MergedNode r : ListSequence.fromList(mergedNodes).distinct()) {
      SModelOperations.addRootNode(resultModel, r.node);
    }
  }

  /**
   * Merges the two given models according to modelMerge
   * 
   * @param modelMerge modelMerge
   * @param left left model
   * @param right right model
   * @return a temporary model 
   */
  public static SModel run(SNode modelMerge, SModel left, SModel right) {
    SModel model = TemporaryModels.getInstance().createEditable(false, TempModuleOptions.forDefaultModule());
    run(left, right, modelMerge, model);
    return model;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink modelRef$l8tE = MetaAdapterFactory.getContainmentLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x19dc9460645cfdd7L, 0x19dc9460645d0827L, "modelRef");
  }
}

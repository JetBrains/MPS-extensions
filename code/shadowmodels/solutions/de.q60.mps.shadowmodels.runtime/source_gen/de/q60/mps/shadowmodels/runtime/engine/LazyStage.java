package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;

public class LazyStage implements ISubgraphStage {
  private ITransformationEngine engine;
  private ILazyStageRef stageRef;

  public LazyStage(ITransformationEngine engine, ILazyStageRef stageRef) {
    this.engine = engine;
    this.stageRef = stageRef;
  }

  @Override
  public IStageReference getStageReference() {
    return stageRef;
  }
  @Override
  public IStageReference getPreviousStageRef() {
    return null;
  }
  @Override
  public IScope getOwnScope() {
    return new StageScope(stageRef);
  }
  @Override
  public <T extends IContainmentTarget> IUniqueContainmentTarget<T> makeUnique(@Nullable IScope scope, T target) {
    if (scope == null) {
      scope = getOwnScope();
    }
    LazyContainmentTarget<T> unique = new LazyContainmentTarget<T>(target);
    return new UniqueTargetInScope<T>(scope, unique);
  }
  @Override
  public void registerContent(IUniqueContainmentTarget call, @Nullable ITransformationResult tresult, @Nullable IContainment containment) {
    throw new UnsupportedOperationException();
  }
  @Override
  public void registerWeaving(IWeaving weaving) {
    throw new UnsupportedOperationException();
  }
  @Override
  public void registerRewriteReplacement(IUniqueContainmentTarget<RewriteCall> rewriteCall, IUniqueContainmentTarget replacement) {
    throw new UnsupportedOperationException();
  }
  @Override
  public IOutputNodeReference resolveWeavingTarget(IScope sourceScope, IReferenceTarget target) {
    throw new UnsupportedOperationException();
  }
  @Nullable
  @Override
  public Iterable<IOutputNodeReference> resolveContainmentTarget(IUniqueContainmentTarget target) {
    if (target.getTarget() instanceof TransformationCall) {
      return engine.execute(stageRef, target).getRootNodes();
    } else if (target.getTarget() instanceof RewriteCall) {
      UniqueTargetInScope<CopyCall> scope = new UniqueTargetInScope(getOwnScope(), new LazyContainmentTarget<CopyCall>(((RewriteCall) target.getTarget()).toCopyCall()));
      return Sequence.<IOutputNodeReference>singleton(new CopiedOutputNodeReference(stageRef, scope));
    } else if (target.getTarget() instanceof CopyCall) {
      return Sequence.<IOutputNodeReference>singleton(new CopiedOutputNodeReference(stageRef, (IUniqueContainmentTarget<CopyCall>) target));
    } else {
      throw new RuntimeException("Unsupported: " + target.getTarget());
    }
  }
  @Override
  public IContainment resolveContainment(IOutputNodeReference child) {
    return null;
  }
  @Override
  public IContainment resolveContainment(IUniqueContainmentTarget child) {
    return null;
  }
  @Override
  public ITransformationResult getTransformationResult(IUniqueContainmentTarget<TransformationCall> call) {
    return engine.execute(stageRef, call);
  }
  @Override
  public boolean hasPendingWeavings() {
    throw new UnsupportedOperationException();
  }
  @Override
  public Iterable<IWeaving> getPendingWeavings() {
    throw new UnsupportedOperationException();
  }
  @Override
  public void clearPendingWeavings() {
    throw new UnsupportedOperationException();
  }
  @Override
  public boolean hasAnyTransformationsApplied() {
    throw new UnsupportedOperationException();
  }
  @Override
  public Iterable<IUniqueContainmentTarget> getRoots() {
    throw new UnsupportedOperationException();
  }
  @Override
  public ITransformationEngine getEngine() {
    return engine;
  }
  @Override
  public Iterable<IUniqueContainmentTarget> resolveContent(IContainmentTarget target) {
    if (stageRef.allowLazyReferenceTargets()) {
      return Sequence.<IUniqueContainmentTarget>singleton(new UniqueTargetInScope(getOwnScope(), new LazyContainmentTarget(target)));
    } else {
      return Sequence.fromIterable(Collections.<IUniqueContainmentTarget>emptyList());
    }
  }
  @Override
  public Iterable<MappingLabels> getMappingLabels() {
    return Sequence.fromIterable(Collections.<MappingLabels>emptyList());
  }

  @Override
  public Iterable<ScopeImport> getDeclaredImports() {
    return Sequence.fromIterable(Collections.<ScopeImport>emptyList());
  }
}

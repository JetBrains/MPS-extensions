package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.google.common.collect.Multimap;
import com.google.common.collect.MultimapBuilder;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Objects;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Indent;
import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.mxgraph.view.mxCellState;
import com.mxgraph.view.mxGraph;

public class LayoutDependencies {
  private static final Logger LOG = Logger.getLogger(LayoutDependencies.class);

  private static final Map<EditorComponent, LayoutDependencies> ourInstances = MapSequence.fromMap(new HashMap<EditorComponent, LayoutDependencies>());

  public static LayoutDependencies getInstance(EditorComponent editorComponent) {
    // No synchronization/locks required for editor code
    ThreadUtils.assertEDT();
    if (editorComponent.isDisposed()) {
      throw new IllegalStateException("Editor is already disposed");
    }

    LayoutDependencies instance = MapSequence.fromMap(ourInstances).get(editorComponent);
    if (instance == null) {
      instance = new LayoutDependencies();
      ((jetbrains.mps.nodeEditor.EditorComponent) editorComponent).addDisposeListener((e) -> MapSequence.fromMap(ourInstances).removeKey(e));
      MapSequence.fromMap(ourInstances).put(editorComponent, instance);
    }
    return instance;
  }

  public static LayoutDependencies getInstance(EditorCell cell) {
    return getInstance(cell.getEditorComponent());
  }

  public static void cleanInstances() {
    ListSequence.fromList(SetSequence.fromSet(MapSequence.fromMap(ourInstances).keySet()).where((it) -> it.isDisposed()).toList()).visitAll((it) -> MapSequence.fromMap(ourInstances).removeKey(it));
  }

  private Multimap<Layoutable, DependencyAndValue> dependencies = MultimapBuilder.hashKeys().arrayListValues().<Layoutable,DependencyAndValue>build();
  private Layoutable currentEvaluation = null;

  public LayoutDependencies() {
  }

  public void layoutAndRecordDependencies(Layoutable layoutable) {
    Layoutable prevEval = currentEvaluation;
    try {
      currentEvaluation = layoutable;
      dependencies.removeAll(layoutable);
      layoutable.layout();
    } finally {
      currentEvaluation = prevEval;
    }
  }

  public <T> T registerDependency(Dependency<T> dep) {
    T value = dep.getValue();
    if (currentEvaluation != null) {
      dependencies.put(currentEvaluation, new DependencyAndValue(dep, value));
    }
    return value;
  }

  public void registerDependenciesForSubtree(EditorCell parent) {
    if (parent instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable((EditorCell_Collection) parent)) {
        dependencies.put(EditorCellLayoutable.createForResponsibleAncestor(parent), new DependencyAndValue(new EditorCellSizeDependency(child)));
        dependencies.put(EditorCellLayoutable.createForResponsibleAncestor(child), new DependencyAndValue(new EditorCellPositionDependency(parent)));
        registerDependenciesForSubtree(child);
      }
    }
  }

  public void cleanDependencies() {
    Set<Layoutable> layoutables = dependencies.keySet();
    ListSequence.fromList(SetSequence.fromSet(layoutables).where((it) -> !(it.isAlive())).toList()).visitAll((it) -> dependencies.removeAll(it));
  }

  public void update() {
    Iterable<Map.Entry<Layoutable, DependencyAndValue>> entries = dependencies.entries();
    List<Layoutable> invalidLayoutables = Sequence.fromIterable(entries).where(new _FunctionTypes._return_P1_E0<Boolean, Map.Entry<Layoutable, DependencyAndValue>>() {
      public Boolean invoke(Map.Entry<Layoutable, DependencyAndValue> it) {
        return it.getValue().isChanged();
      }
    }).select(new _FunctionTypes._return_P1_E0<Layoutable, Map.Entry<Layoutable, DependencyAndValue>>() {
      public Layoutable invoke(Map.Entry<Layoutable, DependencyAndValue> it) {
        return it.getKey();
      }
    }).distinct().toList();
    for (Layoutable layoutable : ListSequence.fromList(invalidLayoutables)) {
      if (layoutable.isAlive()) {
        if (LOG.isDebugLevel()) {
          LOG.debug("Invalid layout detected: " + layoutable);
        }
        layoutAndRecordDependencies(layoutable);
      }
    }
    cleanInstances();
    cleanDependencies();
  }

  public void layout(EditorCell cell) {
    layoutAndRecordDependencies(EditorCellLayoutable.createForResponsibleAncestor(cell));
  }

  public static int getX(EditorCell cell) {
    return (int) getInstance(cell.getEditorComponent()).getPosition(cell)._0();
  }

  public static int getY(EditorCell cell) {
    return (int) getInstance(cell.getEditorComponent()).getPosition(cell)._1();
  }

  public static int getWidth(EditorCell cell) {
    return (int) getInstance(cell.getEditorComponent()).getSize(cell)._0();
  }

  public static int getHeight(EditorCell cell) {
    return (int) getInstance(cell.getEditorComponent()).getSize(cell)._1();
  }

  public Tuples._2<Integer, Integer> getPosition(EditorCell cell) {
    return registerDependency(new EditorCellPositionDependency(cell));
  }

  public Tuples._2<Integer, Integer> getSize(EditorCell cell) {
    return registerDependency(new EditorCellSizeDependency(cell));
  }

  public static abstract class Layoutable {
    public abstract void layout();
    public abstract boolean isAlive();
  }

  public static abstract class Dependency<E> {
    public abstract E getValue();
  }

  public static class DependencyAndValue<E> {
    private Dependency<E> dep;
    private E value;
    public DependencyAndValue(Dependency<E> dep, E value) {
      this.dep = dep;
      this.value = value;
    }
    public DependencyAndValue(Dependency<E> dep) {
      this(dep, dep.getValue());
    }
    public boolean isChanged() {
      return !(Objects.equals(dep.getValue(), value));
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      DependencyAndValue that = (DependencyAndValue) o;
      if ((dep != null ? !(dep.equals(that.dep)) : that.dep != null)) {
        return false;
      }
      if ((value != null ? !(((Object) value).equals(that.value)) : that.value != null)) {
        return false;
      }

      return true;
    }
    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((dep != null ? ((Object) dep).hashCode() : 0));
      result = 31 * result + ((value != null ? ((Object) value).hashCode() : 0));
      return result;
    }
  }

  public static class EditorCellLayoutable extends Layoutable {
    public static EditorCellLayoutable createForResponsibleAncestor(EditorCell cell) {
      if (check_y165zd_a0a0a44(as_y165zd_a0a0a0a54(cell.getParent(), jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class)) instanceof CellLayout_Indent) {
        return createForResponsibleAncestor(cell.getParent());
      }
      return new EditorCellLayoutable(cell);
    }
    private EditorCell cell;
    public EditorCellLayoutable(EditorCell cell) {
      this.cell = cell;
    }
    @Override
    public void layout() {
      cell.requestRelayout();
      cell.relayout();
    }
    @Override
    public boolean isAlive() {
      return ((EditorCell_Basic) cell).isInTree();
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      EditorCellLayoutable that = (EditorCellLayoutable) o;
      if ((cell != null ? !(cell.equals(that.cell)) : that.cell != null)) {
        return false;
      }

      return true;
    }
    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((cell != null ? ((Object) cell).hashCode() : 0));
      return result;
    }
    private static CellLayout check_y165zd_a0a0a44(jetbrains.mps.nodeEditor.cells.EditorCell_Collection checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getCellLayout();
      }
      return null;
    }
    private static <T> T as_y165zd_a0a0a0a54(Object o, Class<T> type) {
      return (type.isInstance(o) ? (T) o : null);
    }
  }

  public static class EditorCellPositionDependency extends Dependency<Tuples._2<Integer, Integer>> {
    private EditorCell cell;
    public EditorCellPositionDependency(EditorCell cell) {
      this.cell = cell;
    }
    @Override
    public Tuples._2<Integer, Integer> getValue() {
      return MultiTuple.<Integer,Integer>from(cell.getX(), cell.getY());
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      EditorCellPositionDependency that = (EditorCellPositionDependency) o;
      if ((cell != null ? !(cell.equals(that.cell)) : that.cell != null)) {
        return false;
      }

      return true;
    }
    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((cell != null ? ((Object) cell).hashCode() : 0));
      return result;
    }
  }

  public static class EditorCellSizeDependency extends Dependency<Tuples._2<Integer, Integer>> {
    private EditorCell cell;
    public EditorCellSizeDependency(EditorCell cell) {
      this.cell = cell;
    }
    @Override
    public Tuples._2<Integer, Integer> getValue() {
      return MultiTuple.<Integer,Integer>from(cell.getWidth(), cell.getHeight());
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      EditorCellSizeDependency that = (EditorCellSizeDependency) o;
      if ((cell != null ? !(cell.equals(that.cell)) : that.cell != null)) {
        return false;
      }

      return true;
    }
    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((cell != null ? ((Object) cell).hashCode() : 0));
      return result;
    }
  }

  public static abstract class mxCellStateLayoutable extends Layoutable {
    protected final mxCellState state;
    public mxCellStateLayoutable(mxCellState state) {
      this.state = state;
    }
    @Override
    public boolean isAlive() {
      mxGraph graph = state.getView().getGraph();
      return contains(graph, graph.getCurrentRoot(), state.getCell());
    }
    private boolean contains(mxGraph graph, Object parent, Object searchFor) {
      if (parent == searchFor) {
        return true;
      }
      for (Object child : graph.getChildCells(parent)) {
        if (contains(graph, child, searchFor)) {
          return true;
        }
      }
      return false;
    }
    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      mxCellStateLayoutable that = (mxCellStateLayoutable) o;
      if ((state != null ? !(state.equals(that.state)) : that.state != null)) {
        return false;
      }

      return true;
    }
    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((state != null ? ((Object) state).hashCode() : 0));
      return result;
    }
  }
}

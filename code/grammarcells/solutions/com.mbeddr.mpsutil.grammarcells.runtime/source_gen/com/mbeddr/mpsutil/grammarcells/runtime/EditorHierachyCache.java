package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Set;
import jetbrains.mps.openapi.editor.descriptor.ConceptEditor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import java.util.Collections;
import java.util.HashMap;
import com.mbeddr.mpsutil.grammarcells.runtime.editorregistry.ConceptEditorRegistry;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.hintsSettings.ConceptEditorHintSettingsComponent;
import jetbrains.mps.ide.project.ProjectHelper;

public class EditorHierachyCache {

  private static EditorHierachyCache ourInstance = new EditorHierachyCache();

  public static EditorHierachyCache getInstance() {
    return ourInstance;
  }

  private Map<SAbstractConcept, Map<Set<String>, ConceptEditor>> myCache = MapSequence.fromMap(new WeakHashMap<SAbstractConcept, Map<Set<String>, ConceptEditor>>());

  public void invalidate() {
    MapSequence.fromMap(myCache).clear();
  }

  public ConceptEditor getActiveEditor(SAbstractConcept concept) {
    return getActiveEditor(concept);
  }

  public ConceptEditor getActiveEditor(SAbstractConcept concept, Set<String> hints) {
    if (hints == null) {
      hints = Collections.<String>emptySet();
    }
    Map<Set<String>, ConceptEditor> hints2editor = MapSequence.fromMap(myCache).get(concept);
    ConceptEditor editor = null;
    if (hints2editor != null) {
      editor = MapSequence.fromMap(hints2editor).get(hints);
      if (editor != null) {
        return editor;
      }
    } else {
      hints2editor = MapSequence.fromMap(new HashMap<Set<String>, ConceptEditor>());
      MapSequence.fromMap(myCache).put(concept, hints2editor);
    }

    editor = calcActiveEditor(concept, hints);
    MapSequence.fromMap(hints2editor).put(hints, editor);
    return editor;
  }

  protected ConceptEditor calcActiveEditor(SAbstractConcept concept, Set<String> hints) {
    return new ConceptEditorRegistry(hints) {
      @Override
      protected boolean ignoreEditor(ConceptEditor editor) {
        // Conditional editor are usually used as annotations without a model element.
        // They are wrappers around the original editor and should not result in disabled actions.
        String name = editor.getClass().getName();
        return name.contains("_conditionalEditor_");
      }
    }.getEditor(concept);
  }

  public boolean isActiveEditor(Class<? extends ConceptEditor> editor, SAbstractConcept concept) {
    return isActiveEditor(editor, concept, null);
  }

  public boolean isActiveEditor(Class<? extends ConceptEditor> editor, SAbstractConcept concept, Set<String> hints) {
    ConceptEditor activeEditor = getActiveEditor(concept, hints);
    if (activeEditor == null) {
      return true;
    }
    return activeEditor.getClass() == editor;
  }

  protected String[] getDefaultEditorHints(EditorContext editorContext) {
    ConceptEditorHintSettingsComponent.HintsState state = ConceptEditorHintSettingsComponent.getInstance(ProjectHelper.toIdeaProject(editorContext.getOperationContext().getProject())).getState();
    return state.getEnabledHints().toArray(new String[0]);
  }
}

package de.itemis.mps.editor.enumeration.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.nodeEditor.cells.TransactionalModelAccessor;
import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.event.MouseEvent;
import java.awt.event.KeyEvent;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;

public class EditorCell_EnumerationCheckbox extends EditorCell_Basic {
  private ModelAccessor myModelAccessor;
  private String state;
  private boolean myCommitInProgress;
  private EnumerationCheckboxImages images;

  public EditorCell_EnumerationCheckbox(EditorContext context, SNode node, ModelAccessor modelAccessor) {
    super(context, node);
    images = new EnumerationCheckboxImages(context.getEditorComponent());
    myCommitInProgress = false;
    myModelAccessor = modelAccessor;
    synchronizeViewWithModel();
    state = myModelAccessor.getText();
    setSelectable(true);
  }
  public boolean isReadOnly() {
    return getStyle().get(StyleAttributes.READ_ONLY);
  }

  @Override
  public void synchronizeViewWithModel() {
    state = myModelAccessor.getText();
    images.setCurrent(state);
    requestRelayout();
  }

  public void setScaleWithEditorFontSize(boolean bool) {
    this.images.setScaleWithEditorFontSize(bool);
  }

  public void addImage(String path, String state, String next) {
    addImage(path, state, next, 1.0);
  }

  public void addImage(String path, String state, String next, double scale) {
    images.addImage(path, scale, state, next, getSNode(), myModelAccessor.getText());
  }

  public void setState(String state) {
    this.state = state;
    images.setCurrent(state);
    getEditorComponent().getEditorContext().getRepository().getModelAccess().executeCommandInEDT(() -> commit());
  }

  public void toggle() {
    setState(images.getNextState());
  }
  public void commit() {
    getContext().getRepository().getModelAccess().checkWriteAccess();
    if (!(SNodeUtil.isAccessible(getSNode(), getContext().getRepository()))) {
      return;
    }
    if (myCommitInProgress) {
      return;
    }
    myCommitInProgress = true;
    try {
      myModelAccessor.setText(state);
      if (myModelAccessor instanceof TransactionalModelAccessor) {
        ((TransactionalModelAccessor) myModelAccessor).commit();
        synchronizeViewWithModel();
        getEditor().relayout();
      }
    } finally {
      myCommitInProgress = false;
    }
  }


  public static EditorCell_EnumerationCheckbox create(EditorContext editorContext, ModelAccessor modelAccessor, SNode node) {
    NodeReadAccessInEditorListener listener = NodeReadAccessCasterInEditor.getReadAccessListener();
    if (modelAccessor instanceof PropertyAccessor) {
      if (listener != null) {
        listener.clearCleanlyReadAccessProperties();
      }
    }
    EditorCell_EnumerationCheckbox result = new EditorCell_EnumerationCheckbox(editorContext, node, modelAccessor);
    if (listener != null) {
      addPropertyDependenciesToEditor(listener, result);
    }
    return result;

  }
  private static void addPropertyDependenciesToEditor(NodeReadAccessInEditorListener listener, EditorCell_EnumerationCheckbox result) {

    for (Pair<SNodeReference, String> pair : listener.popCleanlyReadAccessedProperties()) {
      result.getEditorComponent().getUpdater().getCurrentUpdateSession().registerCleanDependency(result, pair);
    }
  }
  protected void paintContent(Graphics g, ParentSettings settings) {
    int offsetX = (getWidth() - images.getWidth()) / 2;
    int offsetY = (getHeight() - images.getHeight()) / 2;
    images.paint(g, getX() + offsetX, getY() + offsetY, getEditor());


  }

  @Override
  protected void relayoutImpl() {
    myWidth = images.getWidth();
    myHeight = images.getHeight();
  }

  @Override
  public boolean processMousePressed(MouseEvent event) {
    if (getX() <= event.getX() && event.getX() <= getX() + getWidth()) {
      if (getY() <= event.getY() && event.getY() <= getY() + getHeight()) {
        if (!(isReadOnly())) {
          toggle();
        }
        return true;
      }
    }
    return false;
  }
  @Override
  protected boolean doProcessKeyTyped(KeyEvent event, boolean b) {
    if (event.getKeyChar() == ' ') {
      if (!(isReadOnly())) {
        toggle();
      }
      return true;
    }
    return false;
  }


  @Override
  public TextBuilder renderText() {
    return new TextBuilderImpl(((state != null && state.length() > 0) ? state : ""));
  }
}

package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.IConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.INode;
import java.util.Objects;

public class ResultElementAsOutputNode implements IOutputNode {

  protected ITransformationEngine engine;
  protected IResultElement element;

  public ResultElementAsOutputNode(ITransformationEngine engine, @NotNull IResultElement elementRef) {
    this.engine = engine;
    this.element = elementRef;
  }

  @Override
  public IOutputNodeReference getOutputNodeReference() {
    return element.getCanonicalReference();
  }

  @NotNull
  public IResultElement getElement() {
    return element;
  }

  public IConcept getConcept() {
    return getElement().getConcept();
  }
  protected IContainment resolveContainment() {
    return engine.resolveContainment(element.getCanonicalReference());
  }
  @Override
  public IContainment getContainment() {
    return resolveContainment();
  }
  public Iterable<IOutputNodeReference> getChildren(final String role) {
    return Sequence.fromIterable(getElement().getChildren(role)).translate((it) -> it.resolve(engine));
  }
  public Iterable<IOutputNodeReference> getAllChildren() {
    return Sequence.fromIterable(getElement().getAllChildren()).translate((it) -> it.resolve(engine));
  }
  @Override
  public void addNewChild(String role, int index, @Nullable IConcept concept) {
    IChildCreateHandler handler = getElement().getChildAddHandler(role);
    if (handler == null) {
      throw new RuntimeException("No write handler specified for child link '" + role + "'");
    }
    handler.create(index, concept);
  }
  public IOutputNodeReference getReferenceTarget(String role) {
    IReferenceTarget targetRef = getElement().getReferenceTarget(role);
    if (targetRef == null) {
      return null;
    }
    ISubgraphStage stage = engine.resolveStage(getElement().getTransformationResult().getStageRef());
    IOutputNodeReference targetNode = targetRef.resolve(element.getScope(), engine);
    return targetNode;
  }
  public void setReferenceTarget(String role, INode target) {
    IReferenceWriteHandler handler = getElement().getReferenceWriteHandler(role);
    if (handler == null) {
      if (!(Objects.equals(getReferenceTarget(role), target))) {
        throw new RuntimeException("No write handler specified for reference '" + role + "'");
      } else {
        // No handler required for references that never change
      }
    } else {
      handler.write(target);
    }
  }
  public String getPropertyValue(String role) {
    return getElement().getPropertyValue(role);
  }
  public void setPropertyValue(String role, String value) {
    IPropertyWriteHandler handler = getElement().getPropertyWriteHandler(role);
    if (handler == null) {
      if (!(Objects.equals(getPropertyValue(role), value))) {
        throw new RuntimeException("No write handler specified for property '" + role + "'");
      } else {
        // No handler required for properties that never change
      }
    } else {
      handler.write(value);
    }
  }

  public ITransformationEngine getEngine() {
    return engine;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    ResultElementAsOutputNode that = (ResultElementAsOutputNode) o;
    if ((engine != null ? !(engine.equals(that.engine)) : that.engine != null)) {
      return false;
    }
    if ((element != null ? !(element.equals(that.element)) : that.element != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((engine != null ? ((Object) engine).hashCode() : 0));
    result = 31 * result + ((element != null ? ((Object) element).hashCode() : 0));
    return result;
  }

  @Override
  public String toString() {
    return "ResultElementAsNode{" + element + "}";
  }
}

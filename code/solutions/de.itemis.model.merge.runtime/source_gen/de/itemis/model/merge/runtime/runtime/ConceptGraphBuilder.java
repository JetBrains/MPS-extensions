package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Objects;
import java.util.ArrayList;
import java.util.Collection;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import com.google.common.graph.Graph;
import com.google.common.collect.Lists;
import com.google.common.graph.MutableGraph;
import com.google.common.graph.GraphBuilder;
import com.google.common.graph.Graphs;

public class ConceptGraphBuilder {

  private static List<SAbstractConcept> directSubConcepts(List<SAbstractConcept> conceptList, final SAbstractConcept concept) {
    List<SAbstractConcept> transSubConcepts = ListSequence.fromList(conceptList).where((it) -> it.isSubConceptOf(concept) && !(Objects.equals(it, concept))).toList();

    List<SAbstractConcept> directSubConcepts = ListSequence.fromList(new ArrayList<SAbstractConcept>());
    for (final SAbstractConcept transSubconcept : ListSequence.fromList(transSubConcepts)) {
      boolean noTransitive = true;
      for (SAbstractConcept transSubConcept2 : ListSequence.fromList(transSubConcepts).where((it) -> !(Objects.equals(it, transSubconcept)))) {
        if (transSubconcept.isSubConceptOf(transSubConcept2)) {
          noTransitive = false;
          break;
        }
      }
      if (noTransitive) {
        ListSequence.fromList(directSubConcepts).addElement(transSubconcept);
      }
    }

    return directSubConcepts;
  }

  public static Collection<SNode> directSubConcepts(Collection<SNode> concepts, SNode concept) {
    return directSubConcepts(concepts, concept, (SNode x, SNode y) -> (boolean) AbstractConceptDeclaration__BehaviorDescriptor.isSubconceptOf_id73yVtVlWOga.invoke(x, y));
  }

  private static <X> Collection<X> directSubConcepts(Collection<X> conceptList, final X concept, final _FunctionTypes._return_P2_E0<? extends Boolean, ? super X, ? super X> subConceptOf) {
    List<X> transSubConcepts = CollectionSequence.fromCollection(conceptList).where((it) -> subConceptOf.invoke(it, concept) && !(Objects.equals(it, concept))).toList();

    List<X> directSubConcepts = ListSequence.fromList(new ArrayList<X>());
    for (final X transSubconcept : ListSequence.fromList(transSubConcepts)) {
      boolean noTransitive = true;
      for (X transSubConcept2 : ListSequence.fromList(transSubConcepts).where((it) -> !(Objects.equals(it, transSubconcept)))) {
        if (subConceptOf.invoke(transSubconcept, transSubConcept2)) {
          noTransitive = false;
          break;
        }
      }
      if (noTransitive) {
        ListSequence.fromList(directSubConcepts).addElement(transSubconcept);
      }
    }

    return directSubConcepts;
  }



  public static Graph<SAbstractConcept> create(Iterable<SAbstractConcept> concepts) {
    List<SAbstractConcept> conceptList = Lists.newArrayList(concepts);
    MutableGraph<SAbstractConcept> graph = GraphBuilder.directed().<SAbstractConcept>build();

    GraphBuilder.directed();
    for (SAbstractConcept concept : ListSequence.fromList(conceptList)) {
      graph.addNode(concept);
    }

    for (SAbstractConcept concept : ListSequence.fromList(conceptList)) {
      for (SAbstractConcept directsubConcept : ListSequence.fromList(ConceptGraphBuilder.directSubConcepts(conceptList, concept))) {
        graph.putEdge(concept, directsubConcept);
      }
    }


    int nodeSize = graph.nodes().size();
    assert nodeSize == ListSequence.fromList(conceptList).count();

    assert !(Graphs.hasCycle(graph)) : "Loops in Concept Hierarchy";
    return graph;
  }

}

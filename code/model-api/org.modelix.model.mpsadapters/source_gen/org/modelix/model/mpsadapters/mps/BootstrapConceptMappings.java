package org.modelix.model.mpsadapters.mps;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.modelix.model.api.IConcept;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.adapter.ids.MetaIdHelper;
import java.util.Objects;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.language.ConceptRegistry;
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

public class BootstrapConceptMappings {
  public static final BootstrapConceptMappings INSTANCE = new BootstrapConceptMappings();

  private Map<SConceptId, String> sconcept2uid = MapSequence.fromMap(new HashMap<SConceptId, String>());
  private Map<String, SConceptId> uid2sconcept = MapSequence.fromMap(new HashMap<String, SConceptId>());
  private Map<String, IConcept> concepts = MapSequence.fromMap(new HashMap<String, IConcept>());

  public void register(IConcept concept, SAbstractConcept sconcept) {
    register(concept, MetaIdHelper.getConcept(sconcept));
  }

  public void unregister(IConcept concept, SAbstractConcept sconcept) {
    unregister(concept, MetaIdHelper.getConcept(sconcept));
  }

  public synchronized void register(final IConcept concept, final SConceptId sconceptId) {
    final String uid = concept.getUID();
    uid2sconcept = modifyCopy(uid2sconcept, (Map<String, SConceptId> copy) -> MapSequence.fromMap(copy).put(uid, sconceptId));
    sconcept2uid = modifyCopy(sconcept2uid, (Map<SConceptId, String> copy) -> MapSequence.fromMap(copy).put(sconceptId, uid));
    concepts = modifyCopy(concepts, (Map<String, IConcept> copy) -> MapSequence.fromMap(copy).put(uid, concept));
  }

  public synchronized void unregister(IConcept concept, final SConceptId sconceptId) {
    final String uid = concept.getUID();
    if (!(Objects.equals(getSConceptId(uid), sconceptId))) {
      throw new RuntimeException("Attempt to unregister " + uid + " = " + sconceptId + " while " + getSConceptId(uid) + " was registered");
    }
    uid2sconcept = modifyCopy(uid2sconcept, (Map<String, SConceptId> copy) -> MapSequence.fromMap(copy).removeKey(uid));
    sconcept2uid = modifyCopy(sconcept2uid, (Map<SConceptId, String> copy) -> MapSequence.fromMap(copy).removeKey(sconceptId));
    concepts = modifyCopy(concepts, (Map<String, IConcept> copy) -> MapSequence.fromMap(copy).removeKey(uid));
  }

  public SAbstractConcept getSConcept(IConcept concept) {
    SConceptId sconceptId = getSConceptId(concept.getUID());
    if (sconceptId == null) {
      return null;
    }
    ConceptDescriptor conceptDescriptor = ConceptRegistry.getInstance().getConceptDescriptor(sconceptId);
    if (conceptDescriptor instanceof IllegalConceptDescriptor) {
      return null;
    }
    return MetaAdapterFactory.getAbstractConcept(conceptDescriptor);
  }

  public IConcept getConcept(SAbstractConcept concept) {
    SConceptId sconceptId = MetaIdHelper.getConcept(concept);
    String uid = getUID(sconceptId);
    if (uid == null) {
      return null;
    }
    return MapSequence.fromMap(concepts).get(uid);
  }

  public SConceptId getSConceptId(String uid) {
    return MapSequence.fromMap(uid2sconcept).get(uid);
  }

  public String getUID(SConceptId sconceptId) {
    return MapSequence.fromMap(sconcept2uid).get(sconceptId);
  }

  private <K, V> Map<K, V> modifyCopy(Map<K, V> map, _FunctionTypes._void_P1_E0<? super Map<K, V>> modifier) {
    Map<K, V> copy = MapSequence.fromMap(new HashMap<K, V>());
    MapSequence.fromMap(copy).putAll(map);
    modifier.invoke(copy);
    return copy;
  }
}

package de.slisson.mps.richtext.runtime;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.SubstituteInfo;
import de.slisson.mps.editor.multiline.cells.EditorCell_Word;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import de.slisson.mps.hacks.editor.SubstituteUtil;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import de.slisson.mps.richtext.behavior.Word__BehaviorDescriptor;
import de.slisson.mps.richtext.util.RichtextUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import de.slisson.mps.richtext.behavior.Text__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class WordCellSubstituteInfo implements SubstituteInfo {

  private EditorCell_Word myWordCell;
  private SubstituteInfo info;

  public WordCellSubstituteInfo(EditorCell_Word wordCell) {
    myWordCell = wordCell;
    SNode node = SNodeOperations.cast(wordCell.getSNode(), CONCEPTS.Word$5r);
    info = SubstituteUtil.forChild(wordCell.getContext(), SNodeOperations.cast(SNodeOperations.getParent(node), CONCEPTS.Text$bD), null, LINKS.words$C8QZ);
  }

  public List<SubstituteAction> getMatchingActions(String pattern, boolean strict) {
    List<SubstituteAction> actions = wrap(info.getMatchingActions(pattern, strict));
    return actions;
  }

  protected List<SubstituteAction> wrap(Iterable<SubstituteAction> unwrapped) {
    return Sequence.fromIterable(unwrapped).select((it) -> {
      SubstituteAction action = new Action(it);
      return action;
    }).toList();
  }

  public String getOriginalText() {
    return info.getOriginalText();
  }

  public List<SubstituteAction> getSmartMatchingActions(String pattern, boolean strict, EditorCell cell) {
    List<SubstituteAction> actions = wrap(info.getSmartMatchingActions(pattern, strict, cell));
    return actions;
  }

  public boolean hasExactlyNActions(String pattern, boolean strict, int n) {
    return info.hasExactlyNActions(pattern, strict, n);
  }

  public void invalidateActions() {
    info.invalidateActions();
  }

  public void setOriginalText(String pattern) {
    info.setOriginalText(pattern);
  }

  public class Action implements SubstituteAction {
    private SubstituteAction myAction;

    public Action(SubstituteAction action) {
      myAction = action;
    }

    public boolean canSubstitute(String pattern) {
      return myAction.canSubstitute(pattern);
    }
    public boolean canSubstituteStrictly(String pattern) {
      return myAction.canSubstituteStrictly(pattern);
    }
    public SNode getActionType(String pattern) {
      return myAction.getActionType(pattern);
    }

    public SNode getActionType(String pattern, EditorCell cell) {
      return myAction.getActionType(pattern, cell);
    }

    public String getDescriptionText(String pattern) {
      String descriptionText = myAction.getDescriptionText(pattern);

      SNode wordNode = SNodeOperations.cast(myWordCell.getSNode(), CONCEPTS.Word$5r);
      String visibleMatchingText = myAction.getVisibleMatchingText(pattern);

      int maxLength = 5;

      String afterText = Sequence.fromIterable(Sequence.fromArray(getSurroundingText(wordNode, false).split(" "))).first();
      if (afterText == null) {
        afterText = "";
      }
      if (afterText.length() > maxLength) {
        afterText = afterText.substring(0, maxLength) + "...";
      }

      return ((afterText != null && afterText.length() > 0) ? descriptionText + " (" + visibleMatchingText + " " + afterText + ")" : descriptionText);
    }

    public SNode getIconNode(String pattern) {
      return myAction.getIconNode(pattern);
    }

    public String getMatchingText(String pattern) {
      return myAction.getMatchingText(pattern);
    }

    public SNode getOutputConcept() {
      return myAction.getOutputConcept();
    }

    public Object getParameterObject() {
      return myAction.getParameterObject();
    }

    public SNode getSourceNode() {
      return myAction.getSourceNode();
    }

    public String getVisibleMatchingText(String pattern) {
      return myAction.getVisibleMatchingText(pattern);
    }

    public boolean isReferentPresentation() {
      return myAction.isReferentPresentation();
    }

    private String getSurroundingText(SNode wordNode, boolean before) {
      int start = myWordCell.getParent().getTextBefore(myWordCell, 0).length();
      int end = start + myWordCell.getCaretPosition();

      String s = Word__BehaviorDescriptor.getText_idehGfXvI_DB.invoke(wordNode);
      if (s == null) {
        s = "";
      }
      return (before ? RichtextUtil.safeSubstring(s, 0, start) : RichtextUtil.safeSubstring(s, end, s.length()));
    }

    public SNode substitute(@Nullable EditorContext context, String pattern) {
      RichtextUtil._preventSelectionHandling = false;
      SNode wordNode = SNodeOperations.cast(myWordCell.getSNode(), CONCEPTS.Word$5r);
      SNode textNode = SNodeOperations.cast(SNodeOperations.getParent(wordNode), CONCEPTS.Text$bD);

      SNode newNode = myAction.substitute(context, pattern);
      if (!(SNodeOperations.isInstanceOf(newNode, CONCEPTS.IWord$8d))) {
        newNode = ListSequence.fromList(SLinkOperations.getChildren(textNode, LINKS.words$C8QZ)).findLast((it) -> !(SNodeOperations.isInstanceOf(it, CONCEPTS.Word$5r)));
      }

      String s1 = getSurroundingText(wordNode, true);
      String s2 = getSurroundingText(wordNode, false);

      Word__BehaviorDescriptor.setText_id1JwC6U7zkKz.invoke(wordNode, s1);
      if (s2.length() > 0) {
        SNode nextWord = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9f2e0cL, "de.slisson.mps.richtext.structure.Word"));
        Word__BehaviorDescriptor.setText_id1JwC6U7zkKz.invoke(nextWord, s2);
        SNodeOperations.insertNextSiblingChild(wordNode, nextWord);
      }
      if (s1.length() > 0) {
        SNodeOperations.insertNextSiblingChild(wordNode, SNodeOperations.deleteNode(newNode));
      } else {
        SNodeOperations.replaceWithAnother(wordNode, SNodeOperations.deleteNode(newNode));
      }
      Text__BehaviorDescriptor.normalizeStructure_id4Lll81Ty9os.invoke(SNodeOperations.getNodeAncestor(newNode, CONCEPTS.Text$bD, false, false), null);

      if (!(RichtextUtil._preventSelectionHandling)) {
        myWordCell.getContext().flushEvents();
        myWordCell.getContext().selectWRTFocusPolicy(newNode);
      }

      return newNode;
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Word$5r = MetaAdapterFactory.getConcept(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9f2e0cL, "de.slisson.mps.richtext.structure.Word");
    /*package*/ static final SConcept Text$bD = MetaAdapterFactory.getConcept(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9e4e61L, "de.slisson.mps.richtext.structure.Text");
    /*package*/ static final SInterfaceConcept IWord$8d = MetaAdapterFactory.getInterfaceConcept(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9e7aecL, "de.slisson.mps.richtext.structure.IWord");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink words$C8QZ = MetaAdapterFactory.getContainmentLink(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9e4e61L, 0x237c8da86a9e7aeeL, "words");
  }
}

package com.mbeddr.mpsutil.grammarcells.runtime.insertpopup;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.language.SAbstractLink;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.editor.runtime.commands.EditorCommandAdapter;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.nodeEditor.cellActions.CellAction_InsertIntoCollection;
import jetbrains.mps.nodeEditor.cellProviders.AbstractCellListHandler;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import org.jetbrains.mps.openapi.language.SConceptFeature;

/**
 * The class which does the execution of the cell action.
 * <p>
 * Before execution it sets the context cell to the editor context, so the action implementation could derive it.
 */
public class CellActionExecuter {
  @NotNull
  private final EditorCell myContextCell;
  @NotNull
  private final CellAction myAction;
  @NotNull
  private final EditorContext myEditorContext;
  public CellActionExecuter(@NotNull EditorCell contextCell, @NotNull CellAction action, @NotNull EditorContext editorContext) {
    myContextCell = contextCell;
    myAction = action;
    myEditorContext = editorContext;
  }
  public EditorCell getContextCell() {
    return myContextCell;
  }
  public SAbstractLink getRole() {
    return as_lff37u_a0a0f(myContextCell.getSRole(), SAbstractLink.class);
  }
  private boolean canExecute() {
    return myEditorContext.runWithContextCell(myContextCell, () -> myAction.canExecute(myEditorContext));
  }
  public void execute() {
    myEditorContext.runWithContextCell(myContextCell, () -> {
      final Runnable r = () -> myAction.execute(myEditorContext);
      final ModelAccess modelAccess = myEditorContext.getRepository().getModelAccess();
      // editor actions often go beyond cell information and traverse nodes associated with the cell (e.g. NodeEditorActions$EnlargeSelection),
      // keep extra burden of model read here.
      if (myAction.executeInCommand()) {
        modelAccess.executeCommand(new EditorCommandAdapter(r, myEditorContext));
      } else {
        if (modelAccess.canRead()) {
          r.run();
        } else {
          modelAccess.runReadAction(r);
        }
      }
    });
  }
  @NotNull
  public CellAction getAction() {
    return myAction;
  }
  /**
   * Checks if the cell contains the action corresponding to the action type
   * Returns the cell action executer if the action is not null can be executed with the context cell
   * <p>
   * Should be invoked within the read action
   */
  @Nullable
  public static CellActionExecuter getExecutableExecuter(@NotNull EditorCell contextCell, @NotNull CellActionType type, @NotNull EditorContext editorContext) {
    CellAction action = contextCell.getAction(type);
    if (action == null) {
      return null;
    }
    CellActionExecuter cellActionExecuter = new CellActionExecuter(contextCell, action, editorContext);
    if (cellActionExecuter.canExecute()) {
      return cellActionExecuter;
    } else {
      return null;
    }
  }
  /**
   * Returns the cell action executer if the action is not null can be executed with the context cell
   * <p>
   * Should be invoked within the read action
   */
  @Nullable
  public static CellActionExecuter getExecutableExecuter(@NotNull EditorCell contextCell, CellAction action, @NotNull EditorContext editorContext) {
    if (action == null) {
      return null;
    }
    CellActionExecuter cellActionExecuter = new CellActionExecuter(contextCell, action, editorContext);
    if (cellActionExecuter.canExecute()) {
      return cellActionExecuter;
    } else {
      return null;
    }
  }
  /**
   * Checks if the editor component contains the action corresponding to the action type
   * Returns the cell action executer if the action is not null can be executed with the context cell
   * <p>
   * Should be invoked within the read action
   */
  @Nullable
  public static CellActionExecuter getExecutableExecuterFromEditorComponent(@NotNull EditorCell contextCell, @NotNull final CellActionType type, @NotNull final EditorComponent editorComponent) {
    EditorContext editorContext = editorComponent.getEditorContext();
    CellAction action = editorContext.runWithContextCell(contextCell, () -> editorComponent.getComponentAction(type));
    if (action == null) {
      return null;
    }
    CellActionExecuter cellActionExecuter = new CellActionExecuter(contextCell, action, editorContext);
    if (cellActionExecuter.canExecute()) {
      return cellActionExecuter;
    } else {
      return null;
    }
  }
  @Override
  public String toString() {
    if (myAction instanceof CellAction_InsertIntoCollection) {
      String text = textForRole(((AbstractCellListHandler) ReflectionUtil.readField(CellAction_InsertIntoCollection.class, ((CellAction_InsertIntoCollection) myAction), "myListHandler")).getElementSRole());
      if ((text != null && text.length() > 0)) {
        return text;
      }
    }
    return myAction.getDescriptionText();
  }
  public static String textForRole(SConceptFeature role) {
    if (role instanceof SAbstractLink) {
      String targetConceptName = ((SAbstractLink) role).getTargetConcept().getName();
      String roleText = role.getOwner().getName() + "." + role.getName();
      return targetConceptName + " ---> " + roleText;
    }
    if (role != null) {
      return role.getOwner().getName() + "." + role.getName();
    }
    return null;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    CellActionExecuter that = (CellActionExecuter) o;
    if ((myContextCell != null ? !(myContextCell.equals(that.myContextCell)) : that.myContextCell != null)) {
      return false;
    }
    if ((myAction != null ? !(myAction.equals(that.myAction)) : that.myAction != null)) {
      return false;
    }
    if ((myEditorContext != null ? !(myEditorContext.equals(that.myEditorContext)) : that.myEditorContext != null)) {
      return false;
    }

    return true;
  }
  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((myContextCell != null ? ((Object) myContextCell).hashCode() : 0));
    result = 31 * result + ((myAction != null ? ((Object) myAction).hashCode() : 0));
    result = 31 * result + ((myEditorContext != null ? ((Object) myEditorContext).hashCode() : 0));
    return result;
  }
  private static <T> T as_lff37u_a0a0f(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.slisson.mps.tables.runtime.gridmodel;

/*Generated by MPS */

import de.slisson.mps.tables.runtime.simplegrid.SimpleGrid;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.util.Map;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import de.slisson.mps.tables.runtime.simplegrid.ElementFactory;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.slisson.mps.tables.runtime.simplegrid.GridPosition;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Iterator;
import java.util.ArrayList;
import de.slisson.mps.tables.runtime.cells.TableActions;

public class Grid extends GridElement implements IGrid {
  public static final boolean CONSISTENCY_CHECKS_ENABLED = false;
  private SimpleGrid<IGridElement> myCells = new SimpleGrid<IGridElement>().allowNulls(false);
  private int myAlignmentShiftLeft = 0;
  private int myAlignmentShiftUp = 0;
  private SimpleGrid<HeaderReference> myColumnHeaders = new SimpleGrid<HeaderReference>();
  private SimpleGrid<HeaderReference> myRowHeaders = new SimpleGrid<HeaderReference>();
  private HeaderStore myHeaderStore = new HeaderStore();
  private EditorCell mySource;

  private Map<CellActionType, _FunctionTypes._return_P2_E0<? extends CellAction, ? super EditorCell, ? super Boolean>> endCellActions = MapSequence.fromMap(new HashMap<CellActionType, _FunctionTypes._return_P2_E0<? extends CellAction, ? super EditorCell, ? super Boolean>>());

  public Grid() {
    myCells.setDefaultElementFactory(new ElementFactory<IGridElement>() {
      public IGridElement createNewElement() {
        return new UnusedPosition();
      }
    });
    initializeEndCellActions();
  }

  public void setSourceCell(EditorCell cell) {
    mySource = cell;
  }

  public EditorCell getSourceCell() {
    return mySource;
  }

  public Header findHeader(HeaderReference reference) {
    return myHeaderStore.findHeader(reference);
  }

  public Set<Header> getHeaders() {
    return myHeaderStore.getHeaders();
  }

  public Set<Header> getAllHeaders() {
    return myHeaderStore.getAllHeaders();
  }
  @Override
  public void visitElements(IGridElementVisitor visitor) {
    super.visitElements(visitor);
    if (visitor.visitChilds(this)) {
      for (IGridElement e : Sequence.fromIterable(this)) {
        e.visitElements(visitor);
      }
    }
  }

  public void setColumnHeader(int x, int y, HeaderReference reference) {
    myColumnHeaders.setElement(x, y, reference);
    myCells.ensureSize(x + 1, myCells.getSizeY());
  }

  public void setColumnHeader(int x, int y, Header header) {
    myHeaderStore.storeHeader(header);
    setColumnHeader(x, y, header.getReference());
  }

  public void setColumnHeaders(int offsetX, int offsetY, HeaderGrid grid) {
    myHeaderStore.putAll(grid.getHeaderStore());
    for (int x = 0; x < grid.getSizeX(); x++) {
      for (int y = 0; y < grid.getSizeY(); y++) {
        setColumnHeader(x + offsetX, y + offsetY, grid.getElement(x, y));
      }
    }
  }

  public void setColumnHeaders(List<HeaderGrid> headerGrids) {
    int x = 0;
    for (HeaderGrid headerGrid : ListSequence.fromList(headerGrids)) {
      this.setColumnHeaders(x, 0, headerGrid);
      x += headerGrid.getSizeX();
    }
  }

  public void setRowHeaders(List<HeaderGrid> headerGrids) {
    int y = 0;
    for (HeaderGrid headerGrid : ListSequence.fromList(headerGrids)) {
      this.setRowHeaders(0, y, headerGrid);
      y += headerGrid.getSizeY();
    }
  }

  public void setRowHeaders(int offsetX, int offsetY, HeaderGrid grid) {
    myHeaderStore.putAll(grid.getHeaderStore());
    for (int x = 0; x < grid.getSizeX(); x++) {
      for (int y = 0; y < grid.getSizeY(); y++) {
        setRowHeader(x + offsetX, y + offsetY, grid.getElement(x, y));
      }
    }
  }

  public void setRowHeader(int x, int y, HeaderReference reference) {
    myRowHeaders.setElement(x, y, reference);
    myCells.ensureSize(myCells.getSizeX(), y + 1);
  }

  public void setRowHeader(int x, int y, Header header) {
    myHeaderStore.storeHeader(header);
    setRowHeader(x, y, header.getReference());
  }

  public SimpleGrid<HeaderReference> getColumnHeaders() {
    return myColumnHeaders.clone();
  }

  public SimpleGrid<HeaderReference> getRowHeaders() {
    return myRowHeaders.clone();
  }

  public boolean rowHeadersEmpty() {
    return myRowHeaders.isEmpty();
  }

  public HeaderReference getColumnHeader(int x, int y) {
    return myColumnHeaders.getElement(x, y);
  }

  public HeaderReference getRowHeader(int x, int y) {
    return myRowHeaders.getElement(x, y);
  }

  public int getColumnHeadersSizeX() {
    return myColumnHeaders.getSizeX();
  }
  public int getColumnHeadersSizeY() {
    return myColumnHeaders.getSizeY();
  }
  public int getRowHeadersSizeX() {
    return myRowHeaders.getSizeX();
  }
  public int getRowHeadersSizeY() {
    return myRowHeaders.getSizeY();
  }

  public int getAlignmentShiftLeft() {
    return myAlignmentShiftLeft;
  }

  public int getAlignmentShiftUp() {
    return myAlignmentShiftUp;
  }
  public void setAlignmentShiftUp(int shift) {
    myAlignmentShiftUp = shift;
  }
  public void setAlignmentShiftLeft(int shift) {
    myAlignmentShiftLeft = shift;
  }

  protected IRowCreateHandler getRowCreateHandler(int y, boolean left) {
    if (y < 0 || y >= getSizeY()) {
      throw new IndexOutOfBoundsException("y must be between 0 and " + (getSizeX() - 1) + " but was " + y);
    }
    PriorizedValue<IRowCreateHandler> result = null;
    for (int x = 0; x < getSizeX(); x++) {
      IGridElement e = getElement(x, y);
      result = PriorizedValue.getHigher(result, (left ? e.getLeftRowCreateHandler() : e.getRightRowCreateHandler()));
    }
    return check_nvlf_a3a16(result);
  }

  @Override
  public IRowCreateHandler getRightRowCreateHandler(int y) {
    return getRowCreateHandler(y, false);
  }

  @Override
  public IRowCreateHandler getLeftRowCreateHandler(int y) {
    return getRowCreateHandler(y, true);
  }

  protected IRowDeleteHandler getRowDeleteHandler(int y, boolean left) {
    if (y < 0 || y >= getSizeY()) {
      throw new IndexOutOfBoundsException("y must be between 0 and " + (getSizeX() - 1) + " but was " + y);
    }
    PriorizedValue<IRowDeleteHandler> result = null;
    for (int x = 0; x < getSizeX(); x++) {
      IGridElement e = getElement(x, y);
      result = PriorizedValue.getHigher(result, (left ? e.getLeftRowDeleteHandler() : e.getRightRowDeleteHandler()));
    }
    return check_nvlf_a3a76(result);
  }

  @Override
  public IRowDeleteHandler getRightRowDeleteHandler(int y) {
    return getRowDeleteHandler(y, false);
  }

  @Override
  public IRowDeleteHandler getLeftRowDeleteHandler(int y) {
    return getRowDeleteHandler(y, true);
  }



  public void clearRowHeaders() {
    myRowHeaders.setSize(0, 0);
  }

  public void clearColumnHeaders() {
    myColumnHeaders.setSize(0, 0);
  }

  @Override
  public Grid clone() {
    Grid clone = (Grid) super.clone();
    clone.myCells = myCells.clone();
    clone.myColumnHeaders = myColumnHeaders.clone();
    clone.myRowHeaders = myRowHeaders.clone();
    clone.myHeaderStore = new HeaderStore(myHeaderStore);
    for (int x = 0; x < clone.getSizeX(); x++) {
      for (int y = 0; y < clone.getSizeY(); y++) {
        IGridElement element = clone.getElement(x, y);
        clone.setElement(x, y, element.clone());
      }
    }
    return clone;
  }

  public void setValues(Grid source) {
    setSize(source.getSizeX(), source.getSizeY());
    for (int x = 0; x < getSizeX(); x++) {
      for (int y = 0; y < getSizeY(); y++) {
        setElement(x, y, source.getElement(x, y).clone());
      }
    }
  }

  public void moveRow(int from, int to) {
    if (from == to) {
      return;
    }
    myCells.moveRow(from, to);
    myRowHeaders.moveRow(from, to);
  }

  public void moveColumn(int from, int to) {
    if (from == to) {
      return;
    }
    myCells.moveColumn(from, to);
    myColumnHeaders.moveColumn(from, to);
  }

  public void insertRows(int x, int y, IGrid rows) {
    if (rows == null) {
      return;
    }
    for (int i = 0; i < rows.getSizeY(); i++) {
      insertRow(y);
    }
    replaceElements(x, y, rows);
  }

  public void insertColumns(int x, int y, IGrid columns) {
    if (columns == null) {
      return;
    }
    for (int i = 0; i < columns.getSizeX(); i++) {
      insertColumn(x);
    }
    replaceElements(x, y, columns);
  }

  public void expandElements(int x, int y, IGrid childGrid) {
    if (childGrid == null || childGrid.isEmpty()) {
      setElement(x, y, new UnusedPosition());
      return;
    }

    for (int i = 1; i < childGrid.getSizeX(); i++) {
      insertColumn(x);
    }
    for (int i = 1; i < childGrid.getSizeY(); i++) {
      insertRow(y);
    }

    replaceElements(x, y, childGrid);
  }

  public void replaceElements(int x, int y, IGrid childGrid) {
    myCells.replaceElements(x, y, childGrid);
  }

  public boolean isEmpty() {
    return myCells.isEmpty();
  }

  public boolean hasNonNullElements() {
    return myCells.hasNonNullElements();
  }

  public int getSizeX() {
    return myCells.getSizeX();
  }

  public int getSizeY() {
    return myCells.getSizeY();
  }

  public boolean isValidPosition(int x, int y) {
    return x < getSizeX() && y < getSizeY() && x >= 0 && y >= 0;
  }

  public boolean isValidPosition(GridPosition pos) {
    return isValidPosition(pos.getX(), pos.getY());
  }

  @NotNull
  @Override
  public IGridElement getElement(int x, int y) {
    return myCells.getElement(x, y);
  }

  public IGridElement getElement(GridPosition pos) {
    if (pos == null) {
      return null;
    }
    return getElement(pos.getX(), pos.getY());
  }

  public IGridElement getSpanningElement(final int x, final int y) {
    GridPosition pos = getSpanningElementPosition(x, y);
    if (pos == null) {
      return null;
    }
    return getElement(pos);
  }

  public GridPosition getSpanningElementPosition(final int x, final int y) {
    if (!(isValidPosition(x, y))) {
      return null;
    }
    IGridElement e = getElement(x, y);
    return (e instanceof SpannedPosition ? ((SpannedPosition) e).getSpanningStart() : null);
  }

  public boolean isSpanned(int x, int y) {
    return getSpanningElementPosition(x, y) != null;
  }

  public void checkSpanningConsistencyThrow() {
    if (!(CONSISTENCY_CHECKS_ENABLED)) {
      return;
    }

    for (int x = 0; x < getSizeX(); x++) {
      for (int y = 0; y < getSizeY(); y++) {
        // spanning
        IGridElement element = getElement(x, y);
        for (int i = 0; i < element.getSpanX(); i++) {
          for (int k = 0; k < element.getSpanY(); k++) {
            if (i == 0 && k == 0) {
              continue;
            }
            if (!(isValidPosition(x + i, y + k))) {
              throw new RuntimeException("(" + x + ", " + y + ") is spanning invalid position" + (" / inconsistent grid: " + this));
            }
            IGridElement spannedElement = getElement(x + i, y + k);
            if (!(spannedElement instanceof SpannedPosition)) {
              throw new RuntimeException("(" + x + ", " + y + ") is spanning (" + (x + i) + ", " + (y + k) + ") but element is not a SpannedPosition: " + spannedElement + (" / inconsistent grid: " + this));
            }
            SpannedPosition spanInfo = ((SpannedPosition) spannedElement);
            if (spanInfo.getSpanningElement() != element) {
              throw new RuntimeException("(" + x + ", " + y + ") is spanning (" + (x + i) + ", " + (y + k) + ") but is spanned by " + spanInfo.getSpanningElement() + (" / inconsistent grid: " + this));
            }
            if (!(spanInfo.getSpanningStart().equals(x, y))) {
              throw new RuntimeException("(" + x + ", " + y + ") is spanning (" + (x + i) + ", " + (y + k) + ") but spanning start is " + spanInfo.getSpanningStart() + (" / inconsistent grid: " + this));
            }
          }
        }

        // spanned
        if (element instanceof SpannedPosition) {
          SpannedPosition spanned = (SpannedPosition) element;
          if (spanned.getSpanningElement() != getElement(spanned.getSpanningStart())) {
            throw new RuntimeException("(" + x + ", " + y + "): expected at position " + spanned.getSpanningStart() + ": " + spanned.getSpanningElement() + (" / inconsistent grid: " + this));
          }

          if (x - spanned.getSpanningStart().getX() + 1 > spanned.getSpanningElement().getSpanX() || y - spanned.getSpanningStart().getY() + 1 > spanned.getSpanningElement().getSpanY()) {
            throw new RuntimeException("(" + x + ", " + y + ") says it's spanned by " + spanned.getSpanningStart() + " but " + "the element is spanning only (" + spanned.getSpanningElement().getSpanX() + ", " + spanned.getSpanningElement().getSpanY() + ")" + (" / inconsistent grid: " + this));
          }
        }
      }
    }
  }

  public void replaceElement(int x, int y, @NotNull IGridElement element) {
    if (isValidPosition(x, y)) {
      element.replace(getElement(x, y));
    }
    setElement(x, y, element);
  }

  public void setElement(int x, int y, @NotNull IGridElement element) {
    if (element == null) {
      throw new NullPointerException("element is null");
    }

    if (isSpanned(x, y) && !(element instanceof SpannedPosition)) {
      GridPosition pos = getSpanningElementPosition(x, y);
      throw new IllegalArgumentException("position (" + x + ", " + y + ") is spanned by the element in (" + pos.getX() + ", " + pos.getY() + ")");
    }

    // clear old spanning elements
    if (!(element instanceof SpannedPosition)) {
      if (isValidPosition(x, y)) {
        IGridElement oldElement = getElement(x, y);
        for (int i = 0; i < oldElement.getSpanX(); i++) {
          for (int k = 0; k < oldElement.getSpanY(); k++) {
            if (i != 0 || k != 0) {
              myCells.setElement(x + i, y + k, new UnusedPosition());
            }
          }
        }
      }
    }

    myCells.setElement(x, y, element);
    if (element instanceof Grid) {
      myHeaderStore.addChild(((Grid) element).myHeaderStore);
    }

    // set new spanning elements
    if (!(element instanceof SpannedPosition)) {
      GridPosition position = new GridPosition(x, y);
      int requiredSizeX = x + element.getSpanX();
      int requiredSizeY = y + element.getSpanY();
      myCells.ensureSize(requiredSizeX, requiredSizeY);
      for (int i = 0; i < element.getSpanX(); i++) {
        for (int k = 0; k < element.getSpanY(); k++) {
          if (i != 0 || k != 0) {
            myCells.setElement(x + i, y + k, new SpannedPosition(element, position));
          }
        }
      }
    }

    myColumnHeaders.ensureSize(getSizeX(), 0);
    myRowHeaders.ensureSize(0, getSizeY());
  }

  public void clearElement(int x, int y) {
    setElement(x, y, new GridLeaf());
  }

  public void insertRow(int pos) {
    insertRow(pos, null);
  }

  public void insertRow(int pos, ElementFactory<? extends IGridElement> elementFactory) {
    myCells.insertRow(pos, elementFactory);
    myRowHeaders.insertRow(pos);
    updateSpanInfoAfterRowInsert(pos);

    if (pos > 0) {
      // update header spanning
      for (int x = 0; x < myRowHeaders.getSizeX(); x++) {
        HeaderReference headerAbove = myRowHeaders.getElement(x, pos - 1);
        if (headerAbove != null) {
          myRowHeaders.setElement(x, pos, headerAbove.clone());
        }
      }
    }
  }

  public void flatten() {
    GridFlattener.flatten(this);
  }

  public void flattenOneLevel() {
    GridFlattener.flattenOneLevel(this);
  }

  public void insertRows(int pos, int count) {
    for (int i = 0; i < count; i++) {
      insertRow(pos);
    }
  }

  public void insertRows(int pos, int count, ElementFactory<? extends IGridElement> elementFactory) {
    for (int i = 0; i < count; i++) {
      insertRow(pos, elementFactory);
    }
  }

  public void insertColumn(int pos, ElementFactory<? extends IGridElement> elementFactory) {
    myCells.insertColumn(pos, elementFactory);
    myColumnHeaders.insertColumn(pos);
    updateSpanInfoAfterColumnInsert(pos);

    if (pos > 0) {
      // update header spanning
      for (int y = 0; y < myColumnHeaders.getSizeY(); y++) {
        HeaderReference headerLeft = myColumnHeaders.getElement(pos - 1, y);
        if (headerLeft != null) {
          myColumnHeaders.setElement(pos, y, headerLeft.clone());
        }
      }
    }
  }

  private void updateSpanInfoAfterColumnInsert(int columnNr) {
    for (int x = columnNr + 1; x < getSizeX(); x++) {
      for (int y = 0; y < getSizeY(); y++) {
        SpannedPosition spanInfo = as_nvlf_a0a0a0a0a931(getElement(x, y), SpannedPosition.class);
        if (spanInfo == null) {
          continue;
        }
        if (spanInfo.getSpanningStart().getX() >= columnNr) {
          spanInfo.setSpaningStart(new GridPosition(spanInfo.getSpanningStart().getX() + 1, spanInfo.getSpanningStart().getY()));
        }
      }
    }
  }
  private void updateSpanInfoAfterRowInsert(int rowNr) {
    for (int x = 0; x < getSizeX(); x++) {
      for (int y = rowNr + 1; y < getSizeY(); y++) {
        SpannedPosition spanInfo = as_nvlf_a0a0a0a0a041(getElement(x, y), SpannedPosition.class);
        if (spanInfo == null) {
          continue;
        }
        if (spanInfo.getSpanningStart().getY() >= rowNr) {
          spanInfo.setSpaningStart(new GridPosition(spanInfo.getSpanningStart().getX(), spanInfo.getSpanningStart().getY() + 1));
        }
      }
    }
  }

  public void insertColumnAndSpan(int pos) {
    if (pos == 0) {
      insertColumn(0);
      return;
    }
    myCells.insertColumn(pos);
    myColumnHeaders.insertColumn(pos);
    updateSpanInfoAfterColumnInsert(pos);

    // update header spanning
    for (int y = 0; y < myColumnHeaders.getSizeY(); y++) {
      HeaderReference headerLeft = myColumnHeaders.getElement(pos - 1, y);
      if (headerLeft != null) {
        myColumnHeaders.setElement(pos, y, headerLeft.clone());
      }
    }

    // update element spanning
    for (int y = 0; y < getSizeY(); y++) {
      IGridElement leftElement = getElement(pos - 1, y);
      leftElement.incrementSpanningX(this, pos - 1, y);

      SpannedPosition newElement;
      if (leftElement instanceof SpannedPosition) {
        SpannedPosition leftSpanned = (SpannedPosition) leftElement;
        newElement = leftSpanned.clone();
      } else {
        newElement = new SpannedPosition(leftElement, new GridPosition(pos - 1, y));
      }
      setElement(pos, y, newElement);
    }
  }

  public void insertRowAndSpan(int pos) {
    if (pos == 0) {
      insertRow(0);
      return;
    }
    myCells.insertRow(pos);
    myRowHeaders.insertRow(pos);
    updateSpanInfoAfterRowInsert(pos);

    // update header spanning
    for (int x = 0; x < myRowHeaders.getSizeX(); x++) {
      HeaderReference headerUpper = myRowHeaders.getElement(x, pos - 1);
      if (headerUpper != null) {
        myRowHeaders.setElement(x, pos, headerUpper.clone());
      }
    }

    // update element spanning
    for (int x = 0; x < getSizeX(); x++) {
      IGridElement upperElement = getElement(x, pos - 1);
      upperElement.incrementSpanningY(this, x, pos - 1);

      SpannedPosition newElement;
      if (upperElement instanceof SpannedPosition) {
        SpannedPosition upperSpanned = (SpannedPosition) upperElement;
        newElement = upperSpanned.clone();
      } else {
        newElement = new SpannedPosition(upperElement, new GridPosition(x, pos - 1));
      }
      setElement(x, pos, newElement);
    }
  }


  public void insertColumn(int pos) {
    insertColumn(pos, null);
  }

  public void insertColumns(int pos, int count) {
    for (int i = 0; i < count; i++) {
      insertColumn(pos);
    }
  }

  public void insertColumns(int pos, int count, ElementFactory<? extends IGridElement> elementFactory) {
    for (int i = 0; i < count; i++) {
      insertColumn(pos, elementFactory);
    }
  }

  @Override
  public void setSpanToSize() {
    setSpanX(getSizeX());
    setSpanY(getSizeY());
  }

  public void ensureSize(int minSizeX, int minSizeY) {
    myCells.ensureSize(minSizeX, minSizeY);
    myColumnHeaders.ensureSize(minSizeX, myColumnHeaders.getSizeY());
    myRowHeaders.ensureSize(myRowHeaders.getSizeX(), minSizeY);
  }

  public void setSize(int newSizeX, int newSizeY) {
    myCells.setSize(newSizeX, newSizeY);
  }

  public void deleteColumn(int columnIndex) {
    moveColumn(columnIndex, getSizeX() - 1);
    setSize(getSizeX() - 1, getSizeY());
  }

  public void deleteRow(int rowIndex) {
    moveRow(rowIndex, getSizeY() - 1);
    setSize(getSizeX(), getSizeY() - 1);
  }

  @Override
  public void transpose() {
    super.transpose();
    myCells.transposeInPlace();
    {
      Tuples._2<SimpleGrid<HeaderReference>, SimpleGrid<HeaderReference>> _tmp_nvlf_c0hg = MultiTuple.<SimpleGrid<HeaderReference>,SimpleGrid<HeaderReference>>from(myColumnHeaders, myRowHeaders);
      myRowHeaders = _tmp_nvlf_c0hg._0();
      myColumnHeaders = _tmp_nvlf_c0hg._1();
    }
    myColumnHeaders.transposeInPlace();
    myRowHeaders.transposeInPlace();

    for (IGridElement e : Sequence.fromIterable(myCells)) {
      e.transpose();
    }
  }

  @Override
  public Iterator<IGridElement> iterator() {
    return myCells.iterator();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("[" + getSizeX() + "x" + getSizeY() + "]" + "[insert=" + getInsertAction() + ", insertBefore=" + getInsertBeforeAction() + "]" + "{\n");
    boolean firstRow = true;
    sb.append(prefixLines("" + myColumnHeaders, "  C "));
    sb.append(prefixLines("" + myRowHeaders, "  R "));
    for (int y = 0; y < myCells.getSizeY(); y++) {
      if (!(firstRow)) {
        sb.append("\n");
      }
      for (int x = 0; x < myCells.getSizeX(); x++) {
        IGridElement element = myCells.getElement(x, y);
        String elementText = "" + element;
        elementText = prefixLines(elementText, "  [" + x + "," + y + "] (" + check_nvlf_a0a0b0a2a1a4a761(element) + "," + check_nvlf_a0b0a2a1a4a761(element) + ") ");
        sb.append(elementText);
      }
      firstRow = false;
    }
    sb.append("}");
    return sb.toString();
  }

  private static String prefixLines(String text, String linePrefix) {
    StringBuilder result = new StringBuilder();
    String[] textLines = text.split("\n");
    for (String line : textLines) {
      result.append(linePrefix).append(line).append("\n");
    }
    return result.toString();
  }


  public void fillNulls(int startX, int startY, Grid values) {
    if (values == null || values.isEmpty()) {
      return;
    }
    if (values.getSizeY() == 1) {
      int thisX = startX;
      for (int valuesX = 0; valuesX < values.getSizeX(); valuesX++) {
        while (thisX < getSizeX() && getElement(thisX, startY) != null) {
          thisX++;
        }
        if (thisX == getSizeX()) {
          insertColumn(thisX);
        }
        setElement(thisX, startY, values.getElement(valuesX, 0).clone());
      }
    } else if (values.getSizeX() == 1) {
      int thisY = startY;
      for (int valuesY = 0; valuesY < values.getSizeY(); valuesY++) {
        while (thisY < getSizeY() && getElement(startX, thisY) != null) {
          thisY++;
        }
        if (thisY == getSizeY()) {
          insertColumn(thisY);
        }
        setElement(startX, thisY, values.getElement(0, valuesY).clone());
      }
    } else {
      throw new IllegalArgumentException("values must be a vector (size of one dimension == 1)");
    }
  }

  public GridPosition next(GridPosition pos) {
    int x = pos.getX();
    int y = pos.getY();
    x++;
    if (x >= this.getSizeX()) {
      x = 0;
      y++;
    }
    if (y >= this.getSizeY()) {
      return null;
    }
    return new GridPosition(x, y);
  }

  public GridPosition previous(GridPosition pos) {
    int x = pos.getX();
    int y = pos.getY();
    x--;
    if (x < 0) {
      x = this.getSizeX() - 1;
      y--;
    }
    if (y < 0) {
      return null;
    }
    return new GridPosition(x, y);
  }


  public List<IGridElement> createEmptyElementsList(int size) {
    List<IGridElement> row = new ArrayList<IGridElement>(size);
    for (int i = 0; i < size; i++) {
      row.add(new GridLeaf());
    }
    return row;
  }

  public static Grid createRow(List<IGridElement> elements) {
    Grid grid = new Grid();
    grid.setSize(elements.size(), 1);
    for (int x = 0; x < elements.size(); x++) {
      grid.setElement(x, 0, elements.get(x));
    }
    return grid;
  }

  public static Grid createColumn(List<IGridElement> elements) {
    Grid grid = new Grid();
    grid.setSize(1, elements.size());
    for (int y = 0; y < elements.size(); y++) {
      grid.setElement(0, y, elements.get(y));
    }
    return grid;
  }

  public void initializeEndCellActions() {
    MapSequence.fromMap(endCellActions).put(CellActionType.INSERT, (EditorCell cell, Boolean isLeft) -> new TableActions.InsertRowAction(cell, isLeft));
    MapSequence.fromMap(endCellActions).put(CellActionType.INSERT_BEFORE, (EditorCell cell, Boolean isLeft) -> cell.getAction(CellActionType.INSERT));
    MapSequence.fromMap(endCellActions).put(CellActionType.DELETE, (EditorCell cell, Boolean isLeft) -> new TableActions.DeleteRowAction(cell, false, TableActions.DeleteRowAction.DeleteType.DELETE, isLeft));
    MapSequence.fromMap(endCellActions).put(CellActionType.BACKSPACE, (EditorCell cell, Boolean isLeft) -> new TableActions.DeleteRowAction(cell, false, TableActions.DeleteRowAction.DeleteType.BACKSPACE, isLeft));
    MapSequence.fromMap(endCellActions).put(CellActionType.SELECT_NEXT, (EditorCell cell, Boolean isLeft) -> new TableActions.SelectRowNodeAction(cell));
    MapSequence.fromMap(endCellActions).put(CellActionType.SELECT_PREVIOUS, (EditorCell cell, Boolean isLeft) -> new TableActions.SelectRowNodeAction(cell));
    MapSequence.fromMap(endCellActions).put(CellActionType.PASTE, (EditorCell cell, Boolean isLeft) -> new TableActions.PasteAction(cell, isLeft));
  }

  public void setEndCellAction(CellActionType type, _FunctionTypes._return_P2_E0<? extends CellAction, ? super EditorCell, ? super Boolean> creator) {
    MapSequence.fromMap(endCellActions).put(type, creator);
  }

  public _FunctionTypes._return_P2_E0<? extends CellAction, ? super EditorCell, ? super Boolean> getEndCellAction(CellActionType type) {
    return MapSequence.fromMap(endCellActions).get(type);
  }

  public Map<CellActionType, _FunctionTypes._return_P2_E0<? extends CellAction, ? super EditorCell, ? super Boolean>> getEndCellActionsCreator() {
    return endCellActions;
  }

  private static IRowCreateHandler check_nvlf_a3a16(PriorizedValue<IRowCreateHandler> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getValue();
    }
    return null;
  }
  private static IRowDeleteHandler check_nvlf_a3a76(PriorizedValue<IRowDeleteHandler> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getValue();
    }
    return null;
  }
  private static int check_nvlf_a0b0a2a1a4a761(IGridElement checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSpanY();
    }
    return 0;
  }
  private static int check_nvlf_a0a0b0a2a1a4a761(IGridElement checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSpanX();
    }
    return 0;
  }
  private static <T> T as_nvlf_a0a0a0a0a931(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_nvlf_a0a0a0a0a041(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.itemis.mps.editor.celllayout.layout;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import de.itemis.mps.editor.celllayout.boxmodel.Size;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Objects;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.itemis.mps.editor.celllayout.runtime.IEditorCellBasedLayoutable;
import java.util.Collections;
import de.itemis.mps.editor.celllayout.runtime.CellLayoutUtil;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;

public class IndentLayout extends AbstractLayout implements ILayouter {
  private int myIndentSize;

  public IndentLayout(int indentSize) {
    myIndentSize = indentSize;
  }

  public IndentLayout() {
    this(16);
  }

  public void layout(ILayoutableContainer container, @NotNull final Size sizeConstraint) {
    if (isLayoutedByParent(container)) {
      return;
    }
    Text text = loadText(sizeConstraint.getWidth(), container, loadWords(container, (ILayoutable l, Integer indentSize) -> l.getPreferredSize(sizeConstraint.subtract(indentSize, 0))));
    text.applyLayout(container.getInnerX(), container.getInnerY(), sizeConstraint.getWidth());
    layoutIntermediateCollections(container);
  }

  public void layoutIntermediateCollections(final ILayoutableContainer container) {
    List<ILayoutableContainer> list = Sequence.fromIterable(getContainers(container)).where((it) -> it != container && isIntermediateCollection(it)).toList();
    ListSequence.fromList(list).visitAll((it) -> {
      if (ListSequence.fromList(it.getChildren()).isNotEmpty()) {
        LayoutableContainerExtensions.adjustToChildren(it);
      } else {
        ILayoutable prevLeaf = LayoutableTraversalExtensions.prevLeaf(it);
        if (prevLeaf != null) {
          it.setBounds(LayoutableExtensions.getMaxX(prevLeaf), prevLeaf.getY(), 0, 0);
        } else {
          it.setBounds(container.getInnerX(), container.getInnerY(), 0, 0);
        }
      }
    });
  }

  protected Iterable<ILayoutable> getIndentLeafs(ILayoutableContainer container) {
    return Sequence.fromIterable(loadWords(container, (ILayoutable l, Integer indentSize) -> Size.ZERO)).select((it) -> it.getLayoutable());
  }

  @Override
  public Iterable<ILayoutable> getCellsForSelectionPainting(ILayoutableContainer container) {
    return getIndentLeafs(container);
  }

  @Override
  protected Iterable<ILayoutable> getChildrenToMove(ILayoutableContainer container) {
    return getIndentLeafs(container);
  }

  @Override
  public void moveChildren(ILayoutableContainer container, int deltaX, int deltaY) {
    super.moveChildren(container, deltaX, deltaY);
    layoutIntermediateCollections(container);
  }

  @NotNull
  public Size getPreferredInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint0) {
    if (isLayoutedByParent(container)) {
      return Size.ZERO;
    }

    final Wrappers._T<Size> sizeConstraint = new Wrappers._T<Size>(sizeConstraint0);
    Size preferredSize = sizeConstraint0;
    for (int i = 0; i < 5; i++) {
      // The position of line breaks depends on the width constraint.
      // The returned preferred width is used as a constraint for the layout method, but a different width constraint can result in a different height.
      // This was the reason for some overlapping text.
      // Here we try to find a stable size by recursively running the layouter with the resulting size as the new constraint.
      Text text = loadText(sizeConstraint.value.getWidth(), container, loadWords(container, (ILayoutable l, Integer indentSize) -> l.getPreferredSize(sizeConstraint.value.subtract(indentSize, 0))));
      preferredSize = text.getSize();
      if (Objects.equals(preferredSize.getWidth(), sizeConstraint.value.getWidth())) {
        break;
      }
      sizeConstraint.value = preferredSize;
    }
    return preferredSize;
  }

  @NotNull
  public Size getMinInnerSize(ILayoutableContainer container, @NotNull final Size sizeConstraint) {
    if (isLayoutedByParent(container)) {
      return Size.ZERO;
    }
    Iterable<Word> words = loadWords(container, (ILayoutable l, Integer indentSize) -> l.getMinSize(sizeConstraint.subtract(indentSize, 0)));
    int maxWidth = Sequence.fromIterable(words).select((it) -> SizeExtensions.zeroIfOverflow(it.getLayoutable().getMinSize(sizeConstraint), it.getLayoutable()).getWidth()).foldLeft(0, (Integer s, Integer it) -> Math.max(s, it));
    Text text = loadText(maxWidth, container, words);
    Size minSize = text.getSize();

    if (minSize.getWidth() > maxWidth) {
      maxWidth = minSize.getWidth();
      text = loadText(maxWidth, container, words);
      minSize = text.getSize();
    }

    return minSize;
  }

  @NotNull
  public Size getMaxInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint) {
    return Size.UNLIMITED_SIZE;
  }

  public int getAscent(ILayoutableContainer container, final Size sizeConstraint) {
    if (isLayoutedByParent(container)) {
      return 0;
    }
    Text text = loadText(sizeConstraint.getWidth(), container, loadWords(container, (ILayoutable l, Integer indentSize) -> l.getPreferredSize(sizeConstraint.subtract(indentSize, 0))));

    final ILayoutable baselineChild = container.getBaselineChild();
    if (baselineChild != null) {
      int ascent = 0;
      for (Line line : Sequence.fromIterable(text.getLines())) {
        if (ListSequence.fromList(line.getWords()).any((it) -> LayoutableExtensions.isAncestorOf(baselineChild, it.getLayoutable()))) {
          return ascent + line.getAscent();
        }
        ascent += line.getHeight();
      }
    }

    return check_81docr_a6a42(Sequence.fromIterable(text.getLines()).first());
  }

  protected Iterable<Word> loadWords(ILayoutable container, _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Integer> sizeGetter) {
    return loadWords(container, 0, 0, Integer.MAX_VALUE, sizeGetter);
  }

  protected boolean isLayoutedByParent(ILayoutableContainer container) {
    ILayouter parentLayout = check_81docr_a0a0cb(container.getParent());
    return parentLayout instanceof IndentLayout && ((IndentLayout) parentLayout).isIntermediateCollection(container);
  }

  protected Iterable<Word> loadWords(ILayoutable container, final int treeDepth, int indentLevel, int parentMaxWidth, final _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Integer> sizeGetter) {
    final Wrappers._int _indentLevel = new Wrappers._int(indentLevel);
    if (((IEditorCellBasedLayoutable) container).hasIndent()) {
      _indentLevel.value++;
    }
    final int maxWidth = Math.min(parentMaxWidth, getMaxWidth(container));

    if (isIntermediateCollection(container) || treeDepth == 0) {
      return ListSequence.fromList(((ILayoutableContainer) container).getChildren()).translate((it) -> loadWords(it, treeDepth + 1, _indentLevel.value, maxWidth, sizeGetter));
    } else {
      Word word = new Word(container, SizeExtensions.zeroIfOverflow(sizeGetter.invoke(container, getIndentSize(_indentLevel.value)), container), treeDepth, _indentLevel.value, maxWidth);
      return Sequence.<Word>singleton(word);
    }
  }

  protected int getMaxWidth(ILayoutable layoutable) {
    return layoutable.getMaxWidth();
  }

  protected Iterable<ILayoutableContainer> getContainers(ILayoutable container) {
    if (container instanceof ILayoutableContainer && isIndentLayout((ILayoutableContainer) container)) {
      return ListSequence.fromList(((ILayoutableContainer) container).getChildren()).translate((it) -> getContainers(it)).concat(Sequence.fromIterable(Sequence.<ILayoutableContainer>singleton(((ILayoutableContainer) container))));
    } else {
      return Sequence.fromIterable(Collections.<ILayoutableContainer>emptyList());
    }
  }

  protected boolean isIndentLayout(ILayoutableContainer container) {
    return ((ILayoutableContainer) container).getLayouter().getClass() == getClass();
  }

  protected boolean isIntermediateCollection(ILayoutable layoutable) {
    return layoutable instanceof ILayoutableContainer && isIndentLayout(((ILayoutableContainer) layoutable)) && ListSequence.fromList(((ILayoutableContainer) layoutable).getChildren()).count() > 0;
  }

  protected boolean isEmptyIntermediateCollection(ILayoutable layoutable) {
    return layoutable instanceof ILayoutableContainer && isIndentLayout(((ILayoutableContainer) layoutable)) && ListSequence.fromList(((ILayoutableContainer) layoutable).getChildren()).count() == 0;
  }

  protected Text loadText(int width, ILayoutableContainer container, Iterable<Word> words) {
    Text text = new Text();

    boolean noWrap = isNoWrap(container);
    for (Word word : Sequence.fromIterable(words)) {
      if (!(text.getCurrentLine().isEmpty()) && CellLayoutUtil.hasNewLineBefore(CellLayoutUtil.getEditorCell(word.getLayoutable()))) {
        text.newLine();
      }
      text.addWord(word);
      if (!(noWrap)) {
        splitLastLineIfToLong(text, width);
      }
      if (text.getCurrentLine().getWidth() > width) {
        ListSequence.fromList(text.getCurrentLine().getWords()).last().update(width - text.getCurrentLine().getLineIndent());
        text.getCurrentLine().recalucateWidth();
      }
      if (!(text.getCurrentLine().isEmpty()) && CellLayoutUtil.hasNewLineAfter(CellLayoutUtil.getEditorCell(word.getLayoutable()))) {
        text.newLine();
      }
    }
    if (!(noWrap)) {
      splitLastLineIfToLong(text, width);
    }

    text.removeLastLineIfEmpty();
    return text;
  }

  protected boolean isNoWrap(ILayoutable left, ILayoutable right) {
    if (left == null || right == null) {
      return false;
    }
    return isNoWrap(LayoutableExtensions.commonParent(left, right));
  }

  protected boolean isNoWrap(ILayoutable layoutable) {
    if (layoutable == null) {
      return false;
    }
    return layoutable.isNoWrap() || isNoWrap(layoutable.getParent());
  }

  protected void splitLastLineIfToLong(Text text, int widthLimit) {
    if (ListSequence.fromList(text.getCurrentLine().getWords()).count() > 1) {
      widthLimit = Math.min(widthLimit, ListSequence.fromList(text.getCurrentLine().getWords()).last().getMaxWidth());
      if (text.getCurrentLine().getWidth() > widthLimit) {
        List<Word> lineWords = text.getCurrentLine().getWords();
        int wrapPoint = 0;
        if (ListSequence.fromList(lineWords).count() >= 3) {
          wrapPoint = findBestWrapPoint(lineWords, text.getCurrentLine().getFirstValidSplitPoint(widthLimit), ListSequence.fromList(lineWords).count() - 2);
        }
        text.splitLineAfter(text.getCurrentLine(), wrapPoint);
        text.getCurrentLine().setIsWrap(true);
      }
    }
  }

  protected int findBestWrapPoint(List<Word> allWords, int from, int to) {
    if (to < from) {
      throw new IllegalArgumentException(to + " < " + from);
    }
    if (to == from) {
      return from;
    }

    int bestIndex = from;
    int bestRating = rateWrapPoint(allWords, from);

    for (int i = from + 1; i <= to; i++) {
      int rating = rateWrapPoint(allWords, i);
      if (rating >= bestRating) {
        bestIndex = i;
        bestRating = rating;
      }
    }

    return bestIndex;
  }

  protected int rateWrapPoint(List<Word> allWords, int candidateIndex) {
    Word prevWord = (candidateIndex > 0 ? ListSequence.fromList(allWords).getElement(candidateIndex - 1) : null);
    Word leftWord = ListSequence.fromList(allWords).getElement(candidateIndex);
    Word rightWord = (candidateIndex + 1 < ListSequence.fromList(allWords).count() ? ListSequence.fromList(allWords).getElement(candidateIndex + 1) : null);

    int rating = 0;
    if (rightWord != null) {
      rating = rateWrapPoint(leftWord, rightWord, prevWord);
    }


    return rating;
  }

  protected int rateWrapPoint(Word leftWord, Word rightWord, Word prevWord) {
    int rating = 0;
    // prefer wrap at the beginning/end of indent collections
    int difference = Math.abs(leftWord.getTreeDepth() - rightWord.getTreeDepth());
    int treeDepthRating = (int) Math.round(Math.log(difference + 1) * 10);
    if (leftWord.getTreeDepth() > rightWord.getTreeDepth()) {
      treeDepthRating = treeDepthRating * 4 / 3;
    }
    rating += treeDepthRating;

    // after an operator
    if (prevWord != null) {
      if (prevWord.getTreeDepth() > leftWord.getTreeDepth() && leftWord.getTreeDepth() < rightWord.getTreeDepth()) {
        rating += 30;
      }
    }

    // prefer cells that already have space between them
    if (getGapBetweenCells(leftWord.getLayoutable(), rightWord.getLayoutable()) == 0) {
      rating -= 5;
    }
    return rating;
  }

  public class Text {

    public List<Line> myLines = ListSequence.fromList(new ArrayList<Line>());

    public Text() {
      ListSequence.fromList(myLines).addElement(new Line(this));
    }

    @Override
    public String toString() {
      return IterableUtils.join(ListSequence.fromList(myLines).select((it) -> it.toString()), "\n");
    }
    public void addWord(Word word) {
      ListSequence.fromList(myLines).last().addWord(word);
    }

    public void addWordOnNewLine(Word word) {
      newLine();
      addWord(word);
    }

    public void newLine() {
      ListSequence.fromList(myLines).addElement(new Line(this));
    }

    public Iterable<Line> getLines() {
      return myLines;
    }

    public Line getCurrentLine() {
      return ListSequence.fromList(myLines).last();
    }

    public void splitLineAfter(Line line, int splitAfter) {
      ListSequence.fromList(myLines).insertElement(ListSequence.fromList(myLines).indexOf(line) + 1, line.splitLineAfter(splitAfter));
    }

    public int getHeight() {
      return ListSequence.fromList(myLines).foldLeft(0, (Integer s, Line it) -> s + it.getHeight());
    }

    public int getWidth() {
      int width = ListSequence.fromList(myLines).foldLeft(0, (Integer s, Line it) -> Math.max(s, it.getWidth()));
      return width;
    }

    public void applyLayout(int x, int y, int targetWidth) {
      for (Line line : ListSequence.fromList(myLines)) {
        line.applyLayout(x, y, targetWidth);
        y += line.getHeight();
      }
    }

    public Size getSize() {
      return new Size(getWidth(), getHeight());
    }

    public void removeLastLineIfEmpty() {
      if (ListSequence.fromList(myLines).last().isEmpty()) {
        ListSequence.fromList(myLines).removeLastElement();
      }
    }
  }

  protected int getIndentSize() {
    return myIndentSize;
  }

  protected int getIndentSize(int indentLevel) {
    return getIndentSize() * indentLevel;
  }

  protected int getIndentAfterWrap(int indentLevel) {
    return getIndentSize(indentLevel) + getIndentSize() * 2;
  }

  @Override
  protected boolean hasGapBetweenCells(@Nullable ILayoutable left, @Nullable ILayoutable right) {
    if (left instanceof ILayoutableContainer && isIndentLayout(((ILayoutableContainer) left)) && ListSequence.fromList(((ILayoutableContainer) left).getChildren()).count() == 0) {
      return false;
    }
    return super.hasGapBetweenCells(left, right);
  }

  @Override
  public TextBuilder toText(ILayoutableContainer container) {
    TextBuilderImpl resultText = new TextBuilderImpl();

    Text text = loadText(Size.UNLIMITED, container, loadWords(container, (ILayoutable l, Integer indentSize) -> l.getPreferredSize(Size.UNLIMITED_SIZE)));

    for (Line line : Sequence.fromIterable(text.getLines())) {
      TextBuilderImpl resultLine = new TextBuilderImpl();
      Word prevWord = null;
      for (Word word : ListSequence.fromList(line.getWords())) {
        boolean hasGap = (prevWord == null ? false : hasGapBetweenCells(prevWord.getLayoutable(), word.getLayoutable()));
        resultLine.appendToTheRight(word.getLayoutable().toText(), hasGap);
        prevWord = word;
      }
      resultText.appendToTheBottom(resultLine);
    }

    return resultText;
  }

  public class Line {
    private Text myText;
    private List<Word> myWords = ListSequence.fromList(new ArrayList<Word>());
    private boolean myIsWrap = false;
    private int myWidth = -1;

    public Line(Text text) {
      myText = text;
    }

    @Override
    public String toString() {
      return IterableUtils.join(ListSequence.fromList(myWords).select((it) -> it.toString()), " ");
    }

    public void addWord(Word word) {
      ListSequence.fromList(myWords).addElement(word);

      // incremental update of the cached width
      if (myWidth != -1 && ListSequence.fromList(myWords).count() > 1) {
        myWidth += getGapBetweenCells(ListSequence.fromList(myWords).getElement(ListSequence.fromList(myWords).count() - 2).getLayoutable(), word.getLayoutable());
        myWidth += word.getWidth();
      } else {
        myWidth = -1;
      }
    }

    protected void updateWidthAfterWordAdd(Word newWord) {
    }

    public void recalucateWidth() {
      myWidth = -1;
    }

    protected int calcWidth() {
      if (ListSequence.fromList(myWords).isEmpty()) {
        return 0;
      }

      Word prevWord = ListSequence.fromList(myWords).first();
      int width = getLineIndent();
      width += prevWord.getWidth();

      for (Word word : ListSequence.fromList(myWords).skip(1)) {
        width += getGapBetweenCells(prevWord.getLayoutable(), word.getLayoutable());
        width += word.getWidth();
        prevWord = word;
      }
      return width;
    }

    /**
     * If a wrap is done at the beginning of a line it can happen that the content after the wrap is to long.
     * This usually happens when the first word has a smaller width than the last word.
     * In that case we have to avoid a wrap after the first word.
     */
    public int getFirstValidSplitPoint(int widthLimit) {
      int wrapIndent = getIndentAfterWrap(getIndentLevel()) - getIndentSize(getIndentLevel());
      int pos = 1;
      int line1Width = ListSequence.fromList(myWords).first().getWidth();
      int line2Width = getWidth() + wrapIndent - line1Width;
      while (pos < ListSequence.fromList(myWords).count() - 2 && line2Width > widthLimit) {
        int delta = getGapBetweenCells(ListSequence.fromList(myWords).getElement(pos - 1).getLayoutable(), ListSequence.fromList(myWords).getElement(pos).getLayoutable()) + ListSequence.fromList(myWords).getElement(pos).getWidth();
        line1Width += delta;
        line2Width -= delta;
        pos++;
      }
      return pos;
    }

    public int getWidth() {
      if (myWidth == -1) {
        myWidth = calcWidth();
      }
      return myWidth;
    }

    public int getHeight() {
      int ascent = getAscent();
      int descent = getDescent();
      return ascent + descent;
    }

    private int getDescent() {
      return ListSequence.fromList(myWords).select((it) -> it.getDescent()).foldLeft(0, (Integer s, Integer it) -> Math.max(s, it));
    }

    protected int getAscent() {
      return ListSequence.fromList(myWords).select((it) -> it.getAscent()).foldLeft(0, (Integer s, Integer it) -> Math.max(s, it));
    }

    public void applyLayout(final int textX, final int textY, int targetWidth) {
      int baseLine = textY + getAscent();
      int x = textX + getLineIndent();

      // grow words in x direction
      int growAmount = targetWidth - getWidth();
      if (growAmount > 0) {
        List<Word> growingWords = ListSequence.fromList(getWords()).where((it) -> isChildGrowX(it.getLayoutable())).toList();
        if (ListSequence.fromList(growingWords).isNotEmpty()) {
          int singleGrowAmount = growAmount / ListSequence.fromList(growingWords).count();
          for (Word growingWord : ListSequence.fromList(growingWords)) {
            growingWord.addWidth((growingWord == ListSequence.fromList(growingWords).last() ? growAmount : singleGrowAmount));
            growAmount -= singleGrowAmount;
          }
        }
      }

      for (int i = 0; i < ListSequence.fromList(myWords).count(); i++) {
        Word word = ListSequence.fromList(myWords).getElement(i);
        word.applyLayout(x, baseLine - word.getAscent());
        if (i < ListSequence.fromList(myWords).count() - 1) {
          x += word.getWidth() + getGapBetweenCells(word.getLayoutable(), ListSequence.fromList(myWords).getElement(i + 1).getLayoutable());
        }
      }
    }

    public Line splitLineAfter(int splitAfter) {
      Line second = new Line(myText);
      second.myWords = ListSequence.fromListWithValues(new ArrayList<Word>(), ListSequence.fromList(myWords).tailListSequence(splitAfter + 1));
      myWords = ListSequence.fromListWithValues(new ArrayList<Word>(), ListSequence.fromList(myWords).headListSequence(splitAfter + 1));
      myWidth = -1;
      return second;
    }

    public List<Word> getWords() {
      return ListSequence.fromListWithValues(new ArrayList<Word>(), myWords);
    }

    public boolean isEmpty() {
      return ListSequence.fromList(myWords).isEmpty();
    }

    public void setIsWrap(boolean isWrap) {
      myIsWrap = isWrap;
      myWidth = -1;
    }

    public int getLineIndent() {
      if (myIsWrap) {
        return getIndentAfterWrap(getIndentLevel());
      } else {
        return getIndentSize(getIndentLevel());
      }
    }

    public int getIndentLevel() {
      if (ListSequence.fromList(myWords).isEmpty()) {
        return 0;
      }
      return ListSequence.fromList(myWords).first().getIndentLevel();
    }
  }

  public class Word {
    private ILayoutable myLayoutable;
    private Size mySize;
    private int myAscent;
    private int myTreeDepth;
    private int myIndentLevel;
    private int myMaxWidth;

    public Word(ILayoutable layoutable, Size size, int depth, int indentLevel, int maxWidth) {
      myLayoutable = layoutable;
      mySize = size;
      myAscent = layoutable.getAscent(size);
      myTreeDepth = depth;
      myIndentLevel = indentLevel;
      myMaxWidth = maxWidth;
    }

    @Override
    public String toString() {
      return myLayoutable.toString();
    }

    public void update(int widthConstraint) {
      mySize = SizeExtensions.zeroIfOverflow(myLayoutable.getPreferredSize(Size.limitedWidth(widthConstraint)), myLayoutable);
      myAscent = myLayoutable.getAscent(mySize);
    }

    public void setLayoutable(ILayoutable layoutable) {
      myLayoutable = layoutable;
    }

    public int getWidth() {
      return mySize.getWidth();
    }

    public void setWidth(int width) {
      mySize = mySize.deriveWidth(width);
    }

    public void addWidth(int width) {
      setWidth(getWidth() + width);
    }

    public int getHeight() {
      return mySize.getHeight();
    }

    public int getAscent() {
      return myAscent;
    }

    public int getDescent() {
      return getHeight() - getAscent();
    }

    public void applyLayout(int x, int y) {
      myLayoutable.setBounds(x, y, getWidth(), getHeight());
      myLayoutable.relayout(mySize);
    }

    public int getTreeDepth() {
      return myTreeDepth;
    }

    public int getIndentLevel() {
      return myIndentLevel;
    }

    public ILayoutable getLayoutable() {
      return myLayoutable;
    }

    public int getMaxWidth() {
      return myMaxWidth;
    }
  }
  private static int check_81docr_a6a42(Line checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAscent();
    }
    return 0;
  }
  private static ILayouter check_81docr_a0a0cb(ILayoutableContainer checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLayouter();
    }
    return null;
  }
}

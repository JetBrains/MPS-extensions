package com.mbeddr.mpsutil.grammarcells.runtime.insertpopup;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.cells.ReadOnlyUtil;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import java.util.Iterator;
import jetbrains.mps.nodeEditor.cells.EditorCell_Component;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import jetbrains.mps.nodeEditor.ChildrenCollectionFinder;
import jetbrains.mps.nodeEditor.cells.APICellAdapter;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.nodeEditor.cellMenu.TransformationMenuSubstituteInfo;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuLookup;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.editor.menus.transformation.DefaultTransformationMenuLookup;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.lang.editor.menus.transformation.MenuLocations;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import jetbrains.mps.openapi.editor.cells.CellAction;
import java.util.HashSet;
import com.intellij.openapi.ui.popup.util.BaseListPopupStep;
import com.intellij.openapi.ui.popup.ListPopup;
import com.intellij.openapi.ui.popup.JBPopupFactory;
import java.awt.Point;
import com.intellij.ui.awt.RelativePoint;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.util.SNodeOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNode;

public class EditorActionUtils {
  public EditorActionUtils() {
  }
  public static boolean isReadonlyActionEnabled(EditorComponent editorComponent) {
    return !(isPopupComponentActive(editorComponent)) && editorComponent.getSelectionManager().getSelection() != null;
  }
  public static boolean isWriteActionEnabled(EditorComponent editorComponent, Iterable<EditorCell> changingCells) {
    if (!(isReadonlyActionEnabled(editorComponent))) {
      return false;
    }
    return !(ReadOnlyUtil.isCellsReadOnlyInEditor(editorComponent, changingCells));
  }
  private static boolean isPopupComponentActive(EditorComponent editorComponent) {
    return editorComponent.getNodeSubstituteChooser().isVisible() || editorComponent.isContextAssistantFocused();
  }
  public static EditorCell getEditorCellToInsert(EditorComponent editorComponent) {
    Selection selection = editorComponent.getSelectionManager().getSelection();
    // TODO: remove this limitation
    if (!(selection instanceof SingularSelection)) {
      return null;
    }
    Iterator<EditorCell> iterator = selection.getSelectedCells().iterator();
    if (!(iterator.hasNext())) {
      return null;
    }
    EditorCell editorCell = iterator.next();
    return (editorCell instanceof EditorCell_Component ? null : editorCell);
  }
  /**
   * Expects model read lock
   */
  public static EditorCell getSiblingCollectionForInsert(@NotNull EditorCell cell, boolean forward) {
    // TODO FIXME rewrite without hasSingleRolesAtLeftBoundary, cleanup ChildrenCollectionFinder
    EditorCell nextLeaf = (forward ? CellTraversalUtil.getNextLeaf(cell) : CellTraversalUtil.getPrevLeaf(cell));

    if ((cell.isBig() || GeometryUtil.isLastPositionInBigCell(cell)) && ((forward ? hasSingleRolesAtRightBoundary(cell) : hasSingleRolesAtLeftBoundary(cell))) && nextLeaf != null) {
      // Looking for the next child collection in parents
      return new ChildrenCollectionFinder(nextLeaf, cell, forward, true).find();
    }
    return null;
  }
  /**
   * Should be executed inside write action as it reads and modifies a model,
   * and ActionHandler may want to grap command, therefore, model read won't suffice.
   */
  public static void callInsertAction(@NotNull EditorCell cell) {
    if (cell.isErrorState() && APICellAdapter.validate(cell, false, true)) {
      return;
    }
    EditorActionUtils.callAction(cell, CellActionType.INSERT, true);
  }

  /**
   * Should be executed inside write action, see {@link com.mbeddr.mpsutil.grammarcells.runtime.insertpopup.EditorActionUtils#callInsertAction(EditorCell)} for details
   */
  public static void callInsertBeforeAction(@NotNull EditorCell cell) {
    if (cell.isErrorState() && APICellAdapter.validate(cell, true, true)) {
      return;
    }
    EditorActionUtils.callAction(cell, CellActionType.INSERT_BEFORE, false);
  }


  /**
   * Should be executed inside write action as it reads and modifies a model,
   * and ActionHandler may want to grap command, therefore, model read won't suffice.
   */
  public static void callInsertPlaceholderAction(@NotNull EditorCell cell) {
    EditorActionUtils.callAction(cell, CellActionType.INSERT_PLACEHOLDER, true);
  }
  /**
   * Should be executed inside write action, see {@link com.mbeddr.mpsutil.grammarcells.runtime.insertpopup.EditorActionUtils#callInsertPlaceholderAction(EditorCell)} for details
   */
  public static void callInsertPlaceholderBeforeAction(@NotNull EditorCell cell) {
    EditorActionUtils.callAction(cell, CellActionType.INSERT_PLACEHOLDER_BEFORE, false);
  }

  private static void callAction(final EditorCell cell, final CellActionType cellAction, boolean after) {
    final jetbrains.mps.openapi.editor.EditorComponent editorComponent = cell.getEditorComponent();
    ActionHandlerImpl actionHandler = new ActionHandlerImpl(editorComponent);
    Set<CellActionExecuter> actions = SetSequence.fromSet(new LinkedHashSet<CellActionExecuter>());
    if (cell instanceof EditorCell_Label && !(isLinkCollection(cell))) {
      // The next condition is not part of MPS. It fixes a bug where an INSERT action on a property is ignored.
      if (cell.getAction(cellAction) == null || !(cell.getAction(cellAction).canExecute(cell.getContext()))) {
        // Looking for the next child collection to the right from this cell
        EditorCell cellWithRole = new ChildrenCollectionFinder(cell, after, false).find();
        if (cellWithRole == null) {
          // Looking for the next child collection in parents
          cellWithRole = getSiblingCollectionForInsert(cell, after);
        }
        if (cellWithRole != null) {
          SetSequence.fromSet(actions).addSequence(ListSequence.fromList(actionHandler.findCellActionExecuter(cellWithRole, cellAction)));
        }
      }
    }
    if (SetSequence.fromSet(actions).isEmpty()) {
      SetSequence.fromSet(actions).addSequence(ListSequence.fromList(actionHandler.findCellActionExecuter(cell, cellAction)));
    }

    List<SubstituteAction> sideTransformActions = new TransformationMenuSubstituteInfo(cell) {
      @Nullable
      @Override
      protected TransformationMenuLookup getImplicitMenuLookup(TransformationMenuContext context) {
        SAbstractConcept targetConcept = context.getNodeLocation().getContextNode().getConcept();
        return new DefaultTransformationMenuLookup(LanguageRegistry.getInstance(context.getEditorContext().getRepository()), targetConcept);
      }
      @Override
      protected String getMenuLocation() {
        return (cellAction == CellActionType.INSERT_BEFORE ? MenuLocations.LEFT_SIDE_TRANSFORM : MenuLocations.RIGHT_SIDE_TRANSFORM);
      }
    }.getMatchingActions(GrammarCellsUtil.INSERT_TRANSFORMATION_TEXT, true);
    SetSequence.fromSet(actions).addSequence(ListSequence.fromList(sideTransformActions).select((it) -> new CellActionExecuter(cell, new SubstituteActionAsCellAction(it), editorComponent.getEditorContext())));

    // remove action executors with non-unique actions
    Set<CellAction> uniqueActions = SetSequence.fromSet(new HashSet<CellAction>());
    Iterator<CellActionExecuter> itr = SetSequence.fromSet(actions).iterator();
    while (itr.hasNext()) {
      if (!(SetSequence.fromSet(uniqueActions).add(itr.next().getAction()))) {
        itr.remove();
      }
    }

    if (SetSequence.fromSet(actions).isEmpty()) {
    } else if (SetSequence.fromSet(actions).count() == 1) {
      SetSequence.fromSet(actions).first().execute();
    } else {
      int resolvedChoice = InsertPopupSettings.INSTANCE.resolve(SetSequence.fromSet(actions).select((it) -> it.toString()).toList());
      if (resolvedChoice != -1) {
        ListSequence.fromList(SetSequence.fromSet(actions).toList()).getElement(resolvedChoice).execute();
      } else {
        BaseListPopupStep<CellActionExecuter> popupStep = new InsertActionListPopupStep(SetSequence.fromSet(actions).toList());
        ListPopup createListPopup = JBPopupFactory.getInstance().createListPopup(popupStep);
        Point point = (cell == null ? new Point() : new Point(cell.getX(), cell.getY() + cell.getHeight()));
        createListPopup.show(new RelativePoint(((EditorComponent) editorComponent), point));
      }
    }
  }



  /**
   * We can use this method to determine if we should redispatch insert event to the corresponding
   * child collection below the cell returned from getNextLeaf(cell) or we should go on and insert
   * next child into a collection containing cell itself.
   * 
   * @return true if we should redispatch insert event to the next leaft cell
   */
  private static boolean hasSingleRolesAtRightBoundary(EditorCell cell) {
    if (!(hasSingleRole(cell))) {
      return false;
    }

    if (isOnRightBoundary(cell)) {
      EditorCell_Collection parentCell = cell.getParent();
      if (parentCell != null) {
        EditorCell nextLeaf = CellTraversalUtil.getNextLeaf(cell);
        if (nextLeaf != null && SNodeOperations.isAncestor(parentCell.getSNode(), nextLeaf.getSNode())) {
          return true;
        }
        return hasSingleRolesAtRightBoundary(parentCell);
      }
    }
    return true;
  }
  /**
   * We can use this method to determine if we should redispatch insert event to the corresponding 
   * child collection below the cell returned from getPrevLeaf(cell) or we should go on and insert
   * prev. child into a collection containing cell itself
   * 
   * @return true if we should redispatch insert event to the prev. leaft cell
   */
  private static boolean hasSingleRolesAtLeftBoundary(EditorCell cell) {
    if (!(hasSingleRole(cell))) {
      return false;
    }

    if (isOnLeftBoundary(cell)) {
      EditorCell_Collection parentCell = cell.getParent();
      if (parentCell != null) {
        EditorCell prevLeaf = CellTraversalUtil.getPrevLeaf(cell);
        if (prevLeaf != null && SNodeOperations.isAncestor(parentCell.getSNode(), prevLeaf.getSNode())) {
          return true;
        }
        return hasSingleRolesAtLeftBoundary((EditorCell) parentCell);
      }
    }
    return true;
  }
  public static boolean isOnLeftBoundary(EditorCell cell) {
    EditorCell prevLeaf = CellTraversalUtil.getPrevLeaf(cell);
    return prevLeaf == null || prevLeaf.getSNode() != cell.getSNode();
  }
  public static boolean isOnRightBoundary(EditorCell cell) {
    EditorCell nextLeaf = CellTraversalUtil.getNextLeaf(cell);
    return nextLeaf == null || nextLeaf.getSNode() != cell.getSNode();
  }
  private static boolean hasSingleRole(EditorCell cell) {
    SContainmentLink l = jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getContainingLink(((SNode) cell.getSNode()));
    return l != null && l.isValid() && !(l.isMultiple());
  }
  private static boolean isLinkCollection(EditorCell cell) {
    while (cell != null && !(cell.isBig())) {
      if (cell.getSRole() != null) {
        return true;
      }
      cell = cell.getParent();
    }
    return false;
  }
}

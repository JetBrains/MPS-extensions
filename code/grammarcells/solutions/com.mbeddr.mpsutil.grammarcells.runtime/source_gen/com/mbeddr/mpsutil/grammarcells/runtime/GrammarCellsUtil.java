package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import org.jetbrains.mps.util.Condition;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.openapi.editor.descriptor.ConceptEditor;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.openapi.editor.cells.CellConditions;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.openapi.editor.cells.EditorCell_Label;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.presentation.IPropertyPresentationProvider;
import jetbrains.mps.core.aspects.feedback.messages.FailingPropertyConstraintContext;
import jetbrains.mps.smodel.constraints.ConstraintsChildAndPropFacade;
import jetbrains.mps.smodel.action.NodeSubstituteActionsFactoryContext;
import jetbrains.mps.smodel.action.DefaultSChildSetter;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuContext;
import jetbrains.mps.smodel.constraints.ConstraintsCanBeFacade;
import jetbrains.mps.core.aspects.constraints.rules.kinds.ContainmentContext;
import jetbrains.mps.core.aspects.constraints.rules.kinds.CanBeAncestorContext;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;
import jetbrains.mps.nodeEditor.cells.SPropertyAccessor;
import java.util.Collections;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.HashSet;
import jetbrains.mps.nodeEditor.sidetransform.EditorCell_STHint;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class GrammarCellsUtil {
  public static final Condition<EditorCell> SYNTAX_CELL_CONDITION = (EditorCell c) -> GrammarCellsUtil.isSyntaxCell(c);
  public static final String INSERT_TRANSFORMATION_TEXT = "☆";

  @Nullable
  public static IGrammarActionsDescriptor getDescriptor(@Nullable SModule module) {
    return DescriptorCache.getInstance().getDescriptor(module);
  }

  public static List<IGrammarActionsDescriptor> getVisibleDescriptors(SModel currentModel) {
    Set<SLanguage> langs = getVisibleLanguages(currentModel);
    return SetSequence.fromSet(langs).select((it) -> getDescriptor(it.getSourceModule())).where((it) -> it != null).toList();
  }

  public static Set<SLanguage> getVisibleLanguages(SModel contextModel) {
    return VisibleLanguagesCache.getInstance().getVisibleLanguages(contextModel);
  }

  public static List<SAbstractConcept> getVisibleSubconcepts(SAbstractConcept concept, Set<SLanguage> visibleLanguages) {
    return SConceptOperations.getAllSubConcepts(concept, visibleLanguages);
  }

  public static List<SAbstractConcept> getVisibleSubconcepts(SAbstractConcept concept, SModel contextModel) {
    return getVisibleSubconcepts(concept, getVisibleLanguages(contextModel));
  }

  public static List<SConcept> getVisibleSubconceptsNonAbstract(SAbstractConcept concept, SModel contextModel) {
    return getVisibleSubconceptsNonAbstract(concept, getVisibleLanguages(contextModel));
  }
  public static List<SConcept> getVisibleSubconceptsNonAbstract(SAbstractConcept concept, Set<SLanguage> visibleLanguages) {
    List<SAbstractConcept> allSubConcepts = SConceptOperations.getAllSubConcepts(concept, visibleLanguages);
    return ListSequence.fromList(allSubConcepts).where((it) -> it instanceof SConcept && !(((SConcept) it).isAbstract())).select((it) -> ((SConcept) it)).toList();
  }

  public static List<SConcept> getVisibleSubconceptsNonAbstract(SAbstractConcept concept, SModel contextModel, Class<? extends ConceptEditor> ifEditorNotOveridden) {
    return getVisibleSubconceptsNonAbstract(concept, contextModel, ifEditorNotOveridden, null);
  }
  public static List<SConcept> getVisibleSubconceptsNonAbstract(SAbstractConcept concept, SModel contextModel, final Class<? extends ConceptEditor> ifEditorNotOveridden, EditorContext editorContext) {
    final Set<String> hints = GrammarCellsUtil.getSelectionHints(editorContext);
    return ListSequence.fromList(getVisibleSubconceptsNonAbstract(concept, getVisibleLanguages(contextModel))).where((it) -> EditorHierachyCache.getInstance().isActiveEditor(ifEditorNotOveridden, it, hints)).toList();
  }

  /**
   * 
   * @deprecated Use Parser.findRootExpression
   */
  @Deprecated
  public static SNode findRootExpression(SNode start, final SAbstractConcept expressionConcept) {
    return ListSequence.fromList(SNodeOperations.getNodeAncestors(start, null, true)).findFirst((it) -> (SNodeOperations.getParent(it) == null) || !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(it))), SNodeOperations.asSConcept(expressionConcept))));
  }

  public static void selectNextLeaf(EditorContext editorContext) {
    EditorCell selectedCell = editorContext.getSelectedCell();
    SNode selectedNode = selectedCell.getSNode();
    EditorCell nextLeaf = CellTraversalUtil.getNextLeaf(selectedCell, CellConditions.SELECTABLE);
    if (nextLeaf != null) {
      SelectionUtil.selectLabelCellAnSetCaret(editorContext, nextLeaf.getSNode(), nextLeaf.getCellId(), 0);
    } else {
      SelectionUtil.selectCell(editorContext, selectedNode, SelectionManager.FIRST_CELL);
    }
  }

  public static void selectPrevLeaf(EditorContext editorContext) {
    EditorCell selectedCell = editorContext.getSelectedCell();
    SNode selectedNode = selectedCell.getSNode();
    EditorCell prevLeaf = CellTraversalUtil.getPrevLeaf(selectedCell, CellConditions.SELECTABLE);
    if (prevLeaf != null) {
      SelectionUtil.selectLabelCellAnSetCaret(editorContext, prevLeaf.getSNode(), prevLeaf.getCellId(), -1);
    } else {
      SelectionUtil.selectCell(editorContext, selectedNode, SelectionManager.FIRST_CELL);
    }
  }

  public static void selectPrevNextOnSameLine(EditorContext editorContext, boolean next) {
    EditorCell selectedCell = editorContext.getSelectedCell();
    EditorCell leaf = (next ? CellTraversalUtil.getNextLeaf(selectedCell, CellConditions.SELECTABLE) : CellTraversalUtil.getPrevLeaf(selectedCell, CellConditions.SELECTABLE));
    if (isDifferentLine(selectedCell, leaf)) {
      next = !(next);
    }
    if (next) {
      selectNextLeaf(editorContext);
    } else {
      selectPrevLeaf(editorContext);
    }
  }

  protected static boolean isDifferentLine(EditorCell cell1, EditorCell cell2) {
    if (cell1 == null || cell2 == null) {
      return false;
    }
    return cell1.getY() >= cell2.getY() + cell2.getHeight() || cell2.getY() >= cell1.getY() + cell2.getHeight();
  }

  public static void selectCellWithText(EditorContext editorContext, SNode node, String text) {
    editorContext.flushEvents();
    EditorCell nodeCell = editorContext.getEditorComponent().findNodeCell(node);
    if (nodeCell == null) {
      return;
    }

    EditorCell leaf = CellTraversalUtil.getFirstLeaf(nodeCell);
    while (leaf != null) {
      if (leaf.getSNode() == node && leaf instanceof EditorCell_Label && Objects.equals(((EditorCell_Label) leaf).getText(), text)) {
        editorContext.getSelectionManager().setSelection(node, leaf.getCellId(), -1);
        return;
      }
      leaf = CellTraversalUtil.getNextLeaf(leaf);
    }
  }

  public static String getSubstitutionText(SAbstractConcept concept) {
    String alias = SConceptOperations.conceptAlias(concept);
    if ((alias != null && alias.length() > 0)) {
      return alias;
    }
    return concept.getName();
  }

  public static SNode getListElementForSideTransformation(SNode currentNode, SContainmentLink link, boolean leftSide) {
    return getListElementForSideTransformation(currentNode, link, link.getOwner(), link.getTargetConcept(), leftSide);
  }

  public static SNode getListElementForSideTransformation(SNode currentNode, SContainmentLink link, SAbstractConcept parentConcept, SAbstractConcept childConcept, boolean leftSide) {
    if (SNodeOperations.isInstanceOf(currentNode, SNodeOperations.asSConcept(childConcept)) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(currentNode), SNodeOperations.asSConcept(parentConcept)) && Objects.equals(currentNode.getContainmentLink(), link)) {
      return currentNode;
    }

    SNode listElement = new Parser(SNodeOperations.getModel(currentNode)).isEndOf(currentNode, leftSide, childConcept, null);
    if (SNodeOperations.isInstanceOf(listElement, SNodeOperations.asSConcept(childConcept)) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(listElement), SNodeOperations.asSConcept(parentConcept)) && Objects.equals(listElement.getContainmentLink(), link)) {
      return listElement;
    }

    return null;
  }

  public static boolean isValidPropertyValue(SProperty property, @Nullable SAbstractConcept concept, String value) {
    Object internalValue = IPropertyPresentationProvider.getPresentationProviderFor(property).fromPresentation(value);
    SNode dummyNode = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(concept));
    FailingPropertyConstraintContext c = new FailingPropertyConstraintContext(dummyNode, property, internalValue);
    return ConstraintsChildAndPropFacade.checkPropertyValue(c).isEmpty();
  }

  public static String toInternalPropertyValue(SProperty property, String value) {
    Object internalValue = IPropertyPresentationProvider.getPresentationProviderFor(property).fromPresentation(value);
    return property.getType().toString(internalValue);
  }

  public static String toInternalPropertyValueString(SProperty property, String value) {
    Object internalValue = IPropertyPresentationProvider.getPresentationProviderFor(property).fromPresentation(value);
    return property.getType().toString(internalValue);
  }

  public static String fromInternalPropertyValue(SProperty property, String internalValue) {
    return IPropertyPresentationProvider.getPresentationProviderFor(property).getPresentation(internalValue);
  }

  public static SContainmentLink getLinkFromSubstituteContext(final NodeSubstituteActionsFactoryContext context) {
    SNode currentTargetNode = context.getCurrentTargetNode();
    if (currentTargetNode != null) {
      return currentTargetNode.getContainmentLink();
    }
    if (context.getChildSetter() instanceof DefaultSChildSetter) {
      return ((DefaultSChildSetter) context.getChildSetter()).getLink();
    }
    return null;
  }

  public static boolean canBeChild(SAbstractConcept childConcept, final SubstituteMenuContext context) {
    SContainmentLink slink = context.getLink();
    if (slink == null) {
      return true;
    }
    SNode parentNode = context.getParentNode();
    if (!(ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(parentNode).childConcept(childConcept).link(slink).build()).isEmpty())) {
      return false;
    }
    if (!(ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(parentNode).childConcept(childConcept).link(slink).build()).isEmpty())) {
      return false;
    }
    if (!(canBeAncestor(parentNode, childConcept, slink))) {
      return false;
    }
    return true;
  }

  public static boolean canBeChildForSubstitute(SAbstractConcept parentConcept, final SubstituteMenuContext context, SAbstractConcept substituteConcept, SContainmentLink conceptLink) {
    SContainmentLink slink = context.getLink();
    if (slink == null) {
      return true;
    }
    SNode dummyParent = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(parentConcept));
    SNode dummyChild = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(substituteConcept));
    dummyParent.addChild(conceptLink, dummyChild);

    ContainmentContext build = new ContainmentContext.Builder().parentNode(dummyParent).childNode(dummyChild).childConcept(substituteConcept).link(conceptLink).build();
    boolean canBeChild = ConstraintsCanBeFacade.checkCanBeChild(build).isEmpty();
    boolean canBeParent = ConstraintsCanBeFacade.checkCanBeParent(build).isEmpty();
    boolean canBeAncestor = canBeAncestorForSubstitute(dummyParent, dummyChild, conceptLink);
    if (!(canBeChild)) {
      return false;
    }
    if (!(canBeParent)) {
      return false;
    }
    if (!(canBeAncestor)) {
      return false;
    }
    return true;
  }


  public static boolean canBeAncestor(SNode parentNode, SAbstractConcept childConcept, SContainmentLink slink) {
    SNode ancestorNode = parentNode;
    while (ancestorNode != null) {
      boolean canBe = ConstraintsCanBeFacade.checkCanBeAncestor(new CanBeAncestorContext.Builder().ancestorNode(ancestorNode).parentNode(parentNode).childConcept(childConcept).link(slink).build()).isEmpty();
      if (!(canBe)) {
        return false;
      }
      ancestorNode = ancestorNode.getParent();
    }
    return true;
  }

  public static boolean canBeAncestorForSubstitute(SNode parentNode, SNode childNode, SContainmentLink link) {
    SNode ancestorNode = parentNode;
    while (ancestorNode != null) {
      boolean canBe = ConstraintsCanBeFacade.checkCanBeAncestor(new CanBeAncestorContext.Builder().ancestorNode(ancestorNode).parentNode(parentNode).descendantNode(childNode).childConcept(childNode.getConcept()).link(link).build()).isEmpty();
      if (!(canBe)) {
        return false;
      }
      ancestorNode = ancestorNode.getParent();
    }
    return true;
  }

  public static SAbstractConcept getSpecializedTargetConcept(SContainmentLink genuineLink, SAbstractConcept owner) {
    if (genuineLink == null) {
      return null;
    }
    if (Objects.equals(genuineLink.getOwner(), owner)) {
      return genuineLink.getTargetConcept();
    }
    final SNode linkDecl = genuineLink.getDeclarationNode();
    SNode conceptDecl = SNodeOperations.asNode(owner);
    SNode specializedLink = ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getLinkDeclarations_idhEwILKK.invoke(conceptDecl)).findFirst((it) -> SLinkOperations.getTarget(it, LINKS.specializedLink$7ZCN) == linkDecl);
    if ((specializedLink != null)) {
      return SNodeOperations.asSConcept(SLinkOperations.getTarget(specializedLink, LINKS.target$m40F));
    }
    return genuineLink.getTargetConcept();
  }

  public static SAbstractConcept getExpectedOutputConcept(final SubstituteMenuContext _context, SAbstractConcept expectedOutputConceptExactly) {
    if (_context.getTargetConcept() != null) {
      return _context.getTargetConcept();
    }

    SContainmentLink link = _context.getLink();
    if (link != null) {
      return GrammarCellsUtil.getSpecializedTargetConcept(link, _context.getParentNode().getConcept());
    }

    link = check_1c6hsm_a0f0gc(_context.getCurrentTargetNode());
    if (link != null) {
      SAbstractConcept targetConcept = link.getTargetConcept();

      if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(expectedOutputConceptExactly), SNodeOperations.asSConcept(targetConcept))) {
        return targetConcept;
      }
    }

    return expectedOutputConceptExactly;
  }

  public static boolean isExactly(SAbstractConcept c1, SAbstractConcept c2) {
    // there is a bug in MPS when you use node.concept.isExactly with interfaces (returns always false)
    if (c1 != null && c2 != null) {
      return Objects.equals(c1.getName(), c2.getName()) && Objects.equals(c1.getLanguage(), c2.getLanguage());
    } else {
      return false;
    }
  }

  public static boolean isProperty(EditorCell cell) {
    if (!(cell instanceof EditorCell_Property)) {
      return false;
    }
    EditorCell_Property pcell = ((EditorCell_Property) cell);
    ModelAccessor accessor = pcell.getModelAccessor();
    if (accessor == null) {
      return false;
    }
    return accessor instanceof PropertyAccessor || accessor instanceof SPropertyAccessor;
  }

  public static Set<String> getSelectionHints(EditorContext editorContext) {
    if (editorContext == null) {
      return Collections.<String>emptySet();
    }
    EditorCell cell = editorContext.getSelectedCell();
    if (cell == null) {
      return Collections.<String>emptySet();
    }
    String[] hints = ((EditorComponent) editorContext.getEditorComponent()).getEditorHintsForNode(cell.getSNode());
    return SetSequence.fromSetAndArray(new HashSet<String>(), hints);
  }

  public static boolean isSyntaxCell(EditorCell cell) {
    if (cell instanceof EditorCell_STHint) {
      return false;
    }
    if (cell instanceof SideTransformationHolderCell) {
      return false;
    }
    if (cell instanceof EditorCell_Label && !(cell.getStyle().get(StyleAttributes.SELECTABLE))) {
      // this is probably just some additional information that is not part of the syntax
      return false;
    }
    return true;
  }

  public static Iterable<EditorCell> getUnwrappedChildren(EditorCell parent) {
    if (parent instanceof EditorCell_Collection) {
      Iterable<EditorCell> children = ((EditorCell_Collection) parent);
      return Sequence.fromIterable(children).translate((child) -> {
        if (isNonSyntaxWrapper(child)) {
          return getUnwrappedChildren(child);
        } else {
          return Sequence.<EditorCell>singleton(child);
        }
      });
    } else {
      return Collections.emptyList();
    }
  }

  public static boolean isNonSyntaxWrapper(EditorCell cell) {
    if (cell.getSNode().isInstanceOfConcept(CONCEPTS.Attribute$g1)) {
      return true;
    }
    return false;
  }

  public static String getDescriptionForContainmentLink(SContainmentLink link) {
    StringBuilder builder = new StringBuilder();
    SAbstractConcept targetConcept = link.getTargetConcept();
    builder.append((isNotEmptyString(targetConcept.getConceptAlias()) ? targetConcept.getConceptAlias() : targetConcept.getName()));
    builder.append(" (");
    builder.append(link.getName());
    builder.append(") – optional");
    return builder.toString();
  }
  private static SContainmentLink check_1c6hsm_a0f0gc(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getContainmentLink();
    }
    return null;
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink specializedLink$7ZCN = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98051c244L, "specializedLink");
    /*package*/ static final SReferenceLink target$m40F = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, "target");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
  }
}

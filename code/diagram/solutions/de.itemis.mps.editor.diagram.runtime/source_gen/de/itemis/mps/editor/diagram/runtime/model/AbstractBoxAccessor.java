package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import de.itemis.mps.editor.diagram.runtime.shape.IShape;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.awt.geom.AffineTransform;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public abstract class AbstractBoxAccessor extends BoxBaseAccessor implements IBoxAccessor {

  public AbstractBoxAccessor(IAccessorKey id) {
    super(id);
  }

  @Override
  public void delete() {
  }

  @Nullable
  @Override
  public SNode getSNode() {
    return null;
  }

  @Override
  public IShape getShape() {
    return null;
  }

  @NotNull
  @Override
  public List<Port> getPorts() {
    return new ArrayList<Port>();
  }

  @NotNull
  protected SNode getOrCreateLayoutData() {
    return SNodeOperations.cast(getOrCreateLayoutData(CONCEPTS.Layout_Box$XH), CONCEPTS.Layout_Box$XH);
  }

  @Override
  public void writeLayout(Box box) {
    SNode data = getOrCreateLayoutData();
    if (data == null) {
      data = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x8ca79d43eb454791L, 0xbdd40d6130ff895bL, 0x5d43fef24d2a502eL, "de.itemis.mps.editor.diagram.layout.structure.Layout_Box"));
    }
    myDiagramAccessor.storeLayoutData(getId(), data);
    writeLayout(data, box);
  }

  @Override
  public void readLayout(Box box, Bounds defaultBounds) {
    SNode data = SNodeOperations.as(myDiagramAccessor.getLayoutData(getId()), CONCEPTS.Layout_Box$XH);
    readLayout(data, box, defaultBounds);
  }

  protected void readLayout(@Nullable SNode data, Box box, Bounds defaultBounds) {
    if (data != null) {
      Bounds bounds = readBounds(data);
      box.setBounds(bounds);
      AffineTransform transform = SerializeUtil.deserializeAffineTransform(SPropertyOperations.getString(data, PROPS.portTransform$4BUA));
      box.setTransform(transform);
    } else {
      box.setBounds(defaultBounds);
      box.setTransform(null);
    }

    Map<String, Port> portMap = MapSequence.fromMap(new HashMap<String, Port>());
    for (Port port : ListSequence.fromList(box.getPorts())) {
      MapSequence.fromMap(portMap).put(port.getName(), port);
    }
    for (SNode layout : ListSequence.fromList(SLinkOperations.getChildren(data, LINKS.portLayouts$aLr5))) {
      Port port = MapSequence.fromMap(portMap).get(SPropertyOperations.getString(layout, PROPS.portName$4zIg));
      if (port != null) {
        port.setOrdinal(SPropertyOperations.getInteger(layout, PROPS.ordinal$cmw7));
      }
    }

  }

  protected void writeLayout(SNode data, Box box) {
    Bounds bounds = box.getBounds();
    AffineTransform portTransform = box.getPortTransform();
    List<Port> ports = box.getPorts();
    String serializedPortTransform = SerializeUtil.serializeAffineTransform(portTransform);
    writeBounds(bounds, data);
    if (!(Objects.equals(serializedPortTransform, SPropertyOperations.getString(data, PROPS.portTransform$4BUA)))) {
      SPropertyOperations.assign(data, PROPS.portTransform$4BUA, serializedPortTransform);
    }

    // port positions
    final Map<String, SNode> portLayouts = MapSequence.fromMap(new HashMap<String, SNode>());
    ListSequence.fromList(SLinkOperations.getChildren(data, LINKS.portLayouts$aLr5)).visitAll((it) -> MapSequence.fromMap(portLayouts).put(SPropertyOperations.getString(it, PROPS.portName$4zIg), it));
    for (Port port : ListSequence.fromList(ports)) {
      int ordinal = port.getOrdinal();
      if (ordinal != 0) {
        SNode layout = MapSequence.fromMap(portLayouts).get(port.getName());
        if ((layout == null)) {
          layout = SLinkOperations.addNewChild(data, LINKS.portLayouts$aLr5, null);
          SPropertyOperations.assign(layout, PROPS.portName$4zIg, port.getName());
        }
        if (SPropertyOperations.getInteger(layout, PROPS.ordinal$cmw7) != ordinal) {
          SPropertyOperations.assign(layout, PROPS.ordinal$cmw7, ordinal);
        }
        MapSequence.fromMap(portLayouts).removeKey(port.getName());
      }
    }
    for (SNode unused : Sequence.fromIterable(MapSequence.fromMap(portLayouts).values())) {
      SNodeOperations.deleteNode(unused);
    }
  }

  @Override
  public boolean isPreservePortOrder() {
    return false;
  }

  @Override
  public boolean allowConnectionsToBox() {
    List<Port> ports = getPorts();
    return ports == null || ports.isEmpty();
  }

  @NotNull
  @Override
  public Iterable<SNode> getNavigationTargets() {
    return Sequence.fromIterable(Collections.<SNode>emptyList());
  }

  @Override
  public boolean allowScaling() {
    return true;
  }

  @Override
  public boolean annotationExternal(SNode annotationNode) {
    return false;
  }

  @Override
  public boolean canDrop(Object data) {
    return false;
  }

  @Override
  public void drop(Object data) {
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Layout_Box$XH = MetaAdapterFactory.getConcept(0x8ca79d43eb454791L, 0xbdd40d6130ff895bL, 0x5d43fef24d2a502eL, "de.itemis.mps.editor.diagram.layout.structure.Layout_Box");
  }

  private static final class PROPS {
    /*package*/ static final SProperty portTransform$4BUA = MetaAdapterFactory.getProperty(0x8ca79d43eb454791L, 0xbdd40d6130ff895bL, 0x5d43fef24d2a502eL, 0x3f9be62006da33d8L, "portTransform");
    /*package*/ static final SProperty portName$4zIg = MetaAdapterFactory.getProperty(0x8ca79d43eb454791L, 0xbdd40d6130ff895bL, 0xa40cc6a5368f8a1L, 0xa40cc6a5368f8c3L, "portName");
    /*package*/ static final SProperty ordinal$cmw7 = MetaAdapterFactory.getProperty(0x8ca79d43eb454791L, 0xbdd40d6130ff895bL, 0xa40cc6a5368f8a1L, 0x6e884ec9fe5541edL, "ordinal");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink portLayouts$aLr5 = MetaAdapterFactory.getContainmentLink(0x8ca79d43eb454791L, 0xbdd40d6130ff895bL, 0x5d43fef24d2a502eL, 0xa40cc6a53695c20L, "portLayouts");
  }
}

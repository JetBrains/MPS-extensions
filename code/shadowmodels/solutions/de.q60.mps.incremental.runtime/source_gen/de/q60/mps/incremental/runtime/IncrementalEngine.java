package de.q60.mps.incremental.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import de.q60.mps.incremental.util.ContextValue;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import gnu.trove.set.hash.THashSet;
import java.util.concurrent.atomic.AtomicBoolean;
import de.q60.mps.util.invalidation.Invalidatable;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.intellij.openapi.application.ApplicationManager;

public class IncrementalEngine {
  private static final Logger LOG = Logger.getLogger(IncrementalEngine.class);
  public static final ContextValue<IncrementalEngine> CONTEXT_ENGINE = new ContextValue<IncrementalEngine>();

  private IncrementalData data = new IncrementalData(this);
  private List<IInvalidationListener> invalidationListeners = ListSequence.fromList(new ArrayList<IInvalidationListener>());
  private IDependencyListener dependencyListener = new IDependencyListener() {
    public void dependencyAccessed(DependencyKey dep) {
    }
    @Override
    public void dependenciesChanged(Iterable<DependencyKey> deps) {
      if (dependencyListenerMuted) {
        return;
      }
      invalidate(deps);
    }
  };
  private List<Object> activeEvaluations = ListSequence.fromList(new ArrayList<Object>());
  private final Set<DependencyKey> pendingInvalidations = new THashSet<DependencyKey>();
  private final AtomicBoolean invalidateAllPending = new AtomicBoolean(false);
  private AtomicBoolean asyncInvalidation = new AtomicBoolean(false);
  private boolean dependencyListenerMuted = false;
  private Invalidatable invalidatable = new Invalidatable("Incremental Engine", () -> invalidateAll());
  private Set<WatchedEntry> watchedEntries = SetSequence.fromSet(new HashSet<WatchedEntry>());
  private AtomicBoolean isComputingInvalidDeps = new AtomicBoolean(false);
  private boolean useInvalidDependencyRecomputation = false;

  public IncrementalEngine() {
    DependencyBroadcaster.INSTANCE.addListener(dependencyListener);
  }

  public void useInvalidDependencyRecomputation(boolean value) {
    // this is performance optimization that can reuse cache entries if a dependency evaluates to the same value as before
    useInvalidDependencyRecomputation = value;
  }

  public synchronized void setAsyncInvalidation(boolean async) {
    if (asyncInvalidation.compareAndSet(!(async), async)) {
      if (!(async)) {
        flushInvalidations();
      }
    }
  }

  public boolean hasPendingInvalidations() {
    if (invalidateAllPending.get()) {
      return true;
    }
    synchronized (pendingInvalidations) {
      return SetSequence.fromSet(pendingInvalidations).isNotEmpty();
    }
  }

  public synchronized void flushInvalidations() {
    if (invalidateAllPending.getAndSet(false)) {
      doInvalidateAll();
      return;
    }
    List<DependencyKey> changes;
    synchronized (pendingInvalidations) {
      if (SetSequence.fromSet(pendingInvalidations).isEmpty()) {
        return;
      }
      changes = ListSequence.fromListWithValues(new ArrayList<DependencyKey>(), pendingInvalidations);
      SetSequence.fromSet(pendingInvalidations).clear();
    }
    if (ListSequence.fromList(changes).isNotEmpty()) {
      doInvalidate(changes);
    }
  }

  public void dispose() {
    invalidatable.dispose();
    DependencyBroadcaster.INSTANCE.removeListener(dependencyListener);
  }

  public void invalidateAll() {
    if (asyncInvalidation.get()) {
      invalidateAllPending.set(true);
    } else {
      doInvalidateAll();
    }
  }

  protected synchronized void doInvalidateAll() {
    data.clear();
    synchronized (pendingInvalidations) {
      SetSequence.fromSet(pendingInvalidations).clear();
    }
    ListSequence.fromList(invalidationListeners).visitAll((it) -> it.invalidatedAll());
  }

  public void invalidate(Iterable<DependencyKey> changes) {
    if (asyncInvalidation.get()) {
      synchronized (pendingInvalidations) {
        SetSequence.fromSet(pendingInvalidations).addSequence(Sequence.fromIterable(changes));
      }
    } else {
      doInvalidate(changes);
    }
  }

  protected synchronized void doInvalidate(Iterable<DependencyKey> changes) {
    final Set<Object> invalidatedKeys = data.invalidate(changes);
    List<DependencyKey> cacheValueEvents = SetSequence.fromSet(invalidatedKeys).select((it) -> {
      DependencyKey dep = new CachedValueDependency(it, IncrementalEngine.this);
      return dep;
    }).toList();
    if (ListSequence.fromList(cacheValueEvents).isNotEmpty()) {
      boolean wasMuted = dependencyListenerMuted;
      try {
        dependencyListenerMuted = true;
        DependencyBroadcaster.INSTANCE.dependenciesChanged(cacheValueEvents);
      } finally {
        dependencyListenerMuted = wasMuted;
      }
    }
    if (SetSequence.fromSet(invalidatedKeys).isNotEmpty()) {
      for (IInvalidationListener l : ListSequence.fromList(invalidationListeners)) {
        try {
          l.invalidated(invalidatedKeys);
        } catch (Exception ex) {
          if (LOG.isErrorLevel()) {
            LOG.error("Exception in IInvalidationListener " + l, ex);
          }
        }
      }
    }
    SetSequence.fromSet(watchedEntries).where(new _FunctionTypes._return_P1_E0<Boolean, WatchedEntry>() {
      public Boolean invoke(WatchedEntry it) {
        return SetSequence.fromSet(invalidatedKeys).contains(it.incrementalComputable.key);
      }
    }).visitAll(new _FunctionTypes._void_P1_E0<WatchedEntry>() {
      public void invoke(WatchedEntry it) {
        it.notifyListener();
      }
    });
  }

  public void addInvalidationListener(IInvalidationListener l) {
    List<IInvalidationListener> newListeners = ListSequence.fromListWithValues(new ArrayList<IInvalidationListener>(), invalidationListeners);
    ListSequence.fromList(newListeners).addElement(l);
    invalidationListeners = newListeners;
  }

  public void removeInvalidationListener(IInvalidationListener l) {
    List<IInvalidationListener> newListeners = ListSequence.fromListWithValues(new ArrayList<IInvalidationListener>(), invalidationListeners);
    ListSequence.fromList(newListeners).removeElement(l);
    invalidationListeners = newListeners;
  }

  public synchronized <T> T evaluate(final Object key, final _FunctionTypes._return_P0_E0<? extends T> computable) {
    DependencyBroadcaster.INSTANCE.dependencyAccessed(new CachedValueDependency(key, this));
    if (CONTEXT_ENGINE.getValue() == null) {
      return CONTEXT_ENGINE.computeWith(this, () -> doEvaluate(key, computable));
    } else {
      return doEvaluate(key, computable);
    }
  }

  public <T> IWatchedOutput<T> watch(Object key, _FunctionTypes._return_P0_E0<? extends T> function) {
    WatchedEntry<T> entry = new WatchedEntry<T>(new IncrementalComputable<T>(key, function));
    SetSequence.fromSet(watchedEntries).addElement(entry);
    return entry;
  }

  private <T> T doEvaluate(final Object key, final _FunctionTypes._return_P0_E0<? extends T> computable) {
    IncrementalData.CacheEntry<T> cacheEntry = data.getCacheEntry(key);
    if (cacheEntry != null) {
      if (cacheEntry.isValid()) {
        return cacheEntry.getValue();
      } else if (cacheEntry.onlyDependenciesInvalid() && useInvalidDependencyRecomputation) {
        boolean wasComputingInvalidDeps = isComputingInvalidDeps.getAndSet(true);
        try {
          for (IncrementalData.CacheEntry<?> invalidDep : ListSequence.fromList(cacheEntry.getInvalidDependencies())) {
            doEvaluate(invalidDep.getKey(), invalidDep.getFunction());
          }
          cacheEntry.updateStatus();
          if (cacheEntry.isValid()) {
            return cacheEntry.getValue();
          }
        } catch (DependencyCycleException ex) {
          // continue with recomputing the entry
        } finally {
          isComputingInvalidDeps.set(wasComputingInvalidDeps);
        }
      }
    }

    T value;
    Set<DependencyKey> dependencies;
    {
      Tuples._2<T, Set<DependencyKey>> _tmp_oghiry_f0rb = cycleProtection(key, () -> evaluateWithTracking(key, computable));
      value = _tmp_oghiry_f0rb._0();
      dependencies = _tmp_oghiry_f0rb._1();
    }
    data.putEntry(key, value, computable, dependencies);
    return value;
  }

  public <T> T evaluate(IncrementalComputable<T> computable) {
    return evaluate(computable.key, computable.computable);
  }

  protected synchronized <T> T cycleProtection(Object key, final _FunctionTypes._return_P0_E0<? extends T> computable) {
    if (ListSequence.fromList(activeEvaluations).contains(key)) {
      throw new DependencyCycleException(activeEvaluations, key, isComputingInvalidDeps.get());
    }
    ListSequence.fromList(activeEvaluations).addElement(key);
    try {
      return computable.invoke();
    } finally {
      ListSequence.fromList(activeEvaluations).removeLastElement();
    }
  }

  protected final Set<DependencyKey> lostDependencies = new THashSet<DependencyKey>();
  protected <T> Tuples._2<T, Set<DependencyKey>> evaluateWithTracking(final Object key, final _FunctionTypes._return_P0_E0<? extends T> computable) {
    final Set<DependencyKey> collectedDeps = new THashSet<DependencyKey>();
    try {
      T computedValue = DependencyBroadcaster.INSTANCE.evaluateWithTracking(() -> {
        T r = computable.invoke();
        if (SetSequence.fromSet(lostDependencies).isNotEmpty()) {
          SetSequence.fromSet(collectedDeps).addSequence(SetSequence.fromSet(lostDependencies));
          SetSequence.fromSet(lostDependencies).clear();
        }
        return r;
      }, (DependencyKey dep) -> SetSequence.fromSet(collectedDeps).addElement(dep));
      return MultiTuple.<T,Set<DependencyKey>>from(computedValue, collectedDeps);
    } catch (RuntimeException ex) {
      SetSequence.fromSet(lostDependencies).addSequence(SetSequence.fromSet(collectedDeps));
      throw ex;
    }
  }

  private class WatchedEntry<T> implements IWatchedOutput<T> {
    private IncrementalComputable<T> incrementalComputable;
    private _FunctionTypes._void_P1_E0<? super T> listener;
    public WatchedEntry(IncrementalComputable<T> incrementalComputable) {
      this.incrementalComputable = incrementalComputable;
    }
    private T getOutput() {
      return evaluate(incrementalComputable);
    }
    @Override
    public void stop() {
      if (!(SetSequence.fromSet(watchedEntries).contains(this))) {
        throw new IllegalStateException("Already stopped");
      }
      SetSequence.fromSet(watchedEntries).removeElement(this);
      this.listener = null;
    }
    @Override
    public void listen(_FunctionTypes._void_P1_E0<? super T> listener) {
      if (this.listener != null) {
        throw new IllegalStateException("Only one listener is supported");
      }
      if (!(SetSequence.fromSet(watchedEntries).contains(this))) {
        throw new IllegalStateException("Already stopped");
      }
      this.listener = listener;
      notifyListener();
    }
    private void notifyListener() {
      ApplicationManager.getApplication().executeOnPooledThread(() -> listener.invoke(getOutput()));
    }
  }
}

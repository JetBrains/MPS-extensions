package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.modelix.model.api.INode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.q60.mps.polymorphicfunctions.runtime.ParameterList;

public class DependencyTrackingCheck {

  private static Map<Class, _FunctionTypes._void_P1_E0<? super Object>> checkers = MapSequence.fromMap(new HashMap<Class, _FunctionTypes._void_P1_E0<? super Object>>());

  static {
    DependencyTrackingCheck.registerChecker(INode.class, (INode o) -> {
      if (!(o instanceof DependencyTrackingNode)) {
        DependencyTrackingCheck.report(o);
      }
    });
    DependencyTrackingCheck.registerChecker(MappingLabelCall.class, (MappingLabelCall o) -> ListSequence.fromList(o.getInput()).visitAll((it) -> DependencyTrackingCheck.check(it)));
    DependencyTrackingCheck.registerChecker(IContainmentTarget.class, (IContainmentTarget o) -> Sequence.fromIterable(o.getInputNodes()).visitAll((it) -> DependencyTrackingCheck.check(it)));
    DependencyTrackingCheck.registerChecker(IUniqueContainmentTarget.class, new _FunctionTypes._void_P1_E0<IUniqueContainmentTarget>() {
      public void invoke(IUniqueContainmentTarget o) {
        DependencyTrackingCheck.check(o.getTarget());
      }
    });
    DependencyTrackingCheck.registerChecker(ContainmentTargetRootNodes.class, new _FunctionTypes._void_P1_E0<ContainmentTargetRootNodes>() {
      public void invoke(ContainmentTargetRootNodes o) {
        DependencyTrackingCheck.check(o.getContainmentTarget());
        DependencyTrackingCheck.check(o.getStageRef());
      }
    });
    DependencyTrackingCheck.registerChecker(IStageReference.class, (IStageReference o) -> {
      if (o.getSubgraphRef() == o) {
        return;
      }
      DependencyTrackingCheck.check(o.getSubgraphRef());
    });
    DependencyTrackingCheck.registerChecker(ISubgraphRef.class, (ISubgraphRef o) -> Sequence.fromIterable(o.getInputNodes()).visitAll((it) -> DependencyTrackingCheck.check(it)));
    DependencyTrackingCheck.registerChecker(ParameterList.class, (ParameterList o) -> Sequence.fromIterable(o.asSequence()).visitAll((it) -> DependencyTrackingCheck.check(it)));
  }

  public static <T> void registerChecker(Class<T> cls, _FunctionTypes._void_P1_E0<? super T> checker) {
    MapSequence.fromMap(checkers).put(cls, (_FunctionTypes._void_P1_E0<? super Object>) checker);
  }

  public static void check(Object o) {
    if (o == null) {
      return;
    }
    check(o, o.getClass());
  }

  public static void check(Object o, Class cls) {
    if (o == null) {
      return;
    }
    if (cls == null) {
      return;
    }
    _FunctionTypes._void_P1_E0<? super Object> checker = MapSequence.fromMap(checkers).get(cls);
    if (checker != null) {
      checker.invoke(o);
    }
    check(o, cls.getSuperclass());
    for (Class<?> intfc : cls.getInterfaces()) {
      check(o, intfc);
    }
  }

  public static void report(Object o) {
    throw new RuntimeException("Read tracking missing: " + o);
  }
}

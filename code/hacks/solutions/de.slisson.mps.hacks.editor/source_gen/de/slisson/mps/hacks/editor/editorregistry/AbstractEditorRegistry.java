package de.slisson.mps.hacks.editor.editorregistry;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.descriptor.BaseConceptEditor;
import jetbrains.mps.logging.Logger;
import java.util.Comparator;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import java.util.Collection;
import org.jetbrains.mps.util.BreadthConceptHierarchyIterator;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.openapi.editor.descriptor.EditorAspectDescriptor;
import jetbrains.mps.internal.collections.runtime.SetSequence;

/**
 * User: shatalin
 * Date: 5/14/13
 */
public abstract class AbstractEditorRegistry<T extends BaseConceptEditor> {
  private static final Logger LOG = Logger.getLogger(AbstractEditorRegistry.class);
  private static Comparator<BaseConceptEditor> myEditorComparator;
  private static Comparator<BaseConceptEditor> myAncestorEditorComparator;
  private Set<String> myHints;
  public AbstractEditorRegistry(Set<String> activeHints) {
    myHints = activeHints;
  }
  public T getEditor(SAbstractConcept concept) {
    return getEditor(concept, new HashSet<Class<? extends BaseConceptEditor>>());
  }
  public T getEditor(SAbstractConcept concept, @NotNull Collection<Class<? extends BaseConceptEditor>> excludedEditors) {
    Set<SAbstractConcept> processedConcepts = new HashSet<SAbstractConcept>();
    BreadthConceptHierarchyIterator ancestorsIterable = new BreadthConceptHierarchyIterator(concept);
    List<T> resultList = new ArrayList<T>();
    for (SAbstractConcept next : ancestorsIterable) {
      if (processedConcepts.contains(next)) {
        continue;
      }
      T conceptEditor = getEditorForConcept(next, excludedEditors);
      if (conceptEditor != null) {
        if (isEnoughForCurrentContext(conceptEditor)) {
          return conceptEditor;
        } else {
          resultList.add(conceptEditor);
        }
      }
      processedConcepts.add(next);
    }
    if (resultList.isEmpty()) {
      return null;
    }
    Collections.sort(resultList, getAncestorEditorComparator());
    return resultList.get(0);
  }
  private T getEditorForConcept(SAbstractConcept concept, @NotNull Collection<Class<? extends BaseConceptEditor>> excludedEditors) {
    List<T> conceptEditors = collectApplicableEditors(concept);
    if (conceptEditors.isEmpty()) {
      return null;
    }
    Collections.sort(conceptEditors, getEditorComparator());
    T result = null;
    for (T conceptEditor : conceptEditors) {
      if (result == null) {
        if (!(excludedEditors.contains(conceptEditor.getClass()))) {
          result = conceptEditor;
        }
      } else
      if (conceptEditor.getContextHints().size() == result.getContextHints().size()) {
        if (LOG.isErrorLevel()) {
          LOG.error(getErrorMessage(conceptEditor, result));
        }
      } else {
        break;
      }
    }
    return result;
  }
  private List<T> collectApplicableEditors(SAbstractConcept concept) {
    List<T> result = new ArrayList<T>();
    LanguageRuntime languageRuntime = LanguageRegistry.getInstance().getLanguage(concept.getLanguage());
    if (languageRuntime == null) {
      if (LOG.isWarningLevel()) {
        LOG.warning("No language runtime found for language: " + concept.getLanguage() + ". Default editor will be used");
      }
      return result;
    }
    EditorAspectDescriptor aspectDescriptor = null;
    try {
      aspectDescriptor = languageRuntime.getAspect(EditorAspectDescriptor.class);
    } catch (NoClassDefFoundError error) {
      if (LOG.isErrorLevel()) {
        LOG.error("Failed to get editor aspect descriptor for language: " + languageRuntime, error);
      }
    }
    if (aspectDescriptor != null) {
      for (T conceptEditor : getEditors(aspectDescriptor, concept)) {
        if (isApplicableInCurrentContext(conceptEditor)) {
          result.add(conceptEditor);
        }
      }
    }
    return result;
  }
  private boolean isEnoughForCurrentContext(BaseConceptEditor editor) {
    for (String hint : myHints) {
      if (!(editor.getContextHints().contains(hint))) {
        return false;
      }
    }
    return true;
  }
  private boolean isApplicableInCurrentContext(BaseConceptEditor editor) {
    for (String hint : editor.getContextHints()) {
      if (!(SetSequence.fromSet(myHints).contains(hint))) {
        return false;
      }
    }
    return true;
  }
  private String getErrorMessage(T additionalEditor, T mainEditor) {
    String context = "";
    for (String contextHint : myHints) {
      if (!(context.isEmpty())) {
        context += ", ";
      }
      context += contextHint;
    }
    return "Additional editor " + additionalEditor.getClass() + " is applicable to the current context (" + context + "). Skipping this editor , using " + mainEditor.getClass() + ".";
  }
  private static Comparator<BaseConceptEditor> getEditorComparator() {
    if (myEditorComparator == null) {
      myEditorComparator = new Comparator<BaseConceptEditor>() {
        @Override
        public int compare(BaseConceptEditor editor1, BaseConceptEditor editor2) {
          if (editor1.getContextHints().size() == editor2.getContextHints().size()) {
            return editor1.getClass().getName().compareTo(editor2.getClass().getName());
          }
          return editor2.getContextHints().size() - editor1.getContextHints().size();
        }
      };
    }
    return myEditorComparator;
  }
  private static Comparator<BaseConceptEditor> getAncestorEditorComparator() {
    if (myAncestorEditorComparator == null) {
      myAncestorEditorComparator = new Comparator<BaseConceptEditor>() {
        @Override
        public int compare(BaseConceptEditor editor1, BaseConceptEditor editor2) {
          return editor2.getContextHints().size() - editor1.getContextHints().size();
        }
      };
    }
    return myAncestorEditorComparator;
  }
  protected abstract Collection<T> getEditors(EditorAspectDescriptor aspectDescriptor, SAbstractConcept concept);
}

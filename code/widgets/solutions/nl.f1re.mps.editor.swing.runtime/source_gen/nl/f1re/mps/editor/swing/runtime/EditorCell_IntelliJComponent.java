package nl.f1re.mps.editor.swing.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Component;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.openapi.editor.TextBuilder;
import javax.swing.JComponent;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import java.awt.Font;
import javax.swing.JButton;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import com.intellij.ui.components.JBOptionButton;
import jetbrains.mps.nodeEditor.AbstractCellProvider;
import jetbrains.mps.nodeEditor.cells.EditorCell;

/**
 * This class fixes some issues with the original swing component implementation. It sets some sensible defaults for the styles, so that they look more
 * consistent with the other IntelliJ UI components and improves the ascent calculation. The original calculation is
 * component font ascent + border top inset which is not generic but works well for buttons. This new implementation assumes that the baseline is calculated
 * for the swing component which is done for most standard components.
 */
public class EditorCell_IntelliJComponent extends EditorCell_Component {

  private _FunctionTypes._return_P1_E0<? extends TextBuilder, ? super JComponent> textBuilderFunc;

  public EditorCell_IntelliJComponent(EditorContext editorContext, SNode node, @NotNull JComponent component, _FunctionTypes._return_P1_E0<? extends TextBuilder, ? super JComponent> textBuilderFunc) {
    this(editorContext, node, component, FontHelper.regular(), textBuilderFunc);
  }

  public EditorCell_IntelliJComponent(EditorContext editorContext, SNode node, @NotNull JComponent component, @Nullable Font font, _FunctionTypes._return_P1_E0<? extends TextBuilder, ? super JComponent> textBuilderFunc) {
    super(editorContext, node, component);
    this.textBuilderFunc = textBuilderFunc;
    if (!(component instanceof JButton)) {
      getStyle().set(StyleAttributes.PUNCTUATION_LEFT, true);
      getStyle().set(StyleAttributes.PUNCTUATION_RIGHT, true);
    }
    component.setOpaque(false);
    if (!(component instanceof JBOptionButton)) {
      component.putClientProperty("ActionToolbar.smallVariant", true);
    }
    if (font == null) {
      font = FontHelper.regular();
    }
    component.setFont(font);

  }

  @Override
  public int getAscent() {
    JComponent component = getComponent();

    int baseline = component.getBaseline(component.getWidth(), component.getHeight());
    if (baseline < 0) {
      if (myHeight != 0) {
        return myHeight;
      }

      return super.getAscent();
    }

    return baseline;
  }

  public AbstractCellProvider createProvider() {
    return new AbstractCellProvider(getSNode()) {
      @Override
      public EditorCell createEditorCell(EditorContext context) {
        return EditorCell_IntelliJComponent.this;
      }
    };
  }

  @Override
  public TextBuilder renderText() {
    return textBuilderFunc.invoke(getComponent());
  }
}

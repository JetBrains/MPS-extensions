package de.q60.mps.shadowmodels.runtime.model.persistent;

/*Generated by MPS */

import org.modelix.model.api.ITree;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.INodeReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;

public class SM_ReadTransaction extends SM_Transaction implements SM_IReadTransaction {
  private final ITree tree;
  private Set<SM_IMissingNode> missingNodes = SetSequence.fromSet(new HashSet<SM_IMissingNode>());

  public SM_ReadTransaction(@NotNull ITree tree, SM_PBranch branch) {
    super(branch);
    this.tree = tree;
  }
  @Override
  public ITree getTree() {
    return tree;
  }
  @Override
  public SM_PTree getPTree() {
    return (SM_PTree) tree;
  }

  @Override
  public Iterable<SM_IMissingNode> getMissingNodes() {
    return missingNodes;
  }

  @Override
  public void registerMissingNode(SM_IMissingNode missingNode) {
    SetSequence.fromSet(missingNodes).addElement(missingNode);
  }

  @Override
  public String getProperty(long nodeId, String role) {
    if (isLoaded(nodeId)) {
      return getTree().getProperty(nodeId, role);
    } else {
      registerMissingNode(new SM_MissingNodeId(nodeId));
      return null;
    }
  }

  @Override
  public INodeReference getReferenceTarget(long sourceId, String role) {
    if (isLoaded(sourceId)) {
      return getTree().getReferenceTarget(sourceId, role);
    } else {
      registerMissingNode(new SM_MissingNodeId(sourceId));
      return null;
    }
  }

  @Override
  public Iterable<Long> getChildren(long parentId, String role) {
    if (isLoaded(parentId)) {
      Iterable<Long> result = getTree().getChildren(parentId, role);
      return result;
    } else {
      registerMissingNode(new SM_MissingNodeId(parentId));
      return Sequence.fromIterable(Collections.<Long>emptyList());
    }
  }

  @Override
  public Iterable<Long> getAllChildren(long parentId) {
    if (isLoaded(parentId)) {
      Iterable<Long> result = getTree().getAllChildren(parentId);
      return result;
    } else {
      registerMissingNode(new SM_MissingNodeId(parentId));
      return Sequence.fromIterable(Collections.<Long>emptyList());
    }
  }
}

package de.itemis.mps.editor.math.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.actions.CursorPositionTracker;
import de.slisson.mps.hacks.editor.EditorComponentHacks;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.nodeEditor.NodeEditorActions;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.nodeEditor.selection.NodeRangeSelection;
import jetbrains.mps.openapi.editor.cells.CellConditions;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;

public class MathEditorActions {
  private static double tangensAlpha = Math.tan(Math.PI / 4);

  public static void setActions(EditorCell_MathBase cell) {
    CursorPositionTracker cursorPositionTracker = EditorComponentHacks.getPositionTracker(cell.getEditor());
    cell.setAction(CellActionType.LEFT, new MoveLeft(cursorPositionTracker));
    cell.setAction(CellActionType.RIGHT, new MoveRight(cursorPositionTracker));
    cell.setAction(CellActionType.UP, new MoveUp(cursorPositionTracker));
    cell.setAction(CellActionType.DOWN, new MoveDown(cursorPositionTracker));
  }

  public static class MoveLeft extends NodeEditorActions.NavigationAction {
    private final CursorPositionTracker myPositionTracker;
    public MoveLeft(CursorPositionTracker positionTracker) {
      myPositionTracker = positionTracker;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      return selection != null && findTarget(selection) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      EditorCell target = findTarget(selection);
      context.getEditorComponent().changeSelection(target);
      if (target instanceof EditorCell_Label) {
        EditorCell_Label label = (EditorCell_Label) target;
        label.end();
      }
      myPositionTracker.savePosition(target.getCaretX());
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getEditorComponent().getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getFirstCell();
      }
      return null;
    }
    private EditorCell findTarget(final EditorCell cell) {
      return MathEditorActions.findBestTarget(cell, new TargetComparator(CellConditions.SELECTABLE) {
        public boolean isBetter(EditorCell source, EditorCell compareTo, EditorCell isBetter) {
          double hdist1 = Math.abs(compareTo.getX() + compareTo.getWidth() - source.getCaretX());
          double hdist2 = Math.abs(isBetter.getX() + isBetter.getWidth() - source.getCaretX());
          double rating1 = MathEditorActions.verticalDistance(source, compareTo) / tangensAlpha + hdist1;
          double rating2 = MathEditorActions.verticalDistance(source, isBetter) / tangensAlpha + hdist2;
          rating1 += MathEditorActions.structuralDistance(source, compareTo) * 5;
          rating2 += MathEditorActions.structuralDistance(source, isBetter) * 5;
          return rating2 < rating1;
        }
        @Override
        public boolean isAllowed(EditorCell target) {
          return super.isAllowed(target) && target.getX() < cell.getX() && (cell.getX() - target.getX()) > 2;
        }
      });
    }
  }

  public static class MoveRight extends NodeEditorActions.NavigationAction {
    private final CursorPositionTracker myPositionTracker;
    public MoveRight(CursorPositionTracker positionTracker) {
      myPositionTracker = positionTracker;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      return selection != null && findTarget(selection) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      EditorCell target = findTarget(selection);
      context.getEditorComponent().changeSelection(target);
      if (target instanceof EditorCell_Label) {
        EditorCell_Label label = (jetbrains.mps.nodeEditor.cells.EditorCell_Label) target;
        label.home();

      }
      myPositionTracker.savePosition(target.getCaretX());
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getEditorComponent().getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getLastCell();
      }
      return null;
    }
    private EditorCell findTarget(final EditorCell cell) {
      return MathEditorActions.findBestTarget(cell, new TargetComparator(CellConditions.SELECTABLE) {
        public boolean isBetter(EditorCell source, EditorCell compareTo, EditorCell isBetter) {
          double hdist1 = Math.abs(source.getCaretX() - compareTo.getX());
          double hdist2 = Math.abs(source.getCaretX() - isBetter.getX());
          double rating1 = MathEditorActions.verticalDistance(source, compareTo) / tangensAlpha + hdist1;
          double rating2 = MathEditorActions.verticalDistance(source, isBetter) / tangensAlpha + hdist2;
          rating1 += MathEditorActions.structuralDistance(source, compareTo) * 5;
          rating2 += MathEditorActions.structuralDistance(source, isBetter) * 5;
          return rating2 < rating1;
        }
        @Override
        public boolean isAllowed(EditorCell target) {
          return super.isAllowed(target) && target.getX() > cell.getX() && (target.getX() - cell.getX()) > 2;
        }
      });
    }
  }
  public static class MoveUp extends NodeEditorActions.NavigationAction {
    private final CursorPositionTracker myPositionTracker;
    public MoveUp(CursorPositionTracker positionTracker) {
      myPositionTracker = positionTracker;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      return selectedCell != null && selectedCell.getParent() != null && findTarget(selectedCell, selectedCell.getCaretX()) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      int caretX = (myPositionTracker.hasPosition() ? myPositionTracker.getPosition() : selectedCell.getCaretX());
      caretX = (selectedCell.getCaretX() + caretX) / 2;
      EditorCell target = findTarget(selectedCell, caretX);
      target.setCaretX(caretX);
      context.getEditorComponent().changeSelection(target);
      myPositionTracker.savePosition(caretX);
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getEditorComponent().getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getFirstCell();
      }
      return null;
    }
    private EditorCell findTarget(EditorCell cell, int caretX) {
      return getUpper(((jetbrains.mps.nodeEditor.cells.EditorCell) cell), CellConditions.SELECTABLE, caretX);
    }
    public EditorCell getUpper(final jetbrains.mps.nodeEditor.cells.EditorCell cell, Condition<EditorCell> condition, final int baseX) {
      return MathEditorActions.findBestTarget(cell, new TargetComparator(condition) {
        public boolean isBetter(EditorCell source, EditorCell compareTo, EditorCell isBetter) {
          double rating1 = MathEditorActions.verticalDistance(source, compareTo) + MathEditorActions.horizontalDistance(compareTo, baseX) / tangensAlpha;
          double rating2 = MathEditorActions.verticalDistance(source, isBetter) + MathEditorActions.horizontalDistance(isBetter, baseX) / tangensAlpha;
          rating1 += MathEditorActions.structuralDistance(source, compareTo) * 5;
          rating2 += MathEditorActions.structuralDistance(source, isBetter) * 5;
          return rating2 < rating1;
        }
        @Override
        public boolean isAllowed(EditorCell target) {
          return super.isAllowed(target) && target.getY() < cell.getY() && MathEditorActions.verticalDistance(cell, target) > 2;
        }
      });
    }

  }
  public static class MoveDown extends NodeEditorActions.NavigationAction {
    private final CursorPositionTracker myPositionTracker;
    public MoveDown(CursorPositionTracker positionTracker) {
      myPositionTracker = positionTracker;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      return selectedCell != null && findTarget(selectedCell, selectedCell.getCaretX()) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      int caretX = (myPositionTracker.hasPosition() ? myPositionTracker.getPosition() : selectedCell.getCaretX());
      caretX = (selectedCell.getCaretX() + caretX) / 2;
      EditorCell target = findTarget(selectedCell, caretX);
      target.setCaretX(caretX);
      context.getEditorComponent().changeSelection(target);
      myPositionTracker.savePosition(caretX);
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getLastCell();
      }
      return null;
    }
    private EditorCell findTarget(EditorCell cell, int caretX) {
      return getLower(((jetbrains.mps.nodeEditor.cells.EditorCell) cell), CellConditions.SELECTABLE, caretX);
    }

    public EditorCell getLower(final EditorCell cell, Condition<EditorCell> condition, final int baseX) {
      return MathEditorActions.findBestTarget(cell, new TargetComparator(condition) {
        public boolean isBetter(EditorCell source, EditorCell compareTo, EditorCell isBetter) {
          double rating1 = MathEditorActions.verticalDistance(source, compareTo) + MathEditorActions.horizontalDistance(compareTo, baseX) / tangensAlpha;
          double rating2 = MathEditorActions.verticalDistance(source, isBetter) + MathEditorActions.horizontalDistance(isBetter, baseX) / tangensAlpha;
          rating1 += MathEditorActions.structuralDistance(source, compareTo) * 5;
          rating2 += MathEditorActions.structuralDistance(source, isBetter) * 5;
          return rating2 < rating1;
        }
        @Override
        public boolean isAllowed(EditorCell target) {
          return super.isAllowed(target) && target.getY() > cell.getY() && MathEditorActions.verticalDistance(cell, target) > 2;
        }
      });
    }

  }

  public static int formularDistance(EditorCell cell1, EditorCell cell2) {
    EditorCell commonParent = CellTraversalUtil.getCommonParent(cell1, cell2);
    int distance = ListSequence.fromList(getParents(cell1, commonParent)).where((it) -> it instanceof EditorCell_MathBase).count();
    distance += ListSequence.fromList(getParents(cell2, commonParent)).where((it) -> it instanceof EditorCell_MathBase).count();
    return distance;
  }

  public static int structuralDistance(EditorCell cell1, EditorCell cell2) {
    EditorCell commonParent = CellTraversalUtil.getCommonParent(cell1, cell2);
    int distance = ListSequence.fromList(getParents(cell1, commonParent)).where((it) -> it.isBig()).count();
    distance += ListSequence.fromList(getParents(cell2, commonParent)).where((it) -> it.isBig()).count();
    return distance;
  }

  public static List<EditorCell> getParents(EditorCell child, EditorCell stopBefore) {
    List<EditorCell> result = ListSequence.fromList(new ArrayList<EditorCell>());
    for (EditorCell parent = child.getParent(); parent != null && parent != stopBefore; parent = parent.getParent()) {
      ListSequence.fromList(result).addElement(parent);
    }
    return result;
  }

  private static int horizontalDistance(EditorCell cell, int x) {
    if (cell.getX() <= x && x <= cell.getX() + cell.getWidth()) {
      return 0;
    }
    return Math.min(Math.abs(cell.getX() - x), Math.abs(cell.getX() + cell.getWidth() - x));
  }

  public static int verticalDistance(EditorCell ref, EditorCell cell) {
    int refCenter = ref.getY() + ref.getHeight() / 2;
    int cellCenter = cell.getY() + cell.getHeight() / 2;
    return Math.abs(cellCenter - refCenter);
  }

  public static EditorCell findBestTarget(EditorCell cell, ITargetComparator comparator) {
    EditorCell bestMatch = null;

    // look forward
    EditorCell current = CellTraversalUtil.getNextLeaf(cell, comparator);
    while (current != null) {
      if (bestMatch != null) {
        if (comparator.isBetter(cell, bestMatch, current)) {
          bestMatch = current;
        }
      } else {
        bestMatch = current;
      }
      current = CellTraversalUtil.getNextLeaf(current, comparator);
    }

    // look backward
    current = CellTraversalUtil.getPrevLeaf(cell, comparator);
    while (current != null) {
      if (bestMatch != null) {
        if (comparator.isBetter(cell, bestMatch, current)) {
          bestMatch = current;
        }
      } else {
        bestMatch = current;
      }
      current = CellTraversalUtil.getPrevLeaf(current, comparator);
    }

    return bestMatch;
  }

  public interface ITargetComparator extends Condition<EditorCell> {
    boolean isBetter(EditorCell source, EditorCell compareTo, EditorCell isBetter);
    boolean isAllowed(EditorCell target);
  }

  public static abstract class TargetComparator implements ITargetComparator {
    private Condition<EditorCell> myCondition;
    public TargetComparator(Condition<EditorCell> condition) {
      myCondition = condition;
    }
    @Override
    public boolean isAllowed(EditorCell target) {
      return myCondition.met(target);
    }
    @Override
    public boolean met(EditorCell cell) {
      return isAllowed(cell);
    }
  }
}

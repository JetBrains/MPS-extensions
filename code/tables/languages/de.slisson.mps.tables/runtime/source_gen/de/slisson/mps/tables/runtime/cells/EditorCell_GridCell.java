package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.style.StyleAttribute;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import java.awt.Color;
import de.slisson.mps.tables.runtime.style.VerticalAlignment;
import de.slisson.mps.tables.runtime.style.HorizontalAlignment;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import de.slisson.mps.tables.runtime.simplegrid.GridPosition;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.editor.runtime.style.StyleImpl;
import jetbrains.mps.nodeEditor.AdditionalPainter;
import jetbrains.mps.nodeEditor.AbstractAdditionalPainter;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import de.itemis.mps.editor.celllayout.runtime.TopDownCellLayoutAdapter;
import de.slisson.mps.tables.runtime.substitute.GridSubstituteInfo;
import jetbrains.mps.openapi.editor.cells.SubstituteInfo;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import java.util.Iterator;
import jetbrains.mps.openapi.editor.menus.transformation.SNodeLocation;
import jetbrains.mps.openapi.editor.cells.EditorCellContext;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.nodeEditor.cells.EditorCellContextImpl;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.slisson.mps.tables.runtime.gridmodel.Grid;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellGridLeaf;
import com.intellij.util.ObjectUtils;
import jetbrains.mps.nodeEditor.cellActions.CellAction_DeleteNode;
import jetbrains.mps.editor.runtime.cells.AbstractCellAction;

public class EditorCell_GridCell extends NoInsertOverride {
  private static final StyleAttribute<Integer> STYLE_MARGIN_LEFT = StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_margin-left");
  private static final StyleAttribute<Integer> STYLE_MARGIN_RIGHT = StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_margin-right");
  private static final StyleAttribute<Boolean> STYLE_GROW_X = StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grow-x");
  private static final StyleAttribute<Boolean> STYLE_GROW_Y = StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grow-y");
  private static final StyleAttribute<Color> STYLE_BORDER_TOP_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.slisson.mps.tables", "border-top-color");
  private static final StyleAttribute<Color> STYLE_SHADE_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.slisson.mps.tables", "shade-color");
  private static final StyleAttribute<Color> STYLE__BORDER_LEFT_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-left-color");
  private static final StyleAttribute<Integer> STYLE_BORDER_LEFT_WIDTH = StyleAttributes.getInstance().<Integer>getAttribute("de.slisson.mps.tables", "border-left-width");
  private static final StyleAttribute<VerticalAlignment> STYLE_VERTICAL_ALIGNMENT = StyleAttributes.getInstance().<VerticalAlignment>getAttribute("de.slisson.mps.tables", "vertical-alignment");
  private static final StyleAttribute<Color> STYLE_BORDER_LEFT_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.slisson.mps.tables", "border-left-color");
  private static final StyleAttribute<Integer> STYLE_BORDER_BOTTOM_SIZE = StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-bottom-size");
  private static final StyleAttribute<Integer> STYLE_BORDER_TOP_WIDTH = StyleAttributes.getInstance().<Integer>getAttribute("de.slisson.mps.tables", "border-top-width");
  private static final StyleAttribute<Color> STYLE_BORDER_BOTTOM_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.slisson.mps.tables", "border-bottom-color");
  private static final StyleAttribute<Integer> STYLE_BORDER_BOTTOM_WIDTH = StyleAttributes.getInstance().<Integer>getAttribute("de.slisson.mps.tables", "border-bottom-width");
  private static final StyleAttribute<Integer> STYLE__BORDER_LEFT_SIZE = StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-left-size");
  private static final StyleAttribute<Integer> STYLE_BORDER_RIGHT_WIDTH = StyleAttributes.getInstance().<Integer>getAttribute("de.slisson.mps.tables", "border-right-width");
  private static final StyleAttribute<Color> STYLE__BORDER_TOP_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-top-color");
  private static final StyleAttribute<Integer> STYLE__BORDER_TOP_SIZE = StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-top-size");
  private static final StyleAttribute<Color> STYLE__BORDER_BOTTOM_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-bottom-color");
  private static final StyleAttribute<Integer> STYLE__BORDER_RIGHT_SIZE = StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-right-size");
  private static final StyleAttribute<HorizontalAlignment> STYLE_HORIZONTAL_ALIGNMENT = StyleAttributes.getInstance().<HorizontalAlignment>getAttribute("de.slisson.mps.tables", "horizontal-alignment");
  private static final StyleAttribute<Color> STYLE_BORDER_RIGHT_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.slisson.mps.tables", "border-right-color");
  private static final StyleAttribute<Color> STYLE__BORDER_RIGHT_COLOR = StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-right-color");
  private static final StyleAttribute<Boolean> STYLE__HORIZONTAL_STICKY_CELL = StyleAttributes.getInstance().<Boolean>getAttribute("de.slisson.mps.tables", "horizontal-sticky-cell");
  private static final StyleAttribute<Boolean> STYLE__VERTICAL_STICKY_CELL = StyleAttributes.getInstance().<Boolean>getAttribute("de.slisson.mps.tables", "vertical-sticky-cell");

  private EditorCell myWrappedEditorCell;
  private TableEditor myTable;
  private GridPosition myPosition;
  private Style myTableStyle = new StyleImpl();

  private AdditionalPainter<Object> painter = new AbstractAdditionalPainter<Object>() {

    @Override
    public boolean paintsAbove() {
      return true;
    }

    /*package*/ boolean shouldBeStickyX(Point point, Rectangle viewRect, EditorCell cell, boolean ignoreStyle) {
      int tolerance = 1;

      boolean styleCheck = (ignoreStyle ? true : isHorizontallyStickyCell());
      return styleCheck && !(isVisibleInEditor(point)) && viewRect.getX() > cell.getX() && viewRect.getX() + cell.getWidth() - tolerance < myTable.getX() + myTable.getWidth();
    }

    /*package*/ boolean shouldBeStickyY(Point point, Rectangle viewRect, EditorCell cell, boolean ignoreStyle) {
      int tolerance = 1;

      boolean styleCheck = (ignoreStyle ? true : isVerticallyStickyCell());
      return styleCheck && !(isVisibleInEditor(point)) && viewRect.getY() > cell.getY() && viewRect.getY() + cell.getHeight() - tolerance < myTable.getY() + myTable.getHeight();
    }

    @Override
    public void paint(Graphics gr, EditorComponent comp) {
      if (myWrappedEditorCell.getParent() == null) {
        return;
      }
      EditorCell_GridCell cell = EditorCell_GridCell.this;
      Point point = new Point(getX(), getY());
      EditorComponent editorComponent = (EditorComponent) getEditorComponent();
      Rectangle viewRect = editorComponent.getViewport().getViewRect();

      boolean stickyX = shouldBeStickyX(point, viewRect, cell, false);
      boolean stickyY = shouldBeStickyY(point, viewRect, cell, false);

      if (stickyX || stickyY) {
        int x;
        int y;
        if (stickyY) {
          x = 0;
          y = (int) viewRect.getY() - cell.getY() + cell.getTable().getVerticalStickyCellOffset(cell);
        } else if (stickyX) {
          x = (int) viewRect.getX() - cell.getX() + cell.getTable().getHorizonalStickyCellOffset(cell);
          y = 0;
        } else {
          return;
        }
        Graphics g = gr.create();
        g.translate(x, y);
        g.setColor(comp.getStyleRegistry().getEditorBackground());
        g.fillRect(cell.getX(), cell.getY(), cell.getWidth(), cell.getHeight());
        fillBackground(g, new ParentSettings());
        cell.paint(g);
        TableUtils.paintBorders(g, TableUtils.getCellBounds(cell), getStyleValue(STYLE_BORDER_TOP_COLOR), getStyleValue(STYLE_BORDER_TOP_WIDTH), getStyleValue(STYLE_BORDER_LEFT_COLOR), getStyleValue(STYLE_BORDER_LEFT_WIDTH), getStyleValue(STYLE_BORDER_RIGHT_COLOR), getStyleValue(STYLE_BORDER_RIGHT_WIDTH), getStyleValue(STYLE_BORDER_BOTTOM_COLOR), getStyleValue(STYLE_BORDER_BOTTOM_WIDTH));

      }
    }

    @Override
    public boolean paintsBackground() {
      return false;
    }

    @Override
    public void paintBackground(Graphics p1, EditorComponent p2) {
    }

    @Override
    public Object getItem() {
      return null;
    }

    @Override
    public boolean isAbove(AdditionalPainter additionalPainter, EditorComponent editorComponent) {
      return true;
    }
  };

  public boolean isVisibleInEditor(Point point) {
    EditorComponent editorComponent = (EditorComponent) getEditorComponent();
    Rectangle viewRect = editorComponent.getViewport().getViewRect();

    return editorComponent.isShowing() && point.getX() >= viewRect.getX() && point.getX() <= viewRect.getX() + viewRect.getWidth() && point.getY() >= viewRect.getY() && point.getY() <= viewRect.getY() + viewRect.getHeight();
  }

  public EditorCell_GridCell(EditorContext context, SNode snode, EditorCell wrappedCell) {
    super(wrappedCell.getContext(), snode, new TopDownCellLayoutAdapter(new GridCellLayout()), null);
    myWrappedEditorCell = wrappedCell;

    setSubstituteInfo(new GridSubstituteInfo(this));

    // Override any default or unset substitute info of the wrapped cell.
    // Be careful because the wrapped cell may be a transparent (= single-cell, selectable) collection, in which case
    // we need to check its contents. (Example: a tooltip cell is a transparent collection, and we don't want to
    // override any menu of its visible cell, such as a ref cell menu.)
    SubstituteInfo wrappedSubstituteInfo = getSubstituteInfoBypassingTransparentCollections(myWrappedEditorCell);
    if (wrappedSubstituteInfo == null || wrappedSubstituteInfo instanceof GridSubstituteInfo) {
      myWrappedEditorCell.setSubstituteInfo(getSubstituteInfo());
    }

    getStyle().set(StyleAttributes.SELECTABLE, !(myWrappedEditorCell.getStyle().get(StyleAttributes.SELECTABLE)));

    setAction(CellActionType.DELETE, new DeleteAction());
    setAction(CellActionType.BACKSPACE, new DeleteAction());
    setAction(CellActionType.INSERT, new de.slisson.mps.tables.runtime.cells.DoNothingAction());
    setAction(CellActionType.INSERT_BEFORE, new de.slisson.mps.tables.runtime.cells.DoNothingAction());

    Style wrappedStyle = myWrappedEditorCell.getStyle();
    if (!(wrappedStyle.isSpecified(STYLE_MARGIN_LEFT))) {
      wrappedStyle.set(STYLE_MARGIN_LEFT, 3);
    }
    if (!(wrappedStyle.isSpecified(STYLE_MARGIN_RIGHT))) {
      wrappedStyle.set(STYLE_MARGIN_RIGHT, 3);
    }
    getStyle().set(STYLE_GROW_X, true);
    getStyle().set(STYLE_GROW_Y, true);

    fixCellContext(wrappedCell);
    setCellContext(wrappedCell.getCellContext());
  }

  private static SubstituteInfo getSubstituteInfoBypassingTransparentCollections(EditorCell cell) {
    while (true) {
      SubstituteInfo candidate = cell.getSubstituteInfo();
      if (candidate != null) {
        return candidate;
      }

      if (!(cell instanceof EditorCell_Collection)) {
        return null;
      }

      EditorCell_Collection coll = (EditorCell_Collection) cell;

      if (!(coll.isTransparentCollection())) {
        return null;
      }

      // Most transparent collections have a single child which we can get the substitute info from
      // But a custom collection cell could override the isTransparentCollection method to return true even for
      // collections with multiple child cells.
      EditorCell child = getTheOnlyChild(coll);
      if (child == null) {
        return null;
      }

      cell = child;
    }
  }

  private static EditorCell getTheOnlyChild(EditorCell_Collection coll) {
    Iterator<EditorCell> it = coll.iterator();
    if (!(it.hasNext())) {
      // No children
      return null;
    }

    EditorCell firstChild = it.next();
    if (it.hasNext()) {
      // More than one child
      return null;
    }

    return firstChild;
  }

  protected void fixCellContext(EditorCell cell) {
    if (check_hp9uj0_a0a0pb(check_hp9uj0_a0a0a14(cell.getCellContext())) != cell.getSNode()) {
      final SNodeLocation.FromNode nodeLocation = new SNodeLocation.FromNode(cell.getSNode());
      if (cell.getCellContext() == null) {
        cell.setCellContext(new EditorCellContext() {
          public Collection<String> getHints() {
            return Collections.<String>emptyList();
          }
          public SNodeLocation getNodeLocation() {
            return nodeLocation;
          }
          public boolean hasContextHint(String hint) {
            return false;
          }
        });
      } else {
        EditorCellContextImpl cellContext = new EditorCellContextImpl(cell.getCellContext());
        cellContext.setNodeLocation(nodeLocation);
        cell.setCellContext(cellContext);
      }
    }
    if (cell instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) cell))) {
        fixCellContext(child);
      }
    }
  }

  public void assertWrapped() {
    if (myWrappedEditorCell != firstCell()) {
      throw new RuntimeException();
    }
  }

  public VerticalAlignment getVerticalAlignment() {
    VerticalAlignment alignment = getStyleValue(STYLE_VERTICAL_ALIGNMENT);
    return (alignment != null ? alignment : VerticalAlignment.TOP);
  }

  public HorizontalAlignment getHorizontalAlignment() {
    HorizontalAlignment alignment = getStyleValue(STYLE_HORIZONTAL_ALIGNMENT);

    return (alignment != null ? alignment : HorizontalAlignment.LEFT);
  }

  public boolean isHorizontallyStickyCell() {
    Boolean stickyCell = getStyleValue(STYLE__HORIZONTAL_STICKY_CELL);

    return (stickyCell != null ? stickyCell : false);
  }

  public boolean isVerticallyStickyCell() {
    Boolean stickyCell = getStyleValue(STYLE__VERTICAL_STICKY_CELL);

    return (stickyCell != null ? stickyCell : false);
  }

  public boolean isStickyCell() {
    return isHorizontallyStickyCell() || isVerticallyStickyCell();
  }

  public <T> T getStyleValue(StyleAttribute<T> attribute) {
    T value = getStyleValueIfSet(attribute);
    if (value != null) {
      return value;
    }
    // use default value
    return myTableStyle.get(attribute);
  }

  public <T> T getStyleValueIfSet(StyleAttribute<T> attribute) {
    if (getTable().getGrid().getElement(getGridPosition()).getStyle().isSpecified(attribute)) {
      return getTable().getGrid().getElement(getGridPosition()).getStyle().get(attribute);
    }
    if (getStyle().isSpecified(attribute)) {
      return getStyle().get(attribute);
    }
    if (getWrappedCell().getStyle().isSpecified(attribute)) {
      return getWrappedCell().getStyle().get(attribute);
    }
    if (myTableStyle.isSpecified(attribute)) {
      return myTableStyle.get(attribute);
    }

    if (getTable().getStyle().isSpecified(attribute)) {
      return getTable().getStyle().get(attribute);
    }

    if (getTable().getGrid().getElement(new GridPosition(0, 0)).getStyle().isSpecified(attribute)) {
      return getTable().getGrid().getElement(getGridPosition()).getStyle().get(attribute);
    }

    return null;
  }

  public void setTable(TableEditor table) {
    myTable = table;
    getSubstituteInfo().reset();
  }
  @Override
  public void setSubstituteInfo(SubstituteInfo info) {
    if (info == null || info instanceof GridSubstituteInfo) {
      super.setSubstituteInfo(info);
    } else {
    }
  }

  @Override
  public GridSubstituteInfo getSubstituteInfo() {
    return (GridSubstituteInfo) super.getSubstituteInfo();
  }

  public TableEditor getTable() {
    return myTable;
  }

  public void setPosition(GridPosition pos) {
    myPosition = pos;
    if (getCellId() == null) {
      String id = "gridCell_" + pos.getX() + "_" + pos.getY();
      setCellId(id);
      if (myWrappedEditorCell.getCellId() == null && myWrappedEditorCell.getSNode() == getSNode()) {
        myWrappedEditorCell.setCellId(id + "_wrapped");
      }
    }
    getSubstituteInfo().reset();
  }

  public GridPosition getGridPosition() {
    return myPosition;
  }

  public Style getTableStyle() {
    return myTableStyle;
  }

  public void clearStyle() {
    myTableStyle = new StyleImpl();
  }

  @Override
  public String toString() {
    return "GridCell[" + myWrappedEditorCell + "]";
  }

  public EditorCell getWrappedCell() {
    return myWrappedEditorCell;
  }

  public boolean isRowEndCell() {
    return getCellsCount() == 1 && firstCell() instanceof RowEndCell;
  }

  public boolean isEmptyCell() {
    return getCellsCount() == 1 && firstCell() instanceof EditorCell_EmptyTableCell;
  }

  @Override
  public CellAction getAction(CellActionType type) {
    CellAction wrappedAction = myWrappedEditorCell.getAction(type);
    CellAction myAction = super.getAction(type);
    return (wrappedAction != null ? wrappedAction : myAction);
  }

  public boolean isEmptyNodePlaceholder() {
    return getCellsCount() == 1 && firstCell() instanceof EmptyNodePlaceholder;
  }

  public EditorCell unwrap() {
    EditorCell_Collection parent = this.getParent();
    if (parent == null) {
      removeCell(((jetbrains.mps.nodeEditor.cells.EditorCell) myWrappedEditorCell));
    } else {
      parent.addEditorCellBefore(myWrappedEditorCell, this);
      ((jetbrains.mps.nodeEditor.cells.EditorCell_Collection) parent).removeCell(this);
    }
    return myWrappedEditorCell;
  }

  public static EditorCell unwrapAll(EditorCell cell) {
    for (EditorCell child : Sequence.fromIterable(as_hp9uj0_a0a0a88(cell, EditorCell_Collection.class))) {
      unwrapAll(child);
    }
    EditorCell unwrapped = check_hp9uj0_a0b0kd(as_hp9uj0_a0a0b0kd(cell, EditorCell_GridCell.class));
    return (unwrapped == null ? cell : unwrapped);
  }
  @Override
  public void paintDecorations(Graphics g) {
    super.paintDecorations(g);

  }

  protected void syncStyles() {
    if (getWrappedCell() instanceof RowEndCell) {
      return;
    }

    getStyle().set(STYLE__BORDER_LEFT_COLOR, getStyleValue(STYLE_BORDER_LEFT_COLOR));
    getStyle().set(STYLE__BORDER_RIGHT_COLOR, getStyleValue(STYLE_BORDER_RIGHT_COLOR));
    getStyle().set(STYLE__BORDER_TOP_COLOR, getStyleValue(STYLE_BORDER_TOP_COLOR));
    getStyle().set(STYLE__BORDER_BOTTOM_COLOR, getStyleValue(STYLE_BORDER_BOTTOM_COLOR));

    getStyle().set(STYLE__BORDER_LEFT_SIZE, getStyleValue(STYLE_BORDER_LEFT_WIDTH));
    getStyle().set(STYLE__BORDER_RIGHT_SIZE, getStyleValue(STYLE_BORDER_RIGHT_WIDTH));
    getStyle().set(STYLE__BORDER_TOP_SIZE, getStyleValue(STYLE_BORDER_TOP_WIDTH));
    getStyle().set(STYLE_BORDER_BOTTOM_SIZE, getStyleValue(STYLE_BORDER_BOTTOM_WIDTH));

    Style wrappedStyle = getWrappedCell().getStyle();

    if (wrappedStyle.isSpecified(STYLE__HORIZONTAL_STICKY_CELL)) {
      getStyle().set(STYLE__HORIZONTAL_STICKY_CELL, wrappedStyle.get(STYLE__HORIZONTAL_STICKY_CELL));
    }

    if (wrappedStyle.isSpecified(STYLE__VERTICAL_STICKY_CELL)) {
      getStyle().set(STYLE__VERTICAL_STICKY_CELL, wrappedStyle.get(STYLE__VERTICAL_STICKY_CELL));
    }
  }

  @Override
  public void onAdd() {
    super.onAdd();
    syncStyles();
    if (isStickyCell()) {
      if (isHorizontallyStickyCell()) {
        ListSequence.fromList(this.getTable().horizontallyStickyCells).addElement(this);
      }
      if (isVerticallyStickyCell()) {
        ListSequence.fromList(this.getTable().verticallyStickyCells).addElement(this);
      }
      EditorComponent editorComponent = (EditorComponent) this.getEditorComponent();
      editorComponent.addAdditionalPainter(painter);
    }
  }


  @Override
  public void onRemove() {
    super.onRemove();
    if (isHorizontallyStickyCell() || isVerticallyStickyCell()) {
      if (isHorizontallyStickyCell()) {
        ListSequence.fromList(this.getTable().horizontallyStickyCells).removeElement(this);
      }
      if (isVerticallyStickyCell()) {
        ListSequence.fromList(this.getTable().verticallyStickyCells).removeElement(this);
      }
      EditorComponent editorComponent = (EditorComponent) this.getEditorComponent();
      if (this.containsCell((jetbrains.mps.nodeEditor.cells.EditorCell) myWrappedEditorCell)) {
        this.removeCell(myWrappedEditorCell);
      }
      editorComponent.removeAdditionalPainter(painter);
    }
  }

  @Override
  public ParentSettings fillBackground(Graphics graphics, ParentSettings parentSettings) {
    super.fillBackground(graphics, parentSettings);

    ParentSettings settings = parentSettings;

    Color shade = getStyleValue(STYLE_SHADE_COLOR);
    if (shade != null) {
      graphics.setColor(shade);
      graphics.fillRect(getX(), getY(), getWidth(), getHeight());
    }

    return settings;

  }
  public static void unwrapAll_Grid(Grid grid) {
    if (grid == null) {
      return;
    }
    for (int x = 0; x < grid.getSizeX(); x++) {
      for (int y = 0; y < grid.getSizeY(); y++) {
        EditorCellGridLeaf leaf = as_hp9uj0_a0a0a0a1a99(grid.getElement(x, y), EditorCellGridLeaf.class);
        if (leaf == null) {
          continue;
        }
        EditorCell cell = as_hp9uj0_a0a2a0a1a99(grid.getElement(x, y), EditorCell.class);
        EditorCell unwrapped = unwrapAll((leaf.getEditorCell()));
        if (cell != unwrapped) {
          leaf.setEditorCell(unwrapped);
        }
      }
    }
  }


  public int getBorderLeft() {
    return ObjectUtils.notNull(getStyleValue(STYLE_BORDER_LEFT_WIDTH), 0);
  }

  public int getBorderRight() {
    return ObjectUtils.notNull(getStyleValue(STYLE_BORDER_RIGHT_WIDTH), 0);
  }

  public int getBorderTop() {
    return ObjectUtils.notNull(getStyleValue(STYLE_BORDER_TOP_WIDTH), 0);
  }

  public int getBorderBottom() {
    return ObjectUtils.notNull(getStyleValue(STYLE_BORDER_BOTTOM_WIDTH), 0);
  }

  public int getOuterHeight() {
    return getInnerHeight() + getBorderTop() + getBorderBottom();
  }

  public int getInnerHeight() {
    return getWrappedCell().getHeight() + getWrappedCell().getTopInset() + getWrappedCell().getBottomInset();
  }

  public int getOuterWidth() {
    return getInnerWidth() + getBorderLeft() + getBorderRight();
  }

  public int getInnerWidth() {
    return getWrappedCell().getWidth() + getWrappedCell().getLeftInset() + getWrappedCell().getRightInset() + myGapLeft + myGapRight;
  }

  public int getWrappedCellOffsetX() {
    return getBorderLeft() + myGapLeft;
  }

  public int getWrappedCellOffsetY() {
    return getBorderTop();
  }

  protected void updateAlignment() {
  }
  @Override
  public void setWidth(int i) {
    super.setWidth(i);
    updateAlignment();
  }
  @Override
  public void moveTo(int i, int i1) {
    super.moveTo(i, i1);
    updateAlignment();
  }
  @Override
  public void setHeight(int i) {
    super.setHeight(i);
    updateAlignment();
  }
  @Override
  public void setX(int i) {
    super.setX(i);
  }
  @Override
  public void setY(int i) {
    super.setY(i);
  }

  public static EditorCell_GridCell getParentInstance(EditorCell child) {
    return (EditorCell_GridCell) TableTraversalUtil.getParent(child, (EditorCell c) -> c instanceof EditorCell_GridCell);
  }

  private class DeleteAction extends CellAction_DeleteNode {
    public DeleteAction() {
      super(myWrappedEditorCell.getSNode());
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return super.canExecute(context) && check_hp9uj0_a0a0a1bf(getParent(), this) != myWrappedEditorCell.getSNode();
    }
  }

  public class DoNothingAction extends AbstractCellAction {

    public DoNothingAction() {
      super(false);
    }

    public void execute(EditorContext context) {
    }
  }
  private static SNode check_hp9uj0_a0a0pb(SNodeLocation checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getContextNode();
    }
    return null;
  }
  private static SNodeLocation check_hp9uj0_a0a0a14(EditorCellContext checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getNodeLocation();
    }
    return null;
  }
  private static EditorCell check_hp9uj0_a0b0kd(EditorCell_GridCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.unwrap();
    }
    return null;
  }
  private static SNode check_hp9uj0_a0a0a1bf(jetbrains.mps.nodeEditor.cells.EditorCell_Collection checkedDotOperand, DeleteAction checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSNode();
    }
    return null;
  }
  private static <T> T as_hp9uj0_a0a0a88(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_hp9uj0_a0a0b0kd(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_hp9uj0_a0a0a0a1a99(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_hp9uj0_a0a2a0a1a99(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

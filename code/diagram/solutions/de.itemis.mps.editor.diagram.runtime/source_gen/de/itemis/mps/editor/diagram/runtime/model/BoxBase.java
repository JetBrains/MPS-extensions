package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import de.itemis.mps.editor.diagram.runtime.shape.IShape;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import de.itemis.mps.editor.diagram.runtime.EditorUtil;
import de.itemis.mps.editor.diagram.runtime.jgraph.LayoutDependencies;
import de.itemis.mps.editor.diagram.runtime.jgraph.RootDiagramECell;

public abstract class BoxBase extends DiagramElement {
  public static final int PADDING = 6;

  @NotNull
  protected Bounds myBounds = new Bounds(0, 0, 30, 20);
  protected boolean myBoundsChanged = false;
  protected IShape myShape = null;
  protected boolean myScalingAllowed = true;
  protected List<EditorCell> myContentCells = ListSequence.fromList(new ArrayList<EditorCell>());

  public BoxBase() {
  }

  public BoxBase(@Nullable SNode snode) {
    super(snode);
  }

  public void setBounds(@NotNull Bounds bounds) {
    if (bounds == null) {
      throw new NullPointerException();
    }
    if (!(myBounds.equals(bounds))) {
      myBounds = bounds.clone();
      myBoundsChanged = true;
    }
  }

  @NotNull
  public Bounds getBounds() {
    return myBounds.clone();
  }

  public void resetModificationFlags() {
    myBoundsChanged = false;
  }

  public boolean boundsChanged() {
    return myBoundsChanged;
  }

  public IShape getShape() {
    return myShape;
  }

  public void setShape(IShape shape) {
    myShape = shape;
  }

  public boolean setScalingAllowed(boolean allowScaling) {
    return myScalingAllowed = allowScaling;
  }

  public boolean isScalingAllowed() {
    return myScalingAllowed && ListSequence.fromList(myContentCells).select((it) -> ScalingInfoUtil.allowScaling(it)).reduceLeft((a, b) -> a && b);
  }

  public Size getPreferredSize() {
    final Size size = new Size(10, 10);
    for (final EditorCell c : ListSequence.fromList(myContentCells)) {
      DiagramCellUtil.disablePreferredSize(c, () -> {
        EditorUtil.relayoutWithoutWrap(c);

        size.atLeast(LayoutDependencies.getWidth(c) + Box.PADDING, LayoutDependencies.getHeight(c) + Box.PADDING);
      });
    }
    return size;
  }

  public List<EditorCell> getContentCells() {
    return new ArrayList<EditorCell>(myContentCells);
  }

  public void setContentCells(List<? extends EditorCell> cells) {
    for (EditorCell cell : ListSequence.fromList(cells)) {
      if (!(EditorUtil.descendants(cell, RootDiagramECell.class).isEmpty())) {
        throw new IllegalArgumentException("Cell contains a root diagram cell. It should contain only subdiagram cells.");
      }
    }
    myContentCells = new ArrayList<EditorCell>(cells);
  }

}

package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import org.modelix.model.api.INode;
import org.modelix.model.api.INodeWrapper;
import org.modelix.model.api.INodeReference;
import de.q60.mps.polymorphicfunctions.runtime.ParameterList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.NodeUtilKt;
import org.modelix.model.area.IArea;
import de.q60.mps.incremental.runtime.DependencyKey;
import de.q60.mps.incremental.runtime.DependencyBroadcaster;
import org.modelix.model.api.IConcept;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConceptReference;

public class DependencyTrackingNode implements INode, INodeWrapper {
  public static DependencyTrackingNode wrap(INode nodeToWrap) {
    if (nodeToWrap instanceof DependencyTrackingNode) {
      return ((DependencyTrackingNode) nodeToWrap);
    }
    return (nodeToWrap == null ? null : new DependencyTrackingNode(nodeToWrap));
  }
  public static NodeReference wrap(INodeReference nodeToWrap) {
    if (nodeToWrap instanceof NodeReference) {
      return ((NodeReference) nodeToWrap);
    }
    return (nodeToWrap == null ? null : new NodeReference(nodeToWrap));
  }

  public static ParameterList wrap(ParameterList parameters) {
    return new ParameterList(Sequence.fromIterable(parameters.asSequence()).select((it) -> (it instanceof INode ? wrap(((INode) it)) : it)));
  }

  public static INode unwrap(INode node) {
    while (node instanceof DependencyTrackingNode) {
      node = ((DependencyTrackingNode) node).node;
    }
    return node;
  }
  public static INodeReference unwrap(INodeReference node) {
    while (node instanceof NodeReference) {
      node = ((NodeReference) node).getWrappedNodeRef();
    }
    return node;
  }

  public static <T> List<T> wrap(List<T> list) {
    if (ListSequence.fromList(list).ofType(INode.class).where((it) -> !(it instanceof DependencyTrackingNode)).isEmpty()) {
      return list;
    }
    return ListSequence.fromList(list).select((it) -> (T) ((it instanceof INode ? DependencyTrackingNode.wrap((INode) it) : it))).toList();
  }

  public static <T> List<T> unwrap(List<T> list) {
    if (ListSequence.fromList(list).ofType(DependencyTrackingNode.class).isEmpty()) {
      return list;
    }
    return ListSequence.fromList(list).select((it) -> (T) ((it instanceof INode ? DependencyTrackingNode.unwrap((INode) it) : it))).toList();
  }

  public static Object[] wrap(Object[] arr) {
    if (Sequence.fromIterable(Sequence.fromArray(arr)).ofType(INode.class).where((it) -> !(it instanceof DependencyTrackingNode)).isEmpty()) {
      return arr;
    }
    return Sequence.fromIterable(Sequence.fromArray(arr)).select((it) -> (it instanceof INode ? DependencyTrackingNode.wrap((INode) it) : it)).toGenericArray(Object.class);
  }

  public static Object[] unwrap(Object[] arr) {
    if (Sequence.fromIterable(Sequence.fromArray(arr)).ofType(DependencyTrackingNode.class).isEmpty()) {
      return arr;
    }
    return Sequence.fromIterable(Sequence.fromArray(arr)).select((it) -> (it instanceof INode ? DependencyTrackingNode.unwrap((INode) it) : it)).toGenericArray(Object.class);
  }

  public static void checkHasTracking(Object o) {
    DependencyTrackingCheck.check(o);
  }

  private INode node;

  private DependencyTrackingNode(INode node1) {
    node = node1;
  }

  @NotNull
  @Override
  public INode getWrappedNode() {
    return node;
  }

  private INode getDeepUnwrappedNode() {
    return NodeUtilKt.deepUnwrapNode(node);
  }

  @NotNull
  @Override
  public IArea getArea() {
    return new DependencyTrackingArea(node.getArea());
  }

  @Override
  public boolean isValid() {
    return node.isValid();
  }

  protected void notifyAccess(DependencyKey dep) {
    if (node instanceof OutputNodeReferenceAsNode) {
      return;
    }
    DependencyBroadcaster.INSTANCE.dependencyAccessed(dep);
  }

  public void notifyChange(DependencyKey dep) {
    DependencyBroadcaster.INSTANCE.dependenciesChanged(Sequence.<DependencyKey>singleton(dep));
  }

  @Override
  public INodeReference getReference() {
    return new NodeReference(node.getReference());
  }
  @Override
  public IConcept getConcept() {
    return node.getConcept();
  }
  @Nullable
  @Override
  public IConceptReference getConceptReference() {
    return node.getConceptReference();
  }
  @Override
  public String getRoleInParent() {
    notifyAccess(new ContainmentDependency(getDeepUnwrappedNode().getReference()));
    return node.getRoleInParent();
  }
  @Override
  public INode getParent() {
    return wrap(node.getParent());
  }
  @Override
  public Iterable<INode> getChildren(String role) {
    notifyAccess(new RoleDependency(getDeepUnwrappedNode().getReference(), role));
    Iterable<INode> children = node.getChildren(role);
    return Sequence.fromIterable(children).select((it) -> wrap(it));
  }
  @Override
  public Iterable<INode> getAllChildren() {
    notifyAccess(new AllChildrenDependency(getDeepUnwrappedNode().getReference()));
    Iterable<INode> allChildren = node.getAllChildren();
    return Sequence.fromIterable(allChildren).select((it) -> wrap(it));
  }
  @Override
  public void moveChild(String role, int index, INode child) {
    node.moveChild(role, index, unwrap(child));
    notifyChange(new RoleDependency(node.getReference(), role));
    notifyChange(new ContainmentDependency(child.getReference()));
    notifyChange(new AllChildrenDependency(node.getReference()));
  }
  @Override
  public INode addNewChild(String role, int index, IConcept concept) {
    INode newChild = node.addNewChild(role, index, concept);
    notifyChange(new RoleDependency(node.getReference(), role));
    notifyChange(new AllChildrenDependency(node.getReference()));
    return wrap(newChild);
  }
  @NotNull
  @Override
  public INode addNewChild(@Nullable String role, int index, @Nullable IConceptReference concept) {
    INode newChild = node.addNewChild(role, index, concept);
    notifyChange(new RoleDependency(node.getReference(), role));
    notifyChange(new AllChildrenDependency(node.getReference()));
    return wrap(newChild);
  }
  @Override
  public void removeChild(INode child) {
    String role = child.getRoleInParent();
    node.removeChild(unwrap(child));
    notifyChange(new RoleDependency(node.getReference(), role));
    notifyChange(new ContainmentDependency(child.getReference()));
    notifyChange(new AllChildrenDependency(node.getReference()));
  }
  @Override
  public INode getReferenceTarget(String role) {
    notifyAccess(new RoleDependency(getDeepUnwrappedNode().getReference(), role));
    return wrap(node.getReferenceTarget(role));
  }
  @Nullable
  @Override
  public INodeReference getReferenceTargetRef(@NotNull String role) {
    notifyAccess(new RoleDependency(getDeepUnwrappedNode().getReference(), role));
    return wrap(node.getReferenceTargetRef(role));
  }
  @Override
  public void setReferenceTarget(String role, INode target) {
    node.setReferenceTarget(role, unwrap(target));
    notifyChange(new RoleDependency(node.getReference(), role));
    notifyChange(new RoleDependency(getDeepUnwrappedNode().getReference(), "$referenceRoles"));
  }
  @Override
  public void setReferenceTarget(@NotNull String role, @Nullable INodeReference target) {
    node.setReferenceTarget(role, unwrap(target));
    notifyChange(new RoleDependency(node.getReference(), role));
    notifyChange(new RoleDependency(getDeepUnwrappedNode().getReference(), "$referenceRoles"));
  }
  @Override
  public String getPropertyValue(String role) {
    notifyAccess(new RoleDependency(getDeepUnwrappedNode().getReference(), role));
    return node.getPropertyValue(role);
  }
  @Override
  public void setPropertyValue(String role, String value) {
    node.setPropertyValue(role, value);
    notifyChange(new RoleDependency(node.getReference(), role));
    notifyChange(new RoleDependency(getDeepUnwrappedNode().getReference(), "$propertyRoles"));
  }
  @NotNull
  @Override
  public List<String> getPropertyRoles() {
    notifyAccess(new RoleDependency(getDeepUnwrappedNode().getReference(), "$propertyRoles"));
    return node.getPropertyRoles();
  }
  @NotNull
  @Override
  public List<String> getReferenceRoles() {
    notifyAccess(new RoleDependency(getDeepUnwrappedNode().getReference(), "$referenceRoles"));
    return node.getReferenceRoles();
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    DependencyTrackingNode that = (DependencyTrackingNode) o;
    if ((node != null ? !(node.equals(that.node)) : that.node != null)) {
      return false;
    }

    return true;
  }
  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((node != null ? ((Object) node).hashCode() : 0));
    return result;
  }
  @Override
  public String toString() {
    return "Â°" + node;
  }

  public static class NodeReference implements INodeReference {
    private INodeReference wrappedNodeRef;

    public NodeReference(INodeReference wrappedNodeRef) {
      this.wrappedNodeRef = wrappedNodeRef;
    }

    @Nullable
    @Override
    public INode resolveNode(@Nullable IArea area) {
      return DependencyTrackingNode.wrap(wrappedNodeRef.resolveNode(area));
    }

    public INodeReference getWrappedNodeRef() {
      return this.wrappedNodeRef;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      NodeReference that = (NodeReference) o;
      if ((wrappedNodeRef != null ? !(wrappedNodeRef.equals(that.wrappedNodeRef)) : that.wrappedNodeRef != null)) {
        return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((wrappedNodeRef != null ? ((Object) wrappedNodeRef).hashCode() : 0));
      return result;
    }
  }
}

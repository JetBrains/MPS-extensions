package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import jetbrains.mps.openapi.editor.EditorComponent;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import de.itemis.mps.editor.diagram.runtime.jgraph.ILayouter;
import de.itemis.mps.editor.diagram.runtime.jgraph.LayeredLayouter;
import de.itemis.mps.editor.diagram.runtime.shape.IShape;
import java.util.HashSet;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import de.itemis.mps.editor.diagram.runtime.DiagramUtil;
import java.util.Collection;
import de.itemis.mps.editor.diagram.runtime.DiagramContext;
import de.itemis.mps.editor.diagram.runtime.jgraph.BaseDiagramECell;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class DiagramModel {
  private static final Logger LOG = Logger.getLogger(DiagramModel.class);
  public static final boolean ALLOW_DELETE_DURING_SYNC = false;

  private static Map<EditorComponent, Map<SNode, Map<String, DiagramModel>>> ourInstances = MapSequence.fromMap(new HashMap<>());
  private boolean isNewInstance = true;
  private boolean isForceReadFromModel = false;

  public boolean isNewInstance() {
    return isNewInstance;
  }

  public boolean setForceReadFromModel(boolean flag) {
    return isForceReadFromModel = flag;
  }

  public boolean isForceReadFromModel() {
    return isForceReadFromModel;
  }

  private static Map<SNode, Map<String, DiagramModel>> getModels(EditorComponent editorComponent) {
    // No synchronization/locks required for editor code
    ThreadUtils.assertEDT();
    if (editorComponent.isDisposed()) {
      throw new IllegalStateException("Editor is already disposed");
    }

    Map<SNode, Map<String, DiagramModel>> instances = MapSequence.fromMap(ourInstances).get(editorComponent);
    if (instances == null) {
      instances = MapSequence.fromMap(new HashMap<SNode, Map<String, DiagramModel>>());
      ((jetbrains.mps.nodeEditor.EditorComponent) editorComponent).addDisposeListener((e) -> MapSequence.fromMap(ourInstances).removeKey(e));
      MapSequence.fromMap(ourInstances).put(editorComponent, instances);
    }
    return instances;
  }
  private static Map<String, DiagramModel> getModels(EditorComponent editorComponent, SNode snode) {
    Map<String, DiagramModel> instances = MapSequence.fromMap(getModels(editorComponent)).get(snode);
    if (instances == null) {
      instances = MapSequence.fromMap(new HashMap<String, DiagramModel>());
      MapSequence.fromMap(getModels(editorComponent)).put(snode, instances);
    }
    return instances;
  }

  public static DiagramModel getModel(EditorComponent editorComponent, SNode snode, String cellId) {
    DiagramModel instance = MapSequence.fromMap(getModels(editorComponent, snode)).get(cellId);
    if (instance == null) {
      instance = new DiagramModel(editorComponent, snode);
      MapSequence.fromMap(getModels(editorComponent, snode)).put(cellId, instance);
      instance.isNewInstance = true;
    } else {
      instance.isNewInstance = false;
    }
    return instance;
  }

  public static DiagramModel getModel(EditorContext editorContext, SNode snode, IAccessorKey key) {
    return getModel(editorContext.getEditorComponent(), snode, key.serialize());
  }

  @Deprecated
  public static DiagramModel getModel(EditorContext editorContext, SNode snode, String cellId) {
    return getModel(editorContext.getEditorComponent(), snode, cellId);
  }

  public static DiagramModel getModel(EditorComponent editorComponent, SNode snode, String cellId, IDiagramAccessor accessor) {
    DiagramModel instance = getModel(editorComponent, snode, cellId);
    instance.setDiagramAccessor(accessor);
    return instance;
  }

  @Deprecated
  public static DiagramModel getModel(EditorContext editorContext, SNode snode, String cellId, IDiagramAccessor accessor) {
    return getModel(editorContext.getEditorComponent(), snode, cellId, accessor);
  }

  private Map<SNode, IDiagramElement> mySNode2diagramElement = MapSequence.fromMap(new HashMap<SNode, IDiagramElement>());
  private Map<IAccessorKey, IDiagramElement> myAccessor2diagramElement = MapSequence.fromMap(new HashMap<IAccessorKey, IDiagramElement>());
  private Set<Box> myBoxes = SetSequence.fromSet(new LinkedHashSet<Box>());
  private Set<Edge> myEdges = SetSequence.fromSet(new LinkedHashSet<Edge>());
  private Set<Annotation> myAnnotations = SetSequence.fromSet(new LinkedHashSet<Annotation>());
  private EditorComponent myEditorComponent;
  private SNode mySNode;
  private List<IDiagramModelListener> myListeners = new CopyOnWriteArrayList<IDiagramModelListener>();
  private String[] myContextHints = new String[0];
  private List<IDiagramElement> myElementsToDelete = ListSequence.fromList(new ArrayList<IDiagramElement>());
  private List<IConnectionType_Internal> myConnectionTypes = ListSequence.fromList(new ArrayList<IConnectionType_Internal>());
  private ModelSynchronizer mySynchronizer;
  private boolean myLayouterWasExecuted = false;
  private List<IEndpointRedirect> myEndpointRedirects = ListSequence.fromList(new ArrayList<IEndpointRedirect>());
  private ILayouter myLayouter = new LayeredLayouter();
  private DiagramModel myParentModel = null;
  private Map<DiagramModel, IDiagramCell> myChildModels = MapSequence.fromMap(new HashMap<DiagramModel, IDiagramCell>());
  private IShape myDefaultBoxShape;
  private Set<String> myReportedEndpoints = SetSequence.fromSet(new HashSet<String>());
  private IPaletteEntryProvider myPaletteEntryProvider;
  private Map<String, Object> userObjects = MapSequence.fromMap(new HashMap<String, Object>());

  public DiagramModel(EditorComponent editorComponent, SNode snode) {
    myEditorComponent = editorComponent;
    mySNode = snode;
    mySynchronizer = new ModelSynchronizer(this, editorComponent);
  }

  public void putUserObject(String key, Object value) {
    MapSequence.fromMap(userObjects).put(key, value);
  }

  public Object getUserObject(String key) {
    return MapSequence.fromMap(userObjects).get(key);
  }

  public void addEndpointRedirect(IEndpointRedirect redirect) {
    ListSequence.fromList(myEndpointRedirects).addElement(redirect);
  }

  public void clearEndpointRedirects() {
    ListSequence.fromList(myEndpointRedirects).clear();
  }

  public List<IEndpointRedirect> getEndpointRedirects() {
    return myEndpointRedirects;
  }

  @Nullable
  public IConnectionEndpoint_Internal resolveEndpointLocal(@Nullable IConnectionEndpointReference reference, boolean isConnectionEnd) {
    if (reference == null) {
      return null;
    }
    IConnectionEndpointReference previous;
    IConnectionEndpointReference current = reference;
    int timeout = 1000;
    do {
      previous = current;
      for (IEndpointRedirect redirect : ListSequence.fromList(myEndpointRedirects)) {
        IConnectionEndpointReference temp = (isConnectionEnd ? redirect.endFromSModel(current) : redirect.startFromSModel(current));
        if (temp != null) {
          current = temp;
        }
      }
      timeout--;
      if (timeout == 0) {
        throw new RuntimeException("Redirect loop: " + reference);
      }
    } while (current != previous);

    return current.resolve(this, isConnectionEnd);
  }

  public void setDiagramAccessor(@NotNull IDiagramAccessor accessor) {
    mySynchronizer.setDiagramAccessor(accessor);
  }

  public IDiagramAccessor getDiagramAccessor() {
    return mySynchronizer.getDiagramAccessor();
  }

  public String getPaletteFolder(IPaletteEntry action) {
    SAbstractConcept outputConcept = action.getOutputConcept();
    SNode targetNode = null;
    if (action instanceof SubstituteActionPaletteEntry) {
      targetNode = DiagramUtil.getReferenceTarget(((SubstituteActionPaletteEntry) action).getSubstituteAction());
    }
    String folder = getDiagramAccessor().getPaletteFolderForEntry(outputConcept, targetNode);
    return folder;
  }

  public EditorContext getEditorContext() {
    return myEditorComponent.getEditorContext();
  }

  public void setContextHints(Collection<String> hints) {
    myContextHints = hints.toArray(new String[hints.size()]);
  }

  public String[] getContextHints() {
    return myContextHints;
  }

  public void synchronizeWrite(@Nullable final IDiagramCell diagramECell) {
    ScalableEditorCell.withScalingDisabled(() -> myEditorComponent.getEditorContext().getRepository().getModelAccess().executeCommand(() -> {
      if (!(diagramECell.getEditorComponent().isDisposed())) {
        mySynchronizer.toSModel(diagramECell);
        for (DiagramModel child : ListSequence.fromList(getChildModels())) {
          child.synchronizeWrite(diagramECell);
        }
      }
    }));
  }

  public void synchronizeRead(@Nullable final IDiagramCell diagramECell) {
    DiagramContext.withContext(((BaseDiagramECell) diagramECell), new Runnable() {
      @Override
      public void run() {
        ScalableEditorCell.withScalingDisabled(() -> mySynchronizer.fromSModel(diagramECell));
      }
    });
  }

  public void setConnectionTypes(List<? extends IConnectionType_Internal> types) {
    myConnectionTypes = new ArrayList<IConnectionType_Internal>(types);
  }

  public List<IConnectionType_Internal> getConnectionTypes() {
    return Collections.unmodifiableList(myConnectionTypes);
  }

  public Box getNodeBySNode(SNode snode) {
    return (Box) getElementBySNode(snode);
  }

  public Edge getEdgeBySNode(SNode snode) {
    return (Edge) getElementBySNode(snode);
  }

  public IDiagramElement getElementBySNode(SNode snode) {
    return MapSequence.fromMap(mySNode2diagramElement).get(snode);
  }

  public IDiagramElement getElement(IAccessorKey key) {
    return MapSequence.fromMap(myAccessor2diagramElement).get(key);
  }

  public void registerDiagramElement(IDiagramElement element) {
    IDiagramElement existing = MapSequence.fromMap(myAccessor2diagramElement).get(element.getAccessor().getId());
    unregister(existing);
    MapSequence.fromMap(myAccessor2diagramElement).put(element.getAccessor().getId(), element);
    if (element.getSNode() != null) {
      MapSequence.fromMap(mySNode2diagramElement).put(element.getSNode(), element);
    }
    if (element instanceof Box) {
      SetSequence.fromSet(myBoxes).addElement((Box) element);
    }
    if (element instanceof Edge) {
      SetSequence.fromSet(myEdges).addElement((Edge) element);
    }
    if (element instanceof Annotation) {
      SetSequence.fromSet(myAnnotations).addElement((Annotation) element);
    }
    if (existing != null) {
      fireDiagramElementReplaced(existing, element);
    }
    element.setModel(this);
  }

  public void unregister(IDiagramElement element) {
    if (element == null) {
      return;
    }
    if (element instanceof Box) {
      SetSequence.fromSet(myBoxes).removeElement((Box) element);
    }
    if (element instanceof Edge) {
      SetSequence.fromSet(myEdges).removeElement((Edge) element);
    }
    if (element instanceof Annotation) {
      SetSequence.fromSet(myAnnotations).removeElement((Annotation) element);
    }
    MapSequence.fromMap(myAccessor2diagramElement).removeKey(element.getAccessor().getId());
    if (element.getSNode() != null) {
      MapSequence.fromMap(mySNode2diagramElement).removeKey(element.getSNode());
    }
  }

  public Box createNode(IBoxCreator snodeCreator, @Nullable Edge edgeToSplit) {
    PendingBox box = new PendingBox(snodeCreator);
    box.setModel(this);
    box.setEdgeToSplit(edgeToSplit);
    SetSequence.fromSet(myBoxes).addElement(box);
    return box;
  }

  public Edge createEdge(IConnectionType_Internal creator, Box fromNode, String fromPort, Box toNode, String toPort) {
    Edge edge = creator.create(fromNode, fromPort, toNode, toPort);
    edge.setModel(this);
    SetSequence.fromSet(myEdges).addElement(edge);
    return edge;
  }

  public Iterable<Box> getBoxes() {
    return ListSequence.fromListWithValues(new ArrayList<Box>(), myBoxes);
  }

  public Iterable<Edge> getEdges() {
    return ListSequence.fromListWithValues(new ArrayList<Edge>(), myEdges);
  }

  public boolean hasVisibleEdges(final Box box) {
    return Sequence.fromIterable(box.getModel().getEdges()).where((it) -> EndpointUtil.getBox(it.getResolvedEndpointFrom()) == box || EndpointUtil.getBox(it.getResolvedEndpointTo()) == box).any((it) -> it.isVisible());
  }

  public boolean hasInvisibleEdges(final Box box) {
    return Sequence.fromIterable(box.getModel().getEdges()).where((it) -> EndpointUtil.getBox(it.getResolvedEndpointFrom()) == box || EndpointUtil.getBox(it.getResolvedEndpointTo()) == box).any((it) -> !(it.isVisible()));
  }

  public Iterable<Annotation> getAnnotations() {
    return ListSequence.fromListWithValues(new ArrayList<Annotation>(), myAnnotations);
  }
  public List<Annotation> getAnnotations(final IDiagramElement annotatedElement) {
    return SetSequence.fromSet(myAnnotations).where((it) -> it.getAnnotatedElement() == annotatedElement).toList();
  }

  public Iterable<IDiagramElement> getElements() {
    List<IDiagramElement> result = ListSequence.fromList(new ArrayList<IDiagramElement>());
    ListSequence.fromList(result).addSequence(SetSequence.fromSet(myBoxes));
    ListSequence.fromList(result).addSequence(SetSequence.fromSet(myEdges));
    ListSequence.fromList(result).addSequence(SetSequence.fromSet(myAnnotations));
    return result;
  }

  public void removeElements(Iterable<IDiagramElement> toRemove) {
    Sequence.fromIterable(toRemove).visitAll((it) -> removeElement(it));
  }
  public void removeElement(IDiagramElement toRemove) {
    if (toRemove instanceof Box) {
      SetSequence.fromSet(myBoxes).removeElement((Box) toRemove);
    }
    if (toRemove instanceof Edge) {
      SetSequence.fromSet(myEdges).removeElement((Edge) toRemove);
    }
    if (toRemove instanceof Annotation) {
      SetSequence.fromSet(myAnnotations).removeElement((Annotation) toRemove);
    }
    ListSequence.fromList(myElementsToDelete).addElement(toRemove);
  }

  public List<IDiagramElement> getElementsToDelete() {
    return myElementsToDelete;
  }

  public void clearElementsToDelete() {
    ListSequence.fromList(myElementsToDelete).clear();
  }

  public void removeBox(Box box) {
    SetSequence.fromSet(myBoxes).removeElement(box);
  }

  public void removeEdge(Edge edge) {
    SetSequence.fromSet(myEdges).removeElement(edge);
  }

  public void removeAnnotation(Annotation annotation) {
    SetSequence.fromSet(myAnnotations).removeElement(annotation);
  }

  public void addListener(IDiagramModelListener l) {
    myListeners.add(l);
  }

  public void removeListener(IDiagramModelListener l) {
    myListeners.remove(l);
  }

  public void firePendingReplaced(IPendingDiagramElement pending, IDiagramElement replacedBy) {
    for (IDiagramModelListener l : ListSequence.fromList(myListeners)) {
      l.pendingElementReplaced(pending, replacedBy);
    }
  }

  protected void fireDiagramElementReplaced(IDiagramElement previous, IDiagramElement replacedBy) {
    for (IDiagramModelListener l : ListSequence.fromList(myListeners)) {
      l.diagramElementReplaced(previous, replacedBy);
    }
  }

  public void resetModificationFlags() {
    for (IDiagramElement e : Sequence.fromIterable(getElements())) {
      e.resetModificationFlags();
    }
  }

  public boolean isLayouterWasExecuted() {
    return myLayouterWasExecuted;
  }

  public void setLayouterWasExecuted(boolean wasExecuted) {
    myLayouterWasExecuted = wasExecuted;
  }

  @NotNull
  public ILayouter getLayouter() {
    return myLayouter;
  }

  public void setLayouter(@NotNull ILayouter layouter) {
    myLayouter = layouter;
  }

  public Tuples._2<Double, Double> getPreferredSize() {
    double minX = Double.MAX_VALUE;
    double minY = Double.MAX_VALUE;
    double maxX = Double.MIN_VALUE;
    double maxY = Double.MIN_VALUE;
    for (Box box : Sequence.fromIterable(getBoxes())) {
      minX = Math.min(minX, box.getBounds().getMinX());
      minY = Math.min(minY, box.getBounds().getMinY());
      maxX = Math.max(maxX, box.getBounds().getMaxX());
      maxY = Math.max(maxY, box.getBounds().getMaxY());
    }
    return MultiTuple.<Double,Double>from(maxX + 20, maxY + 20);
  }

  protected void setParentModel(DiagramModel parent) {
    myParentModel = parent;
  }

  public DiagramModel getParentModel() {
    return myParentModel;
  }

  public DiagramModel getRootModel() {
    return (myParentModel == null ? this : myParentModel.getRootModel());
  }

  public void addChildModel(DiagramModel child, IDiagramCell source) {
    Map<DiagramModel, IDiagramCell> copy = MapSequence.fromMap(new HashMap<DiagramModel, IDiagramCell>(MapSequence.fromMap(myChildModels).count()));
    MapSequence.fromMap(copy).putAll(myChildModels);
    MapSequence.fromMap(copy).put(child, source);
    child.setParentModel(this);
    myChildModels = copy;
  }

  public void removeChildModel(DiagramModel child) {
    Map<DiagramModel, IDiagramCell> copy = MapSequence.fromMap(new HashMap<DiagramModel, IDiagramCell>(MapSequence.fromMap(myChildModels).count()));
    MapSequence.fromMap(copy).putAll(myChildModels);
    MapSequence.fromMap(copy).removeKey(child);
    child.setParentModel(null);
    myChildModels = copy;
  }

  public void clearChildModels() {
    SetSequence.fromSet(MapSequence.fromMap(myChildModels).keySet()).visitAll((it) -> it.setParentModel(null));
    myChildModels = MapSequence.fromMap(new HashMap<DiagramModel, IDiagramCell>());
  }

  public List<DiagramModel> getChildModels() {
    return ListSequence.fromListWithValues(new ArrayList<DiagramModel>(), MapSequence.fromMap(myChildModels).keySet());
  }

  @Nullable
  public IShape getDefaultBoxShape() {
    return myDefaultBoxShape;
  }

  public void setDefaultBoxShape(@Nullable IShape shape) {
    myDefaultBoxShape = shape;
  }

  public static boolean isNewEdge(Edge edge) {
    return edge.isNew();
  }

  public boolean isSubdiagram() {
    return myParentModel == null;
  }

  public IConnectionEndpoint_Internal resolveEndpointGlobal(IConnectionEndpoint_Internal endpoint, boolean isEnd) {
    if (endpoint instanceof UnresolvedEndpoint) {
      IConnectionEndpointReference endpointReference = ((UnresolvedEndpoint) endpoint).getEndpointReference();
      for (DiagramModel m : Sequence.fromIterable(getAllModels())) {
        IConnectionEndpoint_Internal resolved = m.resolveEndpointLocal(endpointReference, isEnd);
        if (resolved != null) {
          return resolved;
        }
      }

      String referenceString = "" + endpointReference;
      if (!(SetSequence.fromSet(myReportedEndpoints).contains(referenceString))) {
        SetSequence.fromSet(myReportedEndpoints).addElement(referenceString);
        if (LOG.isWarningLevel()) {
          LOG.warning("Cannot resolve endpoint: " + referenceString);
        }
      }
    } else {
      return endpoint;
    }
    return null;
  }

  public Iterable<DiagramModel> getDescendantModels() {
    if (MapSequence.fromMap(myChildModels).isEmpty()) {
      return Sequence.fromIterable(Collections.<DiagramModel>emptyList());
    }
    return SetSequence.fromSet(MapSequence.fromMap(myChildModels).keySet()).concat(SetSequence.fromSet(MapSequence.fromMap(myChildModels).keySet()).translate((it) -> it.getDescendantModels()));
  }

  public Iterable<DiagramModel> getDescendentsAndSelf() {
    return Sequence.fromIterable(Sequence.<DiagramModel>singleton(this)).concat(Sequence.fromIterable(getDescendantModels()));
  }

  public Iterable<DiagramModel> getAllModels() {
    return getRootModel().getDescendentsAndSelf();
  }

  public IPaletteEntryProvider getPaletteEntryProvider() {
    return myPaletteEntryProvider;
  }

  public void setPaletteEntryProvider(IPaletteEntryProvider paletteEntryProvider) {
    myPaletteEntryProvider = paletteEntryProvider;
  }
  public SNode getSNode() {
    return mySNode;
  }
}

package de.itemis.mps.editor.bool.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.nodeEditor.cells.TransactionalModelAccessor;
import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.event.MouseEvent;
import java.awt.event.KeyEvent;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;

public class EditorCell_Checkbox extends EditorCell_Basic {
  private ModelAccessor myModelAccessor;
  private boolean myIsChecked;
  private boolean myCommitInProgress = false;
  private CheckboxImages myImages;

  protected EditorCell_Checkbox(EditorContext context, SNode node, ModelAccessor modelAccessor) {
    super(context, node);
    myImages = new CheckboxImages(context.getRepository());
    myModelAccessor = modelAccessor;
    synchronizeViewWithModel();
    setSelectable(true);
  }

  public boolean isReadOnly() {
    return getStyle().get(StyleAttributes.READ_ONLY);
  }

  public void setImageTrue(String path) {
    setImageTrue(path, 1.0);
  }

  public void setImageFalse(String path) {
    setImageFalse(path, 1.0);
  }

  public void setImageTrue(String path, double scale) {
    myImages.setScaleTrue(scale);
    myImages.setImageTrue(path, getSNode());
  }

  public void setImageFalse(String path, double scale) {
    myImages.setScaleFalse(scale);
    myImages.setImageFalse(path, getSNode());
  }

  @Override
  public void synchronizeViewWithModel() {
    myIsChecked = "true".equals(myModelAccessor.getText());
    myImages.setChecked(myIsChecked);
    requestRelayout();
  }

  public void setChecked(boolean newValue) {
    if (newValue != myIsChecked) {
      myIsChecked = newValue;
      getEditorComponent().getEditorContext().getRepository().getModelAccess().executeCommandInEDT(() -> commit());
    }
  }

  public void toggle() {
    setChecked(!(myIsChecked));
  }

  public void commit() {
    // this method is copied from EditorCell_Property
    getContext().getRepository().getModelAccess().checkWriteAccess();
    if (!(SNodeUtil.isAccessible(getSNode(), getContext().getRepository()))) {
      return;
    }
    if (myCommitInProgress) {
      return;
    }
    myCommitInProgress = true;
    try {
      myModelAccessor.setText((myIsChecked ? "true" : "false"));
      if (myModelAccessor instanceof TransactionalModelAccessor) {
        ((TransactionalModelAccessor) myModelAccessor).commit();
        synchronizeViewWithModel();
        getEditor().relayout();
      }
    } finally {
      myCommitInProgress = false;
    }
  }

  public static EditorCell_Checkbox create(EditorContext editorContext, ModelAccessor modelAccessor, SNode node) {
    NodeReadAccessInEditorListener listener = NodeReadAccessCasterInEditor.getReadAccessListener();
    if (modelAccessor instanceof PropertyAccessor) {
      if (listener != null) {
        listener.clearCleanlyReadAccessProperties();
      }
    }
    EditorCell_Checkbox result = new EditorCell_Checkbox(editorContext, node, modelAccessor);
    if (listener != null) {
      addPropertyDependenciesToEditor(listener, result);
    }
    return result;
  }

  private static void addPropertyDependenciesToEditor(NodeReadAccessInEditorListener listener, EditorCell_Checkbox result) {
    for (Pair<SNodeReference, String> pair : listener.popCleanlyReadAccessedProperties()) {
      result.getEditorComponent().getUpdater().getCurrentUpdateSession().registerCleanDependency(result, pair);
    }
  }

  public void paintContent(Graphics g, ParentSettings settings) {
    int offsetX = (getWidth() - myImages.getWidth()) / 2;
    int offsetY = (getHeight() - myImages.getHeight()) / 2;
    myImages.paint(g, getX() + offsetX, getY() + offsetY, getEditor());
  }

  @Override
  protected void relayoutImpl() {
    myWidth = myImages.getHeight();
    myHeight = myImages.getWidth();
  }

  @Override
  public boolean processMousePressed(MouseEvent event) {
    if (getX() <= event.getX() && event.getX() <= getX() + getWidth()) {
      if (getY() <= event.getY() && event.getY() <= getY() + getHeight()) {
        if (!(isReadOnly())) {
          toggle();
        }
        return true;
      }
    }
    return false;
  }

  @Override
  protected boolean doProcessKeyTyped(KeyEvent event, boolean b) {
    if (event.getKeyChar() == ' ') {
      if (!(isReadOnly())) {
        toggle();
      }
      return true;
    }
    return false;
  }

  @Override
  public TextBuilder renderText() {
    String text = (myIsChecked ? "☑" : "☐");
    return new TextBuilderImpl(text);
  }
}

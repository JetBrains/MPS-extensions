package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import de.q60.mps.logging.runtime.ShadowLogging;

public class MappingLabels {
  private boolean frozen = false;
  private Map<String, MappingLabel> labels = MapSequence.fromMap(new HashMap<String, MappingLabel>());

  public Iterable<Tuples._2<MappingLabelCall, IOutputNodesReference>> getEntries() {
    return MapSequence.fromMap(labels).translate((final IMapping<String, MappingLabel> it) -> MapSequence.fromMap(it.value().entries).select((it2) -> MultiTuple.<MappingLabelCall,IOutputNodesReference>from(new MappingLabelCall(it.key(), it2.key()), it2.value())));
  }

  protected void checkNotFrozen() {
    if (frozen) {
      throw new IllegalStateException("Transformation result computation is already completed.");
    }
  }

  public void freeze() {
    frozen = true;
  }

  public boolean isEmpty() {
    for (MappingLabel label : Sequence.fromIterable(MapSequence.fromMap(labels).values())) {
      if (!(label.isEmpty())) {
        return false;
      }
    }
    return true;
  }

  public MappingLabel getOrCreateLabel(String id) {
    MappingLabel label = MapSequence.fromMap(labels).get(id);
    if (label == null) {
      checkNotFrozen();
      label = new MappingLabel(id);
      MapSequence.fromMap(labels).put(id, label);
    }
    return label;
  }

  public MappingLabel getLabel(String id) {
    return MapSequence.fromMap(labels).get(id);
  }

  @Nullable
  public IOutputNodesReference getOutput(MappingLabelCall labelCall) {
    DependencyTrackingNode.checkHasTracking(labelCall);
    MappingLabel label = getLabel(labelCall.getLabelId());
    if (label == null) {
      return null;
    }
    return label.get(labelCall.getInput());
  }

  public void putEntry(MappingLabelCall labelCall, IOutputNodesReference output) {
    checkNotFrozen();
    DependencyTrackingNode.checkHasTracking(labelCall);
    getOrCreateLabel(labelCall.getLabelId()).put(labelCall.getInput(), output);
  }

  public class MappingLabel {
    private String id;
    private final Map<List<Object>, IOutputNodesReference> entries = MapSequence.fromMap(new HashMap<List<Object>, IOutputNodesReference>());
    public MappingLabel(String id) {
      this.id = id;
    }
    public void put(List<Object> input, IOutputNodesReference output) {
      checkNotFrozen();
      IOutputNodesReference existing = MapSequence.fromMap(entries).get(input);
      if (existing != null) {
        String msg = "Duplicate mapping label entry. Label: " + id + ", input: " + input + ", existing: " + existing + ", additional: " + output;
        ShadowLogging.logError(msg, id, input, existing, output);
        throw new RuntimeException(msg);
      }
      MapSequence.fromMap(entries).put(input, output);
    }
    public IOutputNodesReference get(List<Object> input) {
      return MapSequence.fromMap(entries).get(input);
    }
    public boolean isEmpty() {
      return MapSequence.fromMap(entries).isEmpty();
    }
  }
}

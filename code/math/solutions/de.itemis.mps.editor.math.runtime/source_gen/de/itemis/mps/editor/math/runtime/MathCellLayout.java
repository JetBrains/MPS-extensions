package de.itemis.mps.editor.math.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellLayout.AbstractCellLayout;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.nodeEditor.sidetransform.EditorCell_STHint;
import jetbrains.mps.nodeEditor.cellActions.SideTransformSubstituteInfo;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import java.util.List;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;
import jetbrains.mps.nodeEditor.cellLayout.PunctuationUtil;

public abstract class MathCellLayout extends AbstractCellLayout {

  public MathCellLayout() {
  }

  public void doLayout(EditorCell_Collection collection) {
    final EditorCell_MathBase mathCell = (EditorCell_MathBase) collection;
    Iterable<EditorCell> childCells = mathCell;

    for (jetbrains.mps.nodeEditor.cells.EditorCell child : mathCell.getCells()) {
      child.relayout();
    }

    int prevX = mathCell.getX();
    int prevY = mathCell.getY();
    mathCell.moveTo(0, 0);
    mathCell.setWidth(0);
    mathCell.setHeight(0);
    layout(new MathLayoutableCellAdapter(mathCell, 0, 0), mathCell.getLayoutableChilds(false), mathCell.getSymbols());

    boolean showEndCells = mathCell.showEndCells();
    final Wrappers._T<EditorCell_MathEnd> leftEnd = new Wrappers._T<EditorCell_MathEnd>(null);
    EditorCell_MathEnd rightEnd = null;
    if (showEndCells) {
      leftEnd.value = mathCell.getLeftEndCell();
      rightEnd = mathCell.getRightEndCell();
    }

    if (showEndCells) {
      ListSequence.fromList(mathCell.getLayoutableChilds(false)).visitAll((it) -> it.setX(it.getXInt() + (leftEnd.value.getWidth() + 3)));
    }
    int maxX = ListSequence.fromList(mathCell.getLayoutableChilds(false)).foldLeft(0, (Integer s, MathLayoutableCell it) -> Math.max(s, it.getXInt() + it.getWidthInt()));
    maxX = Math.max(maxX, mathCell.getWidth());
    if (showEndCells) {
      leftEnd.value.moveTo(0, 0);
      rightEnd.moveTo(maxX + 3, 0);
    }

    Sequence.fromIterable(childCells).ofType(EditorCell_STHint.class).visitAll((it) -> it.moveTo(mathCell.getX(), mathCell.getY()));
    updateBounds(mathCell);
    if (showEndCells) {
      leftEnd.value.moveTo(leftEnd.value.getX(), getCenterY(mathCell) - leftEnd.value.getHeight() / 2);
      rightEnd.moveTo(rightEnd.getX(), getCenterY(mathCell) - rightEnd.getHeight() / 2);
      leftEnd.value.relayout();
      rightEnd.relayout();
    }

    mathCell.setX(prevX);
    mathCell.setY(prevY);
    for (EditorCell child : Sequence.fromIterable(mathCell)) {
      child.moveTo(child.getX() + prevX, child.getY() + prevY);
    }

    // side transform hint cell
    for (EditorCell_STHint sthint : Sequence.fromIterable(childCells).ofType(EditorCell_STHint.class)) {
      if (sthint.getSide() == SideTransformSubstituteInfo.Side.LEFT) {
        if (showEndCells) {
          sthint.moveTo(leftEnd.value.getX() - sthint.getWidth(), leftEnd.value.getY() - (leftEnd.value.getHeight() - sthint.getHeight()) / 2);
        } else {
          sthint.moveTo(mathCell.getX() - sthint.getWidth(), mathCell.getY() + (mathCell.getHeight() - sthint.getHeight()) / 2);
        }
      } else {
        if (showEndCells) {
          sthint.moveTo(rightEnd.getX() + rightEnd.getWidth(), rightEnd.getY() - (rightEnd.getHeight() - sthint.getHeight()) / 2);
        } else {
          sthint.moveTo(mathCell.getX() + mathCell.getWidth(), mathCell.getY() + (mathCell.getHeight() - sthint.getHeight()) / 2);
        }
      }
      sthint.relayout();
    }
    fitToChildren(mathCell);

    for (EditorCell child : Sequence.fromIterable(childCells)) {
      child.relayout();
    }

  }

  private static void updateBounds(jetbrains.mps.nodeEditor.cells.EditorCell_Collection collection) {
    EditorCell[] childs = collection.getCells();
    if (childs.length > 0) {
      Rectangle bounds = GeometryUtil.getBounds(childs);
      if (bounds.x + bounds.width > collection.getWidth()) {
        collection.setWidth(bounds.x + bounds.width);
      }
      if (bounds.y + bounds.height > collection.getHeight()) {
        collection.setHeight(bounds.y + bounds.height);
      }
    }
  }

  public static void fitToChildren(EditorCell_Collection collection) {
    int minX = collection.getX();
    int maxX = collection.getX() + collection.getWidth();
    int minY = collection.getY();
    int maxY = collection.getY() + collection.getHeight();
    for (EditorCell child : Sequence.fromIterable(collection)) {
      minX = Math.min(minX, child.getX());
      maxX = Math.max(maxX, child.getX() + child.getWidth());
      minY = Math.min(minY, child.getY());
      maxY = Math.max(maxY, child.getY() + child.getHeight());
    }
    collection.setX(minX);
    collection.setY(minY);
    collection.setWidth(maxX - minX);
    collection.setHeight(maxY - minY);
  }

  @Override
  public int getAscent(EditorCell_Collection collection) {
    if (collection instanceof EditorCell_MathBase) {
      EditorCell_MathBase cell = (EditorCell_MathBase) collection;
      return getCenterY(cell) - 1 + MathUtil.getFontHeight(collection) / 2;
    } else {
      return collection.getAscent();
    }
  }

  protected abstract void layout(MathLayoutableCell cell, List<MathLayoutableCell> childCells, List<IMathSymbol> symbols);

  protected int getCenterY(MathLayoutableCell cell, List<MathLayoutableCell> childCells, List<IMathSymbol> symbols) {
    return cell.getHeightInt() / 2;
  }

  public int getCenterY(EditorCell_MathBase mathCell) {
    return getCenterY(new MathLayoutableCellAdapter(mathCell, -mathCell.getPaintOffsetX(), -mathCell.getPaintOffsetY()), mathCell.getLayoutableChilds(true), mathCell.getSymbols());
  }

  public TextBuilder doLayoutText(Iterable<EditorCell> editorCells) {
    TextBuilder result = new TextBuilderImpl();
    for (EditorCell editorCell : editorCells) {
      result = result.appendToTheRight(editorCell.renderText(), PunctuationUtil.hasLeftGap(editorCell));
    }
    return result;
  }
}

package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellProviders.AbstractCellListHandler;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.language.SConceptFeature;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.nodeEditor.cellActions.CellAction_DeleteNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;

public abstract class InCellListHandler extends AbstractCellListHandler {

  private Iterable<SNode> myChilds;
  private SNode myOwnerNode;

  public InCellListHandler(SNode ownerNode, Iterable<SNode> childs, EditorContext context) {
    super(context);
    myChilds = childs;
    myOwnerNode = ownerNode;
  }

  public String getElementRole() {
    return null;
  }

  public SConceptFeature getElementSRole() {
    return null;
  }

  /**
   * 
   * @deprecated use createEmptyCell()
   */
  @Deprecated
  protected EditorCell createEmptyCell(EditorContext context) {
    return createEmptyCell();
  }
  @Override
  protected EditorCell createEmptyCell() {
    EditorCell_Constant emptyCell = new EditorCell_Constant(getEditorContext(), getNode(), null);
    emptyCell.setDefaultText("");
    emptyCell.setEditable(true);
    emptyCell.setSRole(getElementSRole());

    return emptyCell;
  }
  @Override
  public SNode createNodeToInsert(EditorContext context) {
    return null;
  }

  /**
   * 
   * @deprecated use createNodeCell(SNode node)
   */
  @Deprecated
  public EditorCell createNodeCell(EditorContext context, SNode node) {
    return createNodeCell(node);
  }
  public EditorCell createNodeCell(SNode node) {
    EditorCell nodeCell = getEditorContext().getEditorComponent().getUpdater().getCurrentUpdateSession().updateChildNodeCell(node);
    ChildsTracker.getInstance().registerChild(nodeCell);
    if (nodeCell.getAction(CellActionType.DELETE) == null) {
      nodeCell.setAction(CellActionType.DELETE, new CellAction_DeleteNode(node));
    }
    return nodeCell;
  }
  public abstract SNode createNode(int index);


  protected void doInsertNode(SNode nodeToInsert, SNode anchorNode, boolean insertBefore) {
    int index = Sequence.fromIterable(myChilds).indexOf(anchorNode);
    if (index < 0) {
      index = Sequence.fromIterable(myChilds).count();
    } else {
      if (!(insertBefore)) {
        index++;
      }
    }
    // TODO: remove this method call. Instead, override createNodeToInsert() method
    createNode(index);
  }

  protected SNode getAnchorNode(EditorCell anchorCell) {
    SNode anchorNode = ((anchorCell != null ? anchorCell.getSNode() : null));
    if (anchorNode != null) {
      // anchor should be directly referenced from "list owner"
      while (anchorNode != null && !(Sequence.fromIterable(myChilds).contains(anchorNode))) {
        anchorNode = SNodeOperations.getParent(anchorNode);
      }
    }
    return anchorNode;
  }

  protected List<? extends SNode> getNodesForList() {
    return Sequence.fromIterable(myChilds).toList();
  }

}

package de.itemis.mps.editor.enumeration.runtime;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.awt.image.ImageObserver;
import java.awt.Image;
import jetbrains.mps.ide.ThreadUtils;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorComponentSettings;
import java.awt.Font;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.BasicStroke;
import com.intellij.ui.JBColor;

public class EnumerationCheckboxImages {
  private Map<String, EnumerationCheckboxImage> ecis = MapSequence.fromMap(new HashMap<String, EnumerationCheckboxImage>());
  private EnumerationCheckboxImage current;
  private double heightScaled;
  private double widthScaled;
  private boolean scaleWithEditorFontSize = false;
  private EditorComponent component;

  private ImageObserver sizeObserver = new ImageObserver() {
    public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) {
      boolean widthOrHeightChanged = (infoflags & (HEIGHT | WIDTH)) != 0;
      if (widthOrHeightChanged) {
        ThreadUtils.runInUIThreadNoWait(() -> updateSize());
      }
      return widthOrHeightChanged;
    }
  };

  public EnumerationCheckboxImages(jetbrains.mps.openapi.editor.EditorComponent editorComponent) {
    this.component = (EditorComponent) editorComponent;
  }

  public void setScaleWithEditorFontSize(boolean bool) {
    this.scaleWithEditorFontSize = bool;
    updateSize();
  }

  public void toggle() {
    setCurrent(getNextState());
  }
  public String getNextState() {
    return current.getNext();
  }

  public void setCurrent(String state) {
    current = MapSequence.fromMap(ecis).get(state);
  }
  public EnumerationCheckboxImage getCurrent() {
    return current;
  }
  public boolean exists(String state) {
    return MapSequence.fromMap(ecis).containsKey(state);
  }

  public void addImage(String path, double scale, String state, String next, SNode node, String initialState) {
    EnumerationCheckboxImage eci = new EnumerationCheckboxImage(path, scale, state, next, node);
    MapSequence.fromMap(ecis).put(state, eci);
    if (initialState.equals(state)) {
      current = eci;
    }
    updateSize();
  }

  private int getFontHeight() {
    EditorComponentSettings settings = component.getEditorComponentSettings();
    return settings.getFontMetrics(settings.getDefaultFont().getFontName(), Font.PLAIN, settings.getFontSize()).getHeight();
  }

  public int getHeight() {
    return (int) this.heightScaled;
  }

  public int getWidth() {
    return (int) this.widthScaled;
  }

  private double getScale(EnumerationCheckboxImage image) {
    if (scaleWithEditorFontSize) {
      return getFontHeight() / image.getHeight(sizeObserver);
    } else {
      return image.getScale();
    }
  }

  protected void updateSize() {
    widthScaled = 0.0;
    heightScaled = 0.0;
    for (EnumerationCheckboxImage img : Sequence.fromIterable(MapSequence.fromMap(ecis).values())) {
      double scale = getScale(img);
      widthScaled = ((int) Math.max(widthScaled, img.getWidth(sizeObserver) * scale));
      heightScaled = ((int) Math.max(widthScaled, img.getHeight(sizeObserver) * scale));
    }
    if (widthScaled == 0.0) {
      widthScaled = 12;
    }
    if (heightScaled == 0.0) {
      heightScaled = 12;
    }
  }

  public void paint(Graphics g, int x, int y, EditorComponent editorComponent) {
    Image image = current.getImage();
    double scale = getScale(current);

    int widthScaledInt = ((int) widthScaled);
    int heightScaledInt = ((int) heightScaled);
    if (image != null) {
      int offsetX = (int) ((widthScaled - image.getWidth(sizeObserver) * scale) / 2);
      int offsetY = (int) ((heightScaled - image.getHeight(sizeObserver) * scale) / 2);

      g = g.create();
      Graphics2D g2d = as_jn2c5t_a0a4a5a23(g, Graphics2D.class);
      if (g2d != null) {
        g2d.translate(x + offsetX, y + offsetY);
        g2d.scale(scale, scale);
      }
      g.drawImage(image, 0, 0, editorComponent);
      g.dispose();
    } else {

      int dcWidth = widthScaledInt - 1;
      int dcHeight = heightScaledInt - 1;
      int dcX = x;
      int dcY = y + 1;

      Graphics2D g2d = ((Graphics2D) g.create());
      g2d.setStroke(new BasicStroke(2));
      g2d.setColor(JBColor.BLACK);
      g2d.drawRect(dcX, dcY, dcWidth, dcHeight);

      g2d.dispose();
    }
  }

  private static <T> T as_jn2c5t_a0a4a5a23(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import java.util.List;
import java.util.ArrayList;
import java.awt.geom.AffineTransform;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.Nullable;
import java.awt.geom.Point2D;
import java.awt.geom.NoninvertibleTransformException;
import java.util.Collections;
import java.util.Objects;
import org.jetbrains.annotations.NotNull;
import de.itemis.mps.editor.diagram.runtime.EditorUtil;

public class Box extends BoxBase implements IConnectionEndpoint_Internal {

  private List<Port> myPorts = new ArrayList<Port>();
  private AffineTransform myPortTransformation = AffineTransform.getTranslateInstance(0.0, 0.0);
  private boolean myPreservePortOrder = false;
  private boolean myAllowConnectionsToBox = true;
  private List<SNode> myNavigationTargets = ListSequence.fromList(new ArrayList<SNode>());
  private DiagramModel newOwnerDiagram = null;

  public Box() {
  }

  public Box(@Nullable SNode snode) {
    super(snode);
  }

  public void rotatePortSideClockwise() {
    myPortTransformation.rotate(Math.PI / 2.0);
  }

  public void rotatePortSideCounterClockwise() {
    myPortTransformation.rotate(-Math.PI / 2.0);
  }

  public void flipPortSideVertically() {
    myPortTransformation.scale(1.0, -1.0);
  }

  public void flipPortSideHorizontally() {
    myPortTransformation.scale(-1.0, 1.0);
  }

  public AffineTransform getPortTransform() {
    return (AffineTransform) myPortTransformation.clone();
  }

  public void setTransform(@Nullable AffineTransform transform) {
    myPortTransformation = (transform != null ? transform : AffineTransform.getTranslateInstance(0.0, 0.0));
  }

  public Point transformPortPosition(Point untransformed) {
    AffineTransform t = AffineTransform.getTranslateInstance(0.0, 0.0);

    t.translate(0.5, 0.5);
    t.concatenate(getPortTransform());
    t.translate(-0.5, -0.5);

    Point2D result = new Point2D.Double();
    t.transform(ExtensionMethods.toPoint2D(untransformed), result);
    return ExtensionMethods.toPoint(result);
  }

  public Point inverseTransformPortPosition(Point untransformed) {
    AffineTransform t = AffineTransform.getTranslateInstance(0.0, 0.0);

    t.translate(0.5, 0.5);
    t.concatenate(getPortTransform());
    t.translate(-0.5, -0.5);

    Point2D result = new Point2D.Double();
    try {
      t.inverseTransform(ExtensionMethods.toPoint2D(untransformed), result);
      return ExtensionMethods.toPoint(result);
    } catch (NoninvertibleTransformException e) {
      return untransformed;
    }
  }

  public void addPort(Port port) {
    myPorts.add(port);
    port.setBox(this);
  }

  public List<Port> getPorts() {
    return Collections.unmodifiableList(myPorts);
  }

  @Nullable
  public Port getPort(String name) {
    for (Port port : ListSequence.fromList(myPorts)) {
      if (Objects.equals(port.getName(), name)) {
        return port;
      }
    }
    return null;
  }

  public void setPorts(List<Port> ports) {
    myPorts = new ArrayList<Port>(ports);
    for (Port p : ListSequence.fromList(myPorts)) {
      p.setBox(this);
    }
  }

  public boolean isPreservePortOrder() {
    return myPreservePortOrder;
  }

  public void setPreservePortOrder(boolean preserve) {
    myPreservePortOrder = preserve;
  }

  @Override
  public String toString() {
    return getClass().getSimpleName() + "[" + ((hasRootCell() ? getRootCell() : "null")) + "]";
  }

  @Override
  @Nullable
  public IBoxAccessor getAccessor() {
    return (IBoxAccessor) super.getAccessor();
  }


  @Override
  public boolean isAccessorAllowed(@NotNull IDiagramElementAccessor accessor) {
    return accessor instanceof IBoxAccessor;
  }

  @NotNull
  public IConnectionEndpointReference getEndpointReference() {
    IBoxAccessor accessor = getAccessor();
    return (accessor != null ? new AccessorKeyEnpointReference(accessor.getId()) : new PendingEndpointReference());
  }

  public void setAllowConnectionsToBox(boolean allow) {
    myAllowConnectionsToBox = allow;
  }

  public boolean isAllowConnectionsToBox() {
    return myAllowConnectionsToBox;
  }

  public List<IDiagramCell> getSubdiagramCells() {
    return EditorUtil.firstLevelDescendants(getRootCell(), IDiagramCell.class);
  }

  public List<DiagramModel> getSubdiagramModels() {
    return ListSequence.fromList(getSubdiagramCells()).select((it) -> it.getDiagramModel()).toList();
  }

  @NotNull
  public List<SNode> getNavigationTargets() {
    return ListSequence.fromListWithValues(new ArrayList<SNode>(), myNavigationTargets);
  }

  public void setNavigationTargets(List<SNode> targets) {
    myNavigationTargets = ListSequence.fromListWithValues(new ArrayList<SNode>(), targets);
  }

  public boolean canDrop(Object data) {
    return getAccessor().canDrop(data);
  }

  public void drop(Object data) {
    getAccessor().drop(data);
  }

  public void setNewOwnerDiagram(DiagramModel diagram) {
    newOwnerDiagram = diagram;
  }

  public DiagramModel getNewOwnerDiagram() {
    return newOwnerDiagram;
  }
}

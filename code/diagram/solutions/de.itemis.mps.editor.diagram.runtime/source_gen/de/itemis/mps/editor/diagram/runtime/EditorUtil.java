package de.itemis.mps.editor.diagram.runtime;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.util.IterableUtil;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import de.itemis.mps.editor.diagram.runtime.jgraph.LayoutDependencies;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import de.itemis.mps.editor.diagram.runtime.model.ScalableEditorCell;
import de.itemis.mps.editor.celllayout.runtime.LayoutEngine;
import de.itemis.mps.editor.celllayout.boxmodel.Size;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.UUID;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Objects;

public class EditorUtil {

  public static <T extends EditorCell> void descendants(EditorCell parent, Class<T> type, List<T> accumulator) {
    if (type.isInstance(parent)) {
      accumulator.add((T) parent);
    }
    if (parent instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) parent))) {
        descendants(child, type, accumulator);
      }
    }
  }

  public static <T extends EditorCell> List<T> descendants(EditorCell parent, Class<T> type) {
    List<T> accumulator = new ArrayList<T>();
    descendants(parent, type, accumulator);
    return accumulator;
  }

  public static <T extends EditorCell> void firstLevelDescendants(@Nullable EditorCell parent, Class<T> type, List<T> accumulator) {
    if (parent == null) {
      return;
    }
    if (type.isInstance(parent)) {
      accumulator.add((T) parent);
    } else {
      if (parent instanceof EditorCell_Collection) {
        for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) parent))) {
          firstLevelDescendants(child, type, accumulator);
        }
      }
    }
  }

  public static <T extends EditorCell> List<T> firstLevelDescendants(@Nullable EditorCell parent, Class<T> type) {
    List<T> accumulator = new ArrayList<T>();
    firstLevelDescendants(parent, type, accumulator);
    return accumulator;
  }

  public static void updateBounds(@Nullable jetbrains.mps.nodeEditor.cells.EditorCell_Collection cell) {
    if (cell == null) {
      return;
    }
    List<EditorCell> cells = IterableUtil.asList(cell);
    if (cells.size() > 0) {
      Rectangle bounds = GeometryUtil.getBounds(cells.toArray(new EditorCell[cells.size()]));
      setBounds(bounds, cell);
    } else {
      EditorCell_Collection parent = cell.getParent();
      if (parent != null) {
        setBounds(cell, LayoutDependencies.getX(parent), LayoutDependencies.getY(parent), 0, 0);
      }
    }
  }

  public static Rectangle getBounds(EditorCell cell) {
    LayoutDependencies ldep = LayoutDependencies.getInstance(cell.getEditorComponent());
    Tuples._2<Integer, Integer> position = ldep.getPosition(cell);
    Tuples._2<Integer, Integer> size = ldep.getSize(cell);
    return new Rectangle((int) position._0(), (int) position._1(), (int) size._0(), (int) size._1());
  }

  public static void setBounds(Rectangle bounds, EditorCell_Basic cell) {
    setBounds(cell, bounds.x, bounds.y, bounds.width, bounds.height);
  }

  public static void setBounds(EditorCell_Basic cell, int x, int y, int width, int height) {
    if (cell instanceof ScalableEditorCell) {
      ((ScalableEditorCell) cell).setBoundsRaw(x, y, width, height);
    } else {
      cell.setX(x);
      cell.setY(y);
      cell.setWidth(width);
      cell.setHeight(height);
    }
  }

  public static void relayoutWithoutWrap(EditorCell cell) {
    if (cell == null) {
      return;
    }
    LayoutEngine engine = new LayoutEngine();
    Size preferredSize = engine.getPreferredSize(cell);
    engine.layoutCell(cell, LayoutDependencies.getX(cell), LayoutDependencies.getY(cell), preferredSize.getWidth(), preferredSize.getHeight());
  }

  public static <T> T getAncestor(EditorCell descendant, Class<T> type) {
    if (descendant == null) {
      return null;
    }
    if (type.isInstance(descendant.getParent())) {
      return (T) descendant.getParent();
    } else {
      return getAncestor(descendant.getParent(), type);
    }
  }

  public static List<EditorCell> getChildren(EditorCell parent) {
    List<EditorCell> children = ListSequence.fromList(new ArrayList<EditorCell>());
    if (parent instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable((EditorCell_Collection) parent)) {
        ListSequence.fromList(children).addElement(child);
      }
    }
    return children;
  }

  public static void noCaching(EditorContext context, Runnable runnable) {
    context.getEditorComponent().getUpdater().getCurrentUpdateSession().getCellFactory().pushCellContext();
    try {
      context.getEditorComponent().getUpdater().getCurrentUpdateSession().getCellFactory().addCellContextHints("" + UUID.randomUUID());
      runnable.run();
    } finally {
      context.getEditorComponent().getUpdater().getCurrentUpdateSession().getCellFactory().popCellContext();
    }
  }

  public static void forceMoveTo(EditorCell root, int x, int y) {
    final int deltaX = x - root.getX();
    final int deltaY = y - root.getY();
    List<EditorCell> allCells = descendants(root, EditorCell.class);
    Iterable<Tuples._3<EditorCell, Integer, Integer>> targets = ListSequence.fromList(allCells).select((it) -> MultiTuple.<EditorCell,Integer,Integer>from(it, it.getX() + deltaX, it.getY() + deltaY)).toList();
    for (Tuples._3<EditorCell, Integer, Integer> target : Sequence.fromIterable(targets)) {
      if (!(Objects.equals(target._0().getX(), (int) target._1())) || !(Objects.equals(target._0().getY(), (int) target._2()))) {
        target._0().moveTo((int) target._1(), (int) target._2());
      }
    }
  }

  public static Iterable<EditorCell> getAncestors(EditorCell descendant, boolean includeSelf) {
    List<EditorCell> result = ListSequence.fromList(new ArrayList<EditorCell>());
    for (EditorCell c = (includeSelf ? descendant : descendant.getParent()); c != null; c = c.getParent()) {
      ListSequence.fromList(result).addElement(c);
    }
    return result;
  }

  public static EditorCell getCommonAncestor(List<EditorCell> descendants) {
    EditorCell candidate = ListSequence.fromList(descendants).first();
    while (candidate != null) {
      boolean ancestorOfAll = true;
      for (EditorCell descendant : ListSequence.fromList(descendants).skip(1)) {
        if (candidate != descendant && !(Sequence.fromIterable(getAncestors(descendant, true)).contains(candidate))) {
          ancestorOfAll = false;
          break;
        }
      }
      if (ancestorOfAll) {
        return candidate;
      }
      candidate = candidate.getParent();
    }

    return null;
  }

}

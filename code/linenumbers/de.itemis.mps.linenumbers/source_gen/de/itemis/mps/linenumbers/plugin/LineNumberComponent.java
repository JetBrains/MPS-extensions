package de.itemis.mps.linenumbers.plugin;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.leftHighlighter.AbstractLeftColumn;
import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import jetbrains.mps.ide.editor.MPSFileNodeEditor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import java.awt.Point;
import javax.swing.SwingUtilities;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import com.intellij.ui.JBColor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.event.MouseEvent;
import jetbrains.mps.openapi.editor.Editor;

public class LineNumberComponent extends AbstractLeftColumn {

  /**
   * The left highlighter gets way too many relayout events which we can't influence, so we have to throttle
   * the number of events. I've selected 250ms, which means that the line numbers only update 4 times per second or less.
   */
  public static final int RELAYOUT_THROTTLE_INTERVAL = 250;

  /**
   * The first few relayouts are crucial so we can't throttle those events.
   */
  public static final int THROTTLE_START = 20;

  private static Map<EditorComponent, LineNumberComponent> instances = MapSequence.fromMap(new WeakHashMap<EditorComponent, LineNumberComponent>());

  public static LineNumberComponent getOrCreateInstance(EditorComponent editorComponent) {
    LineNumberComponent instance = MapSequence.fromMap(instances).get(editorComponent);
    if (instance == null) {
      instance = new LineNumberComponent(editorComponent);
      MapSequence.fromMap(instances).put(editorComponent, instance);
    }
    return instance;
  }

  public static LineNumberComponent getInstance(EditorComponent editorComponent) {
    return MapSequence.fromMap(instances).get(editorComponent);
  }

  public static void installAll(Project ideaProject) {
    if (!(LineNumberPreferences.areLineNumbersEnabled(ideaProject))) {
      return;
    }
    for (FileEditor editor : FileEditorManager.getInstance(ideaProject).getAllEditors()) {
      if (editor instanceof MPSFileNodeEditor) {
        MPSFileNodeEditor mpsEditor = ((MPSFileNodeEditor) editor);
        if (!(mpsEditor.isDisposed())) {
          EditorComponent currentEditorComponent = as_3vd20w_a0a0a1a0a1a11(check_3vd20w_a0a0a1a0a1a11(check_3vd20w_a0a0a0b0a0b0l(mpsEditor)), EditorComponent.class);
          LineNumberComponent.getOrCreateInstance(currentEditorComponent).install();
          if (currentEditorComponent != null && currentEditorComponent.isVisible()) {
            currentEditorComponent.getLeftEditorHighlighter().relayout(true);
          }
        }
      }
    }
  }

  public static void uninstallAll() {
    for (LineNumberComponent instance : ListSequence.fromListWithValues(new ArrayList<LineNumberComponent>(), MapSequence.fromMap(instances).values())) {
      instance.uninstall();
    }
  }

  @Nullable
  public ILineList lines;
  private int textPaddingLeft = 10;
  private int textPaddingRight = textPaddingLeft;
  private int textWidth = 30;
  private long lastUpdated = -1;
  private long updateCount = 0;

  private LineNumberComponent(EditorComponent editorComponent) {
    super(editorComponent.getLeftEditorHighlighter());
  }

  private boolean isRightSideOfEditor() {
    // get the left upper most point [0,0] of the gutter (getLeftEditorHighlighter() ) in the coordinate space of the editor component
    Point convertPoint = SwingUtilities.convertPoint(getLeftEditorHighlighter(), new Point(0, 0), getEditorComponent());
    return convertPoint.getX() >= getEditorComponent().getVisibleRect().width;
  }

  public void install() {
    if (ApplicationManager.getApplication().isDisposed() || getEditorComponent().isDisposed()) {
      return;
    }
    jetbrains.mps.project.Project project = ProjectHelper.getProject(getEditorComponent().getEditorContext().getRepository());
    if (project == null || project.isDisposed()) {
      return;
    }
    if (!(LineNumberPreferences.areLineNumbersEnabled(ProjectHelper.toIdeaProject(project)))) {
      return;
    }
    if (!(getLeftEditorHighlighter().getLeftColumns().contains(this))) {
      getLeftEditorHighlighter().addLeftColumn(this);
    }
    updateLineNumbers(false);
  }

  /**
   * Remove the line numbers column from the left editor highlighter and {@link de.itemis.mps.linenumbers.plugin.LineNumberComponent#dispose()} of it.
   */
  public void uninstall() {
    if (getLeftEditorHighlighter().getLeftColumns().contains(this)) {
      getLeftEditorHighlighter().removeLeftColumn(this);
    }
    dispose();
  }


  @Override
  public void dispose() {
    // Similar to uninstall but called when the editor component is disposed. It disposes its LeftEditorHighlighter which disposes each AbstractLeftColumn. There's no need to remove the left column from the highlighter, and it may in fact be harmful because the highlighter is in the process of iterating its list of columns here.
    MapSequence.fromMap(instances).removeKey(getEditorComponent());
  }

  public void updateLineNumbers(boolean foldingChanged) {
    EditorCell rootCell = getEditorComponent().getRootCell();
    lines = LineNumberUtils.findLines(rootCell, foldingChanged);
    if (lines != null) {
      lines.assignLineNumber(1);
    }
    calculateWidth();
  }

  public void calculateWidth() {
    if (lines == null) {
      textWidth = 10;
    } else {
      Font font = getEditorComponent().getEditorComponentSettings().getDefaultFont();
      FontMetrics fontMetrics = getEditorComponent().getFontMetrics(font);
      textWidth = textPaddingLeft + fontMetrics.stringWidth(String.valueOf(lines.getLast().getNumber())) + textPaddingRight;
    }
  }

  @Override
  public void paint(final Graphics graphics) {
    Graphics2D g = (Graphics2D) graphics;
    EditorComponent.turnOnAliasingIfPossible(g);
    Font font = getEditorComponent().getEditorComponentSettings().getDefaultFont();
    graphics.setFont(font);
    graphics.setColor(JBColor.LIGHT_GRAY);
    if (lines != null) {
      Sequence.fromIterable(lines.getLines()).visitAll((it) -> graphics.drawString(String.valueOf(it.getNumber()), getLinePositionX(it), getLinePositionY(it)));
    }
  }

  public int getLinePositionX(Line line) {
    Font font = getEditorComponent().getEditorComponentSettings().getDefaultFont();
    FontMetrics fontMetrics = getEditorComponent().getFontMetrics(font);
    // calculate the x-coordinate to draw the first letter of the line number in dependence of the position of the gutter
    return (isRightSideOfEditor() ? getLeftEditorHighlighter().getVisibleRect().width - getWidth() + textPaddingRight : getWidth() - fontMetrics.stringWidth(String.valueOf(line.getNumber())) - textPaddingRight);
  }

  public int getLinePositionY(Line line) {
    Font font = getEditorComponent().getEditorComponentSettings().getDefaultFont();
    FontMetrics fontMetrics = getEditorComponent().getFontMetrics(font);
    return line.getCell().getY() + (line.getCell().getHeight() - fontMetrics.getHeight()) / 2 + fontMetrics.getAscent();
  }

  public Line getClickedLine(MouseEvent e) {
    int y = e.getY();

    for (Line line : Sequence.fromIterable(lines.getLines())) {
      jetbrains.mps.openapi.editor.cells.EditorCell cell = line.getCell();
      if (y >= cell.getY() && y <= cell.getY() + cell.getHeight()) {
        return line;
      }
    }
    return null;
  }

  @Override
  public void mousePressed(MouseEvent e) {
    super.mousePressed(e);
    Line clickedLine = getClickedLine(e);
    if (clickedLine != null) {
      getEditorComponent().changeSelectionWRTFocusPolicy(clickedLine.getCell());
    }
  }

  @Override
  public int getWidth() {
    return textWidth;
  }

  @Override
  public void editorRebuilt() {
  }

  @Override
  public void relayout(boolean updateFolding) {
    long currentUpdate = System.nanoTime();
    if (updateCount + 1 == Long.MAX_VALUE) {
      updateCount = 0;
    } else {
      updateCount++;
    }
    if (lastUpdated != -1) {
      long timeDiffInMS = (currentUpdate - lastUpdated) / 1000000;
      if (timeDiffInMS < RELAYOUT_THROTTLE_INTERVAL && updateCount >= THROTTLE_START) {
        return;
      }
    }

    lastUpdated = currentUpdate;

    if (updateFolding) {
      EditorComponent ec = getEditorComponent();
      if (ec == null || ec.isDisposed()) {
        return;
      }

      if (ec.isVisible()) {
        updateLineNumbers(true);
      }
    }
  }

  @Override
  public String getName() {
    return "Line numbers";
  }

  private static jetbrains.mps.openapi.editor.EditorComponent check_3vd20w_a0a0a1a0a1a11(Editor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getCurrentEditorComponent();
    }
    return null;
  }
  private static Editor check_3vd20w_a0a0a0b0a0b0l(MPSFileNodeEditor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getNodeEditor();
    }
    return null;
  }
  private static <T> T as_3vd20w_a0a0a1a0a1a11(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

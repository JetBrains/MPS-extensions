package de.itemis.mps.editor.math.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import com.intellij.ui.ColorUtil;
import com.intellij.ui.JBColor;
import java.awt.event.KeyEvent;
import jetbrains.mps.nodeEditor.CellSide;
import com.intellij.util.ui.UIUtil;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import java.util.Objects;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.nodeEditor.IntelligentInputUtil;

public class EditorCell_MathEnd extends EditorCell_Constant {

  private boolean myIsRightEnd;

  public EditorCell_MathEnd(EditorContext context, SNode snode, boolean isRightEnd) {
    super(context, snode, "", false);
    myIsRightEnd = isRightEnd;
  }

  @Override
  public void paintContent(Graphics graphics, ParentSettings settings) {
    super.paintContent(graphics, settings);

    EditorCell selectedCell = getContext().getSelectedCell();
    if (selectedCell != null) {

      // draw border around the term, if an end cell is selected
      if (selectedCell == this) {
        graphics.setColor(ColorUtil.withAlpha(JBColor.BLUE, 0.196));
        EditorCell parent = getParent();
        graphics.drawRect(parent.getX(), parent.getY(), parent.getWidth(), parent.getHeight());
      }

      // mark position of end cells
      if (getTopmostParentMathCell(this) == getTopmostParentMathCell(selectedCell)) {
        graphics.setColor(ColorUtil.withAlpha(JBColor.BLACK, 0.117));
        graphics.fillRect(getX(), getY(), getWidth(), getHeight());
      }
    }
  }

  protected static EditorCell_MathBase getTopmostParentMathCell(EditorCell descendant) {
    EditorCell_MathBase result = null;
    for (EditorCell c = descendant; c != null; c = c.getParent()) {
      if (c instanceof EditorCell_MathBase) {
        result = (EditorCell_MathBase) c;
      }
    }
    return result;
  }

  @Override
  protected boolean doProcessKeyTyped(final KeyEvent keyEvent, final boolean allowErrors) {
    final CellSide side = (myIsRightEnd ? CellSide.RIGHT : CellSide.LEFT);
    setCaretVisible(true);
    if (UIUtil.isReallyTypedEvent(keyEvent)) {
      final Wrappers._T<String> pattern = new Wrappers._T<String>(null);
      getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> pattern.value = ((String) ReflectionUtil.callMethod(EditorCell_Label.class, ((EditorCell_Label) EditorCell_MathEnd.this), "getUpdatedText", new Class[]{String.class}, new Object[]{String.valueOf(keyEvent.getKeyChar())})));

      if (myIsRightEnd) {
        if (Objects.equals(pattern.value, " ")) {
          getEditor().getActionHandler().executeAction(this, CellActionType.RIGHT_TRANSFORM);
          return true;
        }
        pattern.value = " " + pattern.value;
      }
      return IntelligentInputUtil.processCell(this, getContext(), pattern.value, side);
    }
    return false;
  }

  @Override
  public boolean isValidText(String text) {
    return "".equals(text) || " ".equals(text);
  }
}

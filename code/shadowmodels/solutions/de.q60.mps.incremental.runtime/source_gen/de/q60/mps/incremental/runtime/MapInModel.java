package de.q60.mps.incremental.runtime;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;

public abstract class MapInModel<MapT, EntryT, KeyT, ValueT> {

  private IncrementalEngine engine;
  private MapT mapNode;

  public MapInModel(MapT mapNode) {
    this(IncrementalEngine.CONTEXT_ENGINE.getValue(), mapNode);
  }

  public MapInModel(@NotNull IncrementalEngine engine, MapT mapNode) {
    this.engine = engine;
    this.mapNode = mapNode;
  }

  protected abstract Iterable<EntryT> computeEntries(MapT map);
  protected abstract KeyT computeKey(EntryT entry);
  protected abstract ValueT computeValue(EntryT entry);

  public ValueT get(final KeyT key) {
    final Wrappers._T<ValueT> value = new Wrappers._T<ValueT>();
    return engine.evaluate(MultiTuple.<Class<?>,MapT,KeyT>from(getClass(), mapNode, key), () -> {
      Map<KeyT, ValueT> map = getMap();
      if (MapSequence.fromMap(map).containsKey(key)) {
        value.value = MapSequence.fromMap(map).get(key);
      } else {
        value.value = createDefaultValue(key);
      }
      return value.value;
    });
  }

  protected Map<KeyT, ValueT> getMap() {
    return engine.evaluate(MultiTuple.<Class<?>,MapT>from(getClass(), mapNode), () -> {
      Map<KeyT, ValueT> map = MapSequence.fromMap(new HashMap<KeyT, ValueT>());
      for (EntryT entry : Sequence.fromIterable(computeEntries(mapNode))) {
        MapSequence.fromMap(map).put(computeKey(entry), computeValue(entry));
      }
      return map;
    });
  }

  protected ValueT createDefaultValue(KeyT key) {
    return null;
  }
}

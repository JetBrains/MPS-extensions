package de.itemis.mps.utils.serializer.xml.serializer;

/*Generated by MPS */

import org.jdom2.Element;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jdom2.JDOMException;
import java.io.IOException;
import org.jdom2.input.SAXBuilder;
import org.jdom2.Document;
import java.io.StringReader;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.SNodeLegacy;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jdom2.Attribute;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.language.SConcept;

public class NodeDeserializer extends XMLConstants {

  private String PROXY = "proxy";
  private String PROXY_ROLE = "proxy_role";


  private Element rootElement;
  private SModel contextModel;
  private Map<String, String> nodeIDMap = MapSequence.fromMap(new HashMap<String, String>());


  public static NodeDeserializer fromXML(String xml, SModel targetModel, String attrprefix) throws JDOMException, IOException {
    return new NodeDeserializer(xml, targetModel, attrprefix);
  }

  private NodeDeserializer(String xml, SModel targetModel, String attrprefix) throws JDOMException, IOException {
    super(attrprefix);
    this.contextModel = targetModel;
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
      SAXBuilder sax = new SAXBuilder();
      Document build = sax.build(new StringReader(xml));
      rootElement = build.getRootElement();
    } finally {
      Thread.currentThread().setContextClassLoader(cl);
    }
  }



  public SNode getNode() {
    SNode buildNode = buildNode(rootElement);
    resolveReferences(buildNode);
    return buildNode;
  }

  private void resolveReferences(SNode newRootNode) {
    Iterable<SNode> proxies = ListSequence.fromList(SNodeOperations.getNodeDescendants(newRootNode, CONCEPTS.BaseConcept$gP, false, new SAbstractConcept[]{})).where((it) -> new SNodeLegacy(it).getProperty("proxy") != null);
    for (SNode proxy : Sequence.fromIterable(proxies)) {
      SNode parent = SNodeOperations.getParent(proxy);
      SNodeLegacy np = new SNodeLegacy(proxy);
      String modelID = np.getProperty(TARGET_MODEL_ID);
      String nodeID = np.getProperty(TARGET_NODE_ID);
      String role = np.getProperty(PROXY_ROLE);
      SNode target = resolveNode(modelID, nodeID, newRootNode);
      new SNodeLegacy(parent).setReferenceTarget(role, target);
      SNodeOperations.deleteNode(proxy);
    }
  }

  private SNode buildNode(Element element) {
    SNode elementNode = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(SConceptId.deserialize(element.getAttributeValue(CONCEPT_ID)), element.getAttributeValue(CONCEPT_FQN)));
    for (SNode initializedChild : Sequence.fromIterable(elementNode.getChildren())) {
      initializedChild.delete();
    }
    MapSequence.fromMap(nodeIDMap).put(element.getAttributeValue(NODE_ID), elementNode.getNodeId().toString());
    for (Attribute attr : ListSequence.fromList(element.getAttributes())) {
      String n = attr.getName();
      if (!(n.startsWith(PREFIX))) {
        new SNodeLegacy(elementNode).setProperty(n, attr.getValue());
      }
    }
    for (Element c : ListSequence.fromList(element.getChildren())) {
      String linkType = c.getAttributeValue(LINK_TYPE);
      String role = c.getName();
      if (linkType.equals(LINK_TYPE_CHILD)) {
        SNode childNode = buildNode(c);
        new SNodeLegacy(elementNode).insertChildBefore(role, childNode, null);
      } else if (linkType.equals(LINK_TYPE_REF)) {
        String targetModelID = c.getAttributeValue(TARGET_MODEL_ID);
        String targetNodeID = c.getAttributeValue(TARGET_NODE_ID);
        SNode proxy = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept"));
        SNodeLegacy np = new SNodeLegacy(proxy);
        np.setProperty(PROXY, "true");
        np.setProperty(PROXY_ROLE, role);
        np.setProperty(TARGET_MODEL_ID, targetModelID);
        np.setProperty(TARGET_NODE_ID, targetNodeID);
        new SNodeLegacy(elementNode).insertChildBefore(PROXY, proxy, null);
      }
    }
    return elementNode;
  }

  private SNode resolveNode(String modelID, String originalNodeID, SNode newRoot) {
    SNode newNode = resolveInNewSubtree(originalNodeID, newRoot);
    if (newNode != null) {
      return newNode;
    }
    return resolveInExistingModel(modelID, originalNodeID);
  }

  private SNode resolveInExistingModel(final String modelID, final String nodeID) {
    List<SNode> allNodes = SModelOperations.nodesIncludingImported(contextModel, null);
    return ListSequence.fromList(allNodes).findFirst((it) -> it.getNodeId().toString().equals(nodeID) && SNodeOperations.getModel(it).getModelId().toString().equals(modelID));
  }

  private SNode resolveInNewSubtree(String originalNodeID, SNode newRoot) {
    final String newID = MapSequence.fromMap(nodeIDMap).get(originalNodeID);
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(newRoot, CONCEPTS.BaseConcept$gP, true, new SAbstractConcept[]{})).findFirst((it) -> it.getNodeId().toString().equals(newID));
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
  }
}

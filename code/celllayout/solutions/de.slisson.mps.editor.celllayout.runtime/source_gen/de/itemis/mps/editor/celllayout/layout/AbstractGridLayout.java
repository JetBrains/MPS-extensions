package de.itemis.mps.editor.celllayout.layout;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.itemis.mps.editor.celllayout.boxmodel.Size;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;

public abstract class AbstractGridLayout extends AbstractLayout implements ILayouter {
  private static final Logger LOG = Logger.getLogger(AbstractGridLayout.class);
  protected boolean myGrowCellsHorizontal = false;
  protected boolean myGrowCellsVertical = false;

  public AbstractGridLayout() {
    this(false, false);
  }

  public AbstractGridLayout(boolean growCellsHorizontal, boolean growCellsVertical) {
    myGrowCellsHorizontal = growCellsHorizontal;
    myGrowCellsVertical = growCellsVertical;
  }

  public Grid getGrid(ILayoutableContainer container) {
    _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter = (ILayoutable layoutable, Size cellSizeConstraint) -> layoutable.getPreferredSize(cellSizeConstraint);
    Grid grid = loadGrid(container, Size.UNLIMITED_SIZE, sizeGetter);
    return grid;
  }

  public void layout(ILayoutableContainer container, @NotNull Size sizeConstraint) {
    _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter = (ILayoutable layoutable, Size cellSizeConstraint) -> layoutable.getPreferredSize(cellSizeConstraint);
    Grid grid = loadGrid(container, sizeConstraint, sizeGetter);
    layoutGrid(grid, container, sizeConstraint, true);
    if (grid.getWidth() > sizeConstraint.getWidth() || grid.getHeight() > sizeConstraint.getHeight()) {
      if (LOG.isDebugLevel()) {
        LOG.debug("Failed to set the grid size to " + sizeConstraint + ". Size is " + grid.getSize());
      }
    }
    grid.applyLayout(container.getInnerX(), container.getInnerY());
    for (GridElement element : Sequence.fromIterable(grid.getValidElements())) {
      grid.growElement(element, container.getInnerX(), container.getInnerY(), isChildGrowX(element.getLayoutable()), isChildGrowY(element.getLayoutable()));
    }

    for (GridElement element : Sequence.fromIterable(grid.getValidElements())) {
      element.getLayoutable().relayout(LayoutableExtensions.getSize(element.getLayoutable()));
    }
  }

  protected void scaleWidth(Grid grid, int width) {
    float[] weights = null;
    if (width > grid.getWidth()) {
      Set<Integer> pushingColumns = SetSequence.fromSet(new HashSet<Integer>());
      for (GridElement element : Sequence.fromIterable(grid.getValidElements())) {
        if (isChildPushX(element.getLayoutable())) {
          for (int i = element.getColumnIndex(); i <= element.getMaxColumnIndex(); i++) {
            SetSequence.fromSet(pushingColumns).addElement(i);
          }
        }
      }
      if (SetSequence.fromSet(pushingColumns).count() > 0) {
        weights = new float[grid.getSizeX()];
        for (int i = 0; i < grid.getSizeX(); i++) {
          weights[i] = (SetSequence.fromSet(pushingColumns).contains(i) ? 1.0f : 0.0f);
        }
      }
    }
    grid.scaleWidth(width, weights);
  }

  protected void scaleHeight(Grid grid, int height) {
    float[] weights = null;
    if (height > grid.getHeight()) {
      Set<Integer> pushingRows = SetSequence.fromSet(new HashSet<Integer>());
      for (GridElement element : Sequence.fromIterable(grid.getValidElements())) {
        if (isChildPushY(element.getLayoutable())) {
          for (int i = element.getRowIndex(); i <= element.getMaxRowIndex(); i++) {
            SetSequence.fromSet(pushingRows).addElement(i);
          }
        }
      }
      if (SetSequence.fromSet(pushingRows).count() > 0) {
        weights = new float[grid.getSizeY()];
        for (int i = 0; i < grid.getSizeY(); i++) {
          weights[i] = (SetSequence.fromSet(pushingRows).contains(i) ? 1.0f : 0.0f);
        }
      }
    }
    grid.scaleHeight(height, weights);
  }

  @NotNull
  public Size getPreferredInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint) {
    _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter = (ILayoutable layoutable, Size cellSizeConstraint) -> layoutable.getPreferredSize(cellSizeConstraint);
    Grid grid = loadGrid(container, sizeConstraint, sizeGetter);
    layoutGrid(grid, container, sizeConstraint, false);
    return grid.getSize();
  }

  @NotNull
  public Size getMinInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint) {
    _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter = (ILayoutable layoutable, Size cellSizeConstraint) -> layoutable.getMinSize(cellSizeConstraint);
    Grid grid = loadGrid(container, sizeConstraint, sizeGetter);
    return grid.getSize();
  }

  @NotNull
  public Size getMaxInnerSize(ILayoutableContainer container, @NotNull Size sizeConstraint) {
    _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter = (ILayoutable layoutable, Size cellSizeConstraint) -> layoutable.getMaxSize(cellSizeConstraint);
    Grid grid = loadGrid(container, sizeConstraint, sizeGetter);
    return grid.getSize();
  }

  public int getAscent(ILayoutableContainer container, Size sizeConstraint) {
    _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter = (ILayoutable layoutable, Size cellSizeConstraint) -> layoutable.getPreferredSize(cellSizeConstraint);
    Grid grid = loadGrid(container, sizeConstraint, sizeGetter);
    layoutGrid(grid, container, sizeConstraint, true);

    GridElement baseLineGridElement = Sequence.fromIterable(grid.getValidElements()).findFirst((it) -> it.getLayoutable().isBaseLineCell());
    if (baseLineGridElement == null) {
      // handle DEFAULT_BASE_LINE
      final ILayoutable baselineChild = container.getBaselineChild();
      baseLineGridElement = Sequence.fromIterable(grid.getValidElements()).findFirst((it) -> LayoutableExtensions.isAncestorOf(baselineChild, it.getLayoutable()));
    }
    if (baseLineGridElement != null) {
      int ascent = 0;
      for (int i = 0; i < baseLineGridElement.getRowIndex(); i++) {
        ascent += grid.getRowHeight(i);
      }
      ascent += grid.getAscent(baseLineGridElement.getRowIndex());
      return ascent;
    }

    return (grid.getSizeY() > 0 ? grid.getAscent(0) : 0);
  }

  protected Grid loadGrid(ILayoutableContainer container, Size sizeConstraint, final _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter) {
    Grid grid = loadGrid(container);
    initHorizontalGaps(grid);
    final Size cellSizeContraint = sizeConstraint;

    // cells without span first, because later cells may create enough space for the spanning cell
    grid.extendCells((ILayoutable layoutable) -> {
      if (hasAnySpan(layoutable)) {
        return Size.ZERO;
      }
      return SizeExtensions.zeroIfOverflow(sizeGetter.invoke(layoutable, cellSizeContraint), layoutable);
    });
    grid.extendCells((ILayoutable layoutable) -> SizeExtensions.zeroIfOverflow(sizeGetter.invoke(layoutable, cellSizeContraint), layoutable));
    return grid;
  }

  protected boolean hasAnySpan(ILayoutable layoutable) {
    return layoutable.getColumnSpan() != 1 || layoutable.getRowSpan() != 1;
  }

  protected void initHorizontalGaps(Grid grid) {
    for (int y = 0; y < grid.getSizeY(); y++) {
      for (int x = 1; x < grid.getSizeX(); x++) {
        GridElement element = grid.getElement(x, y);
        ILayoutable prevLayoutable = grid.getElement(x - 1, y).getLayoutable();
        ILayoutable layoutable = grid.getElement(x, y).getLayoutable();
        if (prevLayoutable == null || layoutable == null) {
          continue;
        }
        int gap = getGapBetweenCells(prevLayoutable, layoutable);
        if (gap > 0) {
          int gap1 = gap / 2;
          int gap2 = gap - gap1;

          ILayoutable cellForGapRight = LayoutableTraversalExtensions.lastLeaf(prevLayoutable);
          while (cellForGapRight != prevLayoutable && !(de.itemis.mps.editor.celllayout.runtime.LayoutableExtensions.hasRightBorder(cellForGapRight))) {
            cellForGapRight = cellForGapRight.getParent();
          }
          if (cellForGapRight.getBoxModel().getPaddingBox().getRightSize() != gap1) {
            cellForGapRight.getBoxModel().getPaddingBox().setRightSize(gap1);
            check_sqj115_a1a5a5a0a0a72(cellForGapRight.getParent());
          }

          ILayoutable cellForGapLeft = LayoutableTraversalExtensions.firstLeaf(layoutable);
          while (cellForGapLeft != layoutable && !(de.itemis.mps.editor.celllayout.runtime.LayoutableExtensions.hasLeftBorder(cellForGapLeft))) {
            cellForGapLeft = cellForGapLeft.getParent();
          }
          if (cellForGapLeft.getBoxModel().getPaddingBox().getLeftSize() != gap2) {
            cellForGapLeft.getBoxModel().getPaddingBox().setLeftSize(gap2);
            check_sqj115_a1a9a5a0a0a72(cellForGapLeft.getParent());
          }
        }
      }
    }
  }

  protected void layoutGrid(Grid grid, ILayoutableContainer container, Size sizeConstraint, boolean fit) {

    // grow the grid
    if (fit && sizeConstraint.isWidthLimited()) {
      int availableWidth = sizeConstraint.getWidth() - grid.getWidth();
      if (availableWidth > 0) {
        Set<Integer> columnsToGrow = SetSequence.fromSetWithValues(new HashSet<Integer>(), Sequence.fromIterable(grid.getElements()).where((it) -> it.getLayoutable() != null && isChildPushX(it.getLayoutable())).select((it) -> it.getColumnIndex()));
        if (SetSequence.fromSet(columnsToGrow).count() > 0) {
          int growAmount = availableWidth / SetSequence.fromSet(columnsToGrow).count();
          for (int columnIndex : columnsToGrow) {
            if (columnIndex == (int) SetSequence.fromSet(columnsToGrow).last()) {
              growAmount = availableWidth;
            }
            grid.setColumnWidth(columnIndex, grid.getColumnWidth(columnIndex) + growAmount);
            availableWidth -= growAmount;
          }
        }
      }
    }

    // width constraint
    int[] columnMinWidths = null;
    int timeout = 20;
    List<Integer> widths = ListSequence.fromList(new ArrayList<Integer>());
    ListSequence.fromList(widths).addElement(grid.getWidth());
    while (grid.getWidth() > sizeConstraint.getWidth() && --timeout > 0) {
      if (columnMinWidths == null) {
        columnMinWidths = new int[grid.getSizeX()];
        for (int x = 0; x < grid.getSizeX(); x++) {
          columnMinWidths[x] = getColumnMinWidth(grid, x);
        }
      }

      // reduce width of the grid
      float[] weights = new float[grid.getSizeX()];
      for (int i = 0; i < grid.getSizeX(); i++) {
        weights[i] = (grid.getColumnWidth(i) > columnMinWidths[i] ? ((float) grid.getColumnWidth(i)) : 0.0f);
      }
      grid.scaleWidth(sizeConstraint.getWidth(), weights);

      // ensure min width
      for (GridElement element : Sequence.fromIterable(grid.getValidElements()).sort((it) -> it.getColumnSpan(), true)) {
        ILayoutable layoutable = element.getLayoutable();
        element.extendWidth(SizeExtensions.zeroIfOverflow(layoutable.getMinSize(element.getSize()), layoutable).getWidth());
      }

      // update heights
      for (GridElement element : Sequence.fromIterable(grid.getValidElements()).sort((it) -> it.getRowSpan(), true)) {
        Size childSizeConstraint = Size.limitedWidth(element.getWidth());
        Size preferredSize = element.getLayoutable().getPreferredSize(childSizeConstraint);
        int ascent = element.getLayoutable().getAscent(preferredSize);
        element.extendHeight(ascent, preferredSize.getHeight() - ascent);
      }

      ListSequence.fromList(widths).addElement(grid.getWidth());

      if (ListSequence.fromList(widths).count() >= 2 && (int) ListSequence.fromList(widths).getElement(ListSequence.fromList(widths).count() - 2) == (int) ListSequence.fromList(widths).getElement(ListSequence.fromList(widths).count() - 1)) {
        timeout = 1;
      }
    }
    if (timeout <= 0) {
      if (LOG.isDebugLevel()) {
        LOG.debug("Grid layouting timed out. Widths: " + widths + ", target: " + sizeConstraint.getWidth());
      }
    }

    // grow the grid
    if (fit && sizeConstraint.isHeightLimited()) {
      int availableHeight = sizeConstraint.getHeight() - grid.getHeight();
      if (availableHeight > 0) {
        Set<Integer> rowsToGrow = SetSequence.fromSetWithValues(new HashSet<Integer>(), Sequence.fromIterable(grid.getElements()).where((it) -> it.getLayoutable() != null && isChildPushY(it.getLayoutable())).select((it) -> it.getRowIndex()));
        if (SetSequence.fromSet(rowsToGrow).count() > 0) {
          int growAmount = availableHeight / SetSequence.fromSet(rowsToGrow).count();
          for (int rowIndex : rowsToGrow) {
            if (rowIndex == (int) SetSequence.fromSet(rowsToGrow).last()) {
              growAmount = availableHeight;
            }
            grid.setRowHeight(rowIndex, grid.getAscent(rowIndex), grid.getDescent(rowIndex) + growAmount);
            availableHeight -= growAmount;
          }
        }
      }
    }
  }

  protected int getColumnMinWidth(Grid grid, int x) {
    int minWidth = 0;
    for (int y = 0; y < grid.getSizeY(); y++) {
      GridElement element = grid.getElement(x, y);
      ILayoutable layoutable = element.getLayoutable();
      if (layoutable == null) {
        continue;
      }
      if (element.getColumnSpan() != 1) {
        continue;
      }
      minWidth = Math.max(minWidth, SizeExtensions.zeroIfOverflow(layoutable.getMinSize(Size.UNLIMITED_SIZE), layoutable).getWidth());
    }
    return minWidth;
  }

  protected abstract Grid loadGrid(ILayoutableContainer container);

  protected Grid createGrid(int columnCount, int rowCount) {
    return new Grid(columnCount, rowCount);
  }

  @Override
  protected boolean isChildGrowX(ILayoutable child) {
    return myGrowCellsHorizontal || super.isChildGrowX(child);
  }

  @Override
  protected boolean isChildGrowY(ILayoutable child) {
    return myGrowCellsVertical || super.isChildGrowY(child);
  }

  @Override
  public TextBuilder toText(ILayoutableContainer container) {
    TextBuilderImpl text = new TextBuilderImpl();
    Grid grid = getGrid(container);

    for (int y = 0; y < grid.getSizeY(); y++) {
      TextBuilderImpl rowText = new TextBuilderImpl();
      if (grid.getSizeX() > 0) {
        rowText.appendToTheRight(gridElementToText(grid.getElement(0, y)), false);
      }
      for (int x = 1; x < grid.getSizeX(); x++) {
        GridElement element = grid.getElement(x, y);
        ILayoutable prevLayoutable = grid.getElement(x - 1, y).getLayoutable();
        ILayoutable layoutable = grid.getElement(x, y).getLayoutable();
        if (prevLayoutable == null || layoutable == null) {
          continue;
        }
        rowText.appendToTheRight(gridElementToText(element), hasGapBetweenCells(prevLayoutable, layoutable));
      }
      text.appendToTheBottom(rowText);
    }

    return text;
  }

  protected TextBuilder gridElementToText(GridElement element) {
    ILayoutable layoutable = element.getLayoutable();
    return (layoutable == null ? new TextBuilderImpl() : layoutable.toText());
  }
  private static void check_sqj115_a1a5a5a0a0a72(ILayoutableContainer checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.setChanged(true);
    }

  }
  private static void check_sqj115_a1a9a5a0a0a72(ILayoutableContainer checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.setChanged(true);
    }

  }
}

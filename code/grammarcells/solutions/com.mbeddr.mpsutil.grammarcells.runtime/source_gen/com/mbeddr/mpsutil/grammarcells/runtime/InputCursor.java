package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import java.util.Collections;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class InputCursor implements Cloneable {
  private List<IToken> myInput;
  private int myPosition;

  public InputCursor(List<IToken> input) {
    myInput = input;
  }

  public List<IToken> getAll() {
    return myInput;
  }

  public IToken getNext() {
    IToken token = peek();
    next();
    return token;
  }

  public IToken peek() {
    return ListSequence.fromList(myInput).getElement(myPosition);
  }

  public boolean isEnd() {
    return myPosition >= ListSequence.fromList(myInput).count();
  }

  public void next() {
    myPosition++;
  }

  public void previous() {
    myPosition--;
  }

  public void restore(InputCursor saved) {
    myPosition = saved.myPosition;
  }

  public InputCursor save() {
    return clone();
  }

  public void resetPosition() {
    myPosition = 0;
  }

  @Override
  public String toString() {
    return ListSequence.fromList(myInput).subListSequence(0, myPosition) + " %%% " + ListSequence.fromList(myInput).subListSequence(myPosition, ListSequence.fromList(myInput).count());
  }

  @Override
  protected InputCursor clone() {
    try {
      InputCursor clone = ((InputCursor) super.clone());
      return clone;
    } catch (CloneNotSupportedException ex) {
      throw new RuntimeException(ex);
    }
  }

  public Iterator<InputCursor[]> iterateRanges(List<ISymbol> symbols, boolean leftAssociative) {
    if (ListSequence.fromList(symbols).count() < 2) {
      return Collections.<InputCursor[]>singletonList(new InputCursor[]{this.save()}).iterator();
    }
    Iterator<InputCursor[]> result = null;

    if (leftAssociative) {
      for (int i = ListSequence.fromList(symbols).count() - 1; i >= 1; i--) {
        int firstRestriction = (i == 1 ? getRestriction(ListSequence.fromList(symbols).getElement(0)) : -1);
        if (i == ListSequence.fromList(symbols).count() - 1) {
          result = new RangeIterator(this.save(), firstRestriction, getRestriction(ListSequence.fromList(symbols).getElement(i)), leftAssociative);
        } else {
          result = new RangeIterator_SubdivideLast(result, firstRestriction, getRestriction(ListSequence.fromList(symbols).getElement(i)), leftAssociative);
        }
      }
    } else {
      for (int i = 0; i < ListSequence.fromList(symbols).count() - 1; i++) {
        int lastRestriction = (i == ListSequence.fromList(symbols).count() - 2 ? getRestriction(ListSequence.fromList(symbols).getElement(i + 1)) : -1);
        if (i == 0) {
          result = new RangeIterator(this.save(), getRestriction(ListSequence.fromList(symbols).getElement(i)), lastRestriction, leftAssociative);
        } else {
          result = new RangeIterator_SubdivideLast(result, getRestriction(ListSequence.fromList(symbols).getElement(i)), lastRestriction, leftAssociative);
        }
      }
    }

    return result;
  }

  protected int getRestriction(ISymbol symbol) {
    return (symbol.hasFixedTokenNumber() ? symbol.getNumTokens() : -1);
  }

  protected Iterator<InputCursor[]> singletonIterator(int firstSize) {
    List<InputCursor[]> l = new ArrayList<InputCursor[]>(1);
    l.add(new InputCursor[]{new InputCursor(ListSequence.fromList(myInput).subListSequence(0, firstSize)), new InputCursor(ListSequence.fromList(myInput).subListSequence(firstSize, ListSequence.fromList(myInput).count()))});
    return l.iterator();
  }


  public static class RangeIterator implements Iterator<InputCursor[]> {
    private int myFirstSize = 1;
    private InputCursor myCursor;
    private int myLeftRestriction;
    private int myRightRestriction;
    private boolean myLeftAssociative;


    public RangeIterator(InputCursor cursor, boolean leftAssociative) {
      this(cursor, -1, -1, leftAssociative);
    }

    public RangeIterator(InputCursor cursor, int leftRestriction, int rightRestriction, boolean leftAssociative) {
      myCursor = new InputCursor(ListSequence.fromList(cursor.myInput).subListSequence(cursor.myPosition, ListSequence.fromList(cursor.myInput).count()));
      myLeftRestriction = leftRestriction;
      myRightRestriction = rightRestriction;
      myLeftAssociative = leftAssociative;
      if (isRestricted()) {
        myFirstSize = getLeftRestriction();
      } else {
        myFirstSize = (leftAssociative ? ListSequence.fromList(cursor.myInput).count() - 1 : 1);
      }
    }

    public boolean isRestricted() {
      return myLeftRestriction != -1 || myRightRestriction != -1;
    }

    public int getLeftRestriction() {
      int restriction = (myLeftRestriction != -1 ? myLeftRestriction : ListSequence.fromList(myCursor.myInput).count() - myRightRestriction);
      return Math.max(restriction, 0);
    }

    public int getRightRestriction() {
      int restriction = (myRightRestriction != -1 ? myRightRestriction : ListSequence.fromList(myCursor.myInput).count() - myLeftRestriction);
      return Math.max(restriction, 0);
    }

    public boolean hasNext() {
      int inputSize = ListSequence.fromList(myCursor.myInput).count();
      if (isRestricted()) {
        if (inputSize < getLeftRestriction() || inputSize < getRightRestriction()) {
          return false;
        }
        if (getLeftRestriction() + getRightRestriction() != inputSize) {
          return false;
        }
      }
      if (myLeftAssociative) {
        return myFirstSize >= ((isRestricted() ? getLeftRestriction() : 1));
      } else {
        return myFirstSize <= ((isRestricted() ? getLeftRestriction() : inputSize));
      }
    }

    public InputCursor[] next() {
      if (!(hasNext())) {
        throw new RuntimeException("No value available");
      }
      InputCursor[] next = new InputCursor[]{new InputCursor(ListSequence.fromList(myCursor.myInput).subListSequence(0, myFirstSize)), new InputCursor(ListSequence.fromList(myCursor.myInput).subListSequence(myFirstSize, ListSequence.fromList(myCursor.myInput).count()))};
      if (myLeftAssociative) {
        myFirstSize--;
      } else {
        myFirstSize++;
      }
      return next;
    }

    public void remove() {
      throw new UnsupportedOperationException();
    }
  }

  public static class RangeIterator_SubdivideLast implements Iterator<InputCursor[]> {
    private Iterator<InputCursor[]> myIterator;
    private InputCursor[] myLastParent;
    private Iterator<InputCursor[]> mySubIterator;
    private InputCursor[] myNext;
    private int myLeftRestriction;
    private int myRightRestriction;
    private boolean myLeftAssociative;

    public RangeIterator_SubdivideLast(Iterator<InputCursor[]> parentIterator, int leftRestriction, int rightRestriction, boolean leftAssociative) {
      myIterator = parentIterator;
      myLeftRestriction = leftRestriction;
      myRightRestriction = rightRestriction;
      myLeftAssociative = leftAssociative;
    }

    public boolean hasNext() {
      if (!(isInitialized())) {
        loadNext();
      }
      return myNext != null;
    }

    public boolean isInitialized() {
      return myLastParent != null;
    }

    public InputCursor[] next() {
      if (!(isInitialized())) {
        loadNext();
      }
      InputCursor[] next = myNext;
      loadNext();
      return next;
    }

    public void loadNext() {
      if (myLastParent == null) {
        if (myIterator.hasNext()) {
          myLastParent = myIterator.next();
        }
      }
      if (mySubIterator == null) {
        if (myLastParent != null) {
          mySubIterator = new RangeIterator(myLastParent[(myLeftAssociative ? 0 : myLastParent.length - 1)], myLeftRestriction, myRightRestriction, myLeftAssociative);
        }
      }

      while (mySubIterator != null && !(mySubIterator.hasNext())) {
        if (myIterator.hasNext()) {
          myLastParent = myIterator.next();
          mySubIterator = new RangeIterator(myLastParent[(myLeftAssociative ? 0 : myLastParent.length - 1)], myLeftRestriction, myRightRestriction, myLeftAssociative);
        } else {
          myNext = null;
          return;
        }
      }

      if (mySubIterator != null && mySubIterator.hasNext()) {
        InputCursor[] subdividedFirstLast = mySubIterator.next();
        InputCursor[] result = new InputCursor[myLastParent.length - 1 + subdividedFirstLast.length];
        if (myLeftAssociative) {
          System.arraycopy(subdividedFirstLast, 0, result, 0, subdividedFirstLast.length);
          System.arraycopy(myLastParent, 1, result, subdividedFirstLast.length, myLastParent.length - 1);
        } else {
          System.arraycopy(myLastParent, 0, result, 0, myLastParent.length - 1);
          System.arraycopy(subdividedFirstLast, 0, result, myLastParent.length - 1, subdividedFirstLast.length);
        }
        myNext = result;
        Sequence.fromIterable(Sequence.fromArray(myNext)).visitAll((it) -> it.resetPosition());
        return;
      }

      myNext = null;
    }

    public void remove() {
      throw new UnsupportedOperationException();
    }
  }

}

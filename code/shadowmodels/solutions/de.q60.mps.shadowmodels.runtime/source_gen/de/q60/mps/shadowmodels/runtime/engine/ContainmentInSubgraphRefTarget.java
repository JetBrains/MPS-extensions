package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import de.q60.mps.logging.runtime.ShadowLogging;
import java.util.Objects;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class ContainmentInSubgraphRefTarget implements IReferenceTarget {
  private ISubgraphCall subgraphCall;
  private IContainmentTarget containmentTarget;

  private ContainmentInSubgraphRefTarget() {
    // for deserialization
  }

  public ContainmentInSubgraphRefTarget(ISubgraphCall subgraph, IContainmentTarget containmentTarget) {
    this.subgraphCall = subgraph;
    this.containmentTarget = containmentTarget;
  }

  public ISubgraphCall getSubgraphCall() {
    return this.subgraphCall;
  }

  public IContainmentTarget getContainmentTarget() {
    return this.containmentTarget;
  }

  @Override
  public IOutputNodeReference resolve(IScope sourceScope, ITransformationEngine engine) {
    IScope targetScope = new SubgraphCallScopeReference(subgraphCall).resolve(sourceScope, engine);
    if (targetScope == null) {
      RuntimeException ex = new RuntimeException("Failedto resolve scope for " + subgraphCall + " from " + sourceScope);
      ShadowLogging.logError(ex, subgraphCall, sourceScope);
      throw ex;
    }

    return new FirstRootRefTarget(containmentTarget).resolve(targetScope, engine);
  }

  public IOutputNodeReference resolveLocal(final ISubgraphStage stage) {
    ISubgraphRef subgraphRef = stage.getStageReference().getSubgraphRef();
    if (subgraphRef instanceof ChildSubgraphRef) {
      if (Objects.equals(((ChildSubgraphRef) subgraphRef).getCall().getTarget(), subgraphCall)) {
        List<IOutputNodeReference> outputNodes = Sequence.fromIterable(stage.resolveContent(containmentTarget)).translate(new _FunctionTypes._return_P1_E0<Iterable<IOutputNodeReference>, IUniqueContainmentTarget>() {
          public Iterable<IOutputNodeReference> invoke(IUniqueContainmentTarget it) {
            return stage.resolveContainmentTarget(it);
          }
        }).toList();
        if (ListSequence.fromList(outputNodes).count() == 0) {
          return null;
        } else if (ListSequence.fromList(outputNodes).count() == 1) {
          return ListSequence.fromList(outputNodes).first();
        } else {
          throw new RuntimeException("Multiple output nodes found for " + containmentTarget);
        }
      }
    }
    return null;
  }

  @Override
  public String toString() {
    return subgraphCall + ">" + containmentTarget;
  }

  private transient int _cachedHashCode;
  private transient boolean _hashCodeInitialized = false;
  @Override
  public int hashCode() {
    if (!(_hashCodeInitialized)) {
      int c = 0;
      c = 31 * c + Objects.hashCode(containmentTarget);
      c = 31 * c + Objects.hashCode(subgraphCall);
      _cachedHashCode = c;
      _hashCodeInitialized = true;
    }
    return _cachedHashCode;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    ContainmentInSubgraphRefTarget that = (ContainmentInSubgraphRefTarget) o;
    if (!(Objects.equals(containmentTarget, that.containmentTarget))) {
      return false;
    }
    if (!(Objects.equals(subgraphCall, that.subgraphCall))) {
      return false;
    }
    return true;
  }
}

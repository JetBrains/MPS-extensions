package de.q60.mps.shadowmodels.transformation.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.errors.BaseQuickFixProvider;
import de.q60.mps.shadowmodels.transformation.behavior.ISingleInputRule__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class check_MappingConfiguration_inoutLanguages_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_MappingConfiguration_inoutLanguages_NonTypesystemRule() {
  }
  public void applyRule(final SNode n, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    Set<String> inLanguages = SetSequence.fromSetWithValues(new HashSet<String>(), ListSequence.fromList(SLinkOperations.getChildren(n, LINKS.inputLanguages$CAWo)).select((it) -> SPropertyOperations.getString(it, PROPS.moduleId$h8Zx)));
    Set<String> outLanguages = SetSequence.fromSetWithValues(new HashSet<String>(), ListSequence.fromList(SLinkOperations.getChildren(n, LINKS.outputLanguages$CBDr)).select((it) -> SPropertyOperations.getString(it, PROPS.moduleId$h8Zx)));

    for (SNode nb : ListSequence.fromList(SNodeOperations.getNodeDescendants(n, CONCEPTS.NodeBuilder$By, false, new SAbstractConcept[]{}))) {
      if ((SLinkOperations.getTarget(nb, LINKS.concept$huZZ) == null)) {
        continue;
      }
      Language languageModule = as_gib1n6_a0a1a3a1(SNodeOperations.getModel(SLinkOperations.getTarget(nb, LINKS.concept$huZZ)).getModule(), Language.class);
      if (languageModule == null) {
        continue;
      }
      String langId = languageModule.getModuleReference().getModuleId().toString();
      if (!(SetSequence.fromSet(outLanguages).contains(langId))) {
        String langName = languageModule.getModuleReference().getModuleName();
        {
          final MessageTarget errorTarget = new NodeMessageTarget();
          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(nb, "language " + langName + " not declared as an output language", "r:fd3ba2d5-05a9-4b3b-93ad-a566c0e12538(de.q60.mps.shadowmodels.transformation.typesystem)", "1430379073336280684", null, errorTarget);
          {
            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("de.q60.mps.shadowmodels.transformation.typesystem.fix_addOutputLanguage_QuickFix", "1430379073336819912", false);
            intentionProvider.putArgument("mc", n);
            intentionProvider.putArgument("languageId", langId);
            intentionProvider.putArgument("languageName", langName);
            _reporter_2309309498.addIntentionProvider(intentionProvider);
          }
        }
      }
    }

    for (SNode rule : ListSequence.fromList(SNodeOperations.getNodeDescendants(n, CONCEPTS.ISingleInputRule$_b, false, new SAbstractConcept[]{}))) {
      SNode inputConcept = ISingleInputRule__BehaviorDescriptor.getInputConcept_id4ygyjZjb$vD.invoke(rule);
      if ((inputConcept == null)) {
        continue;
      }
      Language languageModule = as_gib1n6_a0a2a5a1(SNodeOperations.getModel(inputConcept).getModule(), Language.class);
      if (languageModule == null) {
        continue;
      }
      String langId = languageModule.getModuleReference().getModuleId().toString();
      if (!(SetSequence.fromSet(inLanguages).contains(langId))) {
        String langName = languageModule.getModuleReference().getModuleName();
        {
          final MessageTarget errorTarget = new NodeMessageTarget();
          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(rule, "language " + langName + " not declared as an input language", "r:fd3ba2d5-05a9-4b3b-93ad-a566c0e12538(de.q60.mps.shadowmodels.transformation.typesystem)", "1430379073336813069", null, errorTarget);
          {
            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("de.q60.mps.shadowmodels.transformation.typesystem.fix_addInputLanguage_QuickFix", "1430379073336827776", false);
            intentionProvider.putArgument("mc", n);
            intentionProvider.putArgument("languageId", langId);
            intentionProvider.putArgument("languageName", langName);
            _reporter_2309309498.addIntentionProvider(intentionProvider);
          }
        }
      }

    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.MappingConfiguration$TT;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }
  private static <T> T as_gib1n6_a0a1a3a1(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_gib1n6_a0a2a5a1(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink inputLanguages$CAWo = MetaAdapterFactory.getContainmentLink(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0xfb8df9d0e8cfc12L, 0xfb8df9d0e8d1b5fL, "inputLanguages");
    /*package*/ static final SContainmentLink outputLanguages$CBDr = MetaAdapterFactory.getContainmentLink(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0xfb8df9d0e8cfc12L, 0xfb8df9d0e8d1b62L, "outputLanguages");
    /*package*/ static final SReferenceLink concept$huZZ = MetaAdapterFactory.getReferenceLink(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x65cd987c65c5ee6cL, 0x65cd987c65c684f2L, "concept");
  }

  private static final class PROPS {
    /*package*/ static final SProperty moduleId$h8Zx = MetaAdapterFactory.getProperty(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x4890893fd2d038e9L, 0x4890893fd2d038ecL, "moduleId");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept NodeBuilder$By = MetaAdapterFactory.getConcept(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x65cd987c65c5ee6cL, "de.q60.mps.shadowmodels.transformation.structure.NodeBuilder");
    /*package*/ static final SInterfaceConcept ISingleInputRule$_b = MetaAdapterFactory.getInterfaceConcept(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x4890893fd32e2f74L, "de.q60.mps.shadowmodels.transformation.structure.ISingleInputRule");
    /*package*/ static final SConcept MappingConfiguration$TT = MetaAdapterFactory.getConcept(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0xfb8df9d0e8cfc12L, "de.q60.mps.shadowmodels.transformation.structure.MappingConfiguration");
  }
}

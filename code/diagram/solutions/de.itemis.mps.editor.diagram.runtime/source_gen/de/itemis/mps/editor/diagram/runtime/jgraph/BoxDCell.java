package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import de.itemis.mps.editor.diagram.runtime.model.SerializableObjectHolder;
import de.itemis.mps.editor.diagram.runtime.model.Box;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import de.itemis.mps.editor.diagram.runtime.model.Port;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.itemis.mps.editor.diagram.runtime.model.IDiagramElement;

public class BoxDCell extends BoxBaseDCell implements ISelfPaintingCell, IMPSCellContainer, IDiagramDCell {

  private SerializableObjectHolder<Box> myBox;
  private SerializableObjectHolder<MyGraph> myGraph;

  public BoxDCell(MyGraph graph) {
    super(graph);

    CellExtensions.setBounds(this, 0, 0, 80, 30);
    this.setVertex(true);
    this.setConnectable(true);
  }


  public void setBox(Box node) {
    myBox = new SerializableObjectHolder<Box>(node);
    setContentCells(node.getContentCells());
  }

  public Box getBox() {
    return myBox.get();
  }

  @Override
  @Nullable
  public EditorCell getBigCell() {
    return check_ixttod_a0a11(check_ixttod_a0a0l(myBox));
  }

  @Override
  public boolean allowScaling() {
    return myBox.get().isScalingAllowed() && ListSequence.fromList(getBox().getSubdiagramCells()).isEmpty();
  }

  @Override
  public boolean constrainPosition() {
    return false;
  }

  @Nullable
  @Override
  public Tuples._2<Double, Double> getRequiredSize() {
    Tuples._2<Double, Double> size = super.getRequiredSize();
    size._1(Math.max((double) size._1(), getRequiredHeightForPorts()));
    return size;
  }

  protected double getRequiredHeightForPorts() {
    Map<Double, Double> portsHeights = MapSequence.fromMap(new HashMap<Double, Double>());
    for (Port port : ListSequence.fromList(myBox.get().getPorts())) {
      double portsHeight = (MapSequence.fromMap(portsHeights).containsKey(port.getRelativeXNN()) ? MapSequence.fromMap(portsHeights).get(port.getRelativeXNN()) : 0.0);
      portsHeight += port.getHeight();
      portsHeight += PortLayouter.SPACE_BETWEEN_PORTS;
      MapSequence.fromMap(portsHeights).put(port.getRelativeXNN(), portsHeight);
    }
    return Sequence.fromIterable(MapSequence.fromMap(portsHeights).values()).foldLeft(0.0, (Double s, Double it) -> Math.max(s, it));
  }

  @Nullable
  @Override
  public IDiagramElement getDiagramElement() {
    return getBox();
  }

  @Override
  public boolean canDrop(Object data) {
    return getBox().canDrop(data);
  }

  @Override
  public void drop(Object data) {
    getBox().drop(data);
  }

  public Iterable<PortDCell> getPorts() {
    return ListSequence.fromList(CellExtensions.getChildren(this)).ofType(PortDCell.class);
  }

  public boolean containsSubdiagram() {
    for (int i = 0; i < this.getChildCount(); i++) {
      if (this.getChildAt(i) instanceof SubDiagramDCell) {
        return true;
      }
    }
    return false;
  }

  private static EditorCell check_ixttod_a0a11(Box checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getRootCell();
    }
    return null;
  }
  private static Box check_ixttod_a0a0l(SerializableObjectHolder<Box> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.get();
    }
    return null;
  }
}

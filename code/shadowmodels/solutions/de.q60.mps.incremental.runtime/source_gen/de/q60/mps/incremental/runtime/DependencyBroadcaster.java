package de.q60.mps.incremental.runtime;

/*Generated by MPS */

import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class DependencyBroadcaster implements IDependencyListener {

  public static final DependencyBroadcaster INSTANCE = new DependencyBroadcaster();

  private List<IDependencyListener> listeners = new ArrayList<IDependencyListener>();
  private ThreadLocal<List<_FunctionTypes._void_P1_E0<? super DependencyKey>>> trackerStacks = new ThreadLocal<List<_FunctionTypes._void_P1_E0<? super DependencyKey>>>();

  protected List<_FunctionTypes._void_P1_E0<? super DependencyKey>> getTrackerStack() {
    List<_FunctionTypes._void_P1_E0<? super DependencyKey>> stack = trackerStacks.get();
    if (stack == null) {
      stack = ListSequence.fromList(new ArrayList<_FunctionTypes._void_P1_E0<? super DependencyKey>>());
      trackerStacks.set(stack);
    }
    return stack;
  }

  public <T> T evaluateWithTracking(_FunctionTypes._return_P0_E0<? extends T> computable, _FunctionTypes._void_P1_E0<? super DependencyKey> accessTracker) {
    final List<_FunctionTypes._void_P1_E0<? super DependencyKey>> stack = getTrackerStack();
    ListSequence.fromList(stack).addElement(accessTracker);
    try {
      return computable.invoke();
    } finally {
      ListSequence.fromList(stack).removeLastElement();
    }
  }

  public void addListener(IDependencyListener l) {
    List<IDependencyListener> newListeners = new ArrayList<IDependencyListener>(listeners);
    newListeners.add(l);
    listeners = newListeners;
  }

  public void removeListener(IDependencyListener l) {
    List<IDependencyListener> newListeners = new ArrayList<IDependencyListener>(listeners);
    newListeners.remove(l);
    listeners = newListeners;
  }

  @Override
  public void dependencyAccessed(DependencyKey dep) {
    List<_FunctionTypes._void_P1_E0<? super DependencyKey>> trackerStack = getTrackerStack();
    if (ListSequence.fromList(trackerStack).isNotEmpty()) {
      ListSequence.fromList(trackerStack).last().invoke(dep);
    }
    for (IDependencyListener l : ListSequence.fromList(listeners)) {
      l.dependencyAccessed(dep);
    }
  }

  @Override
  public void dependenciesChanged(Iterable<DependencyKey> deps) {
    for (IDependencyListener l : ListSequence.fromList(listeners)) {
      l.dependenciesChanged(deps);
    }
  }
}

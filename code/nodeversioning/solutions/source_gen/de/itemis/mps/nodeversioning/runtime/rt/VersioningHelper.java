package de.itemis.mps.nodeversioning.runtime.rt;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import java.security.MessageDigest;
import de.itemis.mps.utils.serializer.xml.serializer.NodeSerializer;
import java.security.NoSuchAlgorithmException;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class VersioningHelper {
  @Nullable
  public static String getHash(@NotNull SNode n) {
    try {
      MessageDigest instance = MessageDigest.getInstance("SHA");
      NodeSerializer serializer = new NodeSerializer(n, true, "");

      // todo: find a propper way to ignore the old versions without mutating the model
      serializer.ignoreAnnotations();
      String xmlAsString = serializer.getXMLAsString();
      return bytesToHex(instance.digest(xmlAsString.getBytes()));
    } catch (NoSuchAlgorithmException e) {
      return null;
    }
  }
  private static final char[] hexArray = "0123456789ABCDEF".toCharArray();
  public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j < bytes.length; j++) {
      int v = bytes[j] & 0xFF;
      hexChars[j * 2] = hexArray[v >>> 4];
      hexChars[j * 2 + 1] = hexArray[v & 0x0F];
    }
    return new String(hexChars);
  }
  @Nullable
  private static SNode lastVersion(@NotNull SNode n) {
    return ListSequence.fromList(new IAttributeDescriptor.NodeAttribute(CONCEPTS.NodeVersion$qo).list(n)).sort((it) -> SPropertyOperations.getInteger(it, PROPS.version$c2Ao), false).first();
  }
  /**
   * Checks if the node has changes since the last version. Does not take into account dependencies.
   * 
   * @param n the node to check
   * @return true if the node has changed or has never been versioned
   */
  public static boolean hasNodeChanged(@NotNull SNode n) {
    boolean hasVersion = ListSequence.fromList(new IAttributeDescriptor.NodeAttribute(CONCEPTS.NodeVersion$qo).list(n)).isNotEmpty();
    if (hasVersion) {
      return !(Objects.equals(SPropertyOperations.getString(lastVersion(n), PROPS.hash$P2p0), getHash(n)));
    }
    return true;
  }
  /**
   * Checks if a node has changed from the specfic version. Return true if a newer version exists or the node has been
   * changed since the last version was created.
   * 
   * @param n the node to check
   * @param since the version from where to check
   * @return true if the node has changed, a newer veriso exsists or the node has never been versioned.
   */
  public static boolean hasNodeChanged(@NotNull SNode n, @NotNull SNode since) {
    boolean hasVersion = ListSequence.fromList(new IAttributeDescriptor.NodeAttribute(CONCEPTS.NodeVersion$qo).list(n)).isNotEmpty();
    if (hasVersion) {
      SNode lastVersion = lastVersion(n);
      return SPropertyOperations.getInteger(lastVersion, PROPS.version$c2Ao) != SPropertyOperations.getInteger(since, PROPS.version$c2Ao) || !(Objects.equals(SPropertyOperations.getString(lastVersion, PROPS.hash$P2p0), getHash(n)));
    }
    return true;
  }


  /**
   * Creates a new NodeVersion for the node. Does not traverse the subtree. Returns null if the node has no changes.
   * Does not mutate the model the caller is responsible for adding the nodeversion to the node annotation of the passed
   * node.
   * 
   * @param n node to version
   * @return a new NodeVersion or null if the node has no changes
   */
  @Nullable
  public static SNode newVersion(@NotNull SNode n) {

    if (!(hasNodeChanged(n))) {
      return null;
    }

    SNode lastVersion = lastVersion(n);
    int newVersionNumber = 1;
    if (lastVersion != null) {
      newVersionNumber = SPropertyOperations.getInteger(lastVersion, PROPS.version$c2Ao) + 1;
    }

    Iterable<SNode> dependencies = collectDependencies(n);

    // detect reference cycle
    boolean hasCycle = Sequence.fromIterable(dependencies).translate((it) -> collectDependencies(it)).contains(n);

    if (hasCycle) {
      throw new RuntimeException("dependency cycle detected");
    }

    if (Sequence.fromIterable(dependencies).any((it) -> hasNodeChanged(it))) {
      throw new DependencyHasChangesException("dependency has changes");
    }


    Iterable<SNode> dependencyVersions = Sequence.fromIterable(dependencies).select((it) -> createLinkVersion_uwzupo_a0a0a0a71a8(lastVersion(it)));


    return createNodeVersion_uwzupo_a02a8(SNodeOperations.copyNode(n), newVersionNumber, getHash(n), dependencyVersions);
  }


  /**
   * Creates a new version information for a node without any checks! Only used as a internal helper to reduce code duplication
   * 
   * @param n the node to version
   * @param lastVersion the last version of the node, if null it will asume the node has never been versioned
   * @return new version information
   */
  private static SNode createVersion(@NotNull SNode n, @Nullable SNode lastVersion) {
    int newVersionNumber = 1;
    if (lastVersion != null) {
      newVersionNumber = SPropertyOperations.getInteger(lastVersion, PROPS.version$c2Ao) + 1;
    }
    return createNodeVersion_uwzupo_a2a11(SNodeOperations.copyNode(n), newVersionNumber, getHash(n));
  }

  public static List<Tuples._3<SNode, SNode, Boolean>> calculateChanges(@NotNull SNode n, @Nullable SNode since) {

    List<Tuples._3<SNode, SNode, Boolean>> res = ListSequence.fromList(new ArrayList<Tuples._3<SNode, SNode, Boolean>>());
    final List<Tuples._2<SNode, CalculationValue<Tuples._2<Boolean, SNode>>>> changeSet = ListSequence.fromList(new ArrayList<Tuples._2<SNode, CalculationValue<Tuples._2<Boolean, SNode>>>>());

    // As we can have cyclic dependencies in the graph we have to do it in a two step process. We fist calculate the changes
    // which result in new versions of a node. And later set the dependency versions.
    calculateChanges(n, since, changeSet);


    for (Tuples._2<SNode, CalculationValue<Tuples._2<Boolean, SNode>>> item : ListSequence.fromList(changeSet)) {
      SNode nodeWithVersion = item._0();
      boolean hasChanged = (boolean) item._1().getFinalValue()._0();
      SNode incompleteVersion = item._1().getFinalValue()._1();

      // As now all versions are calculated we can finally add all the dependencies to node versions.
      Iterable<SNode> dependencyVersions = Sequence.fromIterable(collectDependencies(nodeWithVersion)).select((final SNode dep) -> createLinkVersion_uwzupo_a0a0a0a5a9a31(nodeVersionLens(ListSequence.fromList(changeSet).findFirst((it) -> Objects.equals(it._0(), dep)))));

      ListSequence.fromList(SLinkOperations.getChildren(incompleteVersion, LINKS.dependencies$nOJH)).clear();
      ListSequence.fromList(SLinkOperations.getChildren(incompleteVersion, LINKS.dependencies$nOJH)).addSequence(Sequence.fromIterable(dependencyVersions));

      ListSequence.fromList(res).addElement(MultiTuple.<SNode,SNode,Boolean>from(nodeWithVersion, incompleteVersion, hasChanged));
    }

    return res;
  }

  private static boolean calculateChanges(final SNode n, @Nullable SNode since, final List<Tuples._2<SNode, CalculationValue<Tuples._2<Boolean, SNode>>>> calculations) {

    CalculationValue<Tuples._2<Boolean, SNode>> value;

    final Wrappers._T<SNode> version = new Wrappers._T<SNode>(since);
    if (version.value == null) {
      version.value = lastVersion(n);
    }

    Tuples._2<SNode, CalculationValue<Tuples._2<Boolean, SNode>>> runningCalculation = ListSequence.fromList(calculations).findFirst((it) -> Objects.equals(it._0(), n));
    if (runningCalculation != null && runningCalculation._1().valueAvailable()) {
      return (boolean) runningCalculation._1().getValue()._0();
    } else if (runningCalculation == null) {
      value = new CalculationValue();
      ListSequence.fromList(calculations).addElement(MultiTuple.<SNode,CalculationValue<Tuples._2<Boolean, SNode>>>from(n, value));
    } else {
      value = runningCalculation._1();
    }

    List<NodeVersionCheckResult> checkResult = checkNodeVersion(n, version.value);

    // if any check result is not "nochanges" we have local changes. We can short circuit our own change calculation
    // because we know that we have local changes!
    // We will still traverse down to get the full changeset.
    boolean hasNodeChanged = ListSequence.fromList(checkResult).any((it) -> !(Objects.equals(it.getChange(), NodeVersionCheckResult.ChangeType.NoChanges)));

    SNode currentVersion;
    if (hasNodeChanged) {
      SNode lastVersion = lastVersion(n);
      if (since == lastVersion && isOk(checkNodeVersion(n, lastVersion))) {
        currentVersion = lastVersion;
      } else {
        currentVersion = createVersion(n, lastVersion);
      }
    } else {
      currentVersion = version.value;
    }

    // We know that we have a local change and that we will have to create a new version.
    if (hasNodeChanged) {
      value.setFinalResult(MultiTuple.<Boolean,SNode>from(hasNodeChanged, currentVersion));
    }

    boolean dependenciesChanged = false;

    Iterable<SNode> dependencies = collectDependencies(n);

    if (!(hasNodeChanged)) {
      // We have no local changes or changes in our direct dependencies, but we might have a cycle in the subtree we are
      // about to traverse so we check is one of our dependencies is currently awaiting calculation
      // if so we are participating in a cycle. We insert our own value into the calculation graph
      // before traversing down.
      // The recusive call will later return and insert the correct value into the changeset if required
      boolean dependencyCurrentlyCalculating = Sequence.fromIterable(dependencies).any((final SNode dependency) -> {
        Tuples._2<SNode, CalculationValue<Tuples._2<Boolean, SNode>>> calculationForDependency = ListSequence.fromList(calculations).findFirst((it) -> Objects.equals(it._0(), dependency));

        // We don't care if we have never seen that dependency as we have change then anyways
        boolean dependencyHasBeenVersioned = getDependencyVersion(version.value, dependency) != null;

        return calculationForDependency != null && dependencyHasBeenVersioned && calculationForDependency._1().isCalculating();
      });

      if (dependencyCurrentlyCalculating) {
        value.setIntermediateResult(MultiTuple.<Boolean,SNode>from(hasNodeChanged, currentVersion));
      }
    }

    for (SNode dep : Sequence.fromIterable(dependencies)) {
      SNode dependencyVersion = getDependencyVersion(version.value, dep);
      dependenciesChanged |= calculateChanges(dep, dependencyVersion, calculations);
    }

    // We have changes in the subtree so we need to create new version
    if (dependenciesChanged && !(hasNodeChanged)) {
      currentVersion = createVersion(n, null);
    }

    value.setFinalResult(MultiTuple.<Boolean,SNode>from(dependenciesChanged || hasNodeChanged, currentVersion));
    return (boolean) value.getValue()._0();
  }

  private static SNode getDependencyVersion(SNode version, final SNode dependency) {
    return SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getChildren(version, LINKS.dependencies$nOJH)).findFirst((it) -> Objects.equals(nodeFromDependency(it), dependency)), LINKS.nodeVersion$nOIJ);
  }

  private static SNode nodeFromDependency(SNode n) {
    return SNodeOperations.getParent(SLinkOperations.getTarget(n, LINKS.nodeVersion$nOIJ));
  }

  /**
   * Checks a node with its dependencies for changes but does no traverse the depedencies.
   * 
   * @param n node to check
   * @param since a specific version from where to check. If null the latest version is assumed
   * @return list of changes since the specified version
   */
  public static List<NodeVersionCheckResult> checkNodeVersion(@NotNull SNode n, @Nullable SNode since) {

    SNode lastVersion = lastVersion(n);

    // No version, no more we can say
    if (lastVersion == null) {
      return Collections.singletonList(NodeVersionCheckResult.nodeUnversioned(n));
    }

    @NotNull SNode versionToCheck = (since == null ? lastVersion : since);

    List<NodeVersionCheckResult> results = ListSequence.fromList(new ArrayList<NodeVersionCheckResult>());

    if (hasNodeChanged(n, versionToCheck)) {
      ListSequence.fromList(results).addElement(NodeVersionCheckResult.nodeChanged(n));
    }


    List<SNode> versionedDependencies = ListSequence.fromList(SLinkOperations.getChildren(lastVersion, LINKS.dependencies$nOJH)).select((it) -> nodeFromDependency(it)).toList();
    final List<SNode> currentDependencies = Sequence.fromIterable(collectDependencies(n)).toList();

    Iterable<SNode> removedDependencies = ListSequence.fromList(versionedDependencies).subtract(ListSequence.fromList(currentDependencies));
    Iterable<SNode> newDependencies = ListSequence.fromList(currentDependencies).subtract(ListSequence.fromList(versionedDependencies));

    for (SNode dep : ListSequence.fromList(SLinkOperations.getChildren(lastVersion, LINKS.dependencies$nOJH)).where((it) -> ListSequence.fromList(currentDependencies).contains(nodeFromDependency(it)))) {
      if (hasNodeChanged(nodeFromDependency(dep), SLinkOperations.getTarget(dep, LINKS.nodeVersion$nOIJ))) {
        ListSequence.fromList(results).addElement(NodeVersionCheckResult.dependencyChanged(nodeFromDependency(dep)));
      }
    }


    ListSequence.fromList(results).addSequence(Sequence.fromIterable(removedDependencies).select((it) -> NodeVersionCheckResult.dependencyRemoved(it)));
    ListSequence.fromList(results).addSequence(Sequence.fromIterable(newDependencies).select((it) -> NodeVersionCheckResult.dependencyAdded(it)));

    return results;
  }

  /**
   * Returns a sequence containing each unique node referenced in the subtree. Ingnores references in node attributes and
   * filters out nodes that part of read only models, because we can't version these nodes anyway.
   * 
   * @param n node to traverse
   * @return deduplicated sequence of each node referenced from the subtree.
   */
  @NotNull
  private static Iterable<SNode> collectDependencies(@NotNull final SNode n) {
    Iterable<SNode> seq = ListSequence.fromList(SNodeOperations.getNodeDescendants(n, CONCEPTS.BaseConcept$gP, false, new SAbstractConcept[]{})).translate((it) -> (Iterable<SReference>) it.getReferences()).where((it) -> {
      SNode sourceNode = ((SNode) it.getSourceNode());
      return !(SNodeOperations.hasRole(sourceNode, LINKS.smodelAttribute$KJ43)) && ListSequence.fromList(SNodeOperations.getNodeAncestors(sourceNode, null, false)).all(new _FunctionTypes._return_P1_E0<Boolean, SNode>() {
        public Boolean invoke(SNode it) {
          return !(SNodeOperations.hasRole(it, LINKS.smodelAttribute$KJ43));
        }
      });
    }).select((it) -> {
      SNode targetNode = it.getTargetNode();
      return targetNode;
    }).distinct().where((it) -> !(it.getModel().isReadOnly())).toList();
    return seq;
  }
  private static boolean isOk(List<NodeVersionCheckResult> results) {
    return ListSequence.fromList(results).all((it) -> Objects.equals(it.getChange(), NodeVersionCheckResult.ChangeType.NoChanges));
  }
  public static SNode nodeVersionLens(Tuples._2<SNode, CalculationValue<Tuples._2<Boolean, SNode>>> value) {
    return value._1().getFinalValue()._1();
  }
  private static SNode createLinkVersion_uwzupo_a0a0a0a71a8(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.LinkVersion$ML);
    n0.setReferenceTarget(LINKS.nodeVersion$nOIJ, p0);
    return n0.getResult();
  }
  private static SNode createNodeVersion_uwzupo_a02a8(SNode p0, int p1, String p2, Iterable<? extends SNode> p3) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.NodeVersion$qo);
    n0.forChild(LINKS.node$c4Hx).initNode(p0, CONCEPTS.BaseConcept$gP, true);
    n0.setProperty(PROPS.version$c2Ao, "" + (p1));
    n0.setProperty(PROPS.hash$P2p0, p2);
    n0.forChild(LINKS.dependencies$nOJH).initNodeList(p3, CONCEPTS.LinkVersion$ML);
    return n0.getResult();
  }
  private static SNode createNodeVersion_uwzupo_a2a11(SNode p0, int p1, String p2) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.NodeVersion$qo);
    n0.forChild(LINKS.node$c4Hx).initNode(p0, CONCEPTS.BaseConcept$gP, true);
    n0.setProperty(PROPS.version$c2Ao, "" + (p1));
    n0.setProperty(PROPS.hash$P2p0, p2);
    return n0.getResult();
  }
  private static SNode createLinkVersion_uwzupo_a0a0a0a5a9a31(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.LinkVersion$ML);
    n0.setReferenceTarget(LINKS.nodeVersion$nOIJ, p0);
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept NodeVersion$qo = MetaAdapterFactory.getConcept(0x93b4395635524a1dL, 0xbf2af4d377edbed6L, 0x5a8dacca33f2e335L, "de.itemis.mps.nodeversioning.structure.NodeVersion");
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SConcept LinkVersion$ML = MetaAdapterFactory.getConcept(0x93b4395635524a1dL, 0xbf2af4d377edbed6L, 0x5a8dacca33f2e347L, "de.itemis.mps.nodeversioning.structure.LinkVersion");
  }

  private static final class PROPS {
    /*package*/ static final SProperty version$c2Ao = MetaAdapterFactory.getProperty(0x93b4395635524a1dL, 0xbf2af4d377edbed6L, 0x5a8dacca33f2e335L, 0x5a8dacca33f2e33cL, "version");
    /*package*/ static final SProperty hash$P2p0 = MetaAdapterFactory.getProperty(0x93b4395635524a1dL, 0xbf2af4d377edbed6L, 0x5a8dacca33f2e335L, 0x531877367085bd9dL, "hash");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink dependencies$nOJH = MetaAdapterFactory.getContainmentLink(0x93b4395635524a1dL, 0xbf2af4d377edbed6L, 0x5a8dacca33f2e335L, 0x2f6302025a99cf29L, "dependencies");
    /*package*/ static final SReferenceLink nodeVersion$nOIJ = MetaAdapterFactory.getReferenceLink(0x93b4395635524a1dL, 0xbf2af4d377edbed6L, 0x5a8dacca33f2e347L, 0x2f6302025a99cf27L, "nodeVersion");
    /*package*/ static final SContainmentLink smodelAttribute$KJ43 = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");
    /*package*/ static final SContainmentLink node$c4Hx = MetaAdapterFactory.getContainmentLink(0x93b4395635524a1dL, 0xbf2af4d377edbed6L, 0x5a8dacca33f2e335L, 0x5a8dacca33f2e345L, "node");
  }
}

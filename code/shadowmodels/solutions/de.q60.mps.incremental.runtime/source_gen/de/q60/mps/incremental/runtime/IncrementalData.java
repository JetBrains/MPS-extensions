package de.q60.mps.incremental.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import gnu.trove.map.hash.THashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ISequence;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.ISetSequence;
import java.util.Collections;
import com.google.common.collect.Multimap;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.MultimapBuilder;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import gnu.trove.set.hash.THashSet;
import java.util.List;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class IncrementalData {
  private static final Logger LOG = Logger.getLogger(IncrementalData.class);
  private IncrementalEngine engine;
  private DependenciesMap dependencies = new DependenciesMap();
  private Map<Object, CacheEntry<?>> cacheEntries = new THashMap<>();
  private Set<CacheEntry<?>> invalidatedEntries = SetSequence.fromSet(new HashSet<>());
  private int lastSizeAfterCleanup = 100;

  public IncrementalData(IncrementalEngine engine) {
    this.engine = engine;
  }

  public void clear() {
    dependencies.clear();
    cacheEntries.clear();
  }

  public int getSize() {
    return cacheEntries.size();
  }

  public Set<Object> getDependingKeys(Iterable<DependencyKey> changes) {
    return SetSequence.fromSetWithValues(new HashSet<Object>(), Sequence.fromIterable(changes).translate(new _FunctionTypes._return_P1_E0<Iterable<CacheEntry>, DependencyKey>() {
      public Iterable<CacheEntry> invoke(DependencyKey it) {
        return dependencies.get(it);
      }
    }));
  }

  public Set<Object> invalidate(Iterable<DependencyKey> changedDependencies) {
    try {
      if (invalidatedEntries != null && SetSequence.fromSet(invalidatedEntries).isNotEmpty()) {
        if (LOG.isWarningLevel()) {
          LOG.warning("invalidEntries expected to be empty", new Exception());
        }
      }
      invalidatedEntries = SetSequence.fromSet(new HashSet<>());
      for (DependencyKey change : Sequence.fromIterable(changedDependencies)) {
        if (change instanceof CachedValueDependency && ((CachedValueDependency) change).getEngine() == engine) {
          CacheEntry<?> changedEntry = cacheEntries.get(((CachedValueDependency) change).getKey());
          if (changedEntry != null) {
            for (CacheEntry<?> cacheEntry : SetSequence.fromSet(changedEntry.incomingCacheDependencies)) {
              if (cacheEntry.status == ECacheValueStatus.VALID) {
                cacheEntry.setStatus(ECacheValueStatus.DEPENDENCY_INVALID);
              }
            }
          }
        } else {
          for (CacheEntry cacheEntry : Sequence.fromIterable(dependencies.get(change))) {
            cacheEntry.setStatus(ECacheValueStatus.INVALID);
          }
        }
      }


      if (SetSequence.fromSet(invalidatedEntries).isNotEmpty()) {
        if (LOG.isDebugLevel()) {
          LOG.debug(SetSequence.fromSet(invalidatedEntries).count() + " entries invalidated");
        }
      }

      if (getSize() * 100 / Math.max(lastSizeAfterCleanup, 100) > 120) {
        SetSequence.fromSet(invalidatedEntries).addSequence(SetSequence.fromSet(cleanup()));
      }

      return SetSequence.fromSetWithValues(new HashSet<Object>(), SetSequence.fromSet(invalidatedEntries).select((it) -> it.getKey()));
    } finally {
      invalidatedEntries = null;
    }
  }

  public Set<CacheEntry<?>> cleanup() {
    int oldSize = getSize();
    Set<CacheEntry<?>> removedEntries = SetSequence.fromSet(new HashSet<>());

    Set<CacheEntry<?>> queue = SetSequence.fromSet(new HashSet<>());
    Iterable<CacheEntry<?>> allCacheEntries = cacheEntries.values();
    SetSequence.fromSet(queue).addSequence(Sequence.fromIterable(allCacheEntries).where((it) -> !(it.isReachable())));

    while (SetSequence.fromSet(queue).isNotEmpty()) {
      Set<CacheEntry<?>> currentEntries = queue;
      queue = SetSequence.fromSet(new HashSet<>());
      for (CacheEntry<?> entry : SetSequence.fromSet(currentEntries).where((it) -> !(it.isReachable()))) {
        SetSequence.fromSet(queue).addSequence(SetSequence.fromSet(entry.outgoingCacheDependencies));
        doRemoveCacheEntry(entry, removedEntries);
      }
    }

    if (SetSequence.fromSet(removedEntries).isNotEmpty()) {
      if (LOG.isDebugLevel()) {
        LOG.debug(SetSequence.fromSet(removedEntries).count() + " entries removed. Size: " + oldSize + " -> " + getSize());
      }
    }

    lastSizeAfterCleanup = getSize();
    return removedEntries;
  }

  private void removeInvalidEntries(Object key) {
    CacheEntry<?> entry = cacheEntries.get(key);
    if (entry == null) {
      return;
    }
    if (entry.status != ECacheValueStatus.INVALID) {
      return;
    }
    ISequence<CacheEntry<?>> invalidIncomingDeps = SetSequence.fromSet(entry.incomingCacheDependencies).where((it) -> it.status == ECacheValueStatus.INVALID);
    for (CacheEntry<?> other : Sequence.fromIterable(invalidIncomingDeps)) {
      removeInvalidEntries(other.getKey());
    }
    if (SetSequence.fromSet(entry.incomingCacheDependencies).isEmpty()) {
      removeCacheEntry(cacheEntries.get(key));
    }
  }

  public Set<Object> removeCacheEntry(CacheEntry<?> entry) {
    Set<CacheEntry<?>> removedKeys = SetSequence.fromSet(new HashSet<>());
    doRemoveCacheEntry(entry, removedKeys);
    return SetSequence.fromSetWithValues(new HashSet<Object>(), SetSequence.fromSet(removedKeys).select((it) -> it.getKey()));
  }

  private void doRemoveCacheEntry(final CacheEntry<?> entry, Set<CacheEntry<?>> removedEntries) {
    if (entry == null) {
      return;
    }
    for (CacheEntry<?> incomingDependency : SetSequence.fromSet(entry.incomingCacheDependencies)) {
      doRemoveCacheEntry(incomingDependency, removedEntries);
    }
    if (SetSequence.fromSet(entry.incomingCacheDependencies).isNotEmpty()) {
      throw new IllegalStateException(entry + " still has entries depending on it: " + SetSequence.fromSet(entry.incomingCacheDependencies).select((it) -> it.key));
    }
    SetSequence.fromSet(entry.outgoingCacheDependencies).visitAll((it) -> it.removeIncomingDependency(entry));
    SetSequence.fromSet(entry.dependencies).visitAll((it) -> dependencies.remove(it, entry));
    cacheEntries.remove(entry.key);
    SetSequence.fromSet(removedEntries).addElement(entry);
  }

  @Nullable
  public CacheEntry getCacheEntry(Object key) {
    return cacheEntries.get(key);
  }

  @Nullable
  public CacheEntry getValidCacheEntry(Object key) {
    CacheEntry entry = getCacheEntry(key);
    return (entry != null && entry.isValid() ? entry : null);
  }

  public boolean hasValue(Object key) {
    CacheEntry entry = cacheEntries.get(key);
    return entry != null;
  }

  public <T> void putEntry(Object key, T newValue, _FunctionTypes._return_P0_E0<? extends T> computable, Set<DependencyKey> dependencies) {
    CacheEntry<T> cacheEntry = (CacheEntry<T>) cacheEntries.get(key);
    if (cacheEntry == null) {
      cacheEntry = new CacheEntry<>(key, newValue, computable);
      cacheEntries.put(key, cacheEntry);
    } else {
      cacheEntry.setValue(newValue);
      cacheEntry.function = computable;
      cacheEntry.setStatus(ECacheValueStatus.VALID);
    }

    ISetSequence<CacheEntry<?>> newOutgoingDeps = SetSequence.fromSet(new HashSet<CacheEntry<?>>());
    for (DependencyKey dep : SetSequence.fromSet(dependencies)) {
      if (dep instanceof CachedValueDependency && ((CachedValueDependency) dep).getEngine() == engine) {
        CachedValueDependency cacheDep = ((CachedValueDependency) dep);
        CacheEntry depEntry = cacheEntries.get(cacheDep.getKey());
        if (depEntry == null) {
          putEntry(cacheDep.getKey(), null, () -> null, Collections.<DependencyKey>emptySet());
          depEntry = cacheEntries.get(cacheDep.getKey());
        }
        SetSequence.fromSet(newOutgoingDeps).addElement(depEntry);
      } else {
        this.dependencies.put(dep, cacheEntry);
        SetSequence.fromSet(cacheEntry.dependencies).addElement(dep);
      }
    }
    cacheEntry.setOutgoingDependencies(newOutgoingDeps);
  }

  protected static class DependenciesMap {
    private static final Iterable<IncrementalData.CacheEntry> EMPTY_SEQUENCE = Sequence.fromIterable(Collections.<IncrementalData.CacheEntry>emptyList());
    private THashMap<DependencyKey, Object> map = new THashMap<DependencyKey, Object>();

    protected void clear() {
      map.clear();
    }

    protected void removeAll(Iterable<DependencyKey> keys) {
      for (DependencyKey k : Sequence.fromIterable(keys)) {
        map.remove(k);
      }
    }

    protected Iterable<IncrementalData.CacheEntry> get(DependencyKey key) {
      Object value = map.get(key);
      if (value == null) {
        return EMPTY_SEQUENCE;
      }
      return (value instanceof MultipleValues ? ((MultipleValues) value) : Sequence.<IncrementalData.CacheEntry>singleton((IncrementalData.CacheEntry) value));
    }

    protected void remove(DependencyKey key, IncrementalData.CacheEntry value) {
      Object existing = map.get(key);
      if (existing != null) {
        if (existing instanceof MultipleValues) {
          MultipleValues multiple = ((MultipleValues) existing);
          multiple.remove(value);
          if (multiple.size() == 1) {
            map.put(key, multiple.iterator().next());
          }
        } else if (existing == value) {
          map.remove(key);
        }
      }
    }

    protected void put(DependencyKey key, IncrementalData.CacheEntry value) {
      Object existing = map.get(key);
      if (existing == null) {
        map.put(key, value);
      } else {
        if (existing instanceof MultipleValues) {
          MultipleValues multiple = ((MultipleValues) existing);
          multiple.add(value);
        } else {
          MultipleValues multiple = new MultipleValues();
          multiple.add((IncrementalData.CacheEntry) existing);
          multiple.add(value);
          map.put(key, multiple);
        }
      }
    }

    protected Multimap<IncrementalData.CacheEntry, DependencyKey> toInverse() {
      SetMultimap<IncrementalData.CacheEntry, DependencyKey> result = MultimapBuilder.hashKeys().hashSetValues().<IncrementalData.CacheEntry,DependencyKey>build();
      for (IMapping<DependencyKey, Object> entry : MapSequence.fromMap(map)) {
        Object value = entry.value();
        if (value instanceof MultipleValues) {
          for (IncrementalData.CacheEntry v : SetSequence.fromSet(((MultipleValues) value))) {
            result.put(v, entry.key());
          }
        } else {
          result.put((IncrementalData.CacheEntry) value, entry.key());
        }
      }
      return result;
    }

    private static class MultipleValues extends THashSet<IncrementalData.CacheEntry> {

    }
  }

  public enum ECacheValueStatus {
    VALID(),
    INVALID(),
    DEPENDENCY_INVALID()
  }

  public class CacheEntry<E> {
    private final CachedValueDependency ownCachedDep;
    private boolean isRoot = true;
    private final Object key;
    private E value;
    private _FunctionTypes._return_P0_E0<? extends E> function;
    private ECacheValueStatus status = ECacheValueStatus.VALID;
    private Set<CacheEntry<?>> outgoingCacheDependencies = new THashSet<>();
    private Set<CacheEntry<?>> incomingCacheDependencies = new THashSet<>();
    private Set<DependencyKey> dependencies = new THashSet<DependencyKey>();

    protected CacheEntry(Object key, E value, _FunctionTypes._return_P0_E0<? extends E> function) {
      this.key = key;
      this.value = value;
      this.function = function;
      ownCachedDep = new CachedValueDependency(key, engine);
    }

    public boolean isReachable() {
      return isRoot || SetSequence.fromSet(incomingCacheDependencies).isNotEmpty();
    }

    public boolean isStale() {
      if (isRoot) {
        return status == ECacheValueStatus.INVALID;
      } else {
        if (SetSequence.fromSet(incomingCacheDependencies).isEmpty()) {
          return true;
        }
        return !(SetSequence.fromSet(incomingCacheDependencies).any((it) -> !(it.isStale())));
      }
    }

    public void removeIncomingDependency(CacheEntry entry) {
      SetSequence.fromSet(incomingCacheDependencies).removeElement(entry);
    }

    public void addIncomingDependency(CacheEntry entry) {
      SetSequence.fromSet(incomingCacheDependencies).addElement(entry);
      isRoot = false;
    }

    public void setStatus(ECacheValueStatus newStatus) {
      ECacheValueStatus oldStatus = status;
      if (newStatus == oldStatus) {
        return;
      }
      status = newStatus;
      if (oldStatus == ECacheValueStatus.VALID) {
        if (invalidatedEntries != null) {
          SetSequence.fromSet(invalidatedEntries).addElement(this);
        }
        SetSequence.fromSet(incomingCacheDependencies).visitAll((it) -> {
          if (it.status == ECacheValueStatus.VALID) {
            it.setStatus(ECacheValueStatus.DEPENDENCY_INVALID);
          }
        });
      }
    }
    public void updateStatus() {
      if (status == ECacheValueStatus.DEPENDENCY_INVALID) {
        if (SetSequence.fromSet(outgoingCacheDependencies).all((it) -> it.isValid())) {
          setStatus(ECacheValueStatus.VALID);
        }
      }
    }
    public boolean isValid() {
      return status == ECacheValueStatus.VALID;
    }
    public boolean onlyDependenciesInvalid() {
      return status == ECacheValueStatus.DEPENDENCY_INVALID;
    }
    public List<CacheEntry<?>> getInvalidDependencies() {
      return SetSequence.fromSet(outgoingCacheDependencies).where((it) -> !(it.isValid())).toList();
    }
    protected E getValue() {
      return value;
    }
    protected void setValue(E newValue) {
      if (!(Objects.equals(newValue, getValue()))) {
        SetSequence.fromSet(incomingCacheDependencies).visitAll((it) -> it.setStatus(ECacheValueStatus.INVALID));
      }
      this.value = newValue;
    }

    public void addDependency(CacheEntry dep) {
      SetSequence.fromSet(outgoingCacheDependencies).addElement(dep);
      dep.addIncomingDependency(this);
    }

    public void setOutgoingDependencies(Set<CacheEntry<?>> deps) {
      List<CacheEntry<?>> removedDeps = SetSequence.fromSet(outgoingCacheDependencies).subtract(SetSequence.fromSet(deps)).toList();
      List<CacheEntry<?>> addedDeps = SetSequence.fromSet(deps).subtract(SetSequence.fromSet(outgoingCacheDependencies)).toList();
      ListSequence.fromList(removedDeps).visitAll((it) -> it.removeIncomingDependency(CacheEntry.this));
      ListSequence.fromList(addedDeps).visitAll((it) -> it.addIncomingDependency(CacheEntry.this));
      SetSequence.fromSet(outgoingCacheDependencies).removeSequence(ListSequence.fromList(removedDeps));
      SetSequence.fromSet(outgoingCacheDependencies).addSequence(ListSequence.fromList(addedDeps));
    }

    public Object getKey() {
      return this.key;
    }
    public _FunctionTypes._return_P0_E0<? extends E> getFunction() {
      return this.function;
    }
  }
}

package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.view.mxGraph;
import jetbrains.mps.logging.Logger;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import de.itemis.mps.editor.diagram.runtime.model.ConnectionTypeChooser;
import com.mxgraph.model.mxCell;
import com.mxgraph.util.mxPoint;
import jetbrains.mps.openapi.editor.EditorComponent;
import de.itemis.mps.editor.diagram.runtime.ContextVariables;
import com.mxgraph.view.mxGraphView;
import com.mxgraph.view.mxCellState;
import com.mxgraph.canvas.mxICanvas;
import com.mxgraph.canvas.mxGraphics2DCanvas;
import java.awt.Graphics2D;
import com.mxgraph.model.mxIGraphModel;
import de.itemis.mps.editor.diagram.runtime.model.IDiagramElement;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import de.itemis.mps.editor.diagram.runtime.model.Box;
import de.itemis.mps.editor.diagram.runtime.model.Port;
import de.itemis.mps.editor.diagram.runtime.model.Edge;
import de.itemis.mps.editor.diagram.runtime.model.IEdgeAccessor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.mxgraph.view.mxStylesheet;
import com.mxgraph.util.mxConstants;
import com.mxgraph.view.mxGraphSelectionModel;
import org.jetbrains.annotations.NotNull;
import java.awt.Point;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mxgraph.util.mxUtils;
import com.mxgraph.model.mxICell;
import de.itemis.mps.editor.diagram.runtime.model.IPaletteEntry;
import de.itemis.mps.editor.diagram.runtime.coordinates.ICoordinateSystem;
import java.util.HashSet;
import com.mxgraph.model.mxGeometry;
import com.mxgraph.util.mxEventObject;
import com.mxgraph.util.mxEvent;

public class MyGraph extends mxGraph {
  private static final Logger LOG = Logger.getLogger(MyGraph.class);
  private Model2GraphElementMapper myElementMapper;
  private MyGraphComponent myComponent;
  private DiagramModel myDiagramModel;
  private boolean mySyncSuspended;
  private MPSCellRegistry myMPSCellRegistry = new MPSCellRegistry(this);
  private ConnectionTypeChooser myConnectionTypeChooser;

  public MyGraph(Model2GraphElementMapper elementMapper, DiagramModel model) {
    super(new MyGraphModel());
    myElementMapper = elementMapper;
    myDiagramModel = model;
    myConnectionTypeChooser = new ConnectionTypeChooser(this);
    setAllowDanglingEdges(false);
    setAutoOrigin(false);
    toggleGridSnapping(model.getDiagramAccessor().useGridSnapping());
    setGridSize(model.getDiagramAccessor().getGridSize());
    setSplitEnabled(true);
    setResetEdgesOnMove(false);
    setLabelsVisible(false);
    setAllowLoops(true);
    setDefaultLoopStyle(MyEdgeStyle.getInstance());

    mxCell root = new mxCell();
    root.insert(new RootDCell(MyGraph.this));
    getModel().setRoot(root);
    resetScaleAndTranslation();
  }

  public void resetScaleAndTranslation() {
    mxPoint defaultTranslation = getView().getDefaultTranslation();
    MyGraphComponent graphComponent = getGraphComponent();
    if (graphComponent == null) {
      getView().scaleAndTranslate(1.0, defaultTranslation.getX(), defaultTranslation.getY());
    } else {
      graphComponent.scaleAndTranslate(1.0, defaultTranslation.getX(), defaultTranslation.getY());
    }
    updateViewOrigin();
  }

  public ConnectionTypeChooser getConnectionTypeChooser() {
    return myConnectionTypeChooser;
  }

  public void setGraphComponent(MyGraphComponent component) {
    myComponent = component;
  }

  public MyGraphComponent getGraphComponent() {
    return myComponent;
  }

  public RootDCell getRootDCell() {
    return (RootDCell) this.getDefaultParent();
  }

  public EditorComponent getEditorComponent() {
    // DiagramModel is null when this method is called during mxGraph initialization
    return (myDiagramModel != null ? myDiagramModel.getEditorContext().getEditorComponent() : ((EditorComponent) ContextVariables.getCurrent().getValue("editorComponent")));
  }

  public MPSCellRegistry getMPSCellRegistry() {
    return myMPSCellRegistry;
  }

  public boolean isSyncSuspended() {
    return mySyncSuspended;
  }

  public boolean setSyncSuspended(boolean suspend) {
    return mySyncSuspended = suspend;
  }

  @Override
  protected mxGraphView createGraphView() {
    return new MyGraphView(this);
  }

  @Override
  public boolean isCellFoldable(Object object, boolean b) {
    return false;
  }

  @Override
  public boolean isOrthogonal(mxCellState state) {
    return true;
  }

  public void toggleGridSnapping(boolean flag) {
    setGridEnabled(flag);
  }

  @Override
  public Object createEdge(Object parent, String id, Object value, Object source, Object target, String style) {
    mxCell edge = new EdgeDCell(this);
    edge.setId(id);
    return edge;
  }

  @Override
  public void drawState(final mxICanvas canvas, final mxCellState state, final boolean drawLabel) {
    final mxGraphics2DCanvas canvas2d = as_q25rap_a0a0a83(canvas, mxGraphics2DCanvas.class);

    if (canvas2d != null) {
      final mxCell cell = (mxCell) state.getCell();

      if (cell instanceof ISelfPaintingCell) {
        final ISelfPaintingCell selfPainting = (ISelfPaintingCell) cell;
        if (selfPainting.canPaintSelf(canvas2d, state)) {
          DrawUtil.executeWithGraphicsCopy(canvas2d.getGraphics(), (Graphics2D g) -> selfPainting.paintBackground(g, canvas2d, state));
          if (selfPainting.doesAdditionalPaintingOnly()) {
            DrawUtil.executeWithGraphicsCopy(canvas2d.getGraphics(), canvas2d, (Graphics2D g) -> MyGraph.super.drawState(canvas2d, state, drawLabel));
          }
          DrawUtil.executeWithGraphicsCopy(canvas2d.getGraphics(), (Graphics2D g) -> selfPainting.paintForeground(g, canvas2d, state));
          return;
        }
      }
    }

    super.drawState(canvas, state, drawLabel);
  }

  @Override
  public String getEdgeValidationError(Object edgeCell, Object sourceCell, Object targetCell) {
    mxIGraphModel graphModel = getModel();

    IDiagramElement edgeElement = myElementMapper.getDiagramElement((mxCell) edgeCell);
    IDiagramElement sourceElement = myElementMapper.getDiagramElement((mxCell) sourceCell);
    IDiagramElement targetElement = myElementMapper.getDiagramElement((mxCell) targetCell);

    final Wrappers._T<Box> sourceBox = new Wrappers._T<Box>(as_q25rap_a0a0a6a04(sourceElement, Box.class));
    final Wrappers._T<Box> targetBox = new Wrappers._T<Box>(as_q25rap_a0a0a7a04(targetElement, Box.class));
    final Wrappers._T<Port> sourcePort = new Wrappers._T<Port>(null);
    final Wrappers._T<Port> targetPort = new Wrappers._T<Port>(null);
    if (sourceCell instanceof PortDCell) {
      sourceBox.value = as_q25rap_a0a0a01a04(myElementMapper.getDiagramElement((mxCell) graphModel.getParent(sourceCell)), Box.class);
      sourcePort.value = ((PortDCell) sourceCell).getPort();
    }
    if (targetCell instanceof PortDCell) {
      targetBox.value = as_q25rap_a0a0a11a04(myElementMapper.getDiagramElement((mxCell) graphModel.getParent(targetCell)), Box.class);
      targetPort.value = ((PortDCell) targetCell).getPort();
    }

    if (sourceBox.value == null || targetBox.value == null) {
      return "";
    }

    if (edgeElement instanceof Edge) {
      final IEdgeAccessor edgeAccessor = ((Edge) edgeElement).getAccessor();
      final Wrappers._T<String> msg = new Wrappers._T<String>(null);
      myComponent.getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
        if (!(edgeAccessor.canWriteFrom((sourcePort.value != null ? sourcePort.value : sourceBox.value)))) {
          msg.value = "Invalid source";
        }
        if (!(edgeAccessor.canWriteTo((targetPort.value != null ? targetPort.value : targetBox.value)))) {
          msg.value = "Invalid target";
        }
      });
      if (msg.value != null) {
        return msg.value;
      }
    }

    List<String> reasons = ListSequence.fromList(new ArrayList<String>(1));
    if (!(myConnectionTypeChooser.validateConnection(sourceBox.value, sourcePort.value, targetBox.value, targetPort.value, reasons))) {
      return IterableUtils.join(ListSequence.fromList(reasons), "\n");
    }

    return super.getEdgeValidationError(edgeCell, sourceCell, targetCell);
  }

  @Override
  public boolean isSplitTarget(final Object edgeCell, Object[] boxesToInsert) {
    if (boxesToInsert.length != 1) {
      return false;
    }
    final Object boxToInsert = boxesToInsert[0];
    if (!(edgeCell instanceof EdgeDCell)) {
      return false;
    }
    if (!(boxToInsert instanceof PaletteEntryMxCell)) {
      return false;
    }

    final Wrappers._boolean canSplit = new Wrappers._boolean(false);
    getGraphComponent().getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
      Edge edge = ((EdgeDCell) edgeCell).getEdge();
      SAbstractConcept outputConcept = ((PaletteEntryMxCell) boxToInsert).getData().getOutputConcept();
      canSplit.value = check_q25rap_a0c0a6a14(edge, outputConcept);
    });
    return canSplit.value;

  }

  @Override
  public Object splitEdge(Object edge, Object[] cells, Object newEdge, double dx, double dy) {
    PaletteEntryMxCell box = (PaletteEntryMxCell) cells[0];
    box.setEdgeToSplit((EdgeDCell) edge);

    // The edge is not splitted here, but by the split handler during synchronisation with the MPS model
    Object parent = model.getParent(edge);
    model.beginUpdate();
    try {
      cellsMoved(cells, dx, dy, false, false);
      cellsAdded(cells, parent, model.getChildCount(parent), null, null, true);
    } finally {
      model.endUpdate();
    }
    return newEdge;

  }

  @Override
  protected mxStylesheet createStylesheet() {
    mxStylesheet stylesheet = super.createStylesheet();
    stylesheet.getDefaultEdgeStyle().remove(mxConstants.STYLE_ENDARROW);
    return stylesheet;
  }

  @Override
  protected mxGraphSelectionModel createSelectionModel() {
    return new MyGraphSelectionModel(this);
  }

  @Override
  public MyGraphSelectionModel getSelectionModel() {
    return (MyGraphSelectionModel) super.getSelectionModel();
  }

  @NotNull
  public DiagramModel getRootDiagramModel() {
    return myDiagramModel;
  }

  public JGraphModelSynchronizer getSynchronizer() {
    return JGraphModelSynchronizer.getSynchronizer(getRootDiagramModel());
  }


  @Override
  public Object getDropTarget(Object[] cells, Point pt, Object cell) {
    // annotations cannot change their owner
    if (Sequence.fromIterable(Sequence.fromArray(cells)).ofType(AnnotationDCell.class).isNotEmpty()) {
      return null;
    }

    if (cell == null) {
      cell = Sequence.fromIterable(Sequence.fromArray(getChildCells(getModel().getRoot()))).ofType(RootDCell.class).first();
    }
    while (cell != null && !(isValidDropTarget(cell, cells)) && model.getParent(cell) != model.getRoot()) {
      cell = model.getParent(cell);
    }
    return ((!(mxUtils.contains(cells, cell))) ? cell : null);
  }

  @Override
  public boolean isValidDropTarget(final Object parent, final Object[] cells) {
    try {
      // annotations cannot change their owner
      if (Sequence.fromIterable(Sequence.fromArray(cells)).ofType(AnnotationDCell.class).isNotEmpty()) {
        return false;
      }

      // move to different sub-diagram
      if (parent instanceof BaseDiagramDCell) {
        final Wrappers._boolean allAllowed = new Wrappers._boolean(true);
        final DiagramModel targetDiagram = ((BaseDiagramDCell) parent).getDiagramModel();
        myComponent.getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
          for (Object cell : cells) {
            mxICell currentParent = check_q25rap_a0a0a0a2a4a0a85(as_q25rap_a0a0a0a0a0a2a4a0a95(cell, mxCell.class));
            if (currentParent == null || currentParent == parent) {
              continue;
            }
            IDiagramElement diagramElement = check_q25rap_a0c0a0a2a4a0a85(as_q25rap_a0a0c0a0a0a2a4a0a95(cell, IDiagramDCell.class));
            if (diagramElement != null && !(targetDiagram.getDiagramAccessor().canChangeOwner(diagramElement))) {
              allAllowed.value = false;
              break;
            }
          }
        });
        return allAllowed.value;
      }

      // boxes can only be a direct child of a (sub-)diagram or can split an edge
      if (!(parent instanceof BaseDiagramDCell) && !(parent instanceof EdgeDCell)) {
        return false;
      }

      // allow to drop palette entries only into (sub-)diagrams with a matching entry in the palette
      for (Object cell : cells) {
        if (cell instanceof PaletteEntryMxCell) {
          final IPaletteEntry originalEntry = ((PaletteEntryMxCell) cell).getEntry();
          if (parent instanceof BaseDiagramDCell) {
            BaseDiagramDCell targetDiagramDCell = ((BaseDiagramDCell) parent);
            final DiagramModel targetModel = targetDiagramDCell.getECell().getModel();
            final Wrappers._T<IPaletteEntry> replacementEntry = new Wrappers._T<IPaletteEntry>();
            targetModel.getEditorContext().getRepository().getModelAccess().runReadAction(() -> replacementEntry.value = Sequence.fromIterable(targetModel.getPaletteEntryProvider().getEntries()).findFirst((it) -> originalEntry.isValidReplacement(it)));
            if (replacementEntry.value == null) {
              return false;
            }
          }
        }
      }

      return super.isValidDropTarget(parent, cells);
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("", ex);
      }
      return false;
    }
  }

  public ICoordinateSystem getViewCoordinateSystem() {
    return ExtensionMethods.getCoordinateSystem(getView(), getGraphComponent());
  }

  @Override
  public MyGraphView getView() {
    return (MyGraphView) super.getView();
  }

  @Override
  public boolean isCellConnectable(Object cell) {
    if (cell instanceof BoxDCell) {
      if (!(((BoxDCell) cell).getBox().isAllowConnectionsToBox())) {
        return false;
      }
    }
    return super.isCellConnectable(cell);
  }

  public Iterable<ContextButtonContainer> getContextButtonContainers() {
    Iterable<mxCellState> states = this.getView().getStates().values();
    return Sequence.fromIterable(states).select((it) -> check_q25rap_a0a0a0a1a66(as_q25rap_a0a0a0a0a1a76(it.getCell(), BaseDiagramDCell.class))).where((it) -> it != null);
  }

  @Override
  public MyGraphModel getModel() {
    return (MyGraphModel) super.getModel();
  }

  @Override
  public boolean isExtendParent(Object child) {
    if (child instanceof AnnotationDCell) {
      return false;
    }
    if (child instanceof BoxDCell) {
      return true;
    }
    return super.isExtendParent(child);
  }

  @Override
  public boolean isConstrainChild(Object child) {
    if (child instanceof IDiagramDCell) {
      return ((IDiagramDCell) child).constrainPosition();
    }
    return super.isConstrainChild(child);
  }

  @Override
  public String getToolTipForCell(Object cell) {
    if (cell instanceof IDiagramDCell) {
      return ((IDiagramDCell) cell).getTooltipText();
    }
    return super.getToolTipForCell(cell);
  }

  public void updateViewOrigin() {
    this.updateOrigin();
  }


  @Override
  public void cellsRemoved(Object[] cells) {
    if (cells != null && cells.length > 0) {
      double scale = view.getScale();
      mxPoint tr = view.getTranslate();
      model.beginUpdate();
      try {
        for (int i = 0; i < cells.length; i++) {
          // Disconnects edges which are not in cells
          // change from the original implementation: initialize size of hashset and don't convert the array to a list
          HashSet<Object> cellSet = new HashSet<>(cells.length);
          for (Object cell : cells) {
            cellSet.add(cell);
          }
          Object[] edges = getConnections(cells[i]);
          for (int j = 0; j < edges.length; j++) {
            if (!(cellSet.contains(edges[j]))) {
              mxGeometry geo = model.getGeometry(edges[j]);
              if (geo != null) {
                mxCellState state = view.getState(edges[j]);
                if (state != null) {
                  // Checks which side of the edge is being disconnected
                  Object tmp = state.getVisibleTerminal(true);
                  boolean source = false;
                  while (tmp != null) {
                    if (cells[i] == tmp) {
                      source = true;
                      break;
                    }
                    tmp = model.getParent(tmp);
                  }
                  geo = (mxGeometry) geo.clone();
                  int n = ((source) ? 0 : state.getAbsolutePointCount() - 1);
                  mxPoint pt = state.getAbsolutePoint(n);
                  geo.setTerminalPoint(new mxPoint(pt.getX() / scale - tr.getX(), pt.getY() / scale - tr.getY()), source);
                  model.setTerminal(edges[j], null, source);
                  model.setGeometry(edges[j], geo);
                }
              }
            }
          }
          model.remove(cells[i]);
        }
        fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, "cells", cells));
      } finally {
        model.endUpdate();
      }
    }
  }
  private static boolean check_q25rap_a0c0a6a14(Edge checkedDotOperand, SAbstractConcept outputConcept) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.canSplit(outputConcept);
    }
    return false;
  }
  private static mxICell check_q25rap_a0a0a0a2a4a0a85(mxCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getParent();
    }
    return null;
  }
  private static IDiagramElement check_q25rap_a0c0a0a2a4a0a85(IDiagramDCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDiagramElement();
    }
    return null;
  }
  private static ContextButtonContainer check_q25rap_a0a0a0a1a66(BaseDiagramDCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getContextButtonContainer();
    }
    return null;
  }
  private static <T> T as_q25rap_a0a0a83(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_q25rap_a0a0a6a04(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_q25rap_a0a0a7a04(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_q25rap_a0a0a01a04(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_q25rap_a0a0a11a04(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_q25rap_a0a0a0a0a0a2a4a0a95(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_q25rap_a0a0c0a0a0a2a4a0a95(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_q25rap_a0a0a0a0a1a76(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

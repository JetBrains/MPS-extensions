package de.itemis.mps.comparator.code;

/*Generated by MPS */

import java.util.Map;
import java.util.List;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class MapOfList<K, V> {

  private Map<K, List<V>> map = new HashMap<K, List<V>>();

  public List<K> getAllKeys() {
    List<K> keys = new LinkedList<K>();
    keys.addAll(map.keySet());
    return keys;
  }

  public Set<K> getKeySet() {
    Set<K> keys = SetSequence.fromSet(new HashSet<K>());
    SetSequence.fromSet(keys).addSequence(SetSequence.fromSet(map.keySet()));
    return keys;
  }

  public boolean containsKey(K key) {
    return map.containsKey(key);
  }

  public boolean hasValues(K key) {
    return map.containsKey(key) && ListSequence.fromList(map.get(key)).count() > 0;
  }

  public void addAll(K key, Iterable<V> values) {
    for (V v : Sequence.fromIterable(values)) {
      add(key, v);
    }
  }

  public void add(K key, V value) {
    if (!(map.containsKey(key))) {
      map.put(key, ListSequence.fromList(new LinkedList<V>()));
    }
    ListSequence.fromList(map.get(key)).addElement(value);
  }

  public void clear() {
    map.clear();
  }

  /**
   * Return the counter associated to the element. It is zero if it was never increased.
   * 
   * @param key  
   * @return  
   */
  public List<V> get(K key) {
    if (!(map.containsKey(key))) {
      return ListSequence.fromList(new LinkedList<V>());
    }
    return map.get(key);
  }

  public int size() {
    return map.size();
  }

}

package de.q60.mps.shadowmodels.runtime.concurrentrepo;

/*Generated by MPS */

import de.q60.mps.shadowmodels.runtime.smodel.SM_GlobalModelListener;
import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.module.SRepository;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PBranch;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PTree;
import org.modelix.model.api.INode;
import java.util.Set;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.Collections;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.concurrent.atomic.AtomicBoolean;
import de.q60.mps.util.invalidation.Invalidatable;
import org.jetbrains.mps.openapi.model.SNodeChangeListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.event.SPropertyChangeEvent;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_WriteTransaction;
import kotlin.Unit;
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent;
import org.jetbrains.mps.openapi.model.SNode;
import org.modelix.model.api.INodeReference;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeAdapter;
import org.jetbrains.mps.openapi.event.SNodeAddEvent;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import org.modelix.model.mpsadapters.mps.SModelAsNode;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent;
import org.jetbrains.mps.openapi.model.SModelListener;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.module.SModuleListener;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.modelix.model.mpsadapters.mps.SModuleAsNode;
import org.modelix.model.mpsadapters.mps.SRepositoryAsNode;
import org.modelix.model.area.IArea;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConcept;
import org.modelix.model.api.IConceptReference;
import org.modelix.model.area.IAreaReference;
import java.util.Objects;
import org.modelix.model.mpsadapters.mps.SNodeReferenceAdapter;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.modelix.model.api.IBranch;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import kotlin.jvm.functions.Function0;
import org.modelix.model.area.IAreaListener;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import de.q60.mps.shadowmodels.runtime.smodel.SM_ShadowModel;
import de.q60.mps.shadowmodels.runtime.smodel.SM_ShadowModule;
import de.q60.mps.shadowmodels.runtime.engine.DependencyTrackingNode;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_ITransaction;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

public class RepositoryMirror extends SM_GlobalModelListener {
  private static final Logger LOG = Logger.getLogger(RepositoryMirror.class);

  private static RepositoryMirror ourInstance;

  public static RepositoryMirror getInstance(SRepository repository) {
    RepositoryMirror instance = ourInstance;
    if (instance == null) {
      throw new RuntimeException("Instance not initialised yet");
    }
    return instance;
  }

  public static void setInstance(RepositoryMirror instance) {
    ourInstance = instance;
  }

  private SM_PBranch branch;
  private SM_PTree initialTree;
  private SNodeLoader loader;
  private INode repositoryNode;
  private SRepository repository;
  private final Set<SModule> dirtyModules = Collections.synchronizedSet(new HashSet<SModule>());
  private final Set<SModel> dirtyModels = Collections.synchronizedSet(new HashSet<SModel>());
  private final AtomicBoolean repositoryDirty = new AtomicBoolean(false);
  private Invalidatable invalidatable = new Invalidatable("Repository Mirror", () -> {
  });

  private SNodeChangeListener nodeChangeListener = new SNodeChangeListener() {
    public void propertyChanged(@NotNull final SPropertyChangeEvent e) {
      try {
        branch.runWrite(() -> {
          SM_WriteTransaction t = branch.getWriteTransaction();
          Long nodeId = loader.indexGet(e.getNode().getReference(), t);
          if (nodeId != null && t.getPTree().isLoaded(nodeId)) {
            t.setProperty(nodeId, e.getProperty().getName(), e.getNewValue());
          }
          return Unit.INSTANCE;
        });
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
    }
    public void referenceChanged(@NotNull final SReferenceChangeEvent e) {
      try {
        branch.runWrite(() -> {
          SM_WriteTransaction t = branch.getWriteTransaction();
          Long nodeId = loader.indexGet(e.getNode().getReference(), t);
          if (nodeId != null && t.getPTree().isLoaded(nodeId)) {
            SNode targetNode = check_8mh5gk_a0a0c0a0a0a0a1a0a71(e.getNewValue());
            if (targetNode != null) {
              loader.ensureExists(targetNode, t);
            }
            INodeReference outputTargetRef = (targetNode == null ? null : new SM_PNodeAdapter(loader.indexGet(targetNode.getReference(), t), branch).getReference());
            t.setReferenceTarget(nodeId, e.getAssociationLink().getName(), outputTargetRef);
          }
          return Unit.INSTANCE;
        });
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
    }
    public void nodeAdded(@NotNull final SNodeAddEvent e) {
      try {
        SNode inputParent = (e.isRoot() ? NodeToSNodeAdapter.wrap(new SModelAsNode(e.getModel())) : e.getParent());
        SContainmentLink link = (e.isRoot() ? LINKS.rootNodes$jxXY : e.getAggregationLink());
        updateChildren(inputParent, link, false);
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
    }
    public void nodeRemoved(@NotNull final SNodeRemoveEvent e) {
      try {
        SNode inputParent = (e.isRoot() ? NodeToSNodeAdapter.wrap(new SModelAsNode(e.getModel())) : e.getParent());
        SContainmentLink link = (e.isRoot() ? LINKS.rootNodes$jxXY : e.getAggregationLink());
        updateChildren(inputParent, link, false);
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      }
    }
  };

  private SModelListener modelListener = new SModelListener() {
    public void modelLoaded(SModel m, boolean partially) {
      // Not an actual change. This event happens during the first access of the model content.
    }
    public void modelReplaced(SModel m) {
      SetSequence.fromSet(dirtyModels).addElement(m);
    }
    public void modelUnloaded(SModel m) {
      SetSequence.fromSet(dirtyModels).addElement(m);
    }
    public void modelSaved(SModel m) {
    }
    public void modelAttached(SModel m, SRepository repo) {
    }
    public void modelDetached(SModel m, SRepository repo) {
    }
    public void conflictDetected(SModel m) {
    }
    public void problemsDetected(SModel m, Iterable<SModel.Problem> p1) {
    }
  };

  private SModuleListener moduleListener = new SModuleListener() {
    public void modelAdded(SModule p0, SModel p1) {
      SetSequence.fromSet(dirtyModules).addElement(p0);
    }
    public void beforeModelRemoved(SModule p0, SModel p1) {
    }
    public void modelRemoved(SModule p0, SModelReference p1) {
      SetSequence.fromSet(dirtyModules).addElement(p0);
    }
    public void beforeModelRenamed(SModule p0, SModel p1, SModelReference p2) {
    }
    public void modelRenamed(SModule p0, SModel p1, SModelReference p2) {
    }
    public void dependencyAdded(SModule p0, SDependency p1) {
    }
    public void dependencyRemoved(SModule p0, SDependency p1) {
    }
    public void languageAdded(SModule p0, SLanguage p1) {
    }
    public void languageRemoved(SModule p0, SLanguage p1) {
    }
    public void moduleChanged(SModule p0) {
      SetSequence.fromSet(dirtyModules).addElement(p0);
    }
  };

  public void updateRootNodes(SModel model) {
    updateChildren(NodeToSNodeAdapter.wrap(new SModelAsNode(model)), LINKS.rootNodes$jxXY, false);
  }

  public void updateModelContent(SModel model) {
    updateChildren(NodeToSNodeAdapter.wrap(new SModelAsNode(model)), LINKS.rootNodes$jxXY, false);
  }

  public void updateModels(SModule module) {
    updateChildren(NodeToSNodeAdapter.wrap(new SModuleAsNode(module)), LINKS.models$h3QT, false);
  }

  public void updateModules() {
    updateChildren(NodeToSNodeAdapter.wrap(new SRepositoryAsNode(repository)), LINKS.modules$jBPn, false);
  }

  public void updateChildren(final SNode inputParent, final SContainmentLink link, final boolean updateDescendants) {
    try {
      branch.runWrite(() -> {
        SM_WriteTransaction t = branch.getWriteTransaction();
        Long outputParent = loader.indexGet(inputParent.getReference(), t);
        if (outputParent != null && t.isLoaded(outputParent)) {
          loader.updateChildren(inputParent, outputParent, link, t, updateDescendants);
        }
        return Unit.INSTANCE;
      });
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("", ex);
      }
    }
  }

  private IArea area = new IArea() {
    @NotNull
    @Override
    public INode getRoot() {
      throw new UnsupportedOperationException();
    }

    @Nullable
    @Override
    public IConcept resolveConcept(@NotNull IConceptReference reference) {
      return null;
    }

    @Nullable
    @Override
    public INode resolveNode(@NotNull INodeReference ref) {
      return resolveOriginalNode(ref);
    }

    @NotNull
    @Override
    public IAreaReference getReference() {
      return RepositoryMirrorAreaReference.INSTANCE;
    }

    @Nullable
    @Override
    public IArea resolveArea(@NotNull IAreaReference reference) {
      return (Objects.equals(reference, getReference()) ? this : null);
    }

    @Nullable
    @Override
    public INode resolveOriginalNode(@NotNull INodeReference ref) {
      if (ref instanceof SNodeReferenceAdapter) {
        SNodeReference sref = ((SNodeReferenceAdapter) ref).getReference();
        Long id = loader.indexGet(sref, branch.getTransaction());
        if (id == null) {
          branch.getReadTransaction().registerMissingNode(new MissingSNode(sref));
          return null;
        }
        return new SM_PNodeAdapter(id, branch);
      } else {
        return null;
      }
    }

    @Nullable
    @Override
    public IBranch resolveBranch(@NotNull String id) {
      return (Objects.equals(id, branch.getId()) ? branch : null);
    }

    @NotNull
    @Override
    public List<IArea> collectAreas() {
      return ListSequence.fromListAndArray(new ArrayList<IArea>(), this);
    }

    @Override
    public <T> T executeRead(@NotNull Function0<? extends T> f) {
      return branch.computeRead(f);
    }

    @Override
    public <T> T executeWrite(@NotNull Function0<? extends T> f) {
      return branch.computeWrite(f);
    }

    @Override
    public boolean canRead() {
      return branch.canRead();
    }

    @Override
    public boolean canWrite() {
      return branch.canWrite();
    }

    @Override
    public void addListener(@NotNull IAreaListener p1) {
      throw new UnsupportedOperationException();
    }

    @Override
    public void removeListener(@NotNull IAreaListener p1) {
      throw new UnsupportedOperationException();
    }

    @Override
    public long getLockOrderingPriority() {
      return 0L;
    }
  };

  public RepositoryMirror(final SRepository repository) {
    this.repository = repository;
    loader = new SNodeLoader(repository) {
      @Override
      protected boolean loadChildEagerly(SNode parent, SNode child) {
        if (SNodeOperations.isInstanceOf(parent, CONCEPTS.Repository$db)) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(parent, CONCEPTS.Module$4i)) {
          return true;
        }
        if (SNodeOperations.isInstanceOf(parent, CONCEPTS.Model$2P)) {
          return false;
        }
        return true;
      }
    };
    branch = new SM_PBranch(loader);

    branch.runWrite(() -> {
      SM_WriteTransaction t = branch.getWriteTransaction();
      long repoId = t.addNewLazyChild(SM_PTree.ROOT_ID, "repository", -1, SConceptAdapter.wrap(CONCEPTS.Repository$db));
      t.setUserObject(repoId, SNodeLoader.SOURCE_NODE_REF_KEY, NodeToSNodeAdapter.wrap(new SRepositoryAsNode(repository)).getReference());
      repositoryNode = new SM_PNodeAdapter(repoId, branch);
      initialTree = t.getPTree();
      return Unit.INSTANCE;
    });

    start(repository);
  }

  public IArea getArea() {
    return area;
  }

  public void flush() {
    if (repositoryDirty.getAndSet(false)) {
      repository.getModelAccess().runReadAction(() -> updateModules());
    }
    if (SetSequence.fromSet(dirtyModules).isNotEmpty()) {
      repository.getModelAccess().runReadAction(() -> {
        for (int timeout = 3; timeout > 0 && SetSequence.fromSet(dirtyModules).isNotEmpty(); timeout--) {
          List<SModule> copy;
          synchronized (dirtyModules) {
            copy = ListSequence.fromListWithValues(new ArrayList<SModule>(), dirtyModules);
            SetSequence.fromSet(dirtyModules).clear();
          }
          for (SModule dirtyModule : ListSequence.fromList(copy)) {
            updateModels(dirtyModule);
          }
        }
      });
    }
    if (SetSequence.fromSet(dirtyModels).isNotEmpty()) {
      repository.getModelAccess().runReadAction(() -> {
        for (int timeout = 3; timeout > 0 && SetSequence.fromSet(dirtyModels).isNotEmpty(); timeout--) {
          List<SModel> copy;
          synchronized (dirtyModels) {
            copy = ListSequence.fromListWithValues(new ArrayList<SModel>(), dirtyModels);
            SetSequence.fromSet(dirtyModels).clear();
          }
          for (SModel dirtyModel : ListSequence.fromList(copy)) {
            updateModelContent(dirtyModel);
          }
        }
      });
    }
  }

  public SM_PBranch getBranch() {
    return branch;
  }

  public SNodeLoader getLoader() {
    return loader;
  }

  public INode getRepositoryNode() {
    return repositoryNode;
  }

  @Override
  protected void addListener(SModel model) {
    if (model instanceof SM_ShadowModel) {
      return;
    }
    model.addChangeListener(nodeChangeListener);
    model.addModelListener(modelListener);
  }

  @Override
  protected void removeListener(SModel model) {
    if (model instanceof SM_ShadowModel) {
      return;
    }
    model.removeChangeListener(nodeChangeListener);
    model.removeModelListener(modelListener);
  }

  @Override
  protected void addListener(SModule module) {
    if (module instanceof SM_ShadowModule) {
      return;
    }
    module.addModuleListener(moduleListener);
    repositoryDirty.set(true);
  }

  @Override
  protected void removeListener(SModule module) {
    if (module instanceof SM_ShadowModule) {
      return;
    }
    module.removeModuleListener(moduleListener);
    repositoryDirty.set(true);
  }

  public void dispose() {
    stop();
    invalidatable.dispose();
  }

  @Nullable
  public SNode getOriginalNode(INode mirrorNode) {
    SNodeReference nodeRef = getOriginalNodeRef(mirrorNode);
    if (nodeRef == null) {
      return null;
    }
    return nodeRef.resolve(repository);
  }

  @Nullable
  public static SNode getOriginalNode(INode mirrorNode, SRepository repository) {
    SNodeReference nodeRef = getOriginalNodeRef(mirrorNode);
    if (nodeRef == null) {
      return null;
    }
    return nodeRef.resolve(repository);
  }

  @Nullable
  public static SNodeReference getOriginalNodeRef(INode mirrorNode) {
    if (mirrorNode == null) {
      return null;
    }
    mirrorNode = DependencyTrackingNode.unwrap(mirrorNode);
    if (!(mirrorNode instanceof SM_PNodeAdapter)) {
      return null;
    }
    final SM_PNodeAdapter pnode = ((SM_PNodeAdapter) mirrorNode);
    final IBranch branch = pnode.getBranch();
    SNodeReference nodeRef = (SNodeReference) branch.computeRead(() -> ((SM_ITransaction) branch.getTransaction()).getUserObject(pnode.getNodeId(), SNodeLoader.SOURCE_NODE_REF_KEY));
    return nodeRef;
  }

  public static class RepositoryMirrorAreaReference implements IAreaReference {
    private static final RepositoryMirrorAreaReference INSTANCE = new RepositoryMirrorAreaReference();
    private RepositoryMirrorAreaReference() {
    }
  }
  private static SNode check_8mh5gk_a0a0c0a0a0a0a1a0a71(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetNode();
    }
    return null;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink rootNodes$jxXY = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x69652614fd1c514L, "rootNodes");
    /*package*/ static final SContainmentLink models$h3QT = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, 0x69652614fd1c512L, "models");
    /*package*/ static final SContainmentLink modules$jBPn = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, 0x69652614fd1c517L, "modules");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Repository$db = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, "org.modelix.model.repositoryconcepts.structure.Repository");
    /*package*/ static final SConcept Module$4i = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, "org.modelix.model.repositoryconcepts.structure.Module");
    /*package*/ static final SConcept Model$2P = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, "org.modelix.model.repositoryconcepts.structure.Model");
  }
}

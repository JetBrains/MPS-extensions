package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.event.KeyEvent;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Objects;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.util.Pair;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class SplittablePropertCell extends EditorCell_Property {

  private ITokenizer myTokenizer;

  public SplittablePropertCell(EditorContext editorContext, ModelAccessor modelAccessor, SNode node, ITokenizer tokenizer) {
    super(editorContext, modelAccessor, node);
    myTokenizer = tokenizer;
  }

  @Override
  protected boolean doProcessKeyTyped(KeyEvent event, boolean b) {
    boolean result = super.doProcessKeyTyped(event, b);
    processSplit();
    return result;
  }

  @Override
  protected boolean doProcessKeyPressed(KeyEvent event, boolean b) {
    boolean result = super.doProcessKeyPressed(event, b);
    processSplit();
    return result;
  }

  protected void processSplit() {
    if (!(isErrorState())) {
      return;
    }
    final Wrappers._T<PNode> newTree = new Wrappers._T<PNode>(null);

    final Parser parser = new Parser(getEditorComponent().getEditorContext().getModel());
    getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
      final List<String> propertyStringTokens = ListSequence.fromList(myTokenizer.tokenize(getTextBeforeCaret(), getTextAfterCaret())).where((it) -> (it != null && it.length() > 0)).toList();
      if (ListSequence.fromList(propertyStringTokens).isEmpty()) {
        return;
      }

      List<IToken> nodeTokens = parser.getTokens(getSNode());
      nodeTokens = ListSequence.fromList(nodeTokens).translate((it) -> {
        if (it instanceof PropertyToken && Objects.equals(((PropertyToken) it).getProperty(), ((PropertyAccessor) getModelAccessor()).getProperty())) {
          return ListSequence.fromList(propertyStringTokens).select(new _FunctionTypes._return_P1_E0<IToken, String>() {
            public IToken invoke(String it) {
              IToken token = new TextToken(it);
              return token;
            }
          });
        } else {
          return Sequence.<IToken>singleton(it);
        }

      }).toList();
      newTree.value = parser.parse(nodeTokens, check_fxfxix_b0a0f0a4a9(getSNode().getContainmentLink(), SplittablePropertCell.this));
    });

    if (newTree.value == null) {
      return;
    }

    getEditorComponent().getEditorContext().getRepository().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        SavedCaretPosition caretPosition = new SavedCaretPosition(getEditorComponent().getEditorContext());
        caretPosition.save();
        SNode newSNode = parser.applyParseTree(newTree.value, getSNode());
        Parser parser = new Parser(getEditorComponent().getEditorContext().getModel());
        SNode rootExpression = parser.findRootExpression(newSNode);
        SNode rebalanced = parser.rebalanceIfRequired(rootExpression);
        getEditorComponent().getEditorContext().flushEvents();
        caretPosition.restore(false);
      }
    });
  }






  public static SplittablePropertCell create(EditorContext editorContext, ModelAccessor modelAccessor, SNode node, ITokenizer tokenizer) {
    NodeReadAccessInEditorListener listener = NodeReadAccessCasterInEditor.getReadAccessListener();
    if (modelAccessor instanceof PropertyAccessor) {
      if (listener != null) {
        listener.clearCleanlyReadAccessProperties();
      }
    }
    SplittablePropertCell result = new SplittablePropertCell(editorContext, modelAccessor, node, tokenizer);
    if (listener != null) {
      addPropertyDependenciesToEditor(listener, result);
    }
    return result;
  }

  private static void addPropertyDependenciesToEditor(NodeReadAccessInEditorListener listener, EditorCell_Property result) {
    for (Pair<SNodeReference, String> pair : listener.popCleanlyReadAccessedProperties()) {
      result.getEditorComponent().getUpdater().getCurrentUpdateSession().registerCleanDependency(result, pair);
    }
  }

  private static SAbstractConcept check_fxfxix_b0a0f0a4a9(SContainmentLink checkedDotOperand, SplittablePropertCell checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetConcept();
    }
    return null;
  }
}

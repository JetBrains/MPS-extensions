package com.mbeddr.mpsutil.editor.querylist.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellProviders.AbstractCellListHandler;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.nodeEditor.cellActions.CellAction_InsertIntoCollection;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.openapi.editor.cells.SubstituteInfo;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.Map;
import java.lang.ref.WeakReference;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.nodeEditor.updater.UpdaterImpl;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public abstract class QueryListHandler extends AbstractCellListHandler {
  private SNode myOwner;
  private boolean myReadOnly = false;

  /**
   * 
   * @deprecated 
   */
  @Deprecated
  public QueryListHandler(EditorContext context, SNode owner) {
    this(context, owner, false);
  }

  public QueryListHandler(EditorContext context, SNode owner, boolean readOnly) {
    super(context);
    myOwner = owner;
    myReadOnly = readOnly;
  }

  public String getElementRole() {
    return "";
  }

  @NotNull
  public SNode getNode() {
    return myOwner;
  }

  protected SNode getAnchorNode(EditorCell cell) {
    for (EditorCell c = cell; c != null; c = c.getParent()) {
      if (c.getParent() != null && c.getParent().getSNode() == myOwner) {
        if (c.getParent() == myListEditorCell_Collection) {
          return c.getSNode();
        } else {
          return null;
        }
      }
    }
    throw new RuntimeException("anchor node not found for cell: " + cell);
  }
  /**
   * 
   * @deprecated  use createEmptyCell()
   */
  @Deprecated
  protected EditorCell createEmptyCell(EditorContext ec) {
    return createEmptyCell();
  }
  @Override
  protected EditorCell createEmptyCell() {
    EditorCell_Constant emptyCell = new EditorCell_Constant(getEditorContext(), getNode(), null);
    emptyCell.setDefaultText("<< ... >>");
    emptyCell.setEditable(true);
    emptyCell.setSubstituteInfo(getSubstituteInfo(null));
    emptyCell.setSRole(getElementSRole());
    return emptyCell;
  }

  protected EditorCell postProcessEmptyCell(EditorCell emptyCell) {
    CellAction insertAction = new AbstractCellAction() {
      public void execute(EditorContext context) {
        insertNewNode(myOwner, null, false, context);
      }
    };
    emptyCell.setAction(CellActionType.INSERT, insertAction);
    emptyCell.setAction(CellActionType.INSERT_BEFORE, insertAction);
    return noRightBoundaryOverride(emptyCell);
  }

  protected void doInsertNode(SNode node, SNode node1, boolean b) {
    // not required, because insertNewNode does that
  }

  /**
   * 
   * @deprecated  use createCells(CellLayout layout)
   */
  @Deprecated
  public EditorCell_QueryList createCells(EditorContext ec, CellLayout layout) {
    return createCells(layout);
  }
  @Override
  public EditorCell_QueryList createCells(CellLayout layout) {
    myListEditorCell_Collection = new EditorCell_QueryList(getEditorContext(), myOwner, layout, this);
    myListEditorCell_Collection.setSelectable(false);
    createInnerCells();

    // add insert/insert-before actions
    myListEditorCell_Collection.setAction(CellActionType.INSERT, new CellAction_InsertIntoCollection(this, false));
    myListEditorCell_Collection.setAction(CellActionType.INSERT_BEFORE, new CellAction_InsertIntoCollection(this, true));

    return (EditorCell_QueryList) myListEditorCell_Collection;
  }
  @Override
  public EditorCell createNodeCell(final SNode node) {
    if ((node == null)) {
      EditorCell_Constant nullCell = new EditorCell_Constant(getEditorContext(), myOwner, "", false);
      nullCell.setDefaultText("<null>");
      return nullCell;
    }
    EditorCell cell = createNodeCellNotNull(getEditorContext(), node);
    cell.setAction(CellActionType.INSERT, new AbstractCellAction() {
      public void execute(EditorContext context) {
        insertNewNode(myOwner, node, false, context);
      }
    });
    cell.setAction(CellActionType.INSERT_BEFORE, new AbstractCellAction() {
      public void execute(EditorContext context) {
        insertNewNode(myOwner, node, true, context);
      }
    });

    QueryListContext.getCurrentContext().increaseIndex();
    return cell;
  }

  public SNode createNodeToInsert(EditorContext context) {
    throw new RuntimeException("Method not implemented");
  }

  protected EditorCell createNodeCellNotNull(EditorContext context, @NotNull SNode node) {
    return context.getEditorComponent().getUpdater().getCurrentUpdateSession().updateChildNodeCell(node);
  }

  protected List<? extends SNode> getNodesForList() {
    return Sequence.fromIterable(getNodesForList(getNode())).where((it) -> it != null && (SNodeOperations.getModel(it) != null || myReadOnly)).toList();
  }

  @Override
  public void insertNewChild(EditorContext editorContext, EditorCell anchorCell, boolean insertBefore) {
    SNode anchorNode = getAnchorNode(anchorCell);
    insertNewNode(myOwner, anchorNode, insertBefore, editorContext);
  }

  public SubstituteInfo getSubstituteInfo(SNode child) {
    return getSubstituteInfo(myOwner, child, new SubstituteInfoFactory(getEditorContext()), getEditorContext());
  }

  public abstract Iterable<SNode> getNodesForList(SNode listNode);
  public abstract SubstituteInfo getSubstituteInfo(SNode listNode, SNode elementNode, SubstituteInfoFactory factory, EditorContext editorContext);
  /**
   * 
   * @deprecated 
   */
  @Deprecated
  public void insertNewNode(SNode listNode, SNode anchorNode, boolean insertBefore) {
    insertNewNode(listNode, anchorNode, insertBefore, null);
  }
  public abstract void insertNewNode(SNode listNode, SNode anchorNode, boolean insertBefore, EditorContext editorContext);
  /**
   * 
   * @deprecated 
   */
  @Deprecated
  public void deleteNode(SNode listNode, SNode nodeToDelete) {
    deleteNode(listNode, nodeToDelete, null);
  }
  public abstract void deleteNode(SNode listNode, SNode nodeToDelete, EditorContext editorContext);

  public EditorCell noRightBoundaryOverride(EditorCell cell) {
    EditorCell_Collection wrapper = EditorCell_Collection.createIndent2(cell.getContext(), cell.getSNode());
    wrapper.addEditorCell(cell);

    // use EditorCell_Basic dummy cell instead of EditorCell_Empty to avoid unwanted vertical size
    // (in case empty query should not take any space in the editor)
    EditorCell_Basic rightEnd = new EditorCell_Basic(cell.getContext(), cell.getSNode()) {
      @Override
      protected void paintContent(Graphics graphics, ParentSettings settings) {
      }
    };
    rightEnd.setSelectable(false);
    wrapper.addEditorCell(rightEnd);

    return wrapper;
  }

  protected void setSemanticNodeToCells(EditorCell rootCell, SNode semanticNode) {
    if (!(rootCell instanceof EditorCell_Basic) || semanticNode == null) {
      return;
    }
    ((EditorCell_Basic) rootCell).setSNode(semanticNode);
    if (rootCell instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection) {
      Iterator<EditorCell> children = ((jetbrains.mps.openapi.editor.cells.EditorCell_Collection) rootCell).iterator();
      while (children.hasNext()) {
        setSemanticNodeToCells(children.next(), semanticNode);
      }
    }
  }

  protected EditorCell createCellDuplicatesSafe(_FunctionTypes._return_P0_E0<? extends EditorCell> creator) {
    // remember node to cell mapping
    EditorComponent component = (EditorComponent) getEditorContext().getEditorComponent();
    Map<SNode, WeakReference<EditorCell>> nodesToBigCells = (Map<SNode, WeakReference<EditorCell>>) ReflectionUtil.readField(UpdaterImpl.class, component.getUpdater(), "myBigCellsMap");
    HashMap<SNode, EditorCell> previousMapping = new HashMap<SNode, EditorCell>();
    for (IMapping<SNode, WeakReference<EditorCell>> entry : MapSequence.fromMap(nodesToBigCells)) {
      SNode key = entry.key();
      EditorCell value = entry.value().get();
      if (key != null && value != null) {
        previousMapping.put(key, value);
      }
    }

    // build cell
    EditorCell result = creator.invoke();

    // restore old mappings
    for (SNode key : SetSequence.fromSet(previousMapping.keySet())) {
      EditorCell oldValue = previousMapping.get(key);
      EditorCell newValue = check_rqow2_a0b0k0sb(nodesToBigCells.get(key));
      if (newValue != oldValue) {
        nodesToBigCells.put(key, new WeakReference<EditorCell>(oldValue));
      }
    }

    return result;
  }

  public class DeleteChildAction extends AbstractCellAction {
    private SNode myChildNode;

    public DeleteChildAction(SNode childNode) {
      myChildNode = childNode;
    }

    public void execute(EditorContext context) {
      deleteNode(myOwner, myChildNode, context);
    }
  }
  private static EditorCell check_rqow2_a0b0k0sb(WeakReference<EditorCell> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.get();
    }
    return null;
  }
}

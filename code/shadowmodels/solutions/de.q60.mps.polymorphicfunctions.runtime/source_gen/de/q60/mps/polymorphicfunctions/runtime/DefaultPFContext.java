package de.q60.mps.polymorphicfunctions.runtime;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.MultimapBuilder;
import java.util.Iterator;

public class DefaultPFContext extends AbstractPFContext implements IPFContext {

  private List<IImplementationProvider> myImplementationProviders;
  private RecursionProtection myRecursionProtection = new RecursionProtection();

  public DefaultPFContext(Iterable<IImplementationProvider> implementationProviders) {
    myImplementationProviders = Sequence.fromIterable(implementationProviders).toList();
  }

  public DefaultPFContext(IImplementationProvider implementationProvider) {
    this(Sequence.<IImplementationProvider>singleton(implementationProvider));
  }

  @Override
  public Object callFunction(String id, ParameterList parameters, IPFContext context) {
    return Sequence.fromIterable(callFunctions(id, parameters, false, context)).first();
  }

  @Override
  public Iterable<Object> callFunctions(String id, ParameterList parameters, IPFContext context) {
    return Sequence.fromIterable(callFunctions(id, parameters, true, context)).toList();
  }

  protected Iterable<Object> callFunctions(final String id, final ParameterList parameters, final boolean multiple, final IPFContext context) {
    List<IFunctionImplementation> applicableImplementations = getImplementationsToCall(id, parameters, multiple, context);
    if (!(multiple) && ListSequence.fromList(applicableImplementations).count() > 1) {
      throw new RuntimeException(ListSequence.fromList(applicableImplementations).count() + " applicable implementations found for " + id + "(" + parameters + ")");
    }
    return ListSequence.fromList(applicableImplementations).select((final IFunctionImplementation it) -> IPFContext.CURRENT.computeWith(context, () -> myRecursionProtection.evaluate(it, parameters, context)));
  }

  protected List<IFunctionImplementation> getImplementationsToCall(String id, ParameterList parameters, final boolean multiple, final IPFContext context) {
    List<IFunctionImplementation> applicableImplementations = getApplicableImplementations(id, parameters, context);
    if (!(multiple) && ListSequence.fromList(applicableImplementations).count() == 0) {
      throw new NoApplicableImplementationException("No applicable implementation found for " + id + "(" + parameters + "), active contexts: " + IterableUtils.join(Sequence.fromIterable(context.getContexts()), ", "), id);
    }
    applicableImplementations = Sequence.fromIterable(myRecursionProtection.filter(applicableImplementations, parameters)).toList();
    if (!(multiple) && ListSequence.fromList(applicableImplementations).count() == 0) {
      throw new NoApplicableImplementationException("No applicable implementation remaining for " + id + "(" + parameters + "), active groups: " + IterableUtils.join(Sequence.fromIterable(context.getGroups()), ", "), id);
    }
    if (ListSequence.fromList(applicableImplementations).count() > 1) {
      applicableImplementations = Sequence.fromIterable(applyPriorities(applicableImplementations, (IFunctionImplementation high, IFunctionImplementation low) -> {
        if (priorityFromRules(high, low)) {
          return true;
        }
        if (priorityFromRules(low, high)) {
          return false;
        }
        return !(multiple) && isMoreSpecific(high, low);
      })).toList();
    }
    return applicableImplementations;
  }

  protected List<IFunctionImplementation> getApplicableImplementations(final String id, final ParameterList parameters, final IPFContext context) {
    final Set<String> activeContexts = SetSequence.fromSetWithValues(new HashSet<String>(), context.getContexts());
    Iterable<IFunctionImplementation> result;
    result = ListSequence.fromList(myImplementationProviders).translate((it) -> it.getImplementations(context, id, parameters));
    result = Sequence.fromIterable(result).where((it) -> {
      return Sequence.fromIterable(it.getContextIds()).all(new _FunctionTypes._return_P1_E0<Boolean, String>() {
        public Boolean invoke(String it) {
          return SetSequence.fromSet(activeContexts).contains(it);
        }
      });
    });
    result = Sequence.fromIterable(result).where((it) -> it.isApplicable(context, parameters)).toList();
    return Sequence.fromIterable(result).toList();
  }

  protected Iterable<IFunctionImplementation> applyPriorities(final List<IFunctionImplementation> rules, _FunctionTypes._return_P2_E0<? extends Boolean, ? super IFunctionImplementation, ? super IFunctionImplementation> priorityFunction) {
    if (ListSequence.fromList(rules).count() <= 1) {
      return rules;
    }

    final SetMultimap<IFunctionImplementation, IFunctionImplementation> lowToHigh = MultimapBuilder.hashKeys().hashSetValues().<IFunctionImplementation,IFunctionImplementation>build();
    for (IFunctionImplementation r1 : ListSequence.fromList(rules)) {
      for (IFunctionImplementation r2 : ListSequence.fromList(rules)) {
        if (r1 == r2) {
          continue;
        }
        boolean r1Higher = priorityFunction.invoke(r1, r2);
        boolean r2Higher = priorityFunction.invoke(r2, r1);
        if (r1Higher && r2Higher) {
          continue;
        }
        if (r1Higher) {
          lowToHigh.put(r2, r1);
        }
        if (r2Higher) {
          lowToHigh.put(r1, r2);
        }
      }
    }

    final Set<IFunctionImplementation> highestPriorityRules = SetSequence.fromSet(new HashSet<IFunctionImplementation>());
    new Object() {
      private Set<IFunctionImplementation> visited = SetSequence.fromSet(new HashSet<IFunctionImplementation>());
      public void collectHighestPrio(Iterable<IFunctionImplementation> rules) {
        for (IFunctionImplementation rule : Sequence.fromIterable(rules)) {
          collectHighestPrio(rule);
        }
      }
      public void collectHighestPrio(IFunctionImplementation rule) {
        if (SetSequence.fromSet(visited).contains(rule)) {
          return;
        }
        SetSequence.fromSet(visited).addElement(rule);

        Set<IFunctionImplementation> higher = lowToHigh.get(rule);
        if (higher.isEmpty()) {
          SetSequence.fromSet(highestPriorityRules).addElement(rule);
        } else {
          collectHighestPrio(higher);
        }
      }
    }.collectHighestPrio(rules);

    if (SetSequence.fromSet(highestPriorityRules).isEmpty()) {
      throw new RuntimeException("No implementations left after applying priorities. This shouldn't happen.");
    }
    return highestPriorityRules;
  }

  public boolean priorityFromRules(final IFunctionImplementation highPrio, final IFunctionImplementation lowPrio) {
    return ListSequence.fromList(myImplementationProviders).translate((it) -> it.getPriorityRules()).any((it) -> it.hasHigherPriority(highPrio, lowPrio));
  }

  protected boolean isMoreSpecific(IFunctionImplementation highPrio, IFunctionImplementation lowPrio) {
    if (Sequence.fromIterable(highPrio.getContextIds()).subtract(Sequence.fromIterable(lowPrio.getContextIds())).isNotEmpty() && Sequence.fromIterable(lowPrio.getContextIds()).subtract(Sequence.fromIterable(highPrio.getContextIds())).isEmpty()) {
      return true;
    }
    if (Sequence.fromIterable(highPrio.getContextIds()).subtract(Sequence.fromIterable(lowPrio.getContextIds())).isEmpty() && Sequence.fromIterable(lowPrio.getContextIds()).subtract(Sequence.fromIterable(highPrio.getContextIds())).isNotEmpty()) {
      return false;
    }

    boolean highIsMoreSpecific = false;
    boolean lowIsMoreSpecific = false;

    {
      Iterator<IParameterType> high_it = Sequence.fromIterable(highPrio.getParameterTypes()).iterator();
      Iterator<IParameterType> low_it = Sequence.fromIterable(lowPrio.getParameterTypes()).iterator();
      IParameterType high_var;
      IParameterType low_var;
      while (high_it.hasNext() && low_it.hasNext()) {
        high_var = high_it.next();
        low_var = low_it.next();
        if (high_var.isMoreSpecificThan(low_var)) {
          highIsMoreSpecific = true;
        }
        if (low_var.isMoreSpecificThan(high_var)) {
          lowIsMoreSpecific = true;
        }
      }
    }

    return highIsMoreSpecific && !(lowIsMoreSpecific);
  }
}

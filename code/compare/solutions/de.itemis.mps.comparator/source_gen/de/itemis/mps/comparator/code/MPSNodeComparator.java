package de.itemis.mps.comparator.code;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SDataType;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public final class MPSNodeComparator {

  private static final String PREFIX = MPSNodeComparator.class.getName() + ": ";
  private static String EXPECTED = "expected";
  private static String ACTUAL = "actual";

  public static MPSNodeComparisonResult compare(SNode expected, SNode actual) {
    return compare(expected, actual, true);
  }

  public static MPSNodeComparisonResult compare(SNode expected, SNode actual, boolean compareChildren) {
    return compare(expected, actual, null, null, compareChildren, false);
  }

  public static MPSNodeComparisonResult compare(SNode expected, SNode actual, List<IgnoredProperty> ignoredProperties, boolean compareChildren, boolean verbose) {
    return compare(expected, actual, ignoredProperties, null, compareChildren, verbose);
  }

  public static MPSNodeComparisonResult compare(SNode expected, SNode actual, List<IgnoredProperty> ignoredProperties, List<IgnoredReference> ignoredReferences, boolean compareChildren, boolean verbose) {
    return compare(expected, actual, ignoredProperties, ignoredReferences, false, compareChildren, verbose);
  }

  public static MPSNodeComparisonResult compare(SNode expected, SNode actual, List<IgnoredProperty> ignoredProperties, List<IgnoredReference> ignoredReferences, final boolean compareAnnotations, final boolean compareChildren, final boolean verbose) {
    MPSComparatorOptions options = ((_FunctionTypes._return_P0_E0<MPSComparatorOptions>) () -> {
      final MPSComparatorOptions result_4wac44_a0a0a0n = new MPSComparatorOptions();
      final boolean result_4wac44_a0a0a0a0n = compareChildren;
      result_4wac44_a0a0a0n.compareChildren = result_4wac44_a0a0a0a0n;
      final boolean result_4wac44_a1a0a0a0n = verbose;
      result_4wac44_a0a0a0n.verbose = result_4wac44_a1a0a0a0n;
      final boolean result_4wac44_a2a0a0a0n = compareAnnotations;
      result_4wac44_a0a0a0n.compareAnnotations = result_4wac44_a2a0a0a0n;
      return result_4wac44_a0a0a0n;
    }).invoke();
    ListSequence.fromList(options.ignoredProperties).addSequence(ListSequence.fromList(ignoredProperties));
    ListSequence.fromList(options.ignoredReferences).addSequence(ListSequence.fromList(ignoredReferences));
    return compare(expected, actual, options);
  }


  public static MPSNodeComparisonResult compare(SNode expected, SNode actual, MPSComparatorOptions options) {
    updateExpectedActual(expected, actual);
    MPSNodeComparisonResult result = new MPSNodeComparisonResult(EXPECTED, ACTUAL);
    if (actual == null || expected == null) {
      result.addDifference(new DifferentConceptDifference(expected, actual, EXPECTED, ACTUAL));
      return result;
    }
    // fast return if nodes are the same
    if (Objects.equals(expected, actual)) {
      return result;
    }
    if (!(Objects.equals(SNodeOperations.getConcept(expected), SNodeOperations.getConcept(actual)))) {
      log("different concepts " + EXPECTED + " = " + SNodeOperations.getConcept(expected) + " " + ACTUAL + " = " + SNodeOperations.getConcept(actual), expected, actual, options.verbose);
      result.addDifference(new DifferentConceptDifference(expected, actual, EXPECTED, ACTUAL));
    } else {
      log("same concept", options.verbose);
      fillDifferencesOnProperties(expected, actual, result, options);
      fillDifferencesOnReferences(expected, actual, result, options);
      if (options.compareAnnotations) {
        fillDifferencesOnAnnotations(expected, actual, result, options);
      }

      if (options.compareChildren) {
        fillDifferencesOnChildren(expected, actual, result, options);
      }
    }
    return result;
  }

  private static void log(String message, boolean verbose) {
    log(message, null, null, verbose);
  }

  private static void log(String message, SNode expected, SNode actual, boolean verbose) {
    if (verbose) {
      System.out.print(PREFIX + message);
      if (expected != null) {
        System.out.print(" expected nodeId " + expected.getNodeId());
      }
      if (actual != null) {
        System.out.print(" actual nodeId " + actual.getNodeId());
      }
      System.out.println();
    }
  }

  private static void fillDifferencesOnProperties(SNode expected, SNode actual, MPSNodeComparisonResult result, MPSComparatorOptions options) {
    updateExpectedActual(expected, actual);

    Set<SProperty> aProperties = SetSequence.fromSet(new HashSet<SProperty>());
    SetSequence.fromSet(aProperties).addSequence(Sequence.fromIterable(expected.getProperties()));
    Set<SProperty> bProperties = SetSequence.fromSet(new HashSet<SProperty>());
    SetSequence.fromSet(bProperties).addSequence(Sequence.fromIterable(actual.getProperties()));
    Set<SProperty> allProperties = SetSequence.fromSet(new HashSet<SProperty>());
    SetSequence.fromSet(allProperties).addSequence(SetSequence.fromSet(aProperties));
    SetSequence.fromSet(allProperties).addSequence(SetSequence.fromSet(bProperties));

    for (final SProperty p : SetSequence.fromSet(allProperties)) {
      if (!(isIgnoredProperty(expected, actual, options.ignoredProperties, p.getName()))) {
        if (ListSequence.fromList(options.ignoredProperties).where((it) -> it.getProperty().equals(p.getName())).isEmpty()) {
          log("comparing property " + p, options.verbose);

          // compare property values according to the property data type -> this allows to correctly handle the fact that unset bool prop == false
          SDataType dataType = p.getType();
          Object expectedPropValue = dataType.fromString(expected.getProperty(p));
          Object actualPropValue = dataType.fromString(actual.getProperty(p));

          if (!(Objects.equals(expectedPropValue, actualPropValue))) {
            log("diff found for property " + p, expected, actual, options.verbose);
            result.addDifference(new PropertyDifference(expected, actual, EXPECTED, ACTUAL, p));
          }
        }
      }
    }
  }

  private static boolean isIgnoredProperty(final SNode expected, final SNode actual, List<IgnoredProperty> ignoredProperties, final String property) {
    boolean simpleIsIgnored = ListSequence.fromList(ignoredProperties).any((it) -> (SNodeOperations.isInstanceOf(expected, SNodeOperations.asSConcept(it.getConcept())) || SNodeOperations.isInstanceOf(actual, SNodeOperations.asSConcept(it.getConcept()))) && property.equals(it.getProperty()));

    if (simpleIsIgnored) {
      return true;
    }

    return checkAnnotationForIgnoringProperties(expected, property) || checkAnnotationForIgnoringProperties(actual, property) || shouldIgnoreChildren(expected) || shouldIgnoreChildren(actual);
  }

  private static boolean checkAnnotationForIgnoringProperties(@Nullable SNode node, final String property) {
    if ((node == null)) {
      return false;
    }
    return new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(node) != null && SPropertyOperations.getBoolean(new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(node), PROPS.ignoreAllProperties$Iy7A) || ListSequence.fromList(SLinkOperations.getChildren(new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(node), LINKS.refs$MUwr)).where((it) -> SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.PropertyDeclaration$1S)).any((it) -> SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.PropertyDeclaration$1S), PROPS.name$MnvL).equals(property));
  }

  private static boolean shouldIgnoreChildren(SNode node) {
    return ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, false)).any((it) -> new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(it) != null && SPropertyOperations.getBoolean(new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(it), PROPS.ignoreChildren$IyOD));
  }

  public static boolean isIgnoredChild(final SNode expected, final SNode actual, List<IgnoredChild> ignoredChildren, final String role) {
    boolean simpleIsIgnored = ListSequence.fromList(ignoredChildren).any((it) -> (SNodeOperations.isInstanceOf(expected, SNodeOperations.asSConcept(it.getConcept())) || SNodeOperations.isInstanceOf(actual, SNodeOperations.asSConcept(it.getConcept()))) && role.equals(it.getContaiment()));

    if (simpleIsIgnored) {
      return true;
    }

    return checkAnnotationForIgnoringChildren(expected, role) || checkAnnotationForIgnoringChildren(actual, role) || shouldIgnoreChildren(expected) || shouldIgnoreChildren(actual);
  }

  private static boolean checkAnnotationForIgnoringChildren(@Nullable SNode node, final String role) {
    if ((node == null)) {
      return false;
    }
    return (new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(node) != null) && ListSequence.fromList(SLinkOperations.getChildren(new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(node), LINKS.refs$MUwr)).where((it) -> SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.LinkDeclaration$1p)).any((it) -> SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.LinkDeclaration$1p), PROPS.role$Nsjf).equals(role) && SEnumOperations.isMember(SPropertyOperations.getEnum(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.LinkDeclaration$1p), PROPS.metaClass$PeKc), 0xfc6f4e95b9L));
  }


  private static boolean isIgnoredReference(final SNode expected, final SNode actual, List<IgnoredReference> ignoredReferences, final String role) {
    boolean simpleIsIgnored = ListSequence.fromList(ignoredReferences).any((it) -> (SNodeOperations.isInstanceOf(expected, SNodeOperations.asSConcept(it.getConcept())) || SNodeOperations.isInstanceOf(actual, SNodeOperations.asSConcept(it.getConcept()))) && role.equals(it.getReference()));

    if (simpleIsIgnored) {
      return true;
    }

    return checkAnnotationForIgnoringReferences(expected, role) || checkAnnotationForIgnoringReferences(actual, role) || shouldIgnoreChildren(expected) || shouldIgnoreChildren(actual);
  }

  private static boolean checkAnnotationForIgnoringReferences(@Nullable SNode node, final String role) {
    if ((node == null)) {
      return false;
    }
    return (new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(node) != null) && ListSequence.fromList(SLinkOperations.getChildren(new IAttributeDescriptor.NodeAttribute(CONCEPTS.IgnorePropertiesAnnotation$zD).get(node), LINKS.refs$MUwr)).where((it) -> SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.LinkDeclaration$1p)).any((it) -> SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.LinkDeclaration$1p), PROPS.role$Nsjf).equals(role) && SEnumOperations.isMember(SPropertyOperations.getEnum(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.ref$b10I), CONCEPTS.LinkDeclaration$1p), PROPS.metaClass$PeKc), 0xfc6f4e95b8L));
  }

  private static void fillDifferencesOnReferences(SNode expected, SNode actual, MPSNodeComparisonResult result, MPSComparatorOptions options) {
    updateExpectedActual(expected, actual);

    final Map<String, SReference> aMap = MapSequence.fromMap(new HashMap<String, SReference>());
    final Map<String, SReference> bMap = MapSequence.fromMap(new HashMap<String, SReference>());
    ListSequence.fromList(SNodeOperations.getReferences(expected)).visitAll((ref) -> MapSequence.fromMap(aMap).put(check_4wac44_a0a0a0a0e0nb(SLinkOperations.getRefLink(ref)), ref));
    ListSequence.fromList(SNodeOperations.getReferences(actual)).visitAll((ref) -> MapSequence.fromMap(bMap).put(check_4wac44_a0a0a0a0f0nb(SLinkOperations.getRefLink(ref)), ref));

    for (final String role : SetSequence.fromSet(MapSequence.fromMap(aMap).keySet()).union(SetSequence.fromSet(MapSequence.fromMap(bMap).keySet()))) {
      if (isIgnoredReference(expected, actual, options.ignoredReferences, role)) {
        continue;
      }

      log("comparing reference " + role, options.verbose);
      SReference aRef = ListSequence.fromList(SNodeOperations.getReferences(expected)).findFirst((it) -> check_4wac44_a0a0a0a0d0h0nb(SLinkOperations.getRefLink(it)).equals(role));
      SReference bRef = ListSequence.fromList(SNodeOperations.getReferences(actual)).findFirst((it) -> check_4wac44_a0a0a0a0e0h0nb(SLinkOperations.getRefLink(it)).equals(role));

      if (aRef != null & bRef != null) {
        MPSComparatorOptions newOptions = new MPSComparatorOptions();
        newOptions.compareChildren = options.compareChildrenOfReferences;
        newOptions.compareChildrenOfReferences = options.compareChildrenOfReferences;
        ListSequence.fromList(newOptions.ignoredProperties).addSequence(ListSequence.fromList(options.ignoredProperties));
        ListSequence.fromList(newOptions.ignoredReferences).addSequence(ListSequence.fromList(options.ignoredReferences));
        newOptions.verbose = options.verbose;
        MPSNodeComparisonResult comparison = compare(SLinkOperations.getTargetNode(aRef), SLinkOperations.getTargetNode(bRef), newOptions);
        if (!(comparison.areEquals())) {
          log("diff found for role " + role, expected, actual, options.verbose);
          result.addDifference(new ReferenceDifference(expected, actual, EXPECTED, ACTUAL, role, comparison));
        }
      } else if (aRef != null || bRef != null) {
        log("role not found: " + role, expected, actual, options.verbose);
        result.addDifference(new MissingReferenceDifference(expected, actual, EXPECTED, ACTUAL, role));
      } else {
        throw new IllegalStateException("cannot find references for role " + role + " (expected: <" + SNodeOperations.getConcept(expected) + "> " + expected + " actual: <" + SNodeOperations.getConcept(actual) + "> " + actual + ")");
      }
    }
  }

  private static void fillDifferencesOnAnnotations(SNode expected, SNode actual, MPSNodeComparisonResult result, MPSComparatorOptions options) {
    updateExpectedActual(expected, actual);

    MapOfList<String, SNode> expectedAttributes = new MapOfList<String, SNode>();
    for (SNode attribute : ListSequence.fromList(new IAttributeDescriptor.AllAttributes().list(expected))) {
      expectedAttributes.add(check_4wac44_a0a0a3a14(SNodeOperations.getContainingLink(attribute)), attribute);
    }
    MapOfList<String, SNode> actualAttributes = new MapOfList<String, SNode>();
    for (SNode attribute : ListSequence.fromList(new IAttributeDescriptor.AllAttributes().list(actual))) {
      actualAttributes.add(check_4wac44_a0a0a5a14(SNodeOperations.getContainingLink(attribute)), attribute);
    }
    for (String attrRole : SetSequence.fromSet(expectedAttributes.getKeySet()).union(SetSequence.fromSet(actualAttributes.getKeySet()))) {
      List<SNode> attrsOfAWithGivenRole = expectedAttributes.get(attrRole);
      List<SNode> attrsOfBWithGivenRole = actualAttributes.get(attrRole);
      if (ListSequence.fromList(attrsOfAWithGivenRole).count() != ListSequence.fromList(attrsOfBWithGivenRole).count()) {
        log("different number of attributes for role " + attrRole, expected, actual, options.verbose);

        result.addDifference(new DifferentNumberOfAttributesDifference(expected, actual, EXPECTED, ACTUAL, attrRole, ListSequence.fromList(attrsOfAWithGivenRole).count(), ListSequence.fromList(attrsOfBWithGivenRole).count()));
      } else {
        log("same number of attributes", options.verbose);

        for (int i = 0; i < attrsOfAWithGivenRole.size(); i++) {
          MPSNodeComparisonResult attributeDifference = compare(attrsOfAWithGivenRole.get(i), attrsOfBWithGivenRole.get(i), options);
          if (!(attributeDifference.areEquals())) {
            log("attribute at " + i + " is different", attrsOfAWithGivenRole.get(i), attrsOfBWithGivenRole.get(i), options.verbose);

            result.addDifference(new AttributeDifference(expected, actual, EXPECTED, ACTUAL, attrRole, i, attributeDifference));
          }
        }
      }
    }
  }

  private static void fillDifferencesOnChildren(SNode expected, SNode actual, MPSNodeComparisonResult result, MPSComparatorOptions options) {
    updateExpectedActual(expected, actual);

    Set<String> childRoles = SetSequence.fromSet(new HashSet<String>());
    childRoles.addAll(ListSequence.fromList(SNodeOperations.getChildren(expected)).select((it) -> check_4wac44_a0a0a0a0a3a34(SNodeOperations.getContainingLink(it))).toList());
    childRoles.addAll(ListSequence.fromList(SNodeOperations.getChildren(actual)).select((it) -> check_4wac44_a0a0a0a0a4a34(SNodeOperations.getContainingLink(it))).toList());
    for (final String role : childRoles) {
      if (Objects.equals("smodelAttribute", role)) {
        continue;
      }

      if (isIgnoredChild(expected, actual, options.ignoredChildren, role)) {
        continue;
      }

      log("comparing children for role " + role, options.verbose);
      List<SNode> aChildren = ListSequence.fromList(SNodeOperations.getChildren(expected)).where((it) -> check_4wac44_a0a0a0a0a5a5a34(SNodeOperations.getContainingLink(it)).equals(role)).toList();
      List<SNode> bChildren = ListSequence.fromList(SNodeOperations.getChildren(actual)).where((it) -> check_4wac44_a0a0a0a0a6a5a34(SNodeOperations.getContainingLink(it)).equals(role)).toList();
      if (aChildren.size() != bChildren.size()) {
        log("different number of children", expected, actual, options.verbose);
        result.addDifference(new DifferentNumberOfChildrenDifference(expected, actual, EXPECTED, ACTUAL, role));
      } else {
        log("same number of children", options.verbose);
        for (int i = 0; i < aChildren.size(); i++) {
          MPSNodeComparisonResult childDifference = compare(aChildren.get(i), bChildren.get(i), options.ignoredProperties, options.ignoredReferences, options.compareChildren, options.verbose);
          if (!(childDifference.areEquals())) {
            log("children at " + i + " are different ", ListSequence.fromList(aChildren).getElement(i), ListSequence.fromList(bChildren).getElement(i), options.verbose);
            result.addDifference(new ChildDifference(expected, actual, EXPECTED, ACTUAL, role, i, childDifference));
          }
        }
      }
    }
  }

  private static void updateExpectedActual(SNode expected, SNode actual) {
    if (SNodeOperations.isInstanceOf(actual, CONCEPTS.INamedConcept$Kd)) {
      ACTUAL = SPropertyOperations.getString(SNodeOperations.cast(actual, CONCEPTS.INamedConcept$Kd), PROPS.name$MnvL);
    }
    if (SNodeOperations.isInstanceOf(expected, CONCEPTS.INamedConcept$Kd)) {
      EXPECTED = SPropertyOperations.getString(SNodeOperations.cast(expected, CONCEPTS.INamedConcept$Kd), PROPS.name$MnvL);
    }
  }
  private static String check_4wac44_a0a0a0a0e0nb(SReferenceLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a0a0f0nb(SReferenceLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a0a0d0h0nb(SReferenceLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a0a0e0h0nb(SReferenceLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a3a14(SContainmentLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a5a14(SContainmentLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a0a0a3a34(SContainmentLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a0a0a4a34(SContainmentLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a0a0a5a5a34(SContainmentLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_4wac44_a0a0a0a0a6a5a34(SContainmentLink checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept IgnorePropertiesAnnotation$zD = MetaAdapterFactory.getConcept(0xf47b95d45e734c04L, 0x920418076950153bL, 0x57baa3713191a033L, "de.itemis.mps.compare.structure.IgnorePropertiesAnnotation");
    /*package*/ static final SConcept PropertyDeclaration$1S = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, "jetbrains.mps.lang.structure.structure.PropertyDeclaration");
    /*package*/ static final SConcept LinkDeclaration$1p = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, "jetbrains.mps.lang.structure.structure.LinkDeclaration");
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
  }

  private static final class PROPS {
    /*package*/ static final SProperty ignoreAllProperties$Iy7A = MetaAdapterFactory.getProperty(0xf47b95d45e734c04L, 0x920418076950153bL, 0x57baa3713191a033L, 0x57baa3713191a2cbL, "ignoreAllProperties");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty ignoreChildren$IyOD = MetaAdapterFactory.getProperty(0xf47b95d45e734c04L, 0x920418076950153bL, 0x57baa3713191a033L, 0x57baa3713191a2ceL, "ignoreChildren");
    /*package*/ static final SProperty metaClass$PeKc = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, "metaClass");
    /*package*/ static final SProperty role$Nsjf = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, "role");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink refs$MUwr = MetaAdapterFactory.getContainmentLink(0xf47b95d45e734c04L, 0x920418076950153bL, 0x57baa3713191a033L, 0x57baa37131934095L, "refs");
    /*package*/ static final SReferenceLink ref$b10I = MetaAdapterFactory.getReferenceLink(0xf47b95d45e734c04L, 0x920418076950153bL, 0x57baa3713193410dL, 0x57baa3713193410eL, "ref");
  }
}

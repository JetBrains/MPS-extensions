package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Objects;
import java.util.Iterator;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public class PNode {

  private List<PNode> myChildren = ListSequence.fromList(new ArrayList<PNode>());
  @Nullable
  private IToken myToken;
  @Nullable
  private ISymbol mySymbol;
  @Nullable
  private IRule myRule;

  public PNode(IToken token, ISymbol symbol) {
    myToken = token;
    mySymbol = symbol;
  }

  public PNode(IRule rule) {
    myRule = rule;
  }

  public void setSymbol(ISymbol symbol) {
    mySymbol = symbol;
  }

  public void addChild(PNode pnode) {
    ListSequence.fromList(myChildren).addElement(pnode);
  }

  public IRule getRule() {
    return myRule;
  }

  public void setRule(IRule rule) {
    myRule = rule;
  }

  public ISymbol getSymbol() {
    return mySymbol;
  }

  public IToken getToken() {
    return myToken;
  }

  public List<PNode> getChildren() {
    return myChildren;
  }

  public SNode createSNode(IRecycledNodes recycledNodes) {
    return myRule.createSNode(this, recycledNodes);
  }

  @Override
  public String toString() {
    String result;
    if (myRule != null) {
      result = "Rule[" + myRule + "]";
    } else {
      result = "Symbol[" + mySymbol + ", " + myToken + "]";
    }
    if (ListSequence.fromList(myChildren).isNotEmpty()) {
      result += "{";
      boolean first = true;
      for (PNode child : ListSequence.fromList(myChildren)) {
        if (first) {
          first = false;
        } else {
          result += ", ";
        }
        result += child;
      }
      result += "}";
    }
    return result;
  }

  public boolean matches(PNode other) {
    if (!(Objects.equals(myRule, other.myRule))) {
      // If the 'definedForConcept' is the same, they have the same rule -> they are interchangeable
      if (!(Objects.equals(check_mpum1_a0b0a0cb_0(myRule), check_mpum1_a0b0a0cb(other.myRule)))) {
        return false;
      }
    }
    if (!(Objects.equals(mySymbol, other.mySymbol))) {
      return false;
    }
    if (!(Objects.equals(myToken, other.myToken))) {
      return false;
    }
    if (!(Objects.equals(ListSequence.fromList(myChildren).count(), ListSequence.fromList(other.myChildren).count()))) {
      return false;
    }
    {
      Iterator<PNode> child_it = ListSequence.fromList(myChildren).iterator();
      Iterator<PNode> otherChild_it = ListSequence.fromList(other.myChildren).iterator();
      PNode child_var;
      PNode otherChild_var;
      while (child_it.hasNext() && otherChild_it.hasNext()) {
        child_var = child_it.next();
        otherChild_var = otherChild_it.next();
        if (!(child_var.matches(otherChild_var))) {
          return false;
        }
      }
    }

    return true;
  }
  private static SAbstractConcept check_mpum1_a0b0a0cb(IRule checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDefinedForConcept();
    }
    return null;
  }
  private static SAbstractConcept check_mpum1_a0b0a0cb_0(IRule checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getDefinedForConcept();
    }
    return null;
  }
}

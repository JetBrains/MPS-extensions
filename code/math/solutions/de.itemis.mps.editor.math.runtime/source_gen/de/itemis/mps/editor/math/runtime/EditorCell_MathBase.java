package de.itemis.mps.editor.math.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.List;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.nodeEditor.sidetransform.EditorCell_STHint;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Color;
import com.intellij.ui.JBColor;

public abstract class EditorCell_MathBase extends EditorCell_Collection {

  private double[] myChildScales;
  private List<IMathSymbol> mySymbols;
  private boolean myShowEndCells = true;

  public EditorCell_MathBase(EditorContext context, SNode snode, MathCellLayout layout) {
    this(context, snode, layout, new double[0], ListSequence.fromList(new ArrayList<IMathSymbol>()));
  }

  public EditorCell_MathBase(EditorContext context, SNode snode, MathCellLayout layout, double[] childScales, List<IMathSymbol> symbols) {
    super(context, snode, layout, null);
    myChildScales = childScales;
    mySymbols = symbols;
    MathEditorActions.setActions(this);
  }

  public boolean showEndCells() {
    return myShowEndCells;
  }

  public void init() {
    myShowEndCells = getStyle().get(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.math", "side-tranformation-helper-cells"));

    if (myShowEndCells) {
      EditorCell_MathEnd leftEnd = new EditorCell_MathEnd(getContext(), getSNode(), false);
      EditorCell_MathEnd rightEnd = new EditorCell_MathEnd(getContext(), getSNode(), true);

      leftEnd.setCellId("leftEnd");
      rightEnd.setCellId("rightEnd");

      addEditorCellBefore(leftEnd, firstCell());
      addEditorCellAfter(rightEnd, lastCell());
    }

    int index = 0;
    for (EditorCell cell : Sequence.fromIterable(this)) {
      if (myShowEndCells && cell == firstCell()) {
        continue;
      }
      double scale = getScale(index);
      if (scale != 1.0) {
        cell.getStyle().set(StyleAttributes.FONT_SIZE, (int) Math.round(scale * MathUtil.getFontSize(this)));
      }
      index++;
    }

    init(getSNode(), getLayoutableChilds(true), new MathLayoutableCellAdapter(this, -getPaintOffsetX(), -getPaintOffsetY()), mySymbols);
  }

  protected void init(SNode node, List<MathLayoutableCell> childCells, MathLayoutableCell cell, List<IMathSymbol> symbols) {
  }

  public List<IMathSymbol> getSymbols() {
    return mySymbols;
  }

  public double getScale(int index) {
    if (index < myChildScales.length) {
      return myChildScales[index];
    } else {
      return 1.0;
    }
  }

  public List<MathLayoutableCell> getLayoutableChilds(boolean useTranslation) {
    final double translateX = (useTranslation ? -getPaintOffsetX() : 0.0);
    final double translateY = (useTranslation ? -getPaintOffsetY() : 0.0);
    return Sequence.fromIterable(Sequence.fromArray(getCells())).where((it) -> !(it instanceof EditorCell_MathEnd || it instanceof EditorCell_STHint)).select((it) -> (MathLayoutableCell) new MathLayoutableCellAdapter(it, translateX, translateY)).toList();
  }

  public EditorCell_MathEnd getLeftEndCell() {
    if (!(showEndCells())) {
      throw new IllegalStateException("side tranformation helper cells are disabled");
    }
    return (EditorCell_MathEnd) Sequence.fromIterable(Sequence.fromArray(getCells())).findFirst((it) -> it instanceof EditorCell_MathEnd);
  }

  public EditorCell_MathEnd getRightEndCell() {
    if (!(showEndCells())) {
      throw new IllegalStateException("side tranformation helper cells are disabled");
    }
    return (EditorCell_MathEnd) Sequence.fromIterable(Sequence.fromArray(getCells())).findLast((it) -> it instanceof EditorCell_MathEnd);
  }

  @Override
  public void paintContent(Graphics graphics, ParentSettings settings) {
    Graphics2D g2 = (Graphics2D) graphics.create();
    g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    Color foregroundColor = getStyle().get(StyleAttributes.TEXT_COLOR);
    g2.setColor((foregroundColor != null ? foregroundColor : JBColor.BLACK));
    g2.translate(getPaintOffsetX(), getPaintOffsetY());
    paint(g2, getLayoutableChilds(true), new MathLayoutableCellAdapter(this, -getPaintOffsetX(), -getPaintOffsetY()), mySymbols);
  }

  public double getPaintOffsetX() {
    if (myShowEndCells) {
      return getLeftEndCell().getX() + getLeftEndCell().getWidth() + 3;
    } else {
      return getX();
    }
  }

  public double getPaintOffsetY() {
    return getY();
  }

  protected abstract void paint(Graphics2D g, List<MathLayoutableCell> childCells, MathLayoutableCell cell, List<IMathSymbol> symbols);

  public double getLayoutCenterY() {
    return ((MathCellLayout) myCellLayout).getCenterY(this);
  }
}

package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import org.modelix.model.area.IArea;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConcept;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.IConceptReference;
import org.modelix.model.area.IAreaReference;
import java.util.Objects;
import org.modelix.model.api.INode;
import org.modelix.model.api.INodeReference;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.modelix.model.api.IBranch;
import kotlin.jvm.functions.Function0;
import org.modelix.model.area.IAreaListener;

public class DependencyTrackingArea implements IArea {

  private IArea area;

  public DependencyTrackingArea(IArea area) {
    this.area = area;
  }

  @Override
  public long getLockOrderingPriority() {
    return area.getLockOrderingPriority();
  }

  @Nullable
  @Override
  public IConcept resolveConcept(@NotNull IConceptReference reference) {
    return area.resolveConcept(reference);
  }

  @NotNull
  @Override
  public IAreaReference getReference() {
    return new DependencyTrackingAreaReference(area.getReference());
  }

  @Nullable
  @Override
  public IArea resolveArea(@NotNull IAreaReference reference) {
    return (Objects.equals(reference, getReference()) ? this : area.resolveArea(reference));
  }

  @NotNull
  @Override
  public INode getRoot() {
    return DependencyTrackingNode.wrap(area.getRoot());
  }

  @Nullable
  @Override
  public INode resolveOriginalNode(@NotNull INodeReference reference) {
    return area.resolveOriginalNode(reference);
  }

  @Nullable
  @Override
  public INode resolveNode(@NotNull INodeReference ref) {
    return DependencyTrackingNode.wrap(area.resolveNode(ref));
  }

  @NotNull
  @Override
  public List<IArea> collectAreas() {
    return Sequence.fromIterable(Sequence.<IArea>singleton(this)).concat(ListSequence.fromList(area.collectAreas())).toList();
  }

  @Nullable
  @Override
  public IBranch resolveBranch(@NotNull String id) {
    return area.resolveBranch(id);
  }

  @Override
  public <T> T executeRead(@NotNull Function0<? extends T> f) {
    return area.executeRead(f);
  }

  @Override
  public <T> T executeWrite(@NotNull Function0<? extends T> f) {
    return area.executeWrite(f);
  }

  @Override
  public boolean canRead() {
    return area.canRead();
  }

  @Override
  public boolean canWrite() {
    return area.canWrite();
  }

  @Override
  public void addListener(@NotNull IAreaListener listener) {
    area.addListener(listener);
  }

  @Override
  public void removeListener(@NotNull IAreaListener listener) {
    area.removeListener(listener);
  }

  public static class DependencyTrackingAreaReference implements IAreaReference {
    private IAreaReference wrappedRef;

    public DependencyTrackingAreaReference(IAreaReference wrappedRef) {
      this.wrappedRef = wrappedRef;
    }

    public IAreaReference getWrappedRef() {
      return this.wrappedRef;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      DependencyTrackingAreaReference that = (DependencyTrackingAreaReference) o;
      if ((wrappedRef != null ? !(wrappedRef.equals(that.wrappedRef)) : that.wrappedRef != null)) {
        return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((wrappedRef != null ? ((Object) wrappedRef).hashCode() : 0));
      return result;
    }
  }
}

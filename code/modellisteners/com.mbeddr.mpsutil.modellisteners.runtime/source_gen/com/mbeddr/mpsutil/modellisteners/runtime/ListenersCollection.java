package com.mbeddr.mpsutil.modellisteners.runtime;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ModuleDeploymentListener;
import jetbrains.mps.logging.Logger;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.util.containers.MultiMap;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Collection;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.language.LanguageRegistry;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.runtime.ModuleDeploymentChange;
import jetbrains.mps.smodel.runtime.ModuleRuntime;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;

/**
 * Manages {@link com.mbeddr.mpsutil.modellisteners.runtime.IModelListener custom model listener} instances created from 
 * {@link com.mbeddr.mpsutil.modellisteners.runtime.IModelListenersDescriptor listener descriptors} from currently loaded modules. Updates the listeners and 
 * descriptors as the set of loaded modules changes.
 * 
 * An implementation of {@link org.jetbrains.mps.openapi.model.SModelListener } is registered for each project by
 * a project plugin to forward events to the currently available custom model listeners.
 */
public class ListenersCollection implements ModuleDeploymentListener {
  private static final Logger LOG = Logger.getLogger(ListenersCollection.class);
  private static final ListenersCollection INSTANCE = new ListenersCollection();

  public static ListenersCollection getInstance() {
    return INSTANCE;
  }

  private Map<SModuleReference, IModelListenersDescriptor> myDescriptors = MapSequence.fromMap(new HashMap<>());
  private MultiMap<SAbstractConcept, IModelListener> myListeners = new MultiMap<SAbstractConcept, IModelListener>() {
    @Override
    protected Collection<IModelListener> createCollection() {
      return new ArrayList<IModelListener>(1);
    }
  };

  private Set<IModelListener> myActiveListeners = SetSequence.fromSet(new HashSet<IModelListener>());

  public void install(@NotNull LanguageRegistry languageRegistry) {
    languageRegistry.addRegistryListener(this);

    // XXX here, I walk languages only, unlike original code that tried every module in a global repo, as I expect 'listeners' aspect to be part of a language module only.
    // FIXME please complete generation of the aspect instantiation as part of Language class (j.m.lang.descriptor, together with node<AspectDescritor> in @descriptor model)
    //     and use LR.withAvailableAspects() here, instead.
    languageRegistry.withModuleRuntime(languageRegistry.getAllLanguages().stream().map(SLanguage::getSourceModuleReference), this::loadModule);

    updateListeners();
  }

  public void uninstall(@NotNull LanguageRegistry languageRegistry) {
    languageRegistry.removeRegistryListener(this);
    MapSequence.fromMap(myDescriptors).clear();
  }


  @Override
  public void deploymentStateChanged(@NotNull ModuleDeploymentChange change) {
    // here we don't bother to check if loaded/unloaded module is a language, although would be very nice to be consistent with initial registration/withModuleRuntime call, above
    change.forEachRemoved(this::unloadModule);
    change.forEachReloaded(this::unloadModule);
    change.forEachReloaded(this::loadModule);
    change.forEachAdded(this::loadModule);
    updateListeners();
  }


  protected void loadModule(ModuleRuntime module) {
    IModelListenersDescriptor descriptor = getDescriptor(module);
    if (descriptor != null) {
      MapSequence.fromMap(myDescriptors).put(module.getSourceModule(), descriptor);
    }
  }

  private void unloadModule(ModuleRuntime module) {
    MapSequence.fromMap(myDescriptors).removeKey(module.getSourceModule());
  }

  public void updateListeners() {
    myListeners.clear();
    for (IModelListenersDescriptor descriptor : Sequence.fromIterable(MapSequence.fromMap(myDescriptors).values())) {
      for (IModelListener listener : Sequence.fromIterable(descriptor.getListeners())) {
        myListeners.putValue(listener.getParentConcept(), listener);
      }
    }
  }

  protected IModelListenersDescriptor getDescriptor(ModuleRuntime module) {
    String className = ListenersAspect.getName(module.getSourceModule()) + "." + IModelListenersDescriptor.CLASS_NAME;
    try {
      Class<?> descriptorClass;
      try {
        descriptorClass = module.getOwnClass(className);
      } catch (ClassNotFoundException cnfe) {
        return null;
      }

      return descriptorClass.asSubclass(IModelListenersDescriptor.class).getDeclaredConstructor().newInstance();
    } catch (Exception ex) {
      if (LOG.isWarningLevel()) {
        LOG.warning("Error loading model listeners descriptor from module " + module.getSourceModule().getModuleName(), ex);
      }
      return null;
    }
  }

  public <ListenerType extends IModelListener> void forwardEvent(SAbstractConcept affectedConcept, Class<ListenerType> listenerType, IForwarder<ListenerType> forwarder) {
    if (affectedConcept == null) {
      return;
    }
    for (SAbstractConcept concept : ListSequence.fromList(SConceptOperations.getAllSuperConcepts(affectedConcept, true))) {
      for (IModelListener listener : CollectionSequence.fromCollection(myListeners.get(concept))) {
        if (listenerType.isInstance(listener)) {
          forwardSafe(forwarder, (ListenerType) listener);
        }
      }
    }
  }

  protected <ListenerType extends IModelListener> void forwardSafe(IForwarder<ListenerType> forwarder, ListenerType listener) {
    // prevent endless recursions caused by listeners producing events they listen on

    if (SetSequence.fromSet(myActiveListeners).contains(listener)) {
      return;
    }
    try {
      SetSequence.fromSet(myActiveListeners).addElement(listener);
      forwarder.forward((ListenerType) listener);
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error(String.format("Error in model listener for concept %s", listener.getParentConcept().getQualifiedName()), ex);
      }
    } finally {
      SetSequence.fromSet(myActiveListeners).removeElement(listener);
    }
  }

}

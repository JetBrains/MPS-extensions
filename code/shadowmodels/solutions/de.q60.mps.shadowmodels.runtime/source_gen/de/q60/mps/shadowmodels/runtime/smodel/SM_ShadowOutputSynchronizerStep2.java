package de.q60.mps.shadowmodels.runtime.smodel;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import de.q60.mps.shadowmodels.runtime.util.UserObjectKey;
import org.modelix.model.api.INode;
import jetbrains.mps.extapi.module.SRepositoryExt;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.MPSModuleOwner;
import java.util.Map;
import org.modelix.model.api.INodeReference;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.google.common.collect.SetMultimap;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.google.common.collect.MultimapBuilder;
import org.modelix.model.api.ITree;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PTree;
import org.jetbrains.mps.openapi.module.SRepository;
import org.modelix.model.api.IBranch;
import org.modelix.model.api.ITransaction;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_ITreeChangeVisitor;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import de.q60.mps.shadowmodels.runtime.model.persistent.SM_PNodeAdapter;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import kotlin.Unit;
import javax.swing.SwingUtilities;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import de.q60.mps.shadowmodels.runtime.util.IdShortener;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.model.ModelDeleteHelper;
import de.q60.mps.logging.runtime.ShadowLogging;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.ModelImports;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class SM_ShadowOutputSynchronizerStep2 {
  private static final Logger LOG = Logger.getLogger(SM_ShadowOutputSynchronizerStep2.class);
  private static final String INPUT_NODE_KEY = SM_ShadowOutputSynchronizerStep2.class.getName() + ".INPUT";
  private static final UserObjectKey<INode> INPUT_NODE_UOKEY = new UserObjectKey<INode>("inputNode");

  private SRepositoryExt repository;
  private Set<SM_ShadowModule> createdModules = SetSequence.fromSet(new HashSet<SM_ShadowModule>());
  private MPSModuleOwner moduleOwner = new MPSModuleOwner() {
    public boolean isHidden() {
      return false;
    }
  };
  private Map<INodeReference, SNode> input2output = MapSequence.fromMap(new HashMap<INodeReference, SNode>());
  private SetMultimap<SAbstractConcept, SNode> reusableNodes = MultimapBuilder.hashKeys().hashSetValues().<SAbstractConcept,SNode>build();
  private ITree loadedTree = SM_PTree.EMPTY;

  public SM_ShadowOutputSynchronizerStep2(SRepository repository) {
    this.repository = (SRepositoryExt) repository;
  }

  public void update(final IBranch branch) {
    branch.runRead(() -> {
      ITransaction t = branch.getTransaction();
      ITree newTree = t.getTree();
      final Set<Long> changedNodes = SetSequence.fromSet(new HashSet<Long>());
      Set<Long> removedNodes = SetSequence.fromSet(new HashSet<Long>());
      Set<Long> addedNodes = SetSequence.fromSet(new HashSet<Long>());
      newTree.visitChanges(loadedTree, new SM_ITreeChangeVisitor() {
        @Override
        public void containmentChanged(long nodeId) {
          // There will be a childrenChanged event for the parent
        }
        @Override
        public void childrenChanged(long nodeId, String role) {
          SetSequence.fromSet(changedNodes).addElement(nodeId);
        }
        @Override
        public void referenceChanged(long nodeId, String role) {
          SetSequence.fromSet(changedNodes).addElement(nodeId);
        }
        @Override
        public void propertyChanged(long nodeId, String role) {
          SetSequence.fromSet(changedNodes).addElement(nodeId);
        }
        @Override
        public void userObjectChanged(long nodeId, Object key) {
        }
        @Override
        public void nodeRemoved(long nodeId) {
          if (isRegularNode(SConceptAdapter.unwrap(((SM_PTree) loadedTree).getConcept(nodeId)))) {
            SetSequence.fromSet(removedNodes).addElement(nodeId);
          }
        }
        @Override
        public void nodeAdded(long nodeId) {
          SetSequence.fromSet(changedNodes).addElement(nodeId);
          if (isRegularNode(SConceptAdapter.unwrap(((SM_PTree) newTree).getConcept(nodeId)))) {
            SetSequence.fromSet(addedNodes).addElement(nodeId);
          }
        }
        @Override
        public void nodeLoaded(long nodeId) {
          throw new RuntimeException("Output model shouldn't contain lazy nodes");
        }
        @Override
        public void nodeUnloaded(long nodeId) {
          throw new RuntimeException("Output model shouldn't contain lazy nodes");
        }
        public boolean isRegularNode(SAbstractConcept concept) {
          if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(concept), CONCEPTS.Repository$db)) {
            return false;
          }
          if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(concept), CONCEPTS.Module$4i)) {
            return false;
          }
          if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(concept), CONCEPTS.Model$2P)) {
            return false;
          }
          return true;
        }
      });

      for (long removedNode : removedNodes) {
        SNode reusableNode = MapSequence.fromMap(input2output).removeKey(new SM_PNodeAdapter(removedNode, branch).getReference());
        if ((reusableNode != null)) {
          boolean isRootNode = (SNodeOperations.getParent(reusableNode) == null) && SNodeOperations.getModel(reusableNode) != null;
          if (isRootNode) {
            reusableNodes.put(SNodeOperations.getConcept(reusableNode), reusableNode);
          }
        }
      }

      for (long addedNode : addedNodes) {
        createNode(new SM_PNodeAdapter(addedNode, branch));
      }

      List<INode> changedModels = ListSequence.fromList(new ArrayList<INode>());
      List<INode> changedModules = ListSequence.fromList(new ArrayList<INode>());
      List<INode> changedRepositories = ListSequence.fromList(new ArrayList<INode>());
      Set<SModel> dirtyModelImports = SetSequence.fromSet(new HashSet<SModel>());
      Set<SModule> dirtyModuleImports = SetSequence.fromSet(new HashSet<SModule>());

      for (long changedNodeId : changedNodes) {
        if (changedNodeId == SM_PTree.ROOT_ID) {
          continue;
        }
        if (!(t.containsNode(changedNodeId))) {
          continue;
        }
        SM_PNodeAdapter changedNode = new SM_PNodeAdapter(changedNodeId, branch);
        SNode changedSNode = NodeToSNodeAdapter.wrap(changedNode);

        if (SNodeOperations.isInstanceOf(changedSNode, CONCEPTS.Model$2P)) {
          ListSequence.fromList(changedModels).addElement(changedNode);
        } else if (SNodeOperations.isInstanceOf(changedSNode, CONCEPTS.Module$4i)) {
          ListSequence.fromList(changedModules).addElement(changedNode);
        } else if (SNodeOperations.isInstanceOf(changedSNode, CONCEPTS.Repository$db)) {
          ListSequence.fromList(changedRepositories).addElement(changedNode);
        } else {
          SNode outputNode = getNode(changedNode);
          synchronizeNode(changedSNode, outputNode);
          if (outputNode.getModel() != null) {
            SetSequence.fromSet(dirtyModelImports).addElement(outputNode.getModel());
          }
        }
      }

      // Synchronize models and modules at the end because they need to know the imports
      for (INode changedModel : ListSequence.fromList(changedModels)) {
        if (changedModel.getParent() == null) {
          continue;
        }
        SModel outputModel = getOrCreateModel(getOrCreateModule(changedModel.getParent()), changedModel);
        synchronizeModel(SNodeOperations.cast(NodeToSNodeAdapter.wrap(changedModel), CONCEPTS.Model$2P), outputModel);
        SetSequence.fromSet(dirtyModelImports).addElement(outputModel);
      }
      for (INode changedModule : ListSequence.fromList(changedModules)) {
        SModule outputModule = getOrCreateModule(changedModule);
        synchronizeModule(SNodeOperations.cast(NodeToSNodeAdapter.wrap(changedModule), CONCEPTS.Module$4i), outputModule);
        SetSequence.fromSet(dirtyModuleImports).addElement(outputModule);
      }
      for (INode changedRepo : ListSequence.fromList(changedRepositories)) {
        synchronizeRepository(SNodeOperations.cast(NodeToSNodeAdapter.wrap(changedRepo), CONCEPTS.Repository$db), repository);
      }

      for (SModel model : SetSequence.fromSet(dirtyModelImports)) {
        updateModelImports(model);
        if (model.getModule() != null) {
          SetSequence.fromSet(dirtyModuleImports).addElement(model.getModule());
        }
      }
      for (SModule module : SetSequence.fromSet(dirtyModuleImports)) {
        updateModuleImports(module);
      }

      loadedTree = newTree;
      reusableNodes.clear();

      return Unit.INSTANCE;
    });
  }

  public void dispose() {
    SwingUtilities.invokeLater(() -> repository.getModelAccess().runWriteAction(() -> {
      for (SM_ShadowModule module : ListSequence.fromListWithValues(new ArrayList<SM_ShadowModule>(), createdModules)) {
        removeModule(module);
      }
    }));
  }

  public INode getInputNode(SNode outputNode) {
    return as_u8qr3j_a0a0r(outputNode.getUserObject(INPUT_NODE_KEY), INode.class);
  }

  public SNode getNode(INode input) {
    INodeReference ref = input.getReference();
    SNode output = MapSequence.fromMap(input2output).get(ref);
    if (output == null) {
      throw new RuntimeException("Output doesn't exist for " + input);
    }
    if (!(Objects.equals(output.getConcept(), SConceptAdapter.unwrap(input.getConcept())))) {
      throw new RuntimeException("Wrong concept " + output.getConcept() + ". Expected " + input.getConcept() + ". Node: " + input);
    }
    return output;
  }

  public SNode createNode(final INode input) {
    INodeReference ref = input.getReference();
    SNode output = MapSequence.fromMap(input2output).get(ref);
    if (output != null) {
      return output;
    }

    SAbstractConcept concept = SConceptAdapter.unwrap(input.getConcept());
    Iterable<SNode> candidates = reusableNodes.get(concept);
    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(concept), CONCEPTS.INamedConcept$Kd)) {
      candidates = Sequence.fromIterable(candidates).where((it) -> Objects.equals(SPropertyOperations.getString(SNodeOperations.cast(it, CONCEPTS.INamedConcept$Kd), PROPS.name$MnvL), SPropertyOperations.getString(SNodeOperations.cast(NodeToSNodeAdapter.wrap(input), CONCEPTS.INamedConcept$Kd), PROPS.name$MnvL)));
    }
    output = Sequence.fromIterable(candidates).first();
    if (output == null) {
      output = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(concept));
    } else {
      reusableNodes.remove(concept, output);
    }
    output.putUserObject(INPUT_NODE_KEY, input);
    MapSequence.fromMap(input2output).put(ref, output);
    return output;
  }

  public SModule getOrCreateModule(final INode input) {
    final Wrappers._T<String> name = new Wrappers._T<String>(input.getPropertyValue(PROPS.name$MnvL.getName()));
    if (name.value == null) {
      SNode sinput = NodeToSNodeAdapter.wrap(input);
      if (SNodeOperations.isInstanceOf(sinput, CONCEPTS.ErrorPlaceholder$Uv)) {
        name.value = "!ERR " + SPropertyOperations.getString(SNodeOperations.cast(sinput, CONCEPTS.ErrorPlaceholder$Uv), PROPS.message$clQk);
        while (name.value.endsWith(".")) {
          name.value = name.value.substring(0, name.value.length() - 1);
        }
      } else {
        name.value = IdShortener.shorten(input.getReference().toString());
      }
    }
    SModule module = SetSequence.fromSet(createdModules).findFirst((it) -> Objects.equals(it.getModuleName(), name.value) && Objects.equals(it.getUserObject(INPUT_NODE_UOKEY), input));
    if (module == null) {
      Iterable<SModule> modules = repository.getModules();
      final String id = input.getPropertyValue(PROPS.id$7MjP.getName());
      module = Sequence.fromIterable(modules).findFirst((it) -> Objects.equals(it.getModuleId().toString(), id));
    }
    if (module == null) {
      module = createModule(name.value);
      ((SM_ShadowModule) module).putUserObject(INPUT_NODE_UOKEY, input);
    }
    return module;
  }

  public SModel getOrCreateModel(SModule module, final INode input) {
    final Wrappers._T<String> name = new Wrappers._T<String>(input.getPropertyValue(PROPS.name$MnvL.getName()));
    if (name.value == null) {
      SNode sinput = NodeToSNodeAdapter.wrap(input);
      if (SNodeOperations.isInstanceOf(sinput, CONCEPTS.ErrorPlaceholder$Uv)) {
        name.value = "!ERR " + SPropertyOperations.getString(SNodeOperations.cast(sinput, CONCEPTS.ErrorPlaceholder$Uv), PROPS.message$clQk);
        while (name.value.endsWith(".")) {
          name.value = name.value.substring(0, name.value.length() - 1);
        }
      } else {
        name.value = IdShortener.shorten(input.getReference().toString());
      }
    }
    Iterable<SModel> models = module.getModels();
    SModel model = Sequence.fromIterable(models).ofType(SModel.class).findFirst((it) -> {
      if (!(Objects.equals(it.getName().getLongName(), name.value))) {
        return false;
      }
      if (it instanceof SM_ShadowModel) {
        return Objects.equals(((SM_ShadowModel) it).getUserObject(INPUT_NODE_UOKEY), input);
      }
      return true;
    });
    if (model == null) {
      if (module instanceof SM_ShadowModule) {
        model = createModel((SM_ShadowModule) module, name.value);
        ((SM_ShadowModel) model).putUserObject(INPUT_NODE_UOKEY, input);
      } else {
        Iterable<ModelRoot> modelRoots = module.getModelRoots();
        ModelRoot modelRoot = Sequence.fromIterable(modelRoots).where((it) -> it.canCreateModel(name.value)).first();
        if (modelRoot == null) {
          if (LOG.isErrorLevel()) {
            LOG.error("Can't create model " + name.value + " in module " + module.getModuleName() + "");
          }
          return null;
        }
        model = modelRoot.createModel(name.value);
      }
    }
    return model;
  }


  public void synchronizeRepository(SNode repositorySpec, SRepository repository) {
    checkDuplicateModuleIds(repositorySpec);
    List<SM_ShadowModule> expectedModules = ListSequence.fromList(SLinkOperations.getChildren(repositorySpec, LINKS.modules$jBPn)).select((it) -> getOrCreateModule(SNodeToNodeAdapter.wrap(it))).ofType(SM_ShadowModule.class).toList();
    List<SM_ShadowModule> modulesToRemove = SetSequence.fromSet(createdModules).subtract(ListSequence.fromList(expectedModules)).toList();
    List<SM_ShadowModule> modulesToAdd = ListSequence.fromList(expectedModules).subtract(SetSequence.fromSet(createdModules)).toList();
    if (ListSequence.fromList(modulesToAdd).isNotEmpty()) {
      // ShadowModules are added to the repository by createModule
      throw new RuntimeException("Modules expected to be in the repository: " + modulesToAdd);
    }
    ListSequence.fromList(modulesToRemove).visitAll((it) -> removeModule(it));
  }

  private void checkDuplicateModuleIds(SNode repositorySpec) {
    Set<String> moduleIds = SetSequence.fromSet(new HashSet<String>());
    for (String moduleId : ListSequence.fromList(SLinkOperations.getChildren(repositorySpec, LINKS.modules$jBPn)).select((it) -> SPropertyOperations.getString(it, PROPS.id$7MjP)).where((it) -> (it != null && it.length() > 0))) {
      if (SetSequence.fromSet(moduleIds).contains(moduleId)) {
        throw new RuntimeException("Duplicate output module ID " + moduleId);
      } else {
        SetSequence.fromSet(moduleIds).addElement(moduleId);
      }
    }
  }

  public void synchronizeModule(SNode moduleSpec, final SModule module) {
    List<SModel> expectedModels = ListSequence.fromList(SLinkOperations.getChildren(moduleSpec, LINKS.models$h3QT)).select((it) -> getOrCreateModel(module, SNodeToNodeAdapter.wrap(it))).toList();
    List<SModel> existingModels = Sequence.fromIterable(((Iterable<SModel>) module.getModels())).toList();
    List<SModel> modelsToRemove = ListSequence.fromList(existingModels).subtract(ListSequence.fromList(expectedModels)).toList();
    List<SModel> modelsToAdd = ListSequence.fromList(expectedModels).subtract(ListSequence.fromList(existingModels)).toList();
    if (ListSequence.fromList(modelsToAdd).isNotEmpty()) {
      // ShadowModels are added to the module by createModel
      throw new RuntimeException("Model expected to be added to module already: " + modelsToAdd);
    }
    ListSequence.fromList(modelsToRemove).visitAll((it) -> removeModel(it));
  }

  protected void updateModuleImports(SModule module) {
    Iterable<SModuleReference> moduleRefs = Sequence.fromIterable(Sequence.<SModule>singleton(module)).translate((it) -> it.getModels()).ofType(SM_ShadowModel.class).translate((it) -> it.getModelImports()).select(new _FunctionTypes._return_P1_E0<SModuleReference, SModelReference>() {
      public SModuleReference invoke(SModelReference modelRef) {
        SModuleReference moduleRef = modelRef.getModuleReference();
        if (moduleRef != null) {
          return moduleRef;
        }
        SModel model = modelRef.resolve(repository);
        if (model != null) {
          SModule module = model.getModule();
          if (module != null) {
            return module.getModuleReference();
          }
        }
        return null;
      }
    }).where((it) -> it != null).distinct();
    for (SModuleReference moduleRef : Sequence.fromIterable(moduleRefs)) {
      ((AbstractModule) module).addDependency(moduleRef, false);
    }
  }

  public void synchronizeModel(SNode modelSpec, final SModel model) {
    Set<SNode> expectedRootNodes = SetSequence.fromSetWithValues(new HashSet<SNode>(), ListSequence.fromList(SLinkOperations.getChildren(modelSpec, LINKS.rootNodes$jxXY)).select((it) -> getNode(SNodeToNodeAdapter.wrap(it))));
    Set<SNode> existingRootNodes = SetSequence.fromSetWithValues(new HashSet<SNode>(), model.getRootNodes());
    SetSequence.fromSet(existingRootNodes).subtract(SetSequence.fromSet(expectedRootNodes)).visitAll((it) -> model.removeRootNode(it));
    SetSequence.fromSet(expectedRootNodes).subtract(SetSequence.fromSet(existingRootNodes)).visitAll((it) -> model.addRootNode(it));
  }

  protected void updateModelImports(SModel model) {
    Imports imports = Imports.EMPTY;
    for (SNode root : Sequence.fromIterable(model.getRootNodes())) {
      imports = imports.merge(Imports.get(root));
    }
    imports.apply(model);
  }

  public SModel getOutputModel(SNode inputNode) {
    SNode inputModel = SNodeOperations.getNodeAncestor(inputNode, CONCEPTS.Model$2P, false, false);
    if ((inputModel == null)) {
      throw new RuntimeException("Not inside a model: " + SNodeOperations.present(inputNode));
    }
    SNode inputModule = SNodeOperations.getNodeAncestor(inputModel, CONCEPTS.Module$4i, false, false);
    if ((inputModule == null)) {
      throw new RuntimeException("Not inside a module: " + SNodeOperations.present(inputNode));
    }
    return getOrCreateModel(getOrCreateModule(SNodeToNodeAdapter.wrap(inputModule)), SNodeToNodeAdapter.wrap(inputModel));
  }

  public SNode synchronizeNode(SNode input, SNode output) {
    try {
      Imports.addLanguage(output, output.getConcept());

      for (SProperty property : CollectionSequence.fromCollection(input.getConcept().getProperties())) {
        String newVal = input.getProperty(property);
        if (!(Objects.equals(output.getProperty(property), newVal))) {
          output.setProperty(property, newVal);
        }
      }

      for (SReferenceLink link : CollectionSequence.fromCollection(input.getConcept().getReferenceLinks())) {
        SNode target_ = input.getReferenceTarget(link);
        SNode originalTarget = SM_SNodeAPI.getOriginalNode(target_);

        if (originalTarget != null) {
          output.setReferenceTarget(link, originalTarget);
          Imports.addModel(output, originalTarget);
        } else {
          INode target = SNodeToNodeAdapter.wrap(target_);
          SNode newTarget = (target == null ? null : getNode(target));
          if (!(Objects.equals(output.getReferenceTarget(link), newTarget))) {
            output.setReferenceTarget(link, newTarget);
          }
          if (target_ != null) {
            Imports.addModel(output, getOutputModel(target_));
          }
        }
      }

      for (SContainmentLink link : CollectionSequence.fromCollection(input.getConcept().getContainmentLinks())) {
        synchronizeChildren(input, output, link);
      }

      for (SNode ancestor = output.getParent(), child = output; ancestor != null; child = ancestor, ancestor = ancestor.getParent()) {
        Imports.get(ancestor).merge(Imports.get(child)).put(ancestor);
      }

      return output;
    } catch (Exception ex) {
      return createErrorPlaceholder(ex);
    }
  }

  public void synchronizeChildren(SNode inputParent, final SNode outputParent, final SContainmentLink link) {
    List<SNode> inputChildren = Sequence.fromIterable(((Iterable<SNode>) inputParent.getChildren(link))).toList();
    List<SNode> expectedOutputChildren = ListSequence.fromList(inputChildren).select((it) -> getNode(SNodeToNodeAdapter.wrap(it))).toList();
    List<SNode> existingOutputChildren = Sequence.fromIterable(((Iterable<SNode>) outputParent.getChildren(link))).toList();

    if (!(Objects.equals(existingOutputChildren, expectedOutputChildren))) {
      ListSequence.fromList(existingOutputChildren).visitAll((it) -> outputParent.removeChild(it));
      ListSequence.fromList(expectedOutputChildren).visitAll((it) -> {
        if (it.getParent() != null) {
          it.getParent().removeChild(it);
        }
        if (it.getModel() != null) {
          it.getModel().removeRootNode(it);
        }
        outputParent.insertChildBefore(link, it, null);
        Imports.get(outputParent).merge(Imports.get(it)).put(outputParent);
      });
    }
  }

  protected SM_ShadowModule createModule(String name) {
    SM_ShadowModule module = new SM_ShadowModule(name);
    repository.registerModule(module, moduleOwner);
    SetSequence.fromSet(createdModules).addElement(module);
    return module;
  }

  protected SM_ShadowModel createModel(SM_ShadowModule parent, String name) {
    SM_ShadowModel model = new SM_ShadowModel(parent, name);
    parent.registerModel(model);
    return model;
  }

  protected void removeModule(SM_ShadowModule module) {
    if (module.getRepository() == null) {
      return;
    }
    repository.unregisterModule(module, moduleOwner);
    SetSequence.fromSet(createdModules).removeElement(module);
  }

  protected void removeModel(SModel model) {
    SModule module = model.getModule();
    if (module == null) {
      return;
    }
    if (module instanceof SM_ShadowModule) {
      ((SM_ShadowModule) module).unregisterModel((SModelBase) model);
    } else {
      new ModelDeleteHelper(model).delete();
    }
  }

  protected SNode createErrorPlaceholder(Exception ex) {
    ShadowLogging.logError(ex);
    SNode placeholder = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xbf7bc3bb11d42e4L, 0xb16093d72af96397L, 0x765fd2d37142cde7L, "de.q60.mps.shadowmodels.runtimelang.structure.ErrorPlaceholder"));
    SPropertyOperations.assign(placeholder, PROPS.message$clQk, ex.getMessage());

    StringWriter writer = new StringWriter();
    ex.printStackTrace(new PrintWriter(writer));
    SPropertyOperations.assign(placeholder, PROPS.stacktrace$nbHX, writer.toString());

    return placeholder;
  }

  protected static class Imports {
    private static final String USER_OBJECT_KEY = Imports.class.getName();
    public static Imports EMPTY = new Imports(Sequence.fromIterable(Collections.<SLanguage>emptyList()), Sequence.fromIterable(Collections.<SModelReference>emptyList()));

    private final Set<SLanguage> languages;
    private final Set<SModelReference> models;

    public Imports(Iterable<SLanguage> languages, Iterable<SModelReference> models) {
      this.languages = SetSequence.fromSetWithValues(new HashSet<SLanguage>(), languages);
      this.models = SetSequence.fromSetWithValues(new HashSet<SModelReference>(), models);
    }

    protected void apply(SModel model) {
      SModelReference ownRef = model.getReference();
      for (SLanguage lang : SetSequence.fromSet(languages)) {
        new ModelImports(model).addUsedLanguage(lang);
      }
      for (SModelReference referencedModel : SetSequence.fromSet(models)) {
        if (Objects.equals(referencedModel, ownRef)) {
          continue;
        }
        new ModelImports(model).addModelImport(referencedModel);
      }
    }

    protected Imports with(SLanguage lang) {
      if (SetSequence.fromSet(languages).contains(lang)) {
        return this;
      }
      return new Imports(SetSequence.fromSet(languages).concat(Sequence.fromIterable(Sequence.<SLanguage>singleton(lang))), models);
    }

    protected Imports with(SModelReference model) {
      if (SetSequence.fromSet(models).contains(model)) {
        return this;
      }
      return new Imports(languages, SetSequence.fromSet(models).concat(Sequence.fromIterable(Sequence.<SModelReference>singleton(model))));
    }

    protected Imports merge(Imports other) {
      Imports result = this;
      for (SLanguage lang : SetSequence.fromSet(other.languages)) {
        result = result.with(lang);
      }
      for (SModelReference model : SetSequence.fromSet(other.models)) {
        result = result.with(model);
      }
      return result;
    }

    protected void put(SNode snode) {
      if (equals(get(snode))) {
        return;
      }
      snode.putUserObject(USER_OBJECT_KEY, this);
    }

    protected static Imports get(SNode snode) {
      Imports imports = as_u8qr3j_a0a0a81ec(snode.getUserObject(USER_OBJECT_KEY), Imports.class);
      return (imports != null ? imports : EMPTY);
    }

    protected static void addLanguage(SNode owner, SAbstractConcept concept) {
      addLanguage(owner, concept.getLanguage());
    }

    protected static void addLanguage(SNode owner, SLanguage lang) {
      get(owner).with(lang).put(owner);
    }

    protected static void addModel(SNode owner, SNode targetNode) {
      if (targetNode == null) {
        return;
      }
      addModel(owner, targetNode.getModel());
    }

    protected static void addModel(SNode owner, SModel model) {
      if (model == null) {
        return;
      }
      get(owner).with(model.getReference()).put(owner);
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }

      Imports that = (Imports) o;
      if ((languages != null ? !(((Object) languages).equals(that.languages)) : that.languages != null)) {
        return false;
      }
      if ((models != null ? !(((Object) models).equals(that.models)) : that.models != null)) {
        return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      int result = 0;
      result = 31 * result + ((languages != null ? ((Object) languages).hashCode() : 0));
      result = 31 * result + ((models != null ? ((Object) models).hashCode() : 0));
      return result;
    }
    private static <T> T as_u8qr3j_a0a0a81ec(Object o, Class<T> type) {
      return (type.isInstance(o) ? (T) o : null);
    }
  }
  private static <T> T as_u8qr3j_a0a0r(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Repository$db = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, "org.modelix.model.repositoryconcepts.structure.Repository");
    /*package*/ static final SConcept Module$4i = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, "org.modelix.model.repositoryconcepts.structure.Module");
    /*package*/ static final SConcept Model$2P = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, "org.modelix.model.repositoryconcepts.structure.Model");
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
    /*package*/ static final SConcept ErrorPlaceholder$Uv = MetaAdapterFactory.getConcept(0xbf7bc3bb11d42e4L, 0xb16093d72af96397L, 0x765fd2d37142cde7L, "de.q60.mps.shadowmodels.runtimelang.structure.ErrorPlaceholder");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty message$clQk = MetaAdapterFactory.getProperty(0xbf7bc3bb11d42e4L, 0xb16093d72af96397L, 0x765fd2d37142cde7L, 0x765fd2d37142cde8L, "message");
    /*package*/ static final SProperty id$7MjP = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, 0x3aa34013f2a802e0L, "id");
    /*package*/ static final SProperty stacktrace$nbHX = MetaAdapterFactory.getProperty(0xbf7bc3bb11d42e4L, 0xb16093d72af96397L, 0x765fd2d37142cde7L, 0x765fd2d371498509L, "stacktrace");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink modules$jBPn = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, 0x69652614fd1c517L, "modules");
    /*package*/ static final SContainmentLink models$h3QT = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, 0x69652614fd1c512L, "models");
    /*package*/ static final SContainmentLink rootNodes$jxXY = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x69652614fd1c514L, "rootNodes");
  }
}

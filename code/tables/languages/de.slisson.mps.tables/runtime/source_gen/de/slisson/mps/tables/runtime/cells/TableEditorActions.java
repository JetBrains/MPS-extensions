package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.CellAction;
import java.util.HashMap;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.CellSide;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.nodeEditor.actions.CursorPositionTracker;
import de.slisson.mps.hacks.editor.EditorComponentHacks;
import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.nodeEditor.cells.APICellAdapter;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.selection.Selection;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.CellConditions;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.nodeEditor.selection.NodeRangeSelection;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.cells.CellFinderUtil;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.Objects;
import jetbrains.mps.lang.editor.enumMigration._Layout_Constraints_Enum_MigrationUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import java.awt.Rectangle;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class TableEditorActions {
  private static Map<CellActionType, CellAction> myActionMap = new HashMap<CellActionType, CellAction>();
  private static Condition<EditorCell> EDITABLE_OR_NEXT_CELL = new EditableOrNextPreviousCell(true);
  private static Condition<EditorCell> EDITABLE_OR_PREV_CELL = new EditableOrNextPreviousCell(false);

  static {
    TableEditorActions.myActionMap.put(CellActionType.LEFT, new MoveLeft());
    TableEditorActions.myActionMap.put(CellActionType.RIGHT, new MoveRight());
    TableEditorActions.myActionMap.put(CellActionType.NEXT, new MoveNext());
    TableEditorActions.myActionMap.put(CellActionType.PREV, new MovePrev());
    TableEditorActions.myActionMap.put(CellActionType.LOCAL_HOME, new MoveLocal(true));
    TableEditorActions.myActionMap.put(CellActionType.LOCAL_END, new MoveLocal(false));
    TableEditorActions.myActionMap.put(CellActionType.ROOT_HOME, new MoveToRoot(true));
    TableEditorActions.myActionMap.put(CellActionType.ROOT_END, new MoveToRoot(false));
    TableEditorActions.myActionMap.put(CellActionType.HOME, new MoveHome());
    TableEditorActions.myActionMap.put(CellActionType.END, new MoveEnd());
    TableEditorActions.myActionMap.put(CellActionType.PAGE_DOWN, new MovePageUp());
    TableEditorActions.myActionMap.put(CellActionType.PAGE_UP, new MovePageDown());
    TableEditorActions.myActionMap.put(CellActionType.SELECT_UP, new SelectUp());
    TableEditorActions.myActionMap.put(CellActionType.SELECT_DOWN, new SelectDown());
    TableEditorActions.myActionMap.put(CellActionType.SELECT_RIGHT, new SideSelect(CellSide.RIGHT));
    TableEditorActions.myActionMap.put(CellActionType.SELECT_LEFT, new SideSelect(CellSide.LEFT));
    TableEditorActions.myActionMap.put(CellActionType.SELECT_NEXT, new EnlargeSelection(true));
    TableEditorActions.myActionMap.put(CellActionType.SELECT_PREVIOUS, new EnlargeSelection(false));
    TableEditorActions.myActionMap.put(CellActionType.COMPLETE, new Complete());
  }

  private TableEditorActions() {
  }

  public static void setActions(EditorCell cell, EditorContext editorContext) {
    for (Map.Entry<CellActionType, CellAction> entry : SetSequence.fromSet(TableEditorActions.myActionMap.entrySet())) {
      if (cell.getAction(entry.getKey()) == null) {
        cell.setAction(entry.getKey(), entry.getValue());
      }
    }
    CursorPositionTracker cursorPositionTracker = EditorComponentHacks.getPositionTracker(editorContext.getEditorComponent());
    if (cell.getAction(CellActionType.UP) == null) {
      cell.setAction(CellActionType.UP, new MoveUp(cursorPositionTracker));
    }
    if (cell.getAction(CellActionType.DOWN) == null) {
      cell.setAction(CellActionType.DOWN, new MoveDown(cursorPositionTracker));
    }
  }

  public static abstract class NavigationAction extends AbstractCellAction {
    public NavigationAction() {
    }
    @Override
    public boolean executeInCommand() {
      return false;
    }
  }
  public static abstract class HorizontalNavigationAction extends NavigationAction {
    public EditorCell getNextAlignedLeaf(final EditorCell cell) {
      return CellTraversalUtil.getNextLeaf(cell, (EditorCell c) -> c.isSelectable() && !(GeometryUtil.isAbove(cell, c)) && GeometryUtil.isLeftToRight(cell, c));
    }
    public EditorCell getPrevAlignedLeaf(final EditorCell cell) {
      return CellTraversalUtil.getPrevLeaf(cell, (EditorCell c) -> c.isSelectable() && !(GeometryUtil.isAbove(cell, c)) && GeometryUtil.isLeftToRight(c, cell));
    }
  }
  public static class MoveLocal extends NavigationAction {
    private boolean myHome;
    public MoveLocal(boolean home) {
      myHome = home;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return findTarget(context.getEditorComponent().getSelectionManager()) != null;
    }
    @Override
    public void execute(EditorContext context) {
      SelectionManager selectionManager = context.getEditorComponent().getSelectionManager();
      EditorCell cell = findTarget(selectionManager);
      selectionManager.setSelection(cell);
      if (APICellAdapter.isPunctuationLayout(cell) && (cell instanceof EditorCell_Label) && ((EditorCell_Label) cell).isCaretPositionAllowed(1)) {
        ((EditorCell_Label) cell).setCaretPosition(1);
      } else {
        cell.home();
      }
    }
    private EditorCell findTarget(SelectionManager selectionManager) {
      Selection selection = selectionManager.getSelection();
      if (selection == null) {
        return null;
      }
      List<EditorCell> selectedCells = selection.getSelectedCells();
      EditorCell cell = (myHome ? selectedCells.get(0) : selectedCells.get(selectedCells.size() - 1));
      EditorCell leaf = (myHome ? TableTraversalUtil.getLeafToLeft(cell, CellConditions.SELECTABLE) : TableTraversalUtil.getLeafToRight(cell, CellConditions.SELECTABLE));
      if (leaf != null) {
        return leaf;
      }
      return (myHome ? TableTraversalUtil.getPrevLeaf(cell, CellConditions.SELECTABLE) : TableTraversalUtil.getNextLeaf(cell, CellConditions.SELECTABLE));
    }
  }
  public static class MoveLeft extends NavigationAction {
    public MoveLeft() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      return selection != null && findTarget(selection) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      EditorCell target = findTarget(selection);
      context.getEditorComponent().changeSelection(target);
      if (target instanceof EditorCell_Label) {
        EditorCell_Label label = (EditorCell_Label) target;
        label.end();
      }
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getEditorComponent().getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getFirstCell();
      }
      return null;
    }
    private EditorCell findTarget(EditorCell cell) {
      return TableTraversalUtil.getPrevLeaf(cell, CellConditions.SELECTABLE);
    }
  }
  public static class MoveToRoot extends NavigationAction {
    private boolean myHome;
    public MoveToRoot(boolean home) {
      myHome = home;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return findTarget(context.getEditorComponent().getSelectionManager()) != null;
    }
    @Override
    public void execute(EditorContext context) {
      SelectionManager selectionManager = context.getEditorComponent().getSelectionManager();
      selectionManager.setSelection(findTarget(selectionManager));
      selectionManager.getSelection().ensureVisible();
    }
    private EditorCell findTarget(SelectionManager selectionManager) {
      Selection selection = selectionManager.getSelection();
      if (selection == null) {
        return null;
      }
      EditorCell cell = selection.getSelectedCells().get(0);
      while (cell.getParent() != null) {
        cell = cell.getParent();
      }
      if (cell instanceof EditorCell_Collection) {
        return (myHome ? CellFinderUtil.findFirstSelectableLeaf(cell) : CellFinderUtil.findLastSelectableLeaf(cell));
      }
      return cell;
    }
  }
  public static class MoveHome extends HorizontalNavigationAction {
    public MoveHome() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return findTarget(((EditorComponent) context.getEditorComponent())) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorComponent editorComponent = ((EditorComponent) context.getEditorComponent());
      EditorCell target = findTarget(editorComponent);
      if (target instanceof EditorCell_Label) {
        EditorCell_Label label = (EditorCell_Label) target;
        label.home();
      }
      editorComponent.changeSelection(target);
    }
    private EditorCell findTarget(EditorComponent editorComponent) {
      Selection selection = editorComponent.getSelectionManager().getSelection();
      if (selection == null) {
        return null;
      }
      List<EditorCell> selectedCells = selection.getSelectedCells();
      EditorCell cell = selectedCells.get(0);
      while (getPrevAlignedLeaf(cell) != null) {
        cell = getPrevAlignedLeaf(cell);
      }
      return cell;
    }
  }
  public static class MoveEnd extends HorizontalNavigationAction {
    public MoveEnd() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return findTarget(((EditorComponent) context.getEditorComponent())) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorComponent editorComponent = ((EditorComponent) context.getEditorComponent());
      EditorCell target = findTarget(editorComponent);
      if (target instanceof EditorCell_Label) {
        EditorCell_Label label = (EditorCell_Label) target;
        label.end();
      }
      editorComponent.changeSelection(target);
    }
    private EditorCell findTarget(EditorComponent editorComponent) {
      Selection selection = editorComponent.getSelectionManager().getSelection();
      if (selection == null) {
        return null;
      }
      List<EditorCell> selectedCells = selection.getSelectedCells();
      EditorCell cell = selectedCells.get(selectedCells.size() - 1);
      while (getNextAlignedLeaf(cell) != null) {
        cell = getNextAlignedLeaf(cell);
      }
      return cell;
    }
  }
  public static class MoveRight extends NavigationAction {
    public MoveRight() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      return selection != null && findTarget(selection) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selection = getDeepestSelectedCell(context);
      EditorCell_Label target = findTarget(selection);
      context.getEditorComponent().changeSelection(target);
      if (Objects.equals(_Layout_Constraints_Enum_MigrationUtils.value(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x10901d9d75fL, "jetbrains.mps.lang.editor.structure._Layout_Constraints_Enum"), 0x10901d9d84bL, "punctuation")), target.getStyle().get(StyleAttributes.LAYOUT_CONSTRAINT)) && target.isCaretPositionAllowed(1)) {
        target.setCaretPosition(1);
      } else
      if (target instanceof EditorCell_Label) {
        EditorCell_Label label = target;
        label.home();
      }
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getEditorComponent().getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getLastCell();
      }
      return null;
    }
    private EditorCell_Label findTarget(EditorCell cell) {
      EditorCell toRight = TableTraversalUtil.getLeafToRight(cell, CellConditions.SELECTABLE);
      if (toRight instanceof EditorCell_Label) {
        return (EditorCell_Label) toRight;
      }
      EditorCell nextLeaf = TableTraversalUtil.getNextLeaf(cell, CellConditions.SELECTABLE);
      return (nextLeaf instanceof EditorCell_Label ? (EditorCell_Label) nextLeaf : null);
    }
  }
  public static class MoveUp extends NavigationAction {
    private final CursorPositionTracker myPositionTracker;
    public MoveUp(CursorPositionTracker positionTracker) {
      myPositionTracker = positionTracker;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      return selectedCell != null && selectedCell.getParent() != null && findTarget(selectedCell, selectedCell.getCaretX()) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      int caretX = (myPositionTracker.hasPosition() ? myPositionTracker.getPosition() : selectedCell.getCaretX());
      EditorCell target = findTarget(selectedCell, caretX);
      target.setCaretX(caretX);
      context.getEditorComponent().changeSelection(target);
      myPositionTracker.savePosition(caretX);
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getEditorComponent().getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getFirstCell();
      }
      return null;
    }
    private EditorCell findTarget(EditorCell cell, int caretX) {
      return TableTraversalUtil.getUpperInColumn(cell, CellConditions.SELECTABLE, caretX);
    }
  }
  public static class MoveDown extends NavigationAction {
    private final CursorPositionTracker myPositionTracker;
    public MoveDown(CursorPositionTracker positionTracker) {
      myPositionTracker = positionTracker;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      return selectedCell != null && findTarget(selectedCell, selectedCell.getCaretX()) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selectedCell = getDeepestSelectedCell(context);
      int caretX = (myPositionTracker.hasPosition() ? myPositionTracker.getPosition() : selectedCell.getCaretX());
      EditorCell target = findTarget(selectedCell, caretX);
      target.setCaretX(caretX);
      context.getEditorComponent().changeSelection(target);
      myPositionTracker.savePosition(caretX);
    }
    private EditorCell getDeepestSelectedCell(EditorContext context) {
      Selection deepestSelection = context.getSelectionManager().getDeepestSelection();
      if (deepestSelection instanceof SingularSelection) {
        return ((SingularSelection) deepestSelection).getEditorCell();
      } else
      if (deepestSelection instanceof NodeRangeSelection) {
        return ((NodeRangeSelection) deepestSelection).getLastCell();
      }
      return null;
    }
    private EditorCell findTarget(EditorCell cell, int caretX) {
      return TableTraversalUtil.getLowerInColumn(cell, CellConditions.SELECTABLE, caretX);
    }
  }
  public static class MoveNext extends NavigationAction {
    public MoveNext() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = ((EditorComponent) context.getEditorComponent()).getSelectedCell();
      return selection != null && TableTraversalUtil.getNextLeaf(selection, TableEditorActions.EDITABLE_OR_NEXT_CELL) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorComponent editorComponent = (EditorComponent) context.getEditorComponent();
      EditorCell selection = editorComponent.getSelectedCell();
      editorComponent.changeSelection(TableTraversalUtil.getNextLeaf(selection, TableEditorActions.EDITABLE_OR_NEXT_CELL));
    }
  }
  public static class MovePrev extends NavigationAction {
    public MovePrev() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = ((EditorComponent) context.getEditorComponent()).getSelectedCell();
      return selection != null && TableTraversalUtil.getPrevLeaf(selection, TableEditorActions.EDITABLE_OR_PREV_CELL) != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorComponent editorComponent = (EditorComponent) context.getEditorComponent();
      EditorCell selection = editorComponent.getSelectedCell();
      editorComponent.changeSelection(TableTraversalUtil.getPrevLeaf(selection, TableEditorActions.EDITABLE_OR_PREV_CELL));
    }
  }
  private static void navigatePage(EditorContext context, boolean isDown) {
    EditorComponent editor = (EditorComponent) context.getEditorComponent();
    EditorCell selection = editor.getSelectedCell();
    Rectangle rect = editor.getVisibleRect();
    int height = (int) rect.getHeight();
    height = (isDown ? height : -height);
    int caretX = selection.getCaretX();
    int y = selection.getY() + (selection.getHeight() / 2);
    int newY = y + height;
    EditorCell target = editor.findCellWeak(caretX, newY);
    if (target == null) {
      target = (isDown ? CellFinderUtil.findLastSelectableLeaf(editor.getRootCell()) : CellFinderUtil.findFirstSelectableLeaf(editor.getRootCell()));
      editor.changeSelection(target);
    } else {
      target.setCaretX(caretX);
      editor.changeSelection(target);
    }
  }
  public static class MovePageUp extends NavigationAction {
    public MovePageUp() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return true;
    }
    @Override
    public void execute(EditorContext context) {
      TableEditorActions.navigatePage(context, true);
    }
  }
  public static class MovePageDown extends NavigationAction {
    public MovePageDown() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return true;
    }
    @Override
    public void execute(EditorContext context) {
      TableEditorActions.navigatePage(context, false);
    }
  }
  public static class SelectUp extends NavigationAction {
    public SelectUp() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return findTarget(context.getEditorComponent().getSelectionManager()) != null;
    }
    @Override
    public void execute(EditorContext context) {
      SelectionManager selectionManager = context.getEditorComponent().getSelectionManager();
      EditorCell cell = findTarget(selectionManager);
      selectionManager.pushSelection(selectionManager.createSelection(cell));
      if (cell instanceof EditorCell_Label) {
        ((EditorCell_Label) cell).selectWordOrAll();
      }
    }
    private EditorCell findTarget(SelectionManager selectionManager) {
      Selection selection = selectionManager.getSelection();
      if (selection == null) {
        return null;
      }
      EditorCell cell = selection.getSelectedCells().get(0);
      if (cell instanceof EditorCell_Label && !(((EditorCell_Label) cell).isEverythingSelected())) {
        return cell;
      }
      if (cell.getParent() == null) {
        return null;
      }
      while (cell.getParent() != null && TableEditorActions.isParentATransparentCollection(cell)) {
        cell = cell.getParent();
      }
      EditorCell_Collection parent = cell.getParent();
      while (parent != null) {
        if (parent.isSelectable()) {
          while (parent.getParent() != null && TableEditorActions.isParentATransparentCollection(parent) && parent.getParent().isSelectable()) {
            parent = parent.getParent();
          }
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
  }
  public static class SelectDown extends NavigationAction {
    public SelectDown() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      return context.getEditorComponent().getSelectionManager().getSelectionStackSize() > 1;
    }
    @Override
    public void execute(EditorContext context) {
      context.getEditorComponent().getSelectionManager().popSelection();
    }
  }
  public static class SideSelect extends NavigationAction {
    private CellSide mySide;
    protected SideSelect(CellSide side) {
      mySide = side;
    }
    private EditorCell getNextLeaf(EditorCell current) {
      if (mySide == CellSide.LEFT) {
        return TableTraversalUtil.getPrevLeaf(current, CellConditions.SELECTABLE);
      } else {
        return TableTraversalUtil.getNextLeaf(current, CellConditions.SELECTABLE);
      }
    }
    @Override
    public boolean canExecute(EditorContext context) {
      SelectionManager selectionManager = context.getEditorComponent().getSelectionManager();
      Selection selection = selectionManager.getSelection();
      if (selection instanceof SingularSelection) {
        SingularSelection singularSelection = (SingularSelection) selection;
        if (!(expandSelection(singularSelection)) && selectionManager.getSelectionStackSize() > 1) {
          return true;
        }
        EditorCell selected = singularSelection.getEditorCell();
        EditorCell nextLeaf = getNextLeaf(selected);
        return nextLeaf != null && getCommonSelectableAncestor(selected, nextLeaf) != null;
      }
      return false;
    }
    @Override
    public void execute(EditorContext context) {
      SelectionManager selectionManager = context.getEditorComponent().getSelectionManager();
      SingularSelection selection = (SingularSelection) selectionManager.getSelection();
      if (!(expandSelection(selection)) && selectionManager.getSelectionStackSize() > 1) {
        selectionManager.popSelection();
        return;
      }
      EditorCell selected = selection.getEditorCell();
      EditorCell nextLeaf = getNextLeaf(selected);
      EditorCell cellToSelect = getCommonSelectableAncestor(selected, nextLeaf);
      Selection newSelection = selectionManager.createSelection(cellToSelect);
      if (newSelection instanceof SingularSelection) {
        ((SingularSelection) newSelection).setSideSelectDirection((mySide == CellSide.LEFT ? SingularSelection.SideSelectDirection.LEFT : SingularSelection.SideSelectDirection.RIGHT));
      }
      selectionManager.pushSelection(newSelection);
    }
    private boolean expandSelection(SingularSelection selection) {
      switch (selection.getSideSelectDirection()) {
        case LEFT:
          return mySide == CellSide.LEFT;
        case RIGHT:
          return mySide == CellSide.RIGHT;
        default:
      }
      return true;
    }
    private EditorCell getCommonSelectableAncestor(EditorCell first, EditorCell... cells) {
      EditorCell_Collection result = (first instanceof EditorCell_Collection ? (EditorCell_Collection) first : first.getParent());
      while (result != null) {
        if (result.isSelectable()) {
          boolean common = true;
          for (EditorCell cell : cells) {
            if (!(result.isAncestorOf(cell)) && result != cell) {
              common = false;
              break;
            }
          }
          if (common) {
            return result;
          }
        }
        result = result.getParent();
      }
      return null;
    }
  }
  public static class EnlargeSelection extends NavigationAction {
    private boolean myUp;
    public EnlargeSelection(boolean up) {
      myUp = up;
    }
    @Override
    public boolean canExecute(EditorContext context) {
      // TODO: this check should be reallocated into Selection.canExecuteAction() method once it created
      Selection selection = context.getEditorComponent().getSelectionManager().getSelection();
      if (selection instanceof NodeRangeSelection) {
        return true;
      }
      if (selection instanceof SingularSelection) {
        EditorCell editorCell = ((SingularSelection) selection).getEditorCell();
        return editorCell.getSNode().getParent() != null;
      }
      return false;
    }
    @Override
    public void execute(final EditorContext context) {
      EditorComponent editorComponent = ((EditorComponent) context.getEditorComponent());
      SelectionManager selectionManager = editorComponent.getSelectionManager();
      Selection selection = selectionManager.getSelection();
      if (selection instanceof SingularSelection) {
        EditorCell selectedCell = ((SingularSelection) selection).getEditorCell();
        SNode selectedNode = selectedCell.getSNode();
        SNode topMostNodeInSingularContainment = findTopMostNodeWithSingularContainment(selectedNode);
        if (topMostNodeInSingularContainment != selectedNode) {
          EditorCell nodeCell = editorComponent.findNodeCell(topMostNodeInSingularContainment);
          if (nodeCell != null) {
            editorComponent.pushSelection(nodeCell);
            editorComponent.scrollToCell(nodeCell);
          }
        } else {
          Selection newSelection = selectionManager.createRangeSelection(selectedNode, selectedNode);
          if (newSelection instanceof NodeRangeSelection && selectedCell.isBig()) {
            newSelection = ((NodeRangeSelection) newSelection).enlargeSelection(myUp);
          }
          if (newSelection != null) {
            selectionManager.pushSelection(newSelection);
            newSelection.ensureVisible();
          }
        }
      } else
      if (selection instanceof NodeRangeSelection) {
        Selection newSelection = ((NodeRangeSelection) selection).enlargeSelection(myUp);
        if (newSelection != null) {
          selectionManager.pushSelection(newSelection);
          newSelection.ensureVisible();
        }
      }
    }
    private SNode findTopMostNodeWithSingularContainment(SNode childNode) {
      while (childNode.getParent() != null && !(childNode.getContainmentLink().isMultiple())) {
        childNode = childNode.getParent();
      }
      return childNode;
    }
  }
  public static class Complete extends AbstractCellAction {
    public Complete() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = context.getSelectedCell();
      return selection != null && selection.getSubstituteInfo() != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selection = context.getSelectedCell();
      ((EditorComponent) context.getEditorComponent()).activateNodeSubstituteChooser(selection, ((selection instanceof EditorCell_Label) && ((EditorCell_Label) selection).isEverythingSelected()), false);
    }
  }
  public static class CompleteSmart extends AbstractCellAction {
    public CompleteSmart() {
    }
    @Override
    public boolean canExecute(EditorContext context) {
      EditorCell selection = context.getSelectedCell();
      return selection != null && selection.getSubstituteInfo() != null;
    }
    @Override
    public void execute(EditorContext context) {
      EditorCell selection = context.getSelectedCell();
      ((EditorComponent) context.getEditorComponent()).activateNodeSubstituteChooser(selection, ((selection instanceof EditorCell_Label) && ((EditorCell_Label) selection).isEverythingSelected()), true);
    }
  }

  public static class EditableOrNextPreviousCell implements Condition<EditorCell> {
    private boolean myNext;

    public EditableOrNextPreviousCell(boolean next) {
      myNext = next;
    }

    public boolean met(EditorCell cell) {
      if (CellConditions.EDITABLE.met(cell)) {
        return true;
      }
      EditorCell_GridCell gridCell = (EditorCell_GridCell) TableTraversalUtil.getParent(cell, new Condition<EditorCell>() {
        public boolean met(EditorCell parent) {
          return parent instanceof EditorCell_GridCell;
        }
      });
      if (gridCell != null) {
        List<EditorCell> leafs = TableTraversalUtil.getDescendants(gridCell, CellConditions.SELECTABLE_lEAF);
        EditorCell leaf = (myNext ? ListSequence.fromList(leafs).first() : ListSequence.fromList(leafs).last());
        if (leaf == cell) {
          return true;
        }
      }
      return false;
    }
  }
  public static boolean isParentATransparentCollection(EditorCell child) {
    EditorCell_Collection parent = child.getParent();
    if (!(parent.isTransparentCollection())) {
      return false;
    }

    EditorCell_GridCell gridCell = EditorCell_GridCell.getParentInstance(parent);
    if (gridCell == null) {
      return false;
    }
    List<EditorCell> parentCells = TableTraversalUtil.getParents(child, true);
    List<SNode> parentNodes = ListSequence.fromList(parentCells).select((it) -> it.getSNode()).toList();
    int numNodesToGridCell = ListSequence.fromList(parentNodes).indexOf(gridCell.getSNode());
    if (numNodesToGridCell == 1) {
      return false;
    }

    return true;
  }

}

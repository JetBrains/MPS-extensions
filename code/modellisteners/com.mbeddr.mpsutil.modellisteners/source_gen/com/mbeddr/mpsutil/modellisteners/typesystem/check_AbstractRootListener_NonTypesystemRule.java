package com.mbeddr.mpsutil.modellisteners.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class check_AbstractRootListener_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_AbstractRootListener_NonTypesystemRule() {
  }
  public void applyRule(final SNode arl, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    SNode listenerConcept = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(arl), CONCEPTS.ConceptModelListeners$qT), LINKS.concept$WSQr);
    if (!(SPropertyOperations.getBoolean(SNodeOperations.as(listenerConcept, CONCEPTS.ConceptDeclaration$gH), PROPS.rootable$_9pz))) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(arl, "The target concept is not rootable. Listeners work only for rootable subconcepts.", "r:2151fdfe-9902-487d-944f-4c68051c5619(com.mbeddr.mpsutil.modellisteners.typesystem)", "4083912118064901474", null, errorTarget);
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.AbstractRootListener$QJ;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ConceptModelListeners$qT = MetaAdapterFactory.getConcept(0x309e000449764416L, 0xb947ec02ae4ecef2L, 0x50bfac9a4327df8fL, "com.mbeddr.mpsutil.modellisteners.structure.ConceptModelListeners");
    /*package*/ static final SConcept ConceptDeclaration$gH = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
    /*package*/ static final SConcept AbstractRootListener$QJ = MetaAdapterFactory.getConcept(0x309e000449764416L, 0xb947ec02ae4ecef2L, 0x54bc1de68becf39fL, "com.mbeddr.mpsutil.modellisteners.structure.AbstractRootListener");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink concept$WSQr = MetaAdapterFactory.getReferenceLink(0x309e000449764416L, 0xb947ec02ae4ecef2L, 0x50bfac9a4327df8fL, 0x11a720969b6L, "concept");
  }

  private static final class PROPS {
    /*package*/ static final SProperty rootable$_9pz = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, "rootable");
  }
}

package de.slisson.mps.tables.runtime.selection;

/*Generated by MPS */

import de.slisson.mps.tables.runtime.cells.TableEditor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

/**
 * The user selection can be performed from bottom to top and right to left.
 * For cases where the direction doesn't matter e.g. copy and paste, this class can be used.
 */
public class UndirectedTableRange {

  private TableEditor table;
  private int startColumn;
  private int startRow;
  private int endColumn;
  private int endRow;

  public UndirectedTableRange(TableEditor table, int startRow, int endRow, int startColumn, int endColumn) {
    if (endRow < startRow) {
      throw new IllegalArgumentException(String.format("End row %s is before start row %s", endRow, startRow));
    }
    if (endColumn < startColumn) {
      throw new IllegalArgumentException(String.format("End column %s is before start column %s", endRow, startRow));
    }

    this.table = table;
    this.startColumn = startColumn;
    this.startRow = startRow;
    this.endColumn = endColumn;
    this.endRow = endRow;
  }

  public int getStartRow() {
    return startRow;
  }

  public int getStartColumn() {
    return startColumn;
  }

  public int getEndRow() {
    return endRow;
  }

  public int getEndColumn() {
    return endColumn;
  }

  public TableEditor getTable() {
    return table;
  }

  @Override
  public String toString() {
    return String.format("%s [row,column] [%d,%d] to [%d,%d]", this.getClass().getSimpleName(), getStartRow(), getStartColumn(), getEndRow(), getEndColumn());
  }

  public void iterate(_FunctionTypes._void_P2_E0<? super Integer, ? super Integer> consumer) {
    for (int rowIndex = this.getStartRow(); rowIndex <= this.getEndRow(); rowIndex++) {
      for (int colIndex = this.getStartColumn(); colIndex <= this.getEndColumn(); colIndex++) {
        consumer.invoke(rowIndex, colIndex);
      }
    }
  }

  public UndirectedTableRange withOffset(int rowOffset, int colOffset) {
    return new UndirectedTableRange(getTable(), Math.max(0, this.getStartRow() + rowOffset), Math.max(0, this.getEndRow() + rowOffset), Math.max(0, this.getStartColumn() + colOffset), Math.max(0, this.getEndColumn() + colOffset));
  }

  public UndirectedTableRange withoutLeftColumns(int number) {
    if (number < 0) {
      throw new IllegalArgumentException(String.valueOf(number));
    }
    return new UndirectedTableRange(getTable(), this.getStartRow(), this.getEndRow(), this.getStartColumn() + number, this.getEndColumn());
  }

  public UndirectedTableRange withoutRightColumns(int number) {
    if (number < 0) {
      throw new IllegalArgumentException(String.valueOf(number));
    }
    return new UndirectedTableRange(getTable(), this.getStartRow(), this.getEndRow(), this.getStartColumn(), this.getEndColumn() - number);
  }
}

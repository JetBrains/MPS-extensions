package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;

public class Bounds implements Cloneable {
  private double myX;
  private double myY;
  private double myWidth;
  private double myHeight;

  public Bounds() {
  }

  public Bounds(double x, double y, double width, double height) {
    myX = x;
    myY = y;
    myWidth = width;
    myHeight = height;
  }

  public Point getLeftTop() {
    return new Point(myX, myY);
  }

  public Point getRightBottom() {
    return new Point(myX + myWidth, myY + myHeight);
  }

  public Point getLeftBottom() {
    return new Point(myX, myY + myHeight);
  }

  public Point getRightTop() {
    return new Point(myX + myWidth, myY);
  }

  public void setLeftTop(Point p) {
    setX(p.getX());
    setY(p.getY());
  }

  public void setRightTop(Point p) {
    setRight(p.getX());
    setY(p.getY());
  }

  public void setRightBottom(Point p) {
    setRight(p.getX());
    setBottom(p.getY());
  }

  public void setLeftBottom(Point p) {
    setX(p.getX());
    setBottom(p.getY());
  }

  public void setRight(double right) {
    setX(right - getWidth());
  }

  public void setBottom(double bottom) {
    setY(bottom - getHeight());
  }

  public void setCenterY(double center) {
    setY(center - getHeight() / 2);
  }

  public void setCenterX(double center) {
    setX(center - getWidth() / 2);
  }

  public void setX(double x) {
    myX = x;
  }

  public double getX() {
    return myX;
  }

  public int getXInt() {
    return (int) Math.round(getX());
  }

  public void setY(double y) {
    myY = y;
  }

  public double getY() {
    return myY;
  }

  public int getYInt() {
    return (int) Math.round(getY());
  }

  public void setWidth(double width) {
    myWidth = width;
  }

  public double getWidth() {
    return myWidth;
  }

  public int getWidthInt() {
    return (int) Math.round(getWidth());
  }

  public void setHeight(double height) {
    myHeight = height;
  }

  public double getHeight() {
    return myHeight;
  }

  public int getHeightInt() {
    return (int) Math.round(getHeight());
  }

  public double getMinX() {
    return getX();
  }

  public double getMaxX() {
    return getX() + getWidth();
  }

  public double getMinY() {
    return getY();
  }

  public double getMaxY() {
    return getY() + getHeight();
  }

  public double getCenterX() {
    return (getMinX() + getMaxX()) / 2;
  }

  public double getCenterY() {
    return (getMinY() + getMaxY()) / 2;
  }

  public Point getCenter() {
    return new Point(getCenterX(), getCenterY());
  }

  public void setSize(double width, double height) {
    setWidth(width);
    setHeight(height);
  }

  public void expand(double amount) {
    setX(getX() - amount);
    setY(getY() - amount);
    setWidth(getWidth() + 2.0 * amount);
    setHeight(getHeight() + 2.0 * amount);
  }

  public void grow(Vector2D amount) {
    setWidth(getWidth() + amount.getX());
    setHeight(getHeight() + amount.getY());
  }

  public Bounds combined(Bounds other) {
    double minX = Math.min(this.getMinX(), other.getMinX());
    double maxX = Math.max(this.getMaxX(), other.getMaxX());
    double minY = Math.min(this.getMinY(), other.getMinY());
    double maxY = Math.max(this.getMaxY(), other.getMaxY());
    return new Bounds(minX, minY, maxX - minX, maxY - minY);
  }

  public void scale(double scale) {
    scale(scale, scale);
  }

  public void scale(double scaleX, double scaleY) {
    setWidth(getWidth() * scaleX);
    setHeight(getHeight() * scaleY);
  }

  public void move(double amountX, double amountY) {
    setX(getX() + amountX);
    setY(getY() + amountY);
  }

  public void move(Vector2D amount) {
    move(amount.getX(), amount.getY());
  }

  public boolean contains(Point p) {
    return myX <= p.getX() && p.getX() <= myX + myWidth && myY <= p.getY() && p.getY() <= myY + myHeight;
  }

  public boolean contains(double x, double y) {
    return getX() <= x && x <= getMaxX() && getY() <= y && y <= getMaxY();
  }

  public boolean contains(Bounds childBounds) {
    return contains(childBounds.getX(), childBounds.getY()) && contains(childBounds.getX(), childBounds.getMaxY()) && contains(childBounds.getMaxX(), childBounds.getY()) && contains(childBounds.getMaxX(), childBounds.getMaxY());
  }


  public boolean overlaps(Bounds other) {
    return other.contains(getLeftTop()) || other.contains(getLeftBottom()) || other.contains(getRightTop()) || other.contains(getRightBottom()) || contains(other.getLeftTop()) || contains(other.getLeftBottom()) || contains(other.getRightTop()) || contains(other.getRightBottom());
  }

  @Override
  public Bounds clone() {
    try {
      Bounds clone = (Bounds) super.clone();
      return clone;
    } catch (CloneNotSupportedException ex) {
      throw new RuntimeException(ex);
    }
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    Bounds that = (Bounds) o;
    if (Double.compare(that.myHeight, myHeight) != 0) {
      return false;
    }
    if (Double.compare(that.myWidth, myWidth) != 0) {
      return false;
    }
    if (Double.compare(that.myX, myX) != 0) {
      return false;
    }
    if (Double.compare(that.myY, myY) != 0) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    long temp;
    int result = 0;
    temp = ((myHeight != 0.0) ? Double.doubleToLongBits(myHeight) : 0L);
    result = 31 * result + (int) (temp ^ (temp >> 32));
    temp = ((myWidth != 0.0) ? Double.doubleToLongBits(myWidth) : 0L);
    result = 31 * result + (int) (temp ^ (temp >> 32));
    temp = ((myX != 0.0) ? Double.doubleToLongBits(myX) : 0L);
    result = 31 * result + (int) (temp ^ (temp >> 32));
    temp = ((myY != 0.0) ? Double.doubleToLongBits(myY) : 0L);
    result = 31 * result + (int) (temp ^ (temp >> 32));
    return result;
  }

  @Override
  public String toString() {
    return "[" + myX + ", " + myY + ", " + myWidth + ", " + myHeight + "]";
  }
}

package org.modelix.model.mpsadapters.mps;

/*Generated by MPS */

import org.modelix.model.api.INodeEx;
import org.modelix.model.api.INode;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.area.IArea;
import org.modelix.model.api.IConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConceptReference;
import org.modelix.model.api.IChildLink;
import org.modelix.model.api.INodeKt;
import org.modelix.model.api.INodeReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.Objects;
import org.modelix.model.api.ILanguageRepository;
import org.modelix.model.api.IReferenceLink;
import org.modelix.model.area.ContextArea;
import org.jetbrains.mps.openapi.language.SProperty;
import java.util.List;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import org.modelix.model.api.IProperty;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class SNodeToNodeAdapter implements INodeEx {

  public static INode wrap(SNode nodeToWrap) {
    if (nodeToWrap == null) {
      return null;
    }
    if (nodeToWrap instanceof NodeToSNodeAdapter) {
      return ((NodeToSNodeAdapter) nodeToWrap).getWrapped();
    }
    return new SNodeToNodeAdapter(nodeToWrap);
  }

  public static INode wrap(INode nodeToWrap) {
    // Makes code generation easier. wrap can always be applied to ensure a value is an INode.
    return nodeToWrap;
  }

  private final SNode node;

  private SNodeToNodeAdapter(SNode node1) {
    node = node1;
    notifyModelContentDependency();
  }

  protected void notifyModelContentDependency() {
    SModel model = node.getModel();
    if (model == null) {
      return;
    }
    // TODO
  }

  @NotNull
  @Override
  public IArea getArea() {
    return new MPSArea();
  }

  @Override
  public boolean isValid() {
    return true;
  }

  public SNode getWrapped() {
    return node;
  }

  @Override
  public IConcept getConcept() {
    SConcept sconcept = node.getConcept();
    IConcept concept = BootstrapConceptMappings.INSTANCE.getConcept(sconcept);
    if (concept != null) {
      return concept;
    }
    return new SConceptAdapter(sconcept);
  }

  @Nullable
  @Override
  public IConceptReference getConceptReference() {
    return getConcept().getReference();
  }

  @Override
  public String getRoleInParent() {
    IChildLink link = getContainmentLink();
    if (link == null) {
      return null;
    }
    return INodeKt.key(link, this);
  }

  @Override
  public INode getParent() {
    notifyModelContentDependency();
    SNode parent = node.getParent();
    if (parent != null) {
      return wrap(parent);
    }
    SModel model = node.getModel();
    if (model != null) {
      return new SModelAsNode(model);
    }
    return null;
  }

  @Override
  public INodeReference getReference() {
    return new SNodeReferenceAdapter(node.getReference());
  }

  @Override
  public Iterable<INode> getChildren(String role) {
    notifyModelContentDependency();
    return getChildren(INodeKt.resolveChildLink(this, role));
  }

  @Override
  public Iterable<INode> getAllChildren() {
    notifyModelContentDependency();
    Iterable<? extends SNode> children = node.getChildren();
    return Sequence.fromIterable(children).select((it) -> {
      INode n = new SNodeToNodeAdapter(it);
      return n;
    });
  }

  @Override
  public void moveChild(String role, int index, INode child) {
    IChildLink link = INodeKt.resolveChildLink(this, role);
    moveChild(link, index, child);
  }

  @Override
  public INode addNewChild(final String role, int index, IConcept concept_) {
    Iterable<SContainmentLink> links = node.getConcept().getContainmentLinks();
    SContainmentLink link = Sequence.fromIterable(links).findFirst((it) -> Objects.equals(it.getName(), role));
    if (link == null) {
      throw new RuntimeException(node.getConcept() + " has no containment link '" + role + "'");
    }
    return addNewChild(new SContainmentLinkAdapter(link), index, concept_);
  }

  @NotNull
  @Override
  public INode addNewChild(@Nullable String role, int index, @Nullable IConceptReference conceptRef) {
    IConcept concept = (conceptRef == null ? null : ILanguageRepository.Companion.resolveConcept(conceptRef));
    return addNewChild(role, index, concept);
  }

  @Override
  public void removeChild(INode child) {
    node.removeChild(((SNodeToNodeAdapter) child).node);
  }

  @Override
  public INode getReferenceTarget(String role) {
    IReferenceLink link = INodeKt.resolveReferenceLink(this, role);
    return getReferenceTarget(link);
  }

  @Nullable
  @Override
  public INodeReference getReferenceTargetRef(@NotNull String role) {
    return check_8812ym_a0a14(getReferenceTarget(role), this);
  }

  @Override
  public void setReferenceTarget(String role, INode target) {
    setReferenceTarget(INodeKt.resolveReferenceLink(this, role), target);
  }

  @Override
  public void setReferenceTarget(@NotNull String role, @Nullable INodeReference target) {
    INode targetNode = (target == null ? null : target.resolveNode(ContextArea.INSTANCE.getArea()));
    setReferenceTarget(role, targetNode);
  }

  @Override
  public String getPropertyValue(final String role) {
    notifyModelContentDependency();
    Iterable<SProperty> properties = node.getProperties();
    SProperty property = Sequence.fromIterable(properties).findFirst((it) -> Objects.equals(it.getName(), role));
    if (property == null) {
      return null;
    }
    return getPropertyValue(new SPropertyAdapter(property));
  }

  @Override
  public void setPropertyValue(String role, String value) {
    setPropertyValue(INodeKt.resolveProperty(this, role), value);
  }

  @NotNull
  @Override
  public List<String> getPropertyRoles() {
    Iterable<SProperty> properties = node.getProperties();
    return Sequence.fromIterable(properties).select((it) -> it.getName()).toList();
  }
  @NotNull
  @Override
  public List<String> getReferenceRoles() {
    Iterable<? extends SReference> references = node.getReferences();
    return Sequence.fromIterable(references).select((it) -> it.getLink().getName()).toList();
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    SNodeToNodeAdapter that = (SNodeToNodeAdapter) o;
    if ((node != null ? !(node.equals(that.node)) : that.node != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((node != null ? ((Object) node).hashCode() : 0));
    return result;
  }

  @Override
  public String toString() {
    return "" + node;
  }

  @Override
  public boolean usesRoleIds() {
    return false;
  }

  @NotNull
  @Override
  public INode addNewChild(@NotNull IChildLink role, int index, @Nullable IConcept concept_) {
    SContainmentLink link = ((SContainmentLinkAdapter) role).getLink();
    Iterable<? extends SNode> children_ = node.getChildren(link);
    List<? extends SNode> children = Sequence.fromIterable(children_).toList();
    if (index > ListSequence.fromList(children).count()) {
      throw new IndexOutOfBoundsException(index + " > " + Sequence.fromIterable(children_).count());
    }
    SAbstractConcept concept = SConceptAdapter.unwrap(concept_);
    if (concept == null) {
      concept = link.getTargetConcept();
    }
    SConcept instantiatableConcept = MetaAdapterByDeclaration.asInstanceConcept(concept);
    SModel model = node.getModel();
    SNode newChild = (model == null ? new jetbrains.mps.smodel.SNode(instantiatableConcept) : model.createNode(instantiatableConcept));
    if (index == -1 || index == ListSequence.fromList(children).count()) {
      node.addChild(link, newChild);
    } else {
      node.insertChildBefore(link, newChild, ListSequence.fromList(children).getElement(index));
    }
    return wrap(newChild);
  }
  @NotNull
  @Override
  public INode addNewChild(@NotNull IChildLink role, int index, @Nullable IConceptReference conceptRef) {
    IConcept concept = (conceptRef == null ? null : ILanguageRepository.Companion.resolveConcept(conceptRef));
    return addNewChild(role, index, concept);
  }
  @NotNull
  @Override
  public Iterable<INode> getChildren(@NotNull final IChildLink link) {
    return Sequence.fromIterable(getAllChildren()).where((it) -> Objects.equals(INodeKt.getContainmentLink(it), link));
  }
  @Nullable
  @Override
  public IChildLink getContainmentLink() {
    SContainmentLink link = null;

    SNode parent = node.getParent();
    if (parent != null) {
      link = node.getContainmentLink();
    } else {
      SModel model = node.getModel();
      if (model != null) {
        link = LINKS.rootNodes$jxXY;
      }
    }
    return (link == null ? null : new SContainmentLinkAdapter(link));

  }
  @Nullable
  @Override
  public String getPropertyValue(@NotNull IProperty property) {
    return node.getProperty(((SPropertyAdapter) property).getProperty());
  }
  @Nullable
  @Override
  public INode getReferenceTarget(@NotNull IReferenceLink link) {
    return wrap(node.getReferenceTarget(((SReferenceLinkAdapter) link).getLink()));
  }
  @Nullable
  @Override
  public INodeReference getReferenceTargetRef(@NotNull IReferenceLink role) {
    return check_8812ym_a0a76(getReferenceTarget(role), this);
  }
  @Override
  public void moveChild(@NotNull IChildLink role, int index, @NotNull INode child) {
    SContainmentLink link = ((SContainmentLinkAdapter) role).getLink();
    Iterable<? extends SNode> children_ = node.getChildren(link);
    List<? extends SNode> children = Sequence.fromIterable(children_).toList();
    if (index > ListSequence.fromList(children).count()) {
      throw new IndexOutOfBoundsException(index + " > " + Sequence.fromIterable(children_).count());
    }
    SNode schild = NodeToSNodeAdapter.wrap(child);
    if (SNodeOperations.getParent(schild) != null) {
      SNodeOperations.deleteNode(schild);
    }
    if (index == -1 || index == ListSequence.fromList(children).count()) {
      node.addChild(link, schild);
    } else {
      node.insertChildBefore(link, schild, ListSequence.fromList(children).getElement(index));
    }
  }
  @Override
  public void setPropertyValue(@NotNull IProperty property, @Nullable String value) {
    node.setProperty(((SPropertyAdapter) property).getProperty(), value);
  }
  @Override
  public void setReferenceTarget(@NotNull IReferenceLink link, @Nullable INode target) {
    SNode snodeTarget = NodeToSNodeAdapter.wrap(target);
    node.setReferenceTarget(((SReferenceLinkAdapter) link).getLink(), snodeTarget);
  }
  @Override
  public void setReferenceTarget(@NotNull IReferenceLink role, @Nullable INodeReference target) {
    INode targetNode = (target == null ? null : target.resolveNode(ContextArea.INSTANCE.getArea()));
    setReferenceTarget(role, targetNode);
  }
  private static INodeReference check_8812ym_a0a14(INode checkedDotOperand, SNodeToNodeAdapter checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getReference();
    }
    return null;
  }
  private static INodeReference check_8812ym_a0a76(INode checkedDotOperand, SNodeToNodeAdapter checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getReference();
    }
    return null;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink rootNodes$jxXY = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x69652614fd1c514L, "rootNodes");
  }
}

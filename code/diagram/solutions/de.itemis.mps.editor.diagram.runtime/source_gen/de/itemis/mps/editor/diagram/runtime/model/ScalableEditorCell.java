package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.nodeEditor.cellProviders.AbstractCellListHandler;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.util.Condition;
import java.awt.Graphics2D;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;

public class ScalableEditorCell extends EditorCell_Collection {

  private static boolean scalingDisabled = false;

  public static void withScalingDisabled(Runnable r) {
    boolean wasDisabled = scalingDisabled;
    try {
      scalingDisabled = true;
      r.run();
    } finally {
      scalingDisabled = wasDisabled;
    }
  }

  private double myScale = 1.0;
  private boolean myIsPaintingScaled = false;

  public ScalableEditorCell(EditorContext context, SNode snode, CellLayout layout, AbstractCellListHandler handler) {
    super(context, snode, layout, handler);
  }

  public void setBoundsRaw(int x, int y, int width, int height) {
    myX = x;
    myY = y;
    myWidth = width;
    myHeight = height;
  }

  protected double getScale() {
    return (scalingDisabled ? 1.0 : myScale);
  }

  public void setScale(double scale) {
    myScale = scale;
  }

  private Tuples._2<Integer, Integer> convertCoordinates(int x, int y) {
    double cx = getScale() * (x - myX) + myX;
    double cy = getScale() * (y - myY) + myY;
    return MultiTuple.<Integer,Integer>from((int) Math.abs(cx), (int) Math.abs(cy));
  }

  protected int scaleValue(int unscaled) {
    return (int) Math.abs(getScale() * unscaled);
  }

  protected int unscaleValue(int scaled) {
    return (int) Math.abs(scaled / getScale());
  }

  @Override
  public EditorCell findLeaf(int x, int y) {
    {
      Tuples._2<Integer, Integer> _tmp_a0ntcy_a0w = convertCoordinates(x, y);
      x = _tmp_a0ntcy_a0w._0();
      y = _tmp_a0ntcy_a0w._1();
    }
    return super.findLeaf(x, y);
  }

  @Override
  public EditorCell findNearestLeafOnLine(int x, int y, Condition<EditorCell> condition) {
    {
      Tuples._2<Integer, Integer> _tmp_a0ntcy_a0y = convertCoordinates(x, y);
      x = _tmp_a0ntcy_a0y._0();
      y = _tmp_a0ntcy_a0y._1();
    }
    return super.findNearestLeafOnLine(x, y, condition);
  }

  protected void paintScaled(Graphics2D g_, final _FunctionTypes._void_P1_E0<? super Graphics2D> painter) {
    final Graphics2D g = (Graphics2D) g_.create();
    boolean wasPaintingScaled = myIsPaintingScaled;
    try {
      myIsPaintingScaled = true;
      g.translate(getX(), getY());
      g.scale(getScale(), getScale());
      g.translate(-getX(), -getY());

      // Error messages query the dimensions of the cell.
      // Because we already scale the graphics context, the messages must be drawn unscaled.
      withScalingDisabled(() -> painter.invoke(g));
    } finally {
      g.dispose();
      myIsPaintingScaled = wasPaintingScaled;
    }
  }

  @Override
  public void paintCell(Graphics graphics, final ParentSettings parentSettings) {
    paintScaled(((Graphics2D) graphics), (Graphics2D g) -> ScalableEditorCell.super.paintCell(g, parentSettings));
  }

  @Override
  public void paintDecorations(Graphics graphics) {
    paintScaled(((Graphics2D) graphics), (Graphics2D g) -> ScalableEditorCell.super.paintDecorations(g));
  }

  @Override
  protected void paintContent(Graphics graphics, final ParentSettings settings) {
    paintScaled(((Graphics2D) graphics), (Graphics2D g) -> ScalableEditorCell.super.paintContent(g, settings));
  }

  @Override
  protected void paintChildCells(Graphics graphics, final ParentSettings settings) {
    paintScaled(((Graphics2D) graphics), (Graphics2D g) -> ScalableEditorCell.super.paintChildCells(g, settings));
  }

  @Override
  protected void paintChildDecorations(Graphics graphics) {
    paintScaled(((Graphics2D) graphics), (Graphics2D g) -> ScalableEditorCell.super.paintChildDecorations(g));
  }

  @Override
  protected void relayoutImpl() {
    withScalingDisabled(() -> ScalableEditorCell.super.relayoutImpl());
  }

  @Override
  public int getHeight() {
    return (int) Math.abs(getScale() * super.getHeight());
  }

  @Override
  public int getWidth() {
    return scaleValue(super.getWidth());
  }

  @Override
  public void setWidth(int w) {
    super.setWidth(unscaleValue(w));
  }

  @Override
  public void setHeight(int h) {
    super.setHeight(unscaleValue(h));
  }
}

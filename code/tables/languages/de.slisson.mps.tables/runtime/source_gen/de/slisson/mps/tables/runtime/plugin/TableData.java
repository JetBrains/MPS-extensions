package de.slisson.mps.tables.runtime.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import java.util.LinkedList;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.slisson.mps.tables.runtime.selection.UndirectedTableRange;
import java.util.function.Function;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Objects;
import java.util.stream.Collectors;

public class TableData<T> {

  private List<List<T>> content;

  public TableData() {
    content = ListSequence.fromList(new ArrayList<List<T>>());
  }

  public List<List<T>> get() {
    return content;
  }

  public T get(int rowindex, int colIndex) {
    return ListSequence.fromList(ListSequence.fromList(content).getElement(rowindex)).getElement(colIndex);
  }

  public boolean isEmpty() {
    return ListSequence.fromList(content).isEmpty();
  }

  public int rowSize() {
    return ListSequence.fromList(content).count();
  }

  public int columnSize() {
    if (isEmpty()) {
      return 0;
    }
    return ListSequence.fromList(ListSequence.fromList(content).first()).count();
  }

  public void addData(T element) {
    if (isEmpty()) {
      addRow();
    }
    ListSequence.fromList(ListSequence.fromList(content).last()).addElement(element);
  }

  public void addRow() {
    ListSequence.fromList(content).addElement(LinkedListSequence.fromLinkedList(new LinkedList<T>()));
  }

  public void forEach(_FunctionTypes._void_P3_E0<? super T, ? super Integer, ? super Integer> elementConsumer) {
    forEach(0, 0, elementConsumer);
  }

  public void forEach(int rowOffset, int colOffset, _FunctionTypes._void_P3_E0<? super T, ? super Integer, ? super Integer> elementConsumer) {
    int row = rowOffset;
    for (List<T> rowData : ListSequence.fromList(get())) {
      int col = colOffset;
      for (T element : ListSequence.fromList(rowData)) {
        elementConsumer.invoke(element, row, col);
        col++;
      }
      row++;
    }
  }

  public TableData<T> collect(UndirectedTableRange box, _FunctionTypes._return_P2_E0<? extends T, ? super Integer, ? super Integer> elementCollector) {
    for (int rowIndex = box.getStartRow(); rowIndex <= box.getEndRow(); rowIndex++) {
      this.addRow();
      for (int colIndex = box.getStartColumn(); colIndex <= box.getEndColumn(); colIndex++) {
        this.addData(elementCollector.invoke(rowIndex, colIndex));
      }
    }
    return this;
  }

  public <D> TableData<D> map(Function<T, D> mapElementFun) {
    TableData<D> mappedTable = new TableData<>();
    for (int i = 0; i < ListSequence.fromList(content).count(); i++) {
      List<T> row = ListSequence.fromList(get()).getElement(i);
      for (T element : ListSequence.fromList(row)) {
        mappedTable.addData(mapElementFun.apply(element));
      }
      if (i < ListSequence.fromList(content).count() - 1) {
        mappedTable.addRow();
      }
    }
    return mappedTable;
  }

  public String toFlatString(TableDataSeparator separator) {
    return toFlatString(separator.getElement(), separator.getLine());
  }

  private String toFlatString(String elementSeparator, String lineSeparator) {
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < ListSequence.fromList(content).count(); i++) {
      List<T> row = ListSequence.fromList(get()).getElement(i);
      builder.append(ListSequence.fromList(row).toStream(false).map((element) -> {
        if (element instanceof SNode) {
          return ((SNode) element).getPresentation();
        }
        return Objects.toString(element);
      }).collect(Collectors.joining(elementSeparator)));
      if (i < ListSequence.fromList(content).count() - 1) {
        builder.append(lineSeparator);
      }
    }
    return builder.toString();
  }
}

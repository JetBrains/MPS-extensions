package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.swing.handler.mxMovePreview;
import java.util.List;
import java.awt.geom.Line2D;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import com.mxgraph.swing.mxGraphComponent;
import java.awt.event.MouseEvent;
import com.mxgraph.view.mxCellState;
import java.awt.Graphics;
import java.awt.Graphics2D;
import com.intellij.ui.JBColor;
import java.awt.BasicStroke;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import com.mxgraph.util.mxPoint;
import jetbrains.mps.internal.collections.runtime.Sequence;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import com.mxgraph.model.mxICell;
import com.mxgraph.model.mxGeometry;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.mxgraph.view.mxGraphView;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;

public class MyMovePreview extends mxMovePreview {
  public static final int SNAP_DISTANCE_LIMIT = 10;

  private List<Line2D> myGuideLines;
  private List<Line2D> myPreviousLines;
  private List<ISmartGuide> mySmartGuides = ListSequence.fromListAndArray(new ArrayList<ISmartGuide>(), new SmartGuide_BoxTop(), new SmartGuide_BoxBottom(), new SmartGuide_BoxVerticalCenter(), new SmartGuide_BoxLeft(), new SmartGuide_BoxRight(), new SmartGuide_BoxHorizontalCenter(), new SmartGuide_PortConnection());
  private boolean myGuidesDisabled = false;
  private Vector2D originalTranslate;

  public MyMovePreview(mxGraphComponent graphComponent) {
    super(graphComponent);
  }

  @Override
  public void start(MouseEvent e, mxCellState state) {
    super.start(e, state);
    originalTranslate = VectorExtensions.toVector2D(graphComponent.getGraph().getView().getTranslate());
  }

  @Override
  public void paint(Graphics graphics) {
    super.paint(graphics);

    if (ListSequence.fromList(myGuideLines).isNotEmpty()) {
      DrawUtil.executeWithGraphicsCopy(((Graphics2D) graphics), (Graphics2D g) -> {
        g.setColor(JBColor.GREEN);
        g.setStroke(new BasicStroke(1.0f));
        for (Line2D line : ListSequence.fromList(myGuideLines)) {
          g.draw(line);
        }
      });
    }
  }

  @Override
  public void update(MouseEvent event, double dx, double dy, boolean clone) {
    {
      Tuples._2<Double, Double> _tmp_pm6qat_a0o = snap(dx, dy, event);
      dx = _tmp_pm6qat_a0o._0();
      dy = _tmp_pm6qat_a0o._1();
    }
    mxPoint translate = graphComponent.getGraph().getView().getTranslate();
    double differenceX = originalTranslate.getX() - translate.getX();
    double differenceY = originalTranslate.getY() - translate.getY();
    super.update(event, dx + differenceX, dy + differenceY, clone);
    repaintGuides();
  }

  public void repaintGuides() {
    for (Line2D line : ListSequence.fromList(myPreviousLines)) {
      repaintLine(line);
    }
    for (Line2D line : ListSequence.fromList(myGuideLines)) {
      repaintLine(line);
    }
    myPreviousLines = myGuideLines;
  }

  protected void repaintLine(Line2D line) {
    if (line == null) {
      return;
    }
    repaint(ExtensionMethods.toMxRectangle(JGraphUtil.extend(line.getBounds2D(), 1.0)));
  }

  @Override
  public Object[] stop(boolean commit, MouseEvent event, double dx, double dy, boolean clone, Object target) {
    {
      Tuples._2<Double, Double> _tmp_pm6qat_a0u = snap(dx, dy, event);
      dx = _tmp_pm6qat_a0u._0();
      dy = _tmp_pm6qat_a0u._1();
    }
    myGuideLines = null;

    // There is a bug when you follow a reference with cmd + left click.
    // The editor scrolls to the reference target and the box is moved by the amount the editor scrolled,
    // because a MOUSE_PRESSED event is fired before and a MOUSE_RELEASED after the scroll
    if (editorJumpToReference(event)) {
      commit = false;
    }

    Vector2D translationChangeDuringMove = VectorExtensions.toVector2D(graphComponent.getGraph().getView().getTranslate()).subtract(originalTranslate);
    Vector2D actualMove = new Vector2D(dx, dy).subtract(translationChangeDuringMove);
    graphComponent.getGraph().getModel().beginUpdate();
    try {
      Object[] movedCells = super.stop(commit, event, actualMove.getX(), actualMove.getY(), clone, target);
      expandSubdiagrams(movedCells);
      return movedCells;
    } finally {
      graphComponent.getGraph().getModel().endUpdate();
    }
  }

  private void expandSubdiagrams(Object[] movedCells) {
    Iterable<SubDiagramDCell> subdiagrams = Sequence.fromIterable(Sequence.fromArray(movedCells)).ofType(BoxBaseDCell.class).select((it) -> it.getParent()).ofType(SubDiagramDCell.class);
    for (SubDiagramDCell subdiagram : Sequence.fromIterable(subdiagrams)) {
      BoxDCell parentBox = as_pm6qat_a0a0a1a22(subdiagram.getParent(), BoxDCell.class);
      if (parentBox == null) {
        continue;
      }

      Bounds childrenBounds = ListSequence.fromList(CellExtensions.getChildren(subdiagram)).select((it) -> CellExtensions.getBounds(it)).reduceLeft((a, b) -> a.combined(b));

      Vector2D topLeftDelta = childrenBounds.getLeftTop().toVector2D();
      topLeftDelta = new Vector2D(Math.min(0, topLeftDelta.getX()), Math.min(0, topLeftDelta.getY()));

      Vector2D bottomRightDelta = childrenBounds.getRightBottom().toVector2D();
      bottomRightDelta = bottomRightDelta.subtract(new Vector2D(CellExtensions.getBounds(subdiagram).getWidth(), CellExtensions.getBounds(subdiagram).getHeight()));
      bottomRightDelta = new Vector2D(Math.max(0, bottomRightDelta.getX()), Math.max(0, bottomRightDelta.getY()));

      if (topLeftDelta.getNorm1() != 0 || bottomRightDelta.getNorm1() != 0) {
        Bounds parentBoxBounds = CellExtensions.getBounds(parentBox);
        parentBoxBounds.move(topLeftDelta);
        parentBoxBounds.grow(bottomRightDelta.subtract(topLeftDelta));
        CellExtensions.setBounds(parentBox, parentBoxBounds);
      }

      if (topLeftDelta.getNorm1() != 0) {
        Vector2D childTranslation = topLeftDelta.scalarMultiply(-1);
        for (mxICell child : ListSequence.fromList(CellExtensions.getChildren(subdiagram))) {
          mxGeometry geometry = child.getGeometry();
          geometry.translate(childTranslation.getX(), childTranslation.getY());
          child.setGeometry(geometry);
        }
      }
    }
  }

  protected boolean editorJumpToReference(MouseEvent e) {
    if (e == null) {
      return false;
    }
    return e.getX() < 0 || e.getY() < 0 || e.getX() > e.getComponent().getWidth() || e.getY() > e.getComponent().getHeight();
  }

  public Tuples._2<Double, Double> snap(double dx, double dy, MouseEvent event) {
    myGuideLines = ListSequence.fromList(new ArrayList<Line2D>());

    if (movingCells.length < 1) {
      return MultiTuple.<Double,Double>from(dx, dy);
    }

    if (check_pm6qat_a4a62(event)) {
      myGuidesDisabled = true;
    } else {
      if (check_pm6qat_a0a0a4a62(event) != 0) {
        myGuidesDisabled = false;
      }
    }
    if (myGuidesDisabled) {
      return MultiTuple.<Double,Double>from(dx, dy);
    }

    mxGraphView view = graphComponent.getGraph().getView();
    Object movingCell = movingCells[0];
    mxCellState movingState = view.getState(movingCell);
    final List<mxCellState> states = ListSequence.fromListWithValues(new ArrayList<mxCellState>(), view.getStates().values());

    List<SnapResult> snapResults = ListSequence.fromList(new ArrayList<SnapResult>());
    for (ISmartGuide smartGuide : ListSequence.fromList(mySmartGuides)) {
      ListSequence.fromList(snapResults).addSequence(ListSequence.fromList(smartGuide.snap(dx, dy, SNAP_DISTANCE_LIMIT, movingState, states, view)));
    }
    snapResults = ListSequence.fromList(snapResults).where((it) -> it.getSnapDistance() <= SNAP_DISTANCE_LIMIT).toList();

    ListSequence.fromList(snapResults).visitAll((it) -> it.setNumCrossingBoxes(numCrossingBoxes(it, states)));

    Iterable<SnapResult> sortedResults = snapResults;
    sortedResults = Sequence.fromIterable(sortedResults).sort((it) -> it.getNumCrossingBoxes(), true);
    sortedResults = Sequence.fromIterable(sortedResults).alsoSort((it) -> it.getPriority(), true);
    sortedResults = Sequence.fromIterable(sortedResults).alsoSort((it) -> it.getSnapDistance() + it.getLineLength() / 200.0, true);
    sortedResults = Sequence.fromIterable(sortedResults).alsoSort((it) -> it.getLineLength(), true);

    SnapResult bestSnapResult = Sequence.fromIterable(sortedResults).first();
    double snappedX = 0.0;
    double snappedY = 0.0;
    if (bestSnapResult != null) {
      SnapResult secondary = null;
      snappedX = bestSnapResult.getSnapDistanceX();
      snappedY = bestSnapResult.getSnapDistanceY();
      if (snappedX == 0.0) {
        secondary = Sequence.fromIterable(sortedResults).findFirst((it) -> it.getSnapDistanceX() != 0.0 && it.getSnapDistanceY() == 0.0);
      } else if (snappedY == 0.0) {
        secondary = Sequence.fromIterable(sortedResults).findFirst((it) -> it.getSnapDistanceY() != 0.0 && it.getSnapDistanceX() == 0.0);
      }
      ListSequence.fromList(myGuideLines).addElement(bestSnapResult.getGuideLine());
      if (secondary != null) {
        snappedX += secondary.getSnapDistanceX();
        snappedY += secondary.getSnapDistanceY();
        ListSequence.fromList(myGuideLines).addElement(secondary.getGuideLine());
      }
      dx += snappedX;
      dy += snappedY;
    }

    // always draw lines that don't need a snap move
    for (SnapResult snapResult : ListSequence.fromList(snapResults)) {
      boolean needsSnapX = snapResult.getSnapDistanceX() != 0.0;
      boolean needsSnapY = snapResult.getSnapDistanceY() != 0.0;
      boolean isAlignedX = !(needsSnapX) || de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear((snapResult.getSnapDistanceX() - snappedX), 0.0, 0.5);
      boolean isAlignedY = !(needsSnapY) || de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear((snapResult.getSnapDistanceY() - snappedY), 0.0, 0.5);
      if (isAlignedX && isAlignedY) {
        ListSequence.fromList(myGuideLines).addElement(snapResult.getGuideLine());
      }
    }

    return MultiTuple.<Double,Double>from(dx, dy);
  }

  public int numCrossingBoxes(SnapResult snapResult, List<mxCellState> states) {
    int result = 0;
    for (mxCellState state : ListSequence.fromList(states)) {
      if (state.getCell() instanceof BoxDCell) {
        Rectangle2D boxRect = ExtensionMethods.toRectangle2D(state);
        // slightly crossing is allowed
        boxRect = JGraphUtil.extend(boxRect, -2.0);

        Line2D line = snapResult.getGuideLine();
        Point2D p1 = line.getP1();
        Point2D p2 = line.getP2();

        // partial crossings are OK (line starts/ends in the box)
        if (boxRect.contains(p1) || boxRect.contains(p2)) {
          continue;
        }

        if (line.intersects(boxRect)) {
          result++;
        }
      }
    }
    return result;
  }
  private static boolean check_pm6qat_a4a62(MouseEvent checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isShiftDown();
    }
    return false;
  }
  private static int check_pm6qat_a0a0a4a62(MouseEvent checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getID();
    }
    return 0;
  }
  private static <T> T as_pm6qat_a0a0a1a22(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

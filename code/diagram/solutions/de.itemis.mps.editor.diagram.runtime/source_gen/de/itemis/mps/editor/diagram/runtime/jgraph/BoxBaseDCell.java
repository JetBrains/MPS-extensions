package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.style.StyleAttribute;
import de.itemis.mps.editor.diagram.styles.editor.VerticalAlign;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import java.util.List;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import de.itemis.mps.editor.diagram.runtime.model.Box;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.itemis.mps.editor.diagram.runtime.EditorUtil;
import de.itemis.mps.editor.celllayout.runtime.LayoutEngine;
import com.mxgraph.view.mxGraphView;
import com.mxgraph.view.mxCellState;
import java.awt.geom.Rectangle2D;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.editor.runtime.style.CellAlign;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import java.util.ArrayList;
import java.awt.Graphics2D;
import com.mxgraph.canvas.mxGraphics2DCanvas;
import com.mxgraph.util.mxPoint;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public abstract class BoxBaseDCell extends BaseDCell implements ISelfPaintingCell, IMPSCellContainer, IDiagramDCell {
  private static final StyleAttribute<VerticalAlign> VERTICAL_ALIGN_STYLE = StyleAttributes.getInstance().<VerticalAlign>getAttribute("de.itemis.mps.editor.diagram.styles", "vertical-align");

  private List<MPSCell> myMPSCells;

  public BoxBaseDCell(MyGraph graph) {
    super(graph);
  }

  @Override
  public void layoutMPSCells() {
    Bounds bounds = CellExtensions.getBounds(this);
    bounds.expand(-Box.PADDING);

    for (MPSCell mpsCell : ListSequence.fromList(getMPSCells())) {
      boolean hasSubdiagrams = !(EditorUtil.firstLevelDescendants(mpsCell.getEditorCell(), SubDiagramECell.class).isEmpty());
      if (hasSubdiagrams) {
        new LayoutEngine().layoutCell(mpsCell.getEditorCell(), bounds.getXInt(), bounds.getYInt(), bounds.getWidthInt(), bounds.getHeightInt());
      } else {
        new LayoutEngine().layoutCell(mpsCell.getEditorCell());
        LayoutDependencies.getInstance(mpsCell.getEditorCell()).registerDependenciesForSubtree(mpsCell.getEditorCell());
      }
    }
  }

  @Override
  public void updateMPSCellPositions(mxGraphView view, mxCellState state) {
    for (MPSCell mpsCell : ListSequence.fromList(myMPSCells)) {
      Rectangle2D mpsCellBounds = mpsCell.getBounds();
      Bounds targetBounds = CellExtensions.getBounds(this);
      targetBounds.expand(-Box.PADDING);
      double offsetX = 0.0;
      double offsetY = 0.0;

      Style style = mpsCell.getEditorCell().getStyle();
      Style style2 = check_36tzx1_a0h0a0i(ListSequence.fromList(EditorUtil.getChildren(mpsCell.getEditorCell())).first());

      CellAlign halign = CellAlign.CENTER;
      if (style.isSpecified(StyleAttributes.HORIZONTAL_ALIGN)) {
        halign = style.get(StyleAttributes.HORIZONTAL_ALIGN);
      }
      if (style2 != null && style2.isSpecified(StyleAttributes.HORIZONTAL_ALIGN)) {
        halign = style2.get(StyleAttributes.HORIZONTAL_ALIGN);
      }

      VerticalAlign valign = VerticalAlign.CENTER;
      if (style.isSpecified(VERTICAL_ALIGN_STYLE)) {
        valign = style.get(VERTICAL_ALIGN_STYLE);
      }
      if (style2 != null && style2.isSpecified(VERTICAL_ALIGN_STYLE)) {
        valign = style2.get(VERTICAL_ALIGN_STYLE);
      }

      if (halign == CellAlign.CENTER) {
        offsetX += (targetBounds.getWidth() - mpsCellBounds.getWidth()) / 2;
      } else if (halign == CellAlign.RIGHT) {
        offsetX += (targetBounds.getWidth() - mpsCellBounds.getWidth());
      }
      if (valign == VerticalAlign.CENTER) {
        offsetY += (targetBounds.getHeight() - mpsCellBounds.getHeight()) / 2;
      } else if (valign == VerticalAlign.BOTTOM) {
        offsetY += (targetBounds.getHeight() - mpsCellBounds.getHeight());
      }

      offsetX = Math.max(0.0, offsetX);
      offsetY = Math.max(0.0, offsetY);

      offsetX += Box.PADDING;
      offsetY += Box.PADDING;

      double scale = getScale();
      mpsCell.setStateRelativePos(offsetX * scale, offsetY * scale);
    }

    EditorCell bigCell = getBigCell();
    if (bigCell instanceof EditorCell_Collection) {
      EditorUtil.updateBounds(((EditorCell_Collection) bigCell));
    }
  }

  public void setContentCells(List<EditorCell> contentCells) {
    myMPSCells = ListSequence.fromList(contentCells).where((it) -> it != null).select((it) -> myGraph.get().getMPSCellRegistry().getInstance((jetbrains.mps.nodeEditor.cells.EditorCell) it, BoxBaseDCell.this)).toList();
  }

  @Override
  public List<MPSCell> getMPSCells() {
    return (myMPSCells == null ? new ArrayList<MPSCell>() : new ArrayList<MPSCell>(myMPSCells));
  }

  @Override
  public void paintBackground(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {

    // draw shape
    DrawUtil.drawShape(canvas, state);
  }

  @Override
  public void paintForeground(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {
    double scale = state.getView().getScale();
    mxPoint translate = state.getView().getTranslate();

    for (MPSCell mpsCell : ListSequence.fromList(getMPSCells())) {
      EditorCell editorCell = mpsCell.getEditorCell();

      // MPS cell
      mpsCell.paint(g, state);

      // Compartments
      DrawUtil.drawCompartments(g, mpsCell, state);
    }
  }

  @Override
  public void paintTop(Graphics2D g, mxGraphics2DCanvas canvas, mxCellState state) {
  }

  @Override
  public boolean canPaintSelf(mxGraphics2DCanvas canvas, mxCellState state) {
    return getBigCell() != null;
  }

  @Override
  public boolean doesAdditionalPaintingOnly() {
    return false;
  }

  @Nullable
  @Override
  public Tuples._2<Double, Double> getRequiredSize() {
    Tuples._2<Double, Double> size = super.getRequiredSize();
    if (size == null) {
      return null;
    }
    size = MultiTuple.<Double,Double>from((double) size._0() + Box.PADDING * 2, (double) size._1() + Box.PADDING * 2);
    return size;
  }
  private static Style check_36tzx1_a0h0a0i(EditorCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getStyle();
    }
    return null;
  }
}

package de.itemis.mps.tooltips.runtime;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.HashMap;
import com.intellij.ide.IdeTooltip;
import com.intellij.ide.IdeTooltipManager;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.MouseEvent;
import jetbrains.mps.classloading.ModuleClassLoader;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import com.intellij.ide.TooltipEvent;
import com.intellij.openapi.ui.popup.Balloon;
import java.util.List;
import java.util.ArrayList;
import java.awt.Point;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;

public class TooltipManager {
  private static final boolean TOOLTIP_RADAR_ENABLED = false;

  private static Map<EditorComponent, TooltipManager> ourInstances = new HashMap<EditorComponent, TooltipManager>();

  public static TooltipManager getInstance(EditorComponent editorComponent) {
    TooltipManager instance = TooltipManager.ourInstances.get(editorComponent);
    if (instance == null) {
      instance = new TooltipManager(editorComponent);
      TooltipManager.ourInstances.put(editorComponent, instance);
    }
    return instance;
  }

  public static void disposeInstance(EditorComponent editorComponent) {
    TooltipManager instance = ourInstances.get(editorComponent);
    if (instance != null) {
      ourInstances.remove(editorComponent);
      instance.dispose();
    }
  }

  private EditorComponent myEditorComponent;
  private ITooltip myActiveTooltip;
  private IdeTooltip myLastIdeTooltip;
  private TooltipTimer myTimer = new TooltipTimer() {
    public void showCurrentTooltip(boolean immediately) {
      if (myLastIdeTooltip != null) {
        IdeTooltipManager.getInstance().show(myLastIdeTooltip, true, !(immediately));
      }
    }
  };
  private MouseMotionAdapter myMouseListener = new MouseMotionAdapter() {
    @Override
    public void mouseMoved(MouseEvent event) {
      try {
        handleMouseMoved(event);
      } catch (ModuleClassLoader.ModuleClassLoaderIsDisposedException ex) {
        event.getComponent().removeMouseMotionListener(this);
      }
    }
  };

  public TooltipManager(EditorComponent editorComponent) {
    myEditorComponent = editorComponent;
    myEditorComponent.addMouseMotionListener(myMouseListener);
  }

  public void dispose() {
    myEditorComponent.removeMouseMotionListener(myMouseListener);
  }

  public boolean isActive(ITooltip tooltip) {
    return myActiveTooltip == tooltip;
  }

  protected void handleMouseMoved(MouseEvent event) {
    updateMarkOpacity(event);

    ITooltip previous = myActiveTooltip;
    myActiveTooltip = getTooltipAt(event.getX(), event.getY());
    if (myActiveTooltip == previous) {
      return;
    }
    if (previous != null) {
      if (myLastIdeTooltip != null) {
        myLastIdeTooltip.hide();
        myLastIdeTooltip = null;
      }
      myTimer.mouseMovedOut();
    }
    if (myActiveTooltip != null) {
      EditorCell tooltipCell = myActiveTooltip.getTooltipCell();
      if (tooltipCell != null) {
        TooltipComponent comp = new TooltipComponent(tooltipCell);
        comp.doLayout();
        myLastIdeTooltip = new IdeTooltip(myEditorComponent, myActiveTooltip.getCenter(), comp, myActiveTooltip) {
          @Override
          protected boolean canAutohideOn(TooltipEvent event) {
            if (event.getInputEvent() instanceof MouseEvent) {
              return false;
            }
            return !(event.isIsEventInsideBalloon());
          }
          @Override
          public boolean canBeDismissedOnTimeout() {
            return false;
          }
        };
        myLastIdeTooltip.setPreferredPosition(Balloon.Position.above);
        myLastIdeTooltip.setCalloutShift(myActiveTooltip.getHeight() / 2 + 2);
        myTimer.mouseMovedIn(event.isControlDown(), isNotEmptyString(check_7mhxd1_a1a0f0b0g0u(as_7mhxd1_a0a0b0a5a1a6a02(myEditorComponent, jetbrains.mps.ide.tooltips.TooltipComponent.class), event)));
      }
    }
  }

  private boolean anchorsAreMarked = false;
  public void updateMarkOpacity(MouseEvent event) {
    if (!(TOOLTIP_RADAR_ENABLED)) {
      return;
    }
    if (!(anchorsAreMarked) && !(event.isControlDown())) {
      return;
    }
    List<ITooltip> tooltips = new ArrayList<ITooltip>();
    collectTooltips(myEditorComponent.getRootCell(), tooltips);
    Point eventPoint = event.getPoint();
    for (ITooltip tooltip : tooltips) {
      if (event.isControlDown()) {
        double distance = eventPoint.distance(tooltip.getCenter());
        float opacity = (float) (Math.exp(-distance / 150));
        if (opacity < 0.0f) {
          opacity = 0.0f;
        }
        tooltip.setMarkOpacity(opacity);
      } else {
        tooltip.setMarkOpacity(0.0f);
      }
    }
    if (event.isControlDown()) {
      anchorsAreMarked = true;
    }
  }

  public void collectTooltips(EditorCell root, List<ITooltip> result) {
    if (root instanceof ITooltipProvider) {
      List<ITooltip> list = ((ITooltipProvider) root).getTooltips();
      if (list != null) {
        result.addAll(list);
      }
    } else if (root instanceof ITooltip) {
      result.add(((ITooltip) root));
    }

    if (root instanceof EditorCell_Collection) {
      for (EditorCell child : ((EditorCell_Collection) root)) {
        collectTooltips(child, result);
      }
    }
  }

  protected EditorCell getCellAtPosition(int x, int y) {
    jetbrains.mps.nodeEditor.cells.EditorCell rootCell = myEditorComponent.getRootCell();
    EditorCell result = rootCell.findLeaf(x, y);
    if (result == null) {
      result = findDeepestCell(rootCell, x, y);
    }
    return result;
  }

  protected ITooltip getTooltipAt(int x, int y) {
    EditorCell leaf = getCellAtPosition(x, y);
    if (leaf == null) {
      return null;
    }
    for (EditorCell c = leaf; c != null; c = c.getParent()) {
      if (c instanceof ITooltipProvider) {
        ITooltipProvider provider = (ITooltipProvider) c;
        ITooltip tooltip = provider.getTooltipAt(x, y);
        if (tooltip != null) {
          return tooltip;
        }
      } else if (c instanceof ITooltip) {
        return (ITooltip) c;
      }
    }
    return null;
  }

  public EditorCell findDeepestCell(EditorCell cell, int x, int y) {
    if (cell.getX() <= x && x < cell.getX() + cell.getWidth() && cell.getY() <= y && y < cell.getY() + cell.getHeight()) {
      if (cell instanceof jetbrains.mps.nodeEditor.cells.EditorCell_Collection) {
        jetbrains.mps.nodeEditor.cells.EditorCell_Collection collection = ((jetbrains.mps.nodeEditor.cells.EditorCell_Collection) cell);
        for (EditorCell child : collection) {
          EditorCell result = findDeepestCell(child, x, y);
          if (result != null) {
            return result;
          }
        }
      }
      return cell;
    }
    return null;
  }


  private static String check_7mhxd1_a1a0f0b0g0u(jetbrains.mps.ide.tooltips.TooltipComponent checkedDotOperand, MouseEvent event) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getMPSTooltipText(event);
    }
    return null;
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
  private static <T> T as_7mhxd1_a0a0b0a5a1a6a02(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

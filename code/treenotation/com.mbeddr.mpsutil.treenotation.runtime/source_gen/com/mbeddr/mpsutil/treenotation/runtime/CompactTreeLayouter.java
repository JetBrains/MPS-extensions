package com.mbeddr.mpsutil.treenotation.runtime;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import java.awt.geom.Point2D;
import java.awt.Shape;
import java.awt.geom.GeneralPath;

public class CompactTreeLayouter extends OrthogonalTreeLayouter {
  public static final TreeLayoutType TYPE = new TreeLayoutType() {
    public ITreeLayouter createLayouter(TreeCell cell) {
      return new CompactTreeLayouter(cell);
    }
  };

  public CompactTreeLayouter(TreeCell treeCell) {
    super(treeCell);
  }

  @Override
  public void layoutCollapsed() {
    TreeCell tree = myTreeCell;

    final boolean transposed = tree.isLeftToRight();
    IBounds treeBounds = getBounds(tree, transposed);
    EditorCell rootCell = tree.getTreeRoot();
    IBounds rootBounds = getBounds(rootCell, transposed);

    rootCell.relayout();

    // fold button
    Button foldButton = tree.getFoldButton();
    int rootAndFoldCenterX = tree.getX() + rootBounds.getWidth() / 2;
    if (foldButton != null) {
      IBounds foldButtonBounds = getBounds(foldButton, transposed);
      foldButton.relayout();
      rootAndFoldCenterX = Math.max(rootAndFoldCenterX, tree.getX() + foldButton.getWidth() / 2);
      foldButtonBounds.moveTo(rootAndFoldCenterX - foldButtonBounds.getWidth() / 2, treeBounds.getY());
      foldButton.relayout();
      rootBounds.moveTo(rootAndFoldCenterX - rootBounds.getWidth() / 2, BoundsExtensions.getMaxY(foldButtonBounds) + BUTTON_MARGIN);
    } else {
      rootBounds.moveTo(treeBounds.getX(), treeBounds.getY());
    }

    rootCell.relayout();
    adjustToChildren(treeBounds, Sequence.fromIterable(((Iterable<EditorCell>) tree)).select((it) -> getBounds(it, transposed)), treeBounds.getX(), treeBounds.getY());
  }

  @Override
  public void layoutOnePass() {
    TreeCell tree = myTreeCell;

    int originalX = tree.getX();
    int originalY = tree.getY();

    final boolean transposed = tree.isLeftToRight();
    int levelSpacing = getLevelSpacing();
    int nodeSpacing = tree.getStyle().get(NODE_SPACING);
    IBounds treeBounds = getBounds(tree, transposed);

    EditorCell rootCell = tree.getTreeRoot();

    List<EditorCell> childCells = Sequence.fromIterable(tree.getTreeChildren()).toList();
    List<IBounds> childrenBounds = ListSequence.fromList(childCells).select((it) -> getBounds(it, transposed)).toList();
    List<Button> insertButtons = tree.getInsertButtons();
    List<IBounds> insertButtonsBounds = ListSequence.fromList(insertButtons).select((it) -> getBounds(it, transposed)).toList();

    rootCell.relayout();
    ListSequence.fromList(childCells).visitAll((it) -> it.relayout());
    ListSequence.fromList(insertButtons).visitAll((it) -> it.relayout());
    ensureSpaceForButtons(childrenBounds, nodeSpacing);

    // place root cell and fold button
    // all bounds are not transposed because the position is the same in both cases
    {
      Button foldButton = tree.getFoldButton();
      IBounds rootAndFoldBounds = new EditorCellBounds(rootCell);
      if (foldButton != null) {
        int marginY = Math.max(0, Button.BUTTON_SIZE - rootAndFoldBounds.getHeight());
        int marginTop = marginY;
        int marginBottom = marginY - marginTop;
        rootAndFoldBounds = new BoundsWithMargin(rootAndFoldBounds, Button.BUTTON_SIZE + BUTTON_MARGIN, 0, marginTop, marginBottom);
      }
      rootAndFoldBounds.moveTo(tree.getX(), tree.getY());
      rootCell.relayout();
      foldButton.moveTo(rootAndFoldBounds.getX(), BoundsExtensions.getCenterY(rootAndFoldBounds) - foldButton.getHeight() / 2);
      foldButton.relayout();
    }

    IBounds rootBounds = getBounds(rootCell, transposed);
    int childrenX = BoundsExtensions.getMaxX(rootBounds) + nodeSpacing;
    int childrenY = rootBounds.getY() + levelSpacing;
    placeChildren(ListSequence.fromList(childrenBounds).toList(), childrenX, childrenY, nodeSpacing, false);
    ListSequence.fromList(childCells).visitAll((it) -> it.relayout());

    // delete buttons
    {
      Iterator<IBounds> childBounds_it = ListSequence.fromList(childrenBounds).iterator();
      Iterator<Button> deleteButton_it = ListSequence.fromList(tree.getDeleteButtons()).iterator();
      Iterator<EditorCell> child_it = ListSequence.fromList(childCells).iterator();
      IBounds childBounds_var;
      Button deleteButton_var;
      EditorCell child_var;
      while (childBounds_it.hasNext() && deleteButton_it.hasNext() && child_it.hasNext()) {
        childBounds_var = childBounds_it.next();
        deleteButton_var = deleteButton_it.next();
        child_var = child_it.next();
        EditorCell childRoot = tree.getChildRoot(child_var);
        IBounds childRootBounds = getBounds(childRoot, transposed);
        IBounds deleteButtonBounds = getBounds(deleteButton_var, transposed);
        deleteButton_var.relayout();
        deleteButtonBounds.moveTo(BoundsExtensions.getCenterX(childRootBounds) - deleteButtonBounds.getWidth() / 2, BoundsExtensions.getMaxY(childRootBounds) + BUTTON_MARGIN);
        deleteButton_var.relayout();
      }
    }

    layoutInsertButtons(insertButtonsBounds, rootBounds, childrenBounds, nodeSpacing, insertButtons, childrenY, transposed);

    layoutIntermediateCells(tree, treeBounds, transposed, childrenBounds);
    adjustToChildren(treeBounds, Sequence.fromIterable(((Iterable<EditorCell>) tree)).select((it) -> getBounds(it, transposed)), treeBounds.getX(), treeBounds.getY());
  }

  @Override
  protected Point2D getStartPoint(EditorCell cell) {
    int levelSpacing = getLevelSpacing();
    int lineOffset = Math.max(1, levelSpacing / 2 - 2);
    if (myTreeCell.isLeftToRight()) {
      int x = cell.getX() + lineOffset;
      x = Math.min(x, cell.getX() + cell.getWidth() / 2);
      int y = cell.getY() + cell.getHeight() + TreeCell.ENDPOINT_SPACING;
      return new Point2D.Float(x, y);
    } else {
      int y = cell.getY() + lineOffset;
      y = Math.min(y, cell.getY() + cell.getHeight() / 2);
      int x = cell.getX() + cell.getWidth() + TreeCell.ENDPOINT_SPACING;
      return new Point2D.Float(x, y);
    }
  }

  @Override
  protected Shape createLine(Point2D start, Point2D end) {
    Point2D bendPoint;
    if (myTreeCell.isLeftToRight()) {
      bendPoint = new Point2D.Double(start.getX(), end.getY());
    } else {
      bendPoint = new Point2D.Double(end.getX(), start.getY());
    }

    GeneralPath path = new GeneralPath();
    path.moveTo(start.getX(), start.getY());
    path.lineTo(bendPoint.getX(), bendPoint.getY());
    path.lineTo(end.getX(), end.getY());
    return path;

  }

  @Override
  protected Integer getLevelSpacing() {
    return Math.max(super.getLevelSpacing(), 6);
  }

  @Override
  protected void ensureSpaceForButtons(List<IBounds> childrenBounds, int nodeSpacing) {
    int overlapInsertButtonWithChildCell = (Button.BUTTON_SIZE - nodeSpacing + 1) / 2;
    for (int i = 0; i < ListSequence.fromList(childrenBounds).count(); i++) {
      IBounds childBounds = ListSequence.fromList(childrenBounds).getElement(i);
      boolean isFirst = i == 0;
      boolean isLast = i == ListSequence.fromList(childrenBounds).count() - 1;

      // Only space for insert buttons required. Delete button is placed next to the root cell.
      int childMinWidth;
      if (isFirst && isLast) {
        childMinWidth = Button.BUTTON_SIZE + BUTTON_MARGIN + Button.BUTTON_SIZE;
      } else if (isFirst || isLast) {
        childMinWidth = Button.BUTTON_SIZE + BUTTON_MARGIN + overlapInsertButtonWithChildCell;
      } else {
        childMinWidth = overlapInsertButtonWithChildCell + BUTTON_MARGIN + overlapInsertButtonWithChildCell;
      }

      int margin = childMinWidth - childBounds.getWidth();
      if (margin > 0) {
        int leftMargin = 0;
        if (isFirst && isLast) {
          leftMargin = margin / 2;
        } else if (isFirst) {
          // align center between both buttons with the center of the child
          leftMargin = Button.BUTTON_SIZE + BUTTON_MARGIN / 2 - childBounds.getWidth() / 2;
          leftMargin = Math.max(0, Math.min(margin, leftMargin));
        } else if (isLast) {
          int rightMargin = Button.BUTTON_SIZE + BUTTON_MARGIN / 2 - childBounds.getWidth() / 2;
          rightMargin = Math.max(0, Math.min(margin, rightMargin));
          leftMargin = margin - rightMargin;
        } else {
          leftMargin = margin / 2;
        }
        ListSequence.fromList(childrenBounds).setElement(i, new BoundsWithMargin(childBounds, leftMargin, margin - leftMargin, 0, 0));
      }
    }
  }
}

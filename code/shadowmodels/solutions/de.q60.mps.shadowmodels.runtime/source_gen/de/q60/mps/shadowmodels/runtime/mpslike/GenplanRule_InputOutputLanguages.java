package de.q60.mps.shadowmodels.runtime.mpslike;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class GenplanRule_InputOutputLanguages implements IGenplanRule {
  @Override
  public Genplan apply(Genplan plan, Map<MappingConfigurationId, MappingConfiguration> mcs, int timeout) {

    for (MappingConfiguration mc1 : Sequence.fromIterable(MapSequence.fromMap(mcs).values())) {
      for (MappingConfiguration mc2 : Sequence.fromIterable(MapSequence.fromMap(mcs).values())) {
        IGenplanRule rule = null;
        if (SetSequence.fromSet(mc1.getInputLanguageIds()).subtract(SetSequence.fromSet(mc1.getOutputLanguageIds())).intersect(SetSequence.fromSet(mc2.getOutputLanguageIds()).subtract(SetSequence.fromSet(mc2.getInputLanguageIds()))).isNotEmpty()) {
          rule = new GenplanRule_After(Sequence.<MappingConfigurationId>singleton(mc1.getId()), Sequence.<MappingConfigurationId>singleton(mc2.getId()));
        }
        if (SetSequence.fromSet(mc1.getOutputLanguageIds()).subtract(SetSequence.fromSet(mc1.getInputLanguageIds())).intersect(SetSequence.fromSet(mc2.getInputLanguageIds()).subtract(SetSequence.fromSet(mc2.getOutputLanguageIds()))).isNotEmpty()) {
          if (rule == null) {
            rule = new GenplanRule_Before(Sequence.<MappingConfigurationId>singleton(mc1.getId()), Sequence.<MappingConfigurationId>singleton(mc2.getId()));
          } else {
            throw new RuntimeException("Conflict between " + mc1.getId() + " and " + mc2.getId());
          }
        }
        if (rule != null) {
          plan = rule.apply(plan, mcs, timeout);
        }
      }
    }

    return plan;
  }
}

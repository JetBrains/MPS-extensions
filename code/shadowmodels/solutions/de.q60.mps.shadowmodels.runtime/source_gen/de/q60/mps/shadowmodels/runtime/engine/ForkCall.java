package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import de.q60.mps.polymorphicfunctions.runtime.ParameterList;
import org.jetbrains.annotations.Nullable;
import java.util.Objects;
import org.modelix.model.api.INode;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class ForkCall implements IContainmentTarget, ISubgraphCall {
  private String id;
  private ParameterList parameters;
  private IContainmentTarget rootCall;
  @Nullable
  private String rewriterId;
  private boolean fixpoint;
  private String traceInfo;

  private ForkCall() {
    // for deserialization
  }

  public ForkCall(String id, ParameterList parameters, IContainmentTarget rootCall, boolean fixpoint, String rewriterId, String traceInfo) {
    DependencyTrackingCheck.check(parameters);
    this.id = id;
    this.parameters = parameters;
    this.rootCall = rootCall;
    this.fixpoint = fixpoint;
    this.rewriterId = rewriterId;
    this.traceInfo = traceInfo;
  }

  public String getId() {
    return this.id;
  }

  public ParameterList getParameters() {
    return this.parameters;
  }

  @Override
  public boolean hasContextParameter(String id) {
    for (int i = 0; i < parameters.size(); i++) {
      if (Objects.equals(id, this.id + "." + i)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public Object getContextParameter(String id) {
    for (int i = 0; i < parameters.size(); i++) {
      if (Objects.equals(id, this.id + "." + i)) {
        return parameters.get(i);
      }
    }
    return null;
  }

  public String getTraceInfo() {
    return this.traceInfo;
  }

  public ForkCall setTraceInfo(String traceInfo) {
    this.traceInfo = traceInfo;
    return this;
  }

  @Override
  public Iterable<INode> getInputNodes() {
    return Sequence.fromIterable(parameters.asSequence()).ofType(INode.class);
  }

  public String getRewriterId() {
    return this.rewriterId;
  }

  @Override
  public IContainmentTarget getRootCall() {
    return rootCall;
  }

  @Override
  public boolean isFixpoint() {
    return fixpoint;
  }

  @Override
  public String toString() {
    return id + "(" + parameters + ")";
  }

  private transient int _cachedHashCode;
  private transient boolean _hashCodeInitialized = false;
  @Override
  public int hashCode() {
    if (!(_hashCodeInitialized)) {
      int c = 0;
      c = 31 * c + Objects.hashCode(id);
      c = 31 * c + Objects.hashCode(parameters);
      c = 31 * c + Objects.hashCode(rootCall);
      c = 31 * c + Objects.hashCode(rewriterId);
      c = 31 * c + Objects.hashCode(fixpoint);
      _cachedHashCode = c;
      _hashCodeInitialized = true;
    }
    return _cachedHashCode;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    ForkCall that = (ForkCall) o;
    if (!(Objects.equals(id, that.id))) {
      return false;
    }
    if (!(Objects.equals(parameters, that.parameters))) {
      return false;
    }
    if (!(Objects.equals(rootCall, that.rootCall))) {
      return false;
    }
    if (!(Objects.equals(rewriterId, that.rewriterId))) {
      return false;
    }
    if (!(Objects.equals(fixpoint, that.fixpoint))) {
      return false;
    }
    return true;
  }
}

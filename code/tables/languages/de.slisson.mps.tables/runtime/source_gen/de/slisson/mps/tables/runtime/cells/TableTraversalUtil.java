package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import org.jetbrains.mps.util.Condition;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import de.slisson.mps.tables.runtime.gridmodel.Grid;
import de.slisson.mps.tables.runtime.simplegrid.GridPosition;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellGridLeaf;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class TableTraversalUtil {
  private static Condition<EditorCell> ALWAYS_TRUE_CONDITION = new Condition<EditorCell>() {
    public boolean met(EditorCell p0) {
      return true;
    }
  };

  public static Condition<EditorCell> GRID_CELL = new Condition<EditorCell>() {
    public boolean met(EditorCell cell) {
      return cell instanceof EditorCell_GridCell;
    }
  };

  public static Condition<EditorCell> TABLE_EDITOR = new Condition<EditorCell>() {
    public boolean met(EditorCell cell) {
      return cell instanceof TableEditor;
    }
  };


  private TableTraversalUtil() {
  }

  public static EditorCell getNextSibling(EditorCell cell) {
    return getSibling(cell, true);
  }

  public static EditorCell getPrevSibling(EditorCell cell) {
    return getSibling(cell, false);
  }

  public static EditorCell getSibling(EditorCell cell, boolean forward) {
    EditorCell_GridCell gridCell = as_bnvmg9_a0a0a31(cell, EditorCell_GridCell.class);
    if (gridCell != null) {
      Grid grid = gridCell.getTable().getGrid();

      GridPosition pos = gridCell.getGridPosition();
      pos = (forward ? grid.next(pos) : grid.previous(pos));
      while (pos != null) {
        EditorCell sibling = check_bnvmg9_a0a0e0b0n(as_bnvmg9_a0a0a0e0b0n(grid.getElement(pos), EditorCellGridLeaf.class));
        if (sibling != null) {
          return sibling;
        }
        pos = (forward ? grid.next(pos) : grid.previous(pos));
      }
      return null;
    }


    final EditorCell_Collection parent = getParent(cell);
    if (parent == null) {
      return null;
    }
    Iterator<EditorCell> cellIterator = (forward ? parent.iterator() : parent.reverseIterator());
    cellIterator = ListSequence.fromList(asList(cellIterator)).where((it) -> !(it instanceof PartialTableEditor)).iterator();
    while (cellIterator.hasNext()) {
      if (cellIterator.next().equals(cell) && cellIterator.hasNext()) {
        return cellIterator.next();
      }
    }
    return null;
  }

  private static <T> List<T> asList(Iterator<T> itr) {
    List<T> result = new ArrayList<T>();
    while (itr.hasNext()) {
      result.add(itr.next());
    }
    return result;
  }

  public static EditorCell getNextLeaf(@NotNull EditorCell cell) {
    EditorCell next = getNextSibling(cell);
    if (next != null) {
      return getFirstLeaf(next);
    }
    EditorCell_Collection parent = getParent(cell);
    if (parent != null) {
      return getNextLeaf(parent);
    }
    return null;
  }

  public static EditorCell getNextLeaf(@NotNull EditorCell cell, @NotNull Condition<EditorCell> condition) {
    EditorCell current = getNextLeaf(cell);
    while (current != null) {
      if (condition.met(current)) {
        return current;
      }
      EditorCell next = getNextLeaf(current);
      if (next == current) {
        throw new RuntimeException("next == current: " + next);
      }
      current = next;
    }
    return null;
  }

  public static EditorCell getPrevLeaf(@NotNull EditorCell cell) {
    EditorCell prev = getPrevSibling(cell);
    if (prev != null) {
      return getLastLeaf(prev);
    }
    EditorCell_Collection parent = getParent(cell);
    if (parent != null) {
      return getPrevLeaf(parent);
    }
    return null;
  }

  public static EditorCell getPrevLeaf(@NotNull EditorCell cell, @NotNull Condition<EditorCell> condition) {
    EditorCell current = getPrevLeaf(cell);
    while (current != null) {
      if (condition.met(current)) {
        return current;
      }
      EditorCell prev = getPrevLeaf(current);
      if (prev == current) {
        throw new RuntimeException("prev == current: " + prev);
      }
      current = prev;
    }
    return null;
  }

  private static EditorCell getFirstLastLeaf(EditorCell cell, boolean first) {
    if (cell instanceof EditorCell_Collection) {
      Iterator<EditorCell> itr = (first ? ((EditorCell_Collection) cell).iterator() : ((EditorCell_Collection) cell).reverseIterator());
      while (itr.hasNext()) {
        EditorCell child = itr.next();
        if (!(child instanceof PartialTableEditor)) {
          return getFirstLastLeaf(child, first);
        }
      }
    }
    return cell;
  }

  public static EditorCell getFirstLeaf(@NotNull EditorCell cell) {
    return getFirstLastLeaf(cell, true);
  }

  public static EditorCell getLastLeaf(@NotNull EditorCell cell) {
    return getFirstLastLeaf(cell, false);
  }

  public static EditorCell getLeafToLeft(final EditorCell cell, Condition<EditorCell> condition) {
    return getPrevLeaf(cell, new Condition<EditorCell>() {
      public boolean met(EditorCell current) {
        return current.isSelectable() && !(TableTraversalUtil.isAbove(cell, current)) && !(TableTraversalUtil.isBelow(cell, current)) && TableTraversalUtil.isToRight(cell, current);
      }
    });
  }

  public static EditorCell getLeafToRight(final EditorCell cell, Condition<EditorCell> condition) {
    return getNextLeaf(cell, new Condition<EditorCell>() {
      public boolean met(EditorCell current) {
        return current.isSelectable() && !(TableTraversalUtil.isAbove(cell, current)) && !(TableTraversalUtil.isBelow(cell, current)) && TableTraversalUtil.isToLeft(cell, current);
      }
    });
  }

  public static boolean isToRight(EditorCell cell, EditorCell right) {
    return isToLeft(right, cell);
  }

  public static boolean isToLeft(EditorCell cell, EditorCell left) {
    return cell.getX() + cell.getWidth() <= left.getX();
  }


  public static EditorCell getUpper(EditorCell cell, Condition<EditorCell> condition, int baseX) {
    EditorCell bestMatch = null;
    EditorCell current = getPrevLeaf(cell, condition);
    while (current != null) {
      if (isAbove(current, cell)) {
        if (bestMatch != null && isAbove(current, bestMatch)) {
          break;
        }
        if (bestMatch != null) {
          if (horizontalDistance(bestMatch, baseX) > horizontalDistance(current, baseX)) {
            bestMatch = current;
          }
        } else {
          bestMatch = current;
        }
      }
      current = getPrevLeaf(current, condition);
    }
    return bestMatch;
  }

  public static EditorCell getUpperInColumn(EditorCell cell, Condition<EditorCell> condition, int caretX) {
    EditorCell normalTarget = TableTraversalUtil.getUpper(cell, condition, caretX);
    EditorCell_GridCell gridCell = EditorCell_GridCell.getParentInstance(cell);
    if (gridCell != null) {
      if (EditorCell_GridCell.getParentInstance(normalTarget) == gridCell) {
        return normalTarget;
      }
      Grid grid = gridCell.getTable().getGrid();
      GridPosition currentGridPos = gridCell.getGridPosition();
      GridPosition aboveGridPos = currentGridPos.deriveY(currentGridPos.getY() - 1);
      if (grid.isValidPosition(aboveGridPos)) {
        EditorCell_GridCell aboveGridCell = (EditorCell_GridCell) check_bnvmg9_a0a0a4a2a24(as_bnvmg9_a0a0a0a4a2a24(grid.getElement(aboveGridPos), EditorCellGridLeaf.class));
        if (aboveGridCell != null) {
          EditorCell lastLeaf = TableTraversalUtil.getLastLeaf(aboveGridCell);
          EditorCell aboveBelow = getLower(lastLeaf, TableTraversalUtil.ALWAYS_TRUE_CONDITION, caretX);
          EditorCell target = getUpper(aboveBelow, new SameGridCellCondition(aboveGridCell), caretX);
          return target;
        }
      }
    }
    return TableTraversalUtil.getUpper(cell, condition, caretX);
  }

  public static EditorCell getLowerInColumn(EditorCell cell, final Condition<EditorCell> condition, int caretX) {
    EditorCell normalTarget = TableTraversalUtil.getLower(cell, condition, caretX);
    EditorCell_GridCell gridCell = EditorCell_GridCell.getParentInstance(cell);
    if (gridCell != null) {
      if (EditorCell_GridCell.getParentInstance(normalTarget) == gridCell) {
        return normalTarget;
      }
      Grid grid = gridCell.getTable().getGrid();
      GridPosition currentGridPos = gridCell.getGridPosition();
      GridPosition aboveGridPos = currentGridPos.deriveY(currentGridPos.getY() + 1);
      if (grid.isValidPosition(aboveGridPos)) {
        EditorCell_GridCell belowGridCell = (EditorCell_GridCell) check_bnvmg9_a0a0a4a2a44(as_bnvmg9_a0a0a0a4a2a44(grid.getElement(aboveGridPos), EditorCellGridLeaf.class));
        if (belowGridCell != null) {
          EditorCell firstLeaf = TableTraversalUtil.getFirstLeaf(belowGridCell);
          EditorCell above = getUpper(firstLeaf, TableTraversalUtil.ALWAYS_TRUE_CONDITION, caretX);
          EditorCell target = getLower(above, new SameGridCellCondition(belowGridCell), caretX);
          return target;
        }
      }
    }
    return normalTarget;
  }

  public static EditorCell getLower(EditorCell cell, Condition<EditorCell> condition, int baseX) {
    EditorCell bestMatch = null;
    EditorCell current = getNextLeaf(cell, condition);
    while (current != null) {
      if (isBelow(current, cell)) {
        if (bestMatch != null && isBelow(current, bestMatch)) {
          break;
        }
        if (bestMatch != null) {
          if (horizontalDistance(bestMatch, baseX) >= horizontalDistance(current, baseX)) {
            bestMatch = current;
          }
        } else {
          bestMatch = current;
        }
      }
      current = getNextLeaf(current, condition);
    }
    return bestMatch;
  }

  public static boolean isAbove(EditorCell above, EditorCell below) {
    return above.getY() + above.getHeight() <= below.getY();
  }

  public static boolean isBelow(EditorCell below, EditorCell above) {
    return isAbove(above, below);
  }

  private static int horizontalDistance(EditorCell cell, int x) {
    if (cell.getX() <= x && x <= cell.getX() + cell.getWidth()) {
      return 0;
    }
    return Math.min(Math.abs(cell.getX() - x), Math.abs(cell.getX() + cell.getWidth() - x));
  }

  public static int compare(@NotNull EditorCell firstCell, @NotNull EditorCell secondCell) {
    if (firstCell.equals(secondCell)) {
      return 0;
    }
    EditorCell parent = getCommonParent(firstCell, secondCell);
    assert parent != null;
    assert parent instanceof EditorCell_Collection;
    if (parent.equals(firstCell)) {
      return -1;
    }
    if (parent.equals(secondCell)) {
      return 1;
    }
    for (EditorCell cell : ((EditorCell_Collection) parent)) {
      if (isAncestor(cell, firstCell) || firstCell.equals(cell)) {
        return -1;
      }
      if (isAncestor(cell, secondCell) || secondCell.equals(cell)) {
        return 1;
      }
    }
    assert false;
    // this line should not be reached
    return 0;
  }

  public static EditorCell getCommonParent(@NotNull EditorCell firstCell, @NotNull EditorCell secondCell) {
    List<EditorCell> firstParents = getParents(firstCell, true);
    List<EditorCell> secondParents = getParents(secondCell, true);
    for (EditorCell cell : firstParents) {
      if (secondParents.contains(cell)) {
        return cell;
      }
    }
    return null;
  }

  public static List<EditorCell> getParents(@NotNull EditorCell cell, boolean includeThis) {
    List<EditorCell> parents = new ArrayList<EditorCell>();
    EditorCell tempCell = (includeThis ? cell : getParent(cell));
    while (tempCell != null) {
      parents.add(tempCell);
      tempCell = getParent(tempCell);
    }
    return parents;
  }

  public static boolean isAncestor(@NotNull EditorCell ancestor, @NotNull EditorCell child) {
    EditorCell_Collection parent = getParent(child);
    while (parent != null) {
      if (parent.equals(ancestor)) {
        return true;
      }
      parent = getParent(parent);
    }
    return false;
  }

  public static EditorCell_Collection getFoldedParent(@NotNull EditorCell cell) {
    for (EditorCell_Collection parent = getParent(cell); parent != null; parent = getParent(parent)) {
      if (parent.isCollapsed()) {
        return parent;
      }
    }
    return null;
  }

  public static EditorCell_Collection getParent(EditorCell cell) {
    if (cell instanceof EditorCell_GridCell) {
      return ((EditorCell_GridCell) cell).getTable();
    } else {
      return cell.getParent();
    }
  }

  public static EditorCell getParent(EditorCell cell, Condition<EditorCell> condition) {
    EditorCell parent = cell;
    while (parent != null && !(condition.met(parent))) {
      parent = parent.getParent();
    }
    return parent;
  }

  public static List<EditorCell> getDescendants(EditorCell cell, Condition<EditorCell> condition) {
    List<EditorCell> result = new ArrayList<EditorCell>();
    getDescendants(cell, condition, result);
    return result;
  }

  public static void getDescendants(EditorCell cell, @NotNull Condition<EditorCell> condition, List<EditorCell> accumulator) {
    if (cell == null) {
      return;
    }
    if (condition.met(cell)) {
      accumulator.add(cell);
    }
    EditorCell_Collection collection = as_bnvmg9_a0a2a07(cell, EditorCell_Collection.class);
    if (collection != null) {
      for (EditorCell child : Sequence.fromIterable(collection)) {
        getDescendants(child, condition, accumulator);
      }
    }
  }

  public static SNode getLowestCommonAncestor(Collection<SNode> descendants) {
    SNode candidate = CollectionSequence.fromCollection(descendants).first();
    while (candidate != null) {
      boolean ancestorOfAll = true;
      for (SNode descendant : CollectionSequence.fromCollection(descendants)) {
        if (candidate != descendant && !(ListSequence.fromList(SNodeOperations.getNodeAncestors(descendant, null, false)).contains(candidate))) {
          ancestorOfAll = false;
          break;
        }
      }
      if (ancestorOfAll) {
        return candidate;
      }
      candidate = SNodeOperations.getParent(candidate);
    }

    return null;
  }


  public static class SameGridCellCondition implements Condition<EditorCell> {
    private EditorCell_GridCell myGridCell;

    public SameGridCellCondition(EditorCell_GridCell gridCell) {
      myGridCell = gridCell;
    }

    public boolean met(EditorCell cell) {
      return EditorCell_GridCell.getParentInstance(cell) == myGridCell;
    }
  }
  private static EditorCell check_bnvmg9_a0a0e0b0n(EditorCellGridLeaf checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static EditorCell check_bnvmg9_a0a0a4a2a24(EditorCellGridLeaf checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static EditorCell check_bnvmg9_a0a0a4a2a44(EditorCellGridLeaf checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static <T> T as_bnvmg9_a0a0a31(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_bnvmg9_a0a0a0e0b0n(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_bnvmg9_a0a0a0a4a2a24(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_bnvmg9_a0a0a0a4a2a44(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_bnvmg9_a0a2a07(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

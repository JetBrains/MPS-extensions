package de.q60.mps.shadowmodels.runtime.model.persistent;

/*Generated by MPS */

import org.modelix.model.api.ITree;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.INodeReference;
import org.modelix.model.api.IConcept;
import org.modelix.model.api.IConceptReference;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class SM_WriteTransaction extends SM_Transaction implements SM_IWriteTransaction {
  protected ITree tree;
  private boolean closed = false;
  protected SM_IIdGenerator idGenerator;

  public SM_WriteTransaction(@NotNull ITree tree, SM_PBranch branch, SM_IIdGenerator idGenerator) {
    super(branch);
    this.tree = tree;
    this.idGenerator = idGenerator;
  }

  public void close() {
    closed = true;
  }

  protected void checkNotClosed() {
    if (closed) {
      throw new IllegalStateException("Transaction is already closed");
    }
  }

  @Override
  public SM_PTree getPTree() {
    return (SM_PTree) tree;
  }

  @Override
  public ITree getTree() {
    return tree;
  }

  @Override
  public void setTree(ITree newTree) {
    checkNotClosed();
    this.tree = newTree;
  }

  @Override
  public void setProperty(long nodeId, String role, String value) {
    checkNotClosed();
    tree = getTree().setProperty(nodeId, role, value);
  }

  @Override
  public void setUserObject(long nodeId, Object key, Object value) {
    checkNotClosed();
    tree = getPTree().setUserObject(nodeId, key, value);
  }

  @Override
  public void setReferenceTarget(long sourceId, String role, INodeReference target) {
    checkNotClosed();
    tree = getTree().setReferenceTarget(sourceId, role, target);
  }

  @Override
  public void moveChild(long newParentId, String newRole, int newIndex, long childId) {
    checkNotClosed();
    tree = getTree().moveChild(newParentId, newRole, newIndex, childId);
  }

  @Override
  public long addNewChild(long parentId, String role, int index, IConcept concept) {
    checkNotClosed();
    long newId = idGenerator.generate();
    addNewChild(parentId, role, index, newId, concept);
    return newId;
  }

  @Override
  public long addNewChild(long parentId, String role, int index, IConceptReference concept) {
    checkNotClosed();
    long newId = idGenerator.generate();
    addNewChild(parentId, role, index, newId, concept);
    return newId;
  }

  @Override
  public void addNewChild(long parentId, String role, int index, long childId, IConcept concept) {
    checkNotClosed();
    tree = getTree().addNewChild(parentId, role, index, childId, concept);
  }

  @Override
  public void addNewChild(long parentId, String role, int index, long childId, IConceptReference concept) {
    checkNotClosed();
    tree = getTree().addNewChild(parentId, role, index, childId, concept);
  }

  @Override
  public long addNewLazyChild(long parentId, String role, int index, IConcept concept) {
    throw new RuntimeException("Lazy nodes require a nodeLoader");
  }

  @Override
  public void deleteNode(long nodeId) {
    checkNotClosed();
    for (Long child : Sequence.fromIterable(getTree().getAllChildren(nodeId))) {
      deleteNode(child);
    }
    tree = getTree().deleteNode(nodeId);
  }

  @Override
  public void loadNode(long nodeId) {
    checkNotClosed();
    tree = getPTree().loadNode(nodeId);
  }
}

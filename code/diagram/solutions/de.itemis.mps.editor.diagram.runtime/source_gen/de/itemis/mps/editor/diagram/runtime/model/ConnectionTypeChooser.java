package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import de.itemis.mps.editor.diagram.runtime.jgraph.MyGraph;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Objects;
import org.jetbrains.annotations.NotNull;

public class ConnectionTypeChooser {
  private static final Logger LOG = Logger.getLogger(ConnectionTypeChooser.class);
  private MyGraph myGraph;

  private IConnectionType_Internal myPreferred = null;
  private IConnectionType_Internal myForced = null;

  public ConnectionTypeChooser(MyGraph graph) {
    myGraph = graph;
  }

  public List<IConnectionType_Internal> getConnectionTypes() {
    return Sequence.fromIterable(myGraph.getRootDiagramModel().getAllModels()).translate((it) -> it.getConnectionTypes()).toList();
  }

  public List<IConnectionType_Internal> getAllApplicable(@Nullable final Box fromBox, @Nullable final String fromPort, @Nullable final Box toBox, @Nullable final String toPort, final List<String> reasons) {
    final Wrappers._T<List<IConnectionType_Internal>> result = new Wrappers._T<List<IConnectionType_Internal>>(ListSequence.fromList(new ArrayList<IConnectionType_Internal>()));
    if (fromBox != null && toBox != null) {
      myGraph.getRootDiagramModel().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
        IConnectionType_Internal forced = getForced();
        if (forced != null) {
          if (forced.canCreate(fromBox, fromPort, toBox, toPort, reasons)) {
            ListSequence.fromList(result.value).addElement(forced);
          }
        } else {
          IConnectionType_Internal preferred = getPreferred();
          if (preferred != null) {
            if (preferred.canCreate(fromBox, fromPort, toBox, toPort, reasons)) {
              ListSequence.fromList(result.value).addElement(preferred);
            }
          }
          for (final IConnectionType_Internal c : ListSequence.fromList(getConnectionTypes())) {
            if (c == preferred) {
              continue;
            }
            if (c.canCreate(fromBox, fromPort, toBox, toPort, reasons) && ListSequence.fromList(result.value).all((it) -> {
              // fixme: temporal workaround for disabling same connection types with equal names (from different active diagrams)
              return !(Objects.equals(it.getName(), c.getName()));
            })) {
              ListSequence.fromList(result.value).addElement(c);
            }
          }
        }
      });

      // if it is not a cross diagram edge, use connection types from the common (sub-)diagram only
      if (fromBox.getModel() == toBox.getModel()) {
        List<IConnectionType_Internal> localTypes = ListSequence.fromList(result.value).where((it) -> it.getDiagramModel() == fromBox.getModel()).toList();
        if (ListSequence.fromList(localTypes).isNotEmpty()) {
          result.value = localTypes;
        }
      }
    }

    return result.value;
  }

  public IConnectionType_Internal getApplicable(@NotNull Box fromNode, @Nullable String fromPort, @NotNull Box toNode, @Nullable String toPort, List<String> reasons) {
    return ListSequence.fromList(getAllApplicable(fromNode, fromPort, toNode, toPort, reasons)).first();
  }

  public void setPreferred(IConnectionType_Internal type) {
    myPreferred = type;
  }

  public IConnectionType_Internal getPreferred() {
    List<IConnectionType_Internal> types = getConnectionTypes();
    if (myPreferred != null && !(ListSequence.fromList(types).contains(myPreferred))) {
      // Connection types may be recreated on each read.
      // Try to find the new entry by name.
      myPreferred = ListSequence.fromList(types).findFirst((it) -> Objects.equals(it.getName(), myPreferred.getName()));
    }
    return myPreferred;
  }

  public IConnectionType_Internal getForced() {
    List<IConnectionType_Internal> types = getConnectionTypes();
    if (myForced != null && types != null && !(ListSequence.fromList(types).contains(myForced))) {
      myForced = ListSequence.fromList(types).findFirst((it) -> Objects.equals(it.getName(), myForced.getName()));
    }
    return myForced;
  }

  public void setForced(IConnectionType_Internal forced) {
    myForced = forced;
  }

  public boolean validateConnection(@NotNull final Box fromNode, @Nullable final Port fromPort, @NotNull final Box toNode, @Nullable final Port toPort, final List<String> reasons) {
    try {
      final Wrappers._boolean valid = new Wrappers._boolean(false);
      myGraph.getRootDiagramModel().getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
        IConnectionType_Internal connectionType = getApplicable(fromNode, check_fhj2ox_b0a0a0b0a0v(fromPort), toNode, check_fhj2ox_d0a0a0b0a0v(toPort), reasons);
        valid.value = connectionType != null;
      });
      return valid.value;
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("Validate method has thrown an exception", ex);
      }
      reasons.add("Validate method has thrown an exception: " + ex.getMessage());
      return false;
    }
  }
  private static String check_fhj2ox_b0a0a0b0a0v(Port checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
  private static String check_fhj2ox_d0a0a0b0a0v(Port checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
}

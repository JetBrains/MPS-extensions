package com.mbeddr.mpsutil.grammarcells.runtime;

/*Generated by MPS */

import jetbrains.mps.smodel.action.AbstractSubstituteAction;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.util.PatternUtil;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class MultiTextSubsituteAction extends AbstractSubstituteAction {

  private Iterable<String> myMatchingTexts;

  public MultiTextSubsituteAction(SNode sourceNode, Iterable<String> matchingTexts) {
    super(sourceNode);
    myMatchingTexts = matchingTexts;
  }

  public String getDescriptionText(String pattern) {
    String description = SPropertyOperations.getString(SNodeOperations.as(getOutputConcept(), CONCEPTS.AbstractConceptDeclaration$KA), PROPS.conceptShortDescription$is9d);
    return ((description != null && description.length() > 0) ? description : getOutputConcept().getName());
  }

  public String getMatchingText(String pattern) {
    return getBestMatchingText(pattern);
  }

  protected String getBestMatchingText(String pattern) {
    if (Sequence.fromIterable(myMatchingTexts).isEmpty()) {
      return null;
    }
    if (Sequence.fromIterable(myMatchingTexts).count() == 1) {
      return Sequence.fromIterable(myMatchingTexts).first();
    }
    if ((pattern != null && pattern.length() > 0)) {
      for (String matchingText : myMatchingTexts) {
        if (matchingText.charAt(0) != pattern.charAt(0)) {
          continue;
        }
        if (matchingText.startsWith(pattern)) {
          return matchingText;
        }
        if (matchingText.matches(PatternUtil.getExactItemPatternBuilder(pattern, false, false).toString() + ".*")) {
          return matchingText;
        }
      }
    }
    return Sequence.fromIterable(myMatchingTexts).first();
  }

  public Iterable<SubstituteAction> getMultipleActions() {
    return Sequence.fromIterable(myMatchingTexts).select((it) -> {
      SubstituteAction action = new SingleAction(it, getSourceNode());
      return action;
    });
  }

  public Iterable<SubstituteAction> getMultipleOrSingleAction(boolean multiple) {
    return (multiple ? getMultipleActions() : Sequence.<SubstituteAction>singleton(this));
  }

  public class SingleAction extends AbstractSubstituteAction implements SubstituteAction {
    private String myMatchingText;
    public SingleAction(String matchingText, SNode sourceNode) {
      super(sourceNode);
      myMatchingText = matchingText;
    }
    public String getMatchingText(String pattern) {
      return myMatchingText;
    }
    public String getDescriptionText(String string) {
      return MultiTextSubsituteAction.this.getDescriptionText(myMatchingText);
    }
    @Override
    protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
      return MultiTextSubsituteAction.this.doSubstitute(editorContext, myMatchingText);
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractConceptDeclaration$KA = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration");
  }

  private static final class PROPS {
    /*package*/ static final SProperty conceptShortDescription$is9d = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x403a32c5772bbe20L, "conceptShortDescription");
  }
}

package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.model.mxCell;
import de.itemis.mps.editor.diagram.runtime.model.SerializableObjectHolder;
import com.mxgraph.model.mxGeometry;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import de.itemis.mps.editor.diagram.runtime.model.ScalableEditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import de.itemis.mps.editor.celllayout.runtime.LayoutEngine;
import java.util.List;
import java.util.ArrayList;

public abstract class BaseDCell extends mxCell implements IDiagramDCell {

  protected SerializableObjectHolder<MyGraph> myGraph;
  protected boolean allowElementsToBeBelowRequiredSize = false;

  public BaseDCell(MyGraph graph) {
    this(null, new mxGeometry(), "", graph);
  }

  public BaseDCell(Object value, mxGeometry geometry, String style, MyGraph graph) {
    super(value, geometry, style);
    myGraph = new SerializableObjectHolder<MyGraph>(graph);
  }

  public void setAllowElementsToBeBelowRequiredSize(boolean flag) {
    allowElementsToBeBelowRequiredSize = flag;
  }

  @Nullable
  public Tuples._2<Double, Double> getRequiredSize() {
    final Wrappers._T<Tuples._2<Double, Double>> result = new Wrappers._T<Tuples._2<Double, Double>>(MultiTuple.<Double,Double>from(0.0, 0.0));
    ScalableEditorCell.withScalingDisabled(() -> {
      if (BaseDCell.this instanceof IMPSCellContainer) {
        for (MPSCell mpsCell : ListSequence.fromList(((IMPSCellContainer) BaseDCell.this).getMPSCells())) {
          Tuples._2<Double, Double> minSize = getMinSize(mpsCell);
          if (minSize != null) {
            if (result.value == null) {
              result.value = minSize;
            } else {
              result.value = MultiTuple.<Double,Double>from(Math.max((double) result.value._0(), (double) minSize._0()), Math.max((double) result.value._1(), (double) minSize._1()));
            }
          }
        }
      }
    });
    return result.value;
  }

  public void adjustAndSetBounds(Bounds bounds) {
    if (this._getGraph().getRootDiagramModel().getDiagramAccessor().allowElementsToBeBelowRequiredSize()) {
      for (MPSCell mpsCell : ListSequence.fromList(getMPSCells())) {
        mpsCell.setMaxWidthAttribute(bounds.getWidthInt());
      }
    }

    Tuples._2<Double, Double> requiredSize = getRequiredSize();
    if (bounds.getWidth() < (double) requiredSize._0()) {
      bounds.setWidth((double) requiredSize._0());
    }
    if (bounds.getHeight() < (double) requiredSize._1()) {
      bounds.setHeight((double) requiredSize._1());
    }
    CellExtensions.setBounds(this, bounds);
  }

  public void adjustAndSetBounds(double x, double y, double width, double height) {
    Tuples._2<Double, Double> requiredSize = getRequiredSize();
    CellExtensions.setBounds(this, x, y, Math.max(width, (double) requiredSize._0()), Math.max(height, (double) requiredSize._1()));
  }

  public Tuples._2<Double, Double> getMinSize(MPSCell mpsCell) {
    return mpsCell.getMinSize();
  }

  public void fitSize() {
    Tuples._2<Double, Double> requiredSize = getRequiredSize();
    if (requiredSize != null) {
      Bounds bounds = CellExtensions.getBounds(this);
      bounds.setSize((double) requiredSize._0(), (double) requiredSize._1());
      CellExtensions.setBounds(this, bounds);
    }
  }

  public MyGraph _getGraph() {
    return myGraph.get();
  }

  public double getScale() {
    return _getGraph().getView().getScale();
  }

  @Override
  public String getTooltipText() {
    return null;
  }
  @Override
  public boolean constrainPosition() {
    return true;
  }

  @Override
  public boolean canDrop(Object data) {
    return false;
  }
  @Override
  public void drop(Object data) {
  }

  public void layoutMPSCells() {
    for (MPSCell mpsCell : ListSequence.fromList(getMPSCells())) {
      new LayoutEngine().layoutCell(mpsCell.getEditorCell());
    }
  }

  public List<MPSCell> getMPSCells() {
    if (this instanceof IMPSCellContainer) {
      return ((IMPSCellContainer) this).getMPSCells();
    } else {
      return new ArrayList<MPSCell>();
    }
  }
}

package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.selection.AbstractSelection;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.openapi.editor.EditorComponent;
import java.util.Map;
import jetbrains.mps.openapi.editor.cells.CellInfo;
import jetbrains.mps.openapi.editor.selection.SelectionStoreException;
import jetbrains.mps.nodeEditor.selection.SelectionRestoreException;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.selection.SelectionInfoImpl;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import de.slisson.mps.editor.multiline.runtime.ClipboardUtils;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.openapi.editor.selection.SelectionInfo;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import java.awt.Graphics2D;
import java.awt.Color;
import com.intellij.openapi.editor.colors.EditorColorsManager;
import com.intellij.openapi.editor.colors.EditorColors;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import java.util.Collections;
import org.jetbrains.mps.openapi.model.SNode;

public class MultilineSelection extends AbstractSelection {
  private static final Logger LOG = Logger.getLogger(MultilineSelection.class);
  private static final String PROPERTY_SELECTION_START = "selectionStart";
  private static final String PROPERTY_SELECTION_END = "selectionEnd";
  private EditorCell_Multiline myMultilineCell;
  private int mySelectionStart;
  /**
   * can be lower than mySelectionStart
   */
  private int mySelectionEnd;
  public MultilineSelection(EditorComponent editorComponent, Map<String, String> properties, CellInfo cellInfo) throws SelectionStoreException, SelectionRestoreException {
    super(editorComponent);
    if (cellInfo == null) {
      throw new SelectionStoreException("Required CellInfo parameter is null");
    }
    EditorCell editorCell = cellInfo.findCell(((jetbrains.mps.nodeEditor.EditorComponent) editorComponent));
    if (editorCell instanceof EditorCell_Multiline) {
      myMultilineCell = (EditorCell_Multiline) editorCell;
    } else {
      throw new SelectionRestoreException();
    }
    int start = SelectionInfoImpl.Util.getIntProperty(properties, PROPERTY_SELECTION_START);
    int end = SelectionInfoImpl.Util.getIntProperty(properties, PROPERTY_SELECTION_END);
    setSelectionRange(start, end);
  }
  public MultilineSelection(EditorComponent editorComponent, EditorCell_Multiline multilineCell, int start, int end) {
    super(editorComponent);
    myMultilineCell = multilineCell;
    setSelectionRange(start, end);
  }
  public void setSelectionStart(int newValue) {
    setSelectionRange(newValue, mySelectionEnd);
  }
  public int getSelectionStart() {
    return mySelectionStart;
  }
  public int getSelectionEnd() {
    return mySelectionEnd;
  }
  public void setSelectionEnd(int newValue) {
    setSelectionRange(mySelectionStart, newValue);
  }
  public void setSelectionRange(int selStart, int selEnd) {
    mySelectionStart = selStart;
    mySelectionEnd = selEnd;
  }
  public EditorCell_Multiline getMultilineCell() {
    return myMultilineCell;
  }
  public void updateVisibleSelection(int selStart, int selEnd) {
    int caretPos = selEnd;
    if (selStart > selEnd) {
      int temp = selStart;
      selStart = selEnd;
      selEnd = temp;
    }
    int wordStart = 0;
    for (EditorCell_Word wordCell : Sequence.fromIterable(myMultilineCell.getWordCells())) {
      int wordLength = wordCell.getText().length();
      int wordEnd = wordStart + wordLength;
      if (wordStart <= caretPos && caretPos <= wordEnd && selEnd != selStart) {
        int newCaretPosition = caretPos - wordStart;
        if (wordCell.isCaretPositionAllowed(newCaretPosition)) {
          wordCell.setCaretPosition(newCaretPosition);
        }
      }
      wordCell.setSelectionStart(limitValue(selStart - wordStart, 0, wordLength));
      wordCell.setSelectionEnd(limitValue(selEnd - wordStart, 0, wordLength));
      wordStart += wordCell.getTextIncludingSeparator().length();
    }
  }
  public void activate() {
    ((jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent()).repaint();
  }
  public void deactivate() {
    updateVisibleSelection(0, 0);
  }
  public void ensureVisible() {
    EditorCell caretCell = myMultilineCell.getWordCellContainingPos(mySelectionEnd);
    if (caretCell == null) {
      return;
    }
    getEditorComponent().scrollToCell(caretCell);
  }
  @Override
  public void executeAction(CellActionType type) {
    if (CellActionType.SELECT_LEFT == type || CellActionType.SELECT_RIGHT == type) {
      int newEnd = (type == CellActionType.SELECT_LEFT ? mySelectionEnd - 1 : mySelectionEnd + 1);
      changeSelection(newEnd);
    } else if (type == CellActionType.DELETE || type == CellActionType.BACKSPACE) {
      executeDeleteSelectedText();
    } else if (type == CellActionType.COPY) {
      ClipboardUtils.setClipboardText(getSelectedText());
    } else if (type == CellActionType.CUT) {
      executeAction(CellActionType.COPY);
      executeDeleteSelectedText();
    } else if (type == CellActionType.PASTE) {
      pasteClipboardText();
    } else if (type == CellActionType.SELECT_PREVIOUS || type == CellActionType.SELECT_UP) {
      selectUpOrDown(true);
    } else if (type == CellActionType.SELECT_NEXT || type == CellActionType.SELECT_DOWN) {
      selectUpOrDown(false);
    } else if (type == CellActionType.LEFT || type == CellActionType.RIGHT || type == CellActionType.DOWN || type == CellActionType.UP) {
      clearSelection();
    } else {
      if (LOG.isInfoLevel()) {
        LOG.info("unhandled action: " + type);
      }
    }
  }
  @Override
  public boolean canExecuteAction(CellActionType type) {
    switch (type) {
      case SELECT_LEFT:
      case SELECT_RIGHT:
      case DELETE:
      case BACKSPACE:
      case COPY:
      case CUT:
      case PASTE:
      case SELECT_PREVIOUS:
      case SELECT_UP:
      case SELECT_NEXT:
      case SELECT_DOWN:
      case LEFT:
      case RIGHT:
      case DOWN:
      case UP:
        return true;
      default:
        return false;
    }
  }

  public String getSelectedText() {
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.max(mySelectionStart, mySelectionEnd);
    return myMultilineCell.getText().substring(first, last);
  }
  public void clearSelection() {
    int caretPos = mySelectionEnd;
    setSelectionRange(caretPos, caretPos);
    myMultilineCell.setCaretPosition(caretPos, true);
  }
  public void pasteClipboardText() {
    getEditorComponent().getEditorContext().getRepository().getModelAccess().executeCommand(() -> {
      deleteSelectedText();
      String textToInsert = ClipboardUtils.getClipboardText();
      myMultilineCell.insertText(textToInsert);
    });
  }
  public void selectUpOrDown(boolean up) {
    EditorCell_Word cursorCell = myMultilineCell.getWordCellContainingPos(mySelectionEnd);
    int newCaretPosition = mySelectionEnd - myMultilineCell.getCellStartPosition(cursorCell);
    if (cursorCell.isCaretPositionAllowed(newCaretPosition)) {
      cursorCell.setCaretPosition(newCaretPosition);
    }
    EditorCell upperOrLower = (up ? SelectionUtil.getUpper(cursorCell) : SelectionUtil.getLower(cursorCell));
    if (!(upperOrLower instanceof EditorCell_Word)) {
      return;
    }
    EditorCell_Word upperOrLowerWordCell = (EditorCell_Word) upperOrLower;
    if (upperOrLowerWordCell.getParent() != myMultilineCell) {
      return;
    }

    upperOrLowerWordCell.setCaretX(cursorCell.getCaretX());
    int newEnd = myMultilineCell.getTextBefore(upperOrLowerWordCell, upperOrLowerWordCell.getCaretPosition()).length();
    changeSelection(newEnd);
  }
  public void executeDeleteSelectedText() {
    ModelAccess modelAccess = getEditorComponent().getEditorContext().getRepository().getModelAccess();
    if (modelAccess.canWrite()) {
      deleteSelectedText();
    } else {
      modelAccess.executeCommand(() -> deleteSelectedText());
    }
  }
  public void deleteSelectedText() {
    String text = myMultilineCell.getText();
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.min(Math.max(mySelectionStart, mySelectionEnd), text.length());
    text = text.substring(0, first) + text.substring(last, text.length());
    myMultilineCell.setText(text);
    setSelectionRange(0, 0);
    myMultilineCell.setCaretPosition(first, true);
  }
  private void changeSelection(int newEnd) {
    if (newEnd < 0 || newEnd > myMultilineCell.getTextLength()) {
      return;
    }
    SelectionManager selectionManager = getEditorComponent().getSelectionManager();
    Selection newSelection;
    if (newEnd != mySelectionEnd) {
      newSelection = new MultilineSelection(getEditorComponent(), myMultilineCell, mySelectionStart, newEnd);
    } else {
      newSelection = selectionManager.createSelection(myMultilineCell.getParent());
      if (newSelection instanceof SingularSelection) {
        ((SingularSelection) newSelection).setSideSelectDirection((mySelectionStart > newEnd ? SingularSelection.SideSelectDirection.LEFT : SingularSelection.SideSelectDirection.RIGHT));
      }
    }
    selectionManager.setSelection(newSelection);
  }
  public SelectionInfo getSelectionInfo() throws SelectionStoreException {
    SelectionInfoImpl selectionInfo = new SelectionInfoImpl(this.getClass().getName(), PersistenceFacade.getInstance().createModuleReference("dc038ceb-b7ea-4fea-ac12-55f7400e97ba(de.slisson.mps.editor.multiline.runtime)"));
    selectionInfo.setCellInfo(myMultilineCell.getCellInfo());
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_START, Integer.toString(mySelectionStart));
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_END, Integer.toString(mySelectionEnd));
    return selectionInfo;
  }
  public boolean isSame(Selection other) {
    if (this == other) {
      return true;
    }
    if (other == null || getClass() != other.getClass()) {
      return false;
    }
    MultilineSelection otherSelection = (MultilineSelection) other;
    if (!(myMultilineCell.equals(otherSelection.myMultilineCell))) {
      return false;
    }
    if (mySelectionStart != otherSelection.mySelectionStart) {
      return false;
    }
    if (mySelectionEnd != otherSelection.mySelectionEnd) {
      return false;
    }
    return true;
  }
  public void paintSelection(Graphics2D g) {
    Color color = EditorColorsManager.getInstance().getGlobalScheme().getColor(EditorColors.SELECTION_BACKGROUND_COLOR);
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.max(mySelectionStart, mySelectionEnd);
    jetbrains.mps.nodeEditor.EditorComponent.turnOnAliasingIfPossible(g);
    myMultilineCell.paintRange(g, first, last, color, true);
  }
  public int getCaretPosition() {
    return mySelectionEnd;
  }
  public EditorCell_Word getCellContainingCaret() {
    return myMultilineCell.getWordCellContainingPos(getCaretPosition());
  }
  public static int limitValue(int value, int min, int max) {
    int result = value;
    result = Math.min(result, max);
    result = Math.max(result, min);
    return result;
  }
  @NotNull
  @Override
  public List<EditorCell> getSelectedCells() {
    return Collections.singletonList((EditorCell) myMultilineCell);
  }
  @NotNull
  @Override
  public List<SNode> getSelectedNodes() {
    return Collections.singletonList(myMultilineCell.getSNode());
  }
}

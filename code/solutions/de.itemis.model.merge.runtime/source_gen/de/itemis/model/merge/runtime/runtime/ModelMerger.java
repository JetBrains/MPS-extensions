package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import com.google.common.collect.ImmutableMap;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Collection;
import com.google.common.collect.BiMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import com.google.common.collect.ImmutableBiMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.stream.Stream;
import java.util.Objects;
import java.util.LinkedList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import com.google.common.collect.HashBiMap;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import com.google.common.collect.Lists;
import java.util.Set;
import com.google.common.collect.Sets;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.mps.openapi.language.SProperty;
import com.google.common.collect.Multimap;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import com.google.common.collect.ImmutableMultimap;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

/**
 * Given a ModelMerge Definition will merge a list of two root nodes accordingly
 */
public class ModelMerger {

  private MergerResolverImpl modelMergeResult;

  private ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction;

  public ModelMerger(MergerResolverImpl modelMergeResult) {
    this.modelMergeResult = modelMergeResult;
    ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction = modelMergeResult.conceptToIdFunction();
    ImmutableMap.Builder<SAbstractConcept, Identity> builder = ImmutableMap.<SAbstractConcept,Identity>builder();
    for (Map.Entry<SAbstractConcept, Identity> e : SetSequence.fromSet(conceptToIdFunction.entrySet())) {
      final SAbstractConcept concept = e.getKey();
      final Identity identity = e.getValue();
      builder.put(concept, (SNode n) -> identity.get(n) + concept);
    }
    this.conceptToIdFunction = builder.build();
  }

  public static ModelMerger create(SNode mergingPolicy) {
    MergerResolverImpl modelMergeResult = PolicyMergerResolver.run(mergingPolicy, new ContentHolderFactoryExtension(mergingPolicy));
    return new ModelMerger(modelMergeResult);
  }


  /**
   * 
   * 
   * @param leftRoots root nodes left
   * @param rightRoots root nodes right
   * @return merged result of descendantes of both roots
   */
  public Iterable<MergedNode> merge(Collection<? extends SNode> leftRoots, Collection<? extends SNode> rightRoots) {
    BiMap<String, SNode> idToLeftNodes = makeIdToNodeMap(leftRoots, conceptToIdFunction);
    final BiMap<String, SNode> idToRightNodes = makeIdToNodeMap(rightRoots, conceptToIdFunction);


    List<MergedNode> mergedWithoutReferences = Sequence.fromIterable(mergeWithoutReferences(leftRoots, conceptToIdFunction, modelMergeResult, rightRoots)).toList();

    Map<String, SNode> idToMergedNode = makeIdToMergedNode(mergedWithoutReferences);

    Collection<String> handeledRightIds = mergeReferences(idToLeftNodes, idToRightNodes, modelMergeResult, idToMergedNode);

    CollectionSequence.fromCollection(handeledRightIds).visitAll((it) -> idToRightNodes.remove(it));
    mergeReferences(idToRightNodes, ImmutableBiMap.<String,SNode>builder().build(), modelMergeResult, idToMergedNode);

    return mergedWithoutReferences;
  }

  private Map<String, SNode> makeIdToMergedNode(List<MergedNode> mergedWithoutReferences) {
    final ImmutableMap.Builder<String, SNode> builder = ImmutableMap.<String,SNode>builder();
    for (final MergedNode e : ListSequence.fromList(mergedWithoutReferences)) {
      Stream.of(e.id1, e.id2).filter((String s) -> !(Objects.isNull(s))).distinct().forEach((String s) -> builder.put(s, e.node));
    }

    return builder.build();
  }

  private Collection<String> mergeReferences(BiMap<String, SNode> idToLeftNodes, BiMap<String, SNode> idToRightNodes, MergerResolverImpl modelMergeResult, Map<String, SNode> idToMergedNode) {
    List<String> handledRightIds = ListSequence.fromList(new LinkedList<String>());
    for (Map.Entry<String, SNode> e : SetSequence.fromSet(idToLeftNodes.entrySet())) {
      String id = e.getKey();
      SNode mergedNodeWithoutRef = idToMergedNode.get(id);

      SNode rightNode = idToRightNodes.get(id);
      SNode leftNode = idToLeftNodes.get(id);

      assert (leftNode != null) || (rightNode != null);

      SNode mergedNode;
      if ((rightNode != null) && (leftNode != null)) {
        ListSequence.fromList(handledRightIds).addElement(id);
        assert SNodeOperations.getConcept(leftNode).equals(SNodeOperations.getConcept(rightNode)) : "Left / Right Concepts do not match " + SNodeOperations.getConcept(leftNode) + "/" + SNodeOperations.getConcept(rightNode);

        for (SReference mergedReference : Sequence.fromIterable(leftNode.getReferences())) {
          SReferenceLink link = mergedReference.getLink();

          SNode mergedLeftRefed = findMergedRefed(leftNode, link, idToLeftNodes, idToMergedNode);
          SNode mergedRightRefed = findMergedRefed(rightNode, link, idToRightNodes, idToMergedNode);

          ConceptRefMerger referenceMerger = modelMergeResult.referenceMergerFor(SNodeOperations.getConcept(mergedNodeWithoutRef), link);
          mergedNode = referenceMerger.merge(mergedLeftRefed, mergedRightRefed);
          if ((mergedNode != null)) {
            mergedNodeWithoutRef.setReferenceTarget(link, mergedNode);
          }
        }

      } else {
        SNode originalNode = ((leftNode != null) ? leftNode : rightNode);
        BiMap<String, SNode> idToOrginalNode = ((leftNode != null) ? idToLeftNodes : idToRightNodes);

        for (SReference mergedReference : Sequence.fromIterable(originalNode.getReferences())) {
          SReferenceLink link = mergedReference.getLink();
          SNode findMergedRefed = findMergedRefed(originalNode, link, idToOrginalNode, idToMergedNode);
          if ((findMergedRefed != null)) {
            mergedNodeWithoutRef.setReferenceTarget(link, findMergedRefed);
          }
        }
      }
    }
    return handledRightIds;
  }

  private SNode findMergedRefed(SNode leftNode, SReferenceLink link, BiMap<String, SNode> idToLeftNodes, Map<String, SNode> idToMergedNode) {
    SNode target = leftNode.getReference(link).getTargetNode();
    String id = idToLeftNodes.inverse().get(target);
    return idToMergedNode.get(id);
  }

  private BiMap<String, SNode> makeIdToNodeMap(Iterable<? extends SNode> mergedWithoutReferences, ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction) {
    List<SNode> allNodes = Sequence.fromIterable(mergedWithoutReferences).translate((it) -> SNodeOperations.getNodeDescendants(it, null, false, new SAbstractConcept[]{})).distinct().union(Sequence.fromIterable(mergedWithoutReferences)).toList();

    BiMap<String, SNode> idToNodeMap = HashBiMap.create();
    for (SNode node : ListSequence.fromList(allNodes)) {
      Identity identity = conceptToIdFunction.get(SNodeOperations.getConcept(node));
      assert identity != null : "No Identity-Function found for concept " + SNodeOperations.getConcept(node);
      String id = identity.get(node);

      SNode oldNode = idToNodeMap.putIfAbsent(id, node);
      assert oldNode == null : "For id " + id + " two nodes are present: " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(oldNode) + "  -AND- " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(node);
    }
    return idToNodeMap;
  }

  private Iterable<MergedNode> mergeWithoutReferences(Collection<? extends SNode> leftRoots, final ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction, final MergerResolverImpl modelMergeResult, final Collection<? extends SNode> rightRoots) {

    List<MergedNode> leftMergedRoots = CollectionSequence.fromCollection(leftRoots).select((leftRoot) -> transitiveMerge(conceptToIdFunction, rightRoots, modelMergeResult, leftRoot)).toList();

    Collection<? extends SNode> umergedRightRoots = computeUnmergedRightRoots(leftRoots, conceptToIdFunction, rightRoots, modelMergeResult);


    return ListSequence.fromList((CollectionSequence.fromCollection(umergedRightRoots).select((rightRoot) -> transitiveMerge(conceptToIdFunction, Lists.<SNode>newLinkedList(), modelMergeResult, rightRoot)).toList())).union(ListSequence.fromList(leftMergedRoots)).toList();
  }

  private Collection<? extends SNode> computeUnmergedRightRoots(Collection<? extends SNode> leftRoots, final ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction, Collection<? extends SNode> rightRoots, final MergerResolverImpl modelMergeResult) {

    final Set<String> leftIds = Sets.newHashSet(CollectionSequence.fromCollection(leftRoots).select((it) -> idOf(conceptToIdFunction, it)));
    Collection<? extends SNode> remaingRightRoots = CollectionSequence.fromCollection(rightRoots).where((it) -> !(SetSequence.fromSet(leftIds).contains(idOf(conceptToIdFunction, it)))).toList();
    CollectionSequence.fromCollection(remaingRightRoots).select((rightRoot) -> transitiveMerge(conceptToIdFunction, Lists.<SNode>newLinkedList(), modelMergeResult, rightRoot));
    return remaingRightRoots;
  }

  private MergedNode transitiveMerge(ImmutableMap<SAbstractConcept, Identity> conceptToIdFunction, Collection<? extends SNode> rightRoots, MergerResolverImpl modelMergeResult, SNode leftRoot) {

    SNode rightMatch = findMatchingRoot(idOf(conceptToIdFunction, leftRoot), conceptToIdFunction, rightRoots);

    assert rightMatch == null || leftRoot.getConcept().equals(rightMatch.getConcept()) : "Concepts of Matched Nodes differ " + leftRoot.getConcept() + " != " + rightMatch.getConcept();

    return makeMergedNode(leftRoot, rightMatch, modelMergeResult);
  }

  private SNode findMatchingRoot(final String id, final ImmutableMap<SAbstractConcept, Identity> conceptToId, Collection<? extends SNode> rightNodes) {
    return CollectionSequence.fromCollection(rightNodes).findFirst((it) -> idOf(conceptToId, it).equals(id));
  }
  private String idOf(ImmutableMap<SAbstractConcept, Identity> conceptToId, SNode it) {
    return conceptToId.get(it.getConcept()).get(it);
  }

  private MergedNode makeMergedNode(SNode leftNode, SNode rightNode, MergerResolver mergerResolver) {
    SNode newInstance = newInstanceOf(leftNode);
    String leftId = this.conceptToIdFunction.get(leftNode.getConcept()).get(leftNode);

    if (rightNode != null) {
      List<SNode> leftSmodelAttribute = SLinkOperations.getChildren(((SNode) leftNode), LINKS.smodelAttribute$KJ43);
      List<SNode> rightSmodelAttribute = SLinkOperations.getChildren(((SNode) rightNode), LINKS.smodelAttribute$KJ43);

      List<SNode> mergedSmodelAttributes = Sequence.fromIterable(this.merge(leftSmodelAttribute, rightSmodelAttribute)).select((it) -> SNodeOperations.cast(it.node, CONCEPTS.Attribute$g1)).toList();
      ListSequence.fromList(SLinkOperations.getChildren(newInstance, LINKS.smodelAttribute$KJ43)).addSequence(ListSequence.fromList(mergedSmodelAttributes));

      mergePropertiesToInstance(leftNode, mergerResolver, rightNode, newInstance);
      mergeChildrenToInstance(leftNode, mergerResolver, rightNode, newInstance);
      String rightId = this.conceptToIdFunction.get(rightNode.getConcept()).get(rightNode);

      return new MergedNode(leftNode.getContainmentLink(), newInstance, leftId, rightId);
    }
    deepCopy(leftNode, newInstance);
    return new MergedNode(leftNode.getContainmentLink(), newInstance, leftId, null);
  }

  private SNode newInstanceOf(SNode leftNode) {
    SConcept concept = leftNode.getConcept();
    SNode newInstance = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(concept));
    ((jetbrains.mps.smodel.SNode) newInstance).setId(leftNode.getNodeId());
    return newInstance;
  }

  private void deepCopy(SNode leftNode, SNode newInstance) {
    for (SProperty property : Sequence.fromIterable(leftNode.getProperties())) {
      String value = leftNode.getProperty(property);
      newInstance.setProperty(property, value);
    }

    List<SNode> leftModelAttributes = SLinkOperations.getChildren(((SNode) leftNode), LINKS.smodelAttribute$KJ43);

    List<SNode> attributesCopy = ListSequence.fromList(leftModelAttributes).select((attribute) -> {
      SNode newInstanceOfAttribute = newInstanceOf(attribute);
      deepCopy(attribute, newInstanceOfAttribute);
      return SNodeOperations.cast(newInstanceOfAttribute, CONCEPTS.Attribute$g1);
    }).distinct().toList();

    ListSequence.fromList((SLinkOperations.getChildren(((SNode) newInstance), LINKS.smodelAttribute$KJ43))).addSequence(ListSequence.fromList(attributesCopy));

    Iterable<? extends SNode> children = leftNode.getChildren();
    for (SNode child : Sequence.fromIterable(children).subtract(ListSequence.fromList(leftModelAttributes))) {
      SNode newInstanceOfChild = newInstanceOf(child);
      deepCopy(child, newInstanceOfChild);
      newInstance.addChild(child.getContainmentLink(), newInstanceOfChild);
    }
  }


  private void mergeChildrenToInstance(SNode leftNode, MergerResolver mergerResolver, SNode rightNode, SNode newInstance) {
    assert leftNode.getConcept().equals(rightNode.getConcept()) : "Concepts of left and right node must not differ " + leftNode.getConcept() + " != " + rightNode.getConcept();
    Multimap<SContainmentLink, SNode> linkToLeftNodes = this.makeLinkToNodes(leftNode);
    Multimap<SContainmentLink, SNode> linkToRightNodes = this.makeLinkToNodes(rightNode);

    for (SContainmentLink link : SetSequence.fromSet(Sets.union(linkToLeftNodes.keySet(), linkToRightNodes.keySet()))) {
      Collection<SNode> leftNodesForLink = linkToLeftNodes.get(link);
      Collection<SNode> rightNodesForLink = linkToRightNodes.get(link);
      SConcept concept = leftNode.getConcept();

      mergeChildrenOfLink(mergerResolver, concept, link, leftNode, rightNode, leftNodesForLink, rightNodesForLink, newInstance);
    }

  }

  private void mergeChildrenOfLink(final MergerResolver mergerResolver, SConcept concept, SContainmentLink link, SNode leftNode, SNode rightNode, Collection<SNode> leftNodesForLink, Collection<SNode> rightNodesForLink, SNode newInstance) {
    ConceptChildMerger childMerger = mergerResolver.childMergerFor(concept, link);
    assert childMerger != null : "ConceptChildMerger for Concept " + concept + " and link " + link + " not found!";

    List<SNode> merged = childMerger.merge(leftNode, rightNode, leftNodesForLink, rightNodesForLink, (SNode leftChild, SNode rightChild) -> ModelMerger.this.makeMergedNode(leftChild, rightChild, mergerResolver).node);

    assert merged != null : "Merged Node null for " + childMerger.link();
    for (SNode m : ListSequence.fromList(merged)) {
      newInstance.addChild(childMerger.link(), SNodeOperations.copyNode(m));
    }
  }

  private Multimap<SContainmentLink, SNode> makeLinkToNodes(SNode node) {
    ImmutableMultimap.Builder<SContainmentLink, SNode> builder = ImmutableMultimap.<SContainmentLink,SNode>builder();
    Iterable<? extends SNode> children = node.getChildren();
    for (SNode child : Sequence.fromIterable(children).where((it) -> !(SNodeOperations.isInstanceOf(((SNode) it), CONCEPTS.Attribute$g1)))) {
      builder.put(child.getContainmentLink(), child);
    }
    return builder.build();
  }


  private void mergePropertiesToInstance(SNode leftRoot, MergerResolver result, SNode rightRoot, SNode newInstance) {
    for (SProperty property : Sequence.fromIterable(leftRoot.getProperties())) {
      PropertyMerger propertyMerger = result.propertyMergerFor(leftRoot.getConcept(), property);
      assert propertyMerger != null : "PropertyMerger not found for Concept " + leftRoot.getConcept() + " and Property " + property + ".";
      String mergedProperty = propertyMerger.merge(leftRoot, rightRoot).toString();
      newInstance.setProperty(property, mergedProperty);
    }
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink smodelAttribute$KJ43 = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
  }
}

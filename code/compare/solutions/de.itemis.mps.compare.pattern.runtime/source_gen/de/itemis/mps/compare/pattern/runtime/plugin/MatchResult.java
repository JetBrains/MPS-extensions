package de.itemis.mps.compare.pattern.runtime.plugin;

/*Generated by MPS */

import java.util.Map;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;

public final class MatchResult {

  private boolean isMatch;
  private Map<String, Object> mappings;

  public static MatchResult noMatch() {
    return new MatchResult(false, null);
  }

  public MatchResult(boolean isMatch, Map<String, Object> mappings) {
    this.isMatch = isMatch;
    this.mappings = mappings;
  }

  public MatchResult() {
  }

  @Override
  public String toString() {
    return "MatchResult " + isMatch + " " + mappings;
  }

  public MatchResult xor(boolean value) {
    this.isMatch ^= value;
    return this;
  }
  public void setIsMatch(boolean isMatch) {
    this.isMatch = isMatch;
  }

  public Map<String, Object> getMappings() {
    if (this.mappings == null) {
      return null;
    } else {
      return Collections.<String,Object>unmodifiableMap(this.mappings);
    }
  }

  protected void put(String name, Object value) {
    if (this.mappings == null) {
      this.mappings = MapSequence.fromMap(new HashMap<String, Object>());
    }
    MapSequence.fromMap(this.mappings).put(name, value);
  }

  public Object get(String name) {
    if (this.mappings == null) {
      return null;
    } else {
      return MapSequence.fromMap(this.mappings).get(name);
    }
  }

  public boolean isMatch() {
    return this.isMatch;
  }

  protected MatchResult unify(MatchResult that) {
    boolean isMatch = this.isMatch && that.isMatch;
    MatchResult result = new MatchResult();
    result.isMatch = isMatch;

    if (isMatch) {
      Map<String, Object> mappings = MapSequence.fromMap(new HashMap<String, Object>());
      if (this.mappings != null) {
        MapSequence.fromMap(mappings).putAll(this.mappings);
      }
      if (that.mappings != null) {
        MapSequence.fromMap(mappings).putAll(that.mappings);
      }
      result.mappings = mappings;
    }

    return result;
  }
}

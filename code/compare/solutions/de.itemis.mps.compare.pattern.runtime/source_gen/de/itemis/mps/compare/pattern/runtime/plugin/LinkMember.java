package de.itemis.mps.compare.pattern.runtime.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SAbstractLink;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class LinkMember extends PatternBuilderInitPart<IPatternEvaluator> {

  protected SAbstractLink link;
  protected boolean exact;

  public LinkMember(SAbstractLink link, Expression<IPatternEvaluator> inner, String annotation, boolean exact, boolean negated) {
    super(inner, annotation, negated);
    this.link = link;
    this.exact = exact;
  }

  public LinkMember(SAbstractLink link, Expression<IPatternEvaluator> inner, String annotation, boolean exact) {
    this(link, inner, annotation, exact, false);
  }

  public LinkMember(SAbstractLink link, Expression<IPatternEvaluator> inner, String annotation) {
    this(link, inner, annotation, true);
  }

  public LinkMember(SAbstractLink link, Expression<IPatternEvaluator> inner) {
    this(link, inner, null);
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    SAbstractLink genuineLink = this.link;
    builder.append(genuineLink.getName() + "@" + this.annotation + " = ");

    if (ListSequence.fromList(this.inner.getValues()).count() > 1) {
      builder.append("[");
    }
    boolean first = true;
    for (IPatternEvaluator value : ListSequence.fromList(this.inner.getValues())) {
      if (first) {
        first = false;
      } else {
        builder.append(", ");
      }
      builder.append(value.toString());
    }
    if (ListSequence.fromList(this.inner.getValues()).count() > 1) {
      builder.append("]");
    }
    return builder.toString();
  }

  @Override
  public MatchResult match(SNode node) {
    if (node != null) {
      List<SNode> targets = ListSequence.fromList(new ArrayList<SNode>());
      List<IPatternEvaluator> expressions = inner.getValues();
      SAbstractLink genuineLink = this.link;
      if (genuineLink instanceof SReferenceLink) {
        ListSequence.fromList(targets).addElement(node.getReferenceTarget((SReferenceLink) genuineLink));
      } else {
        Iterable<? extends SNode> children = node.getChildren((SContainmentLink) genuineLink);
        if (!(genuineLink.isMultiple()) && !(children.iterator().hasNext())) {
          ListSequence.fromList(targets).addElement(null);
        } else {
          ListSequence.fromList(targets).addSequence(Sequence.fromIterable(children));
        }
      }

      MatchResult result = null;

      if (ListSequence.fromList(expressions).isEmpty()) {
        result = new MatchResult(true, null);

        if (result.isMatch() && shouldAnnotate()) {
          if (!(genuineLink.isMultiple())) {
            result.put(annotation, ListSequence.fromList(targets).first());
          } else {
            result.put(annotation, targets);
          }
        }
      } else {
        if (exact) {
          result = new MatchResult(ListSequence.fromList(targets).count() == ListSequence.fromList(expressions).count(), null);

          if (result.isMatch()) {
            for (int i = 0; i < ListSequence.fromList(targets).count(); i++) {
              result = result.unify(ListSequence.fromList(expressions).getElement(i).match(ListSequence.fromList(targets).getElement(i)));
            }
          }

          if (result.isMatch() && shouldAnnotate()) {
            if (!(genuineLink.isMultiple())) {
              result.put(annotation, ListSequence.fromList(targets).first());
            } else {
              result.put(annotation, targets);
            }
          }
        } else {
          // this can only happen if we have a pattern builder list as the expression
          result = new MatchResult(ListSequence.fromList(targets).count() >= ListSequence.fromList(expressions).count(), null);

          if (result.isMatch()) {
            int targetIndex = 0;
            int expressionIndex = 0;
            List<SNode> filtered = ListSequence.fromList(new ArrayList<SNode>());

            while (targetIndex < ListSequence.fromList(targets).count() && expressionIndex < ListSequence.fromList(expressions).count()) {
              SNode currentTarget = ListSequence.fromList(targets).getElement(targetIndex);
              IPatternEvaluator currentExpression = ListSequence.fromList(expressions).getElement(expressionIndex);
              MatchResult currentResult = currentExpression.match(currentTarget);

              if (currentResult.isMatch()) {
                ListSequence.fromList(filtered).addElement(currentTarget);
                result = result.unify(currentResult);
                expressionIndex++;
              }

              targetIndex++;
            }

            if (expressionIndex == ListSequence.fromList(expressions).count()) {
              if (shouldAnnotate()) {
                if (!(genuineLink.isMultiple())) {
                  result.put(annotation, ListSequence.fromList(filtered).first());
                } else {
                  result.put(annotation, filtered);
                }
              }
            } else if (expressionIndex < ListSequence.fromList(expressions).count()) {
              result.setIsMatch(false);
            } else {
              result = MatchResult.noMatch();
            }
          }
        }
      }

      return result;
    }
    return MatchResult.noMatch();
  }

  @Override
  public SNode build(SNode node) {
    for (IPatternEvaluator value : ListSequence.fromList(this.inner.getValues())) {
      SNode built = value.build(node);
      SAbstractLink genuineLink = this.link;
      if (genuineLink instanceof SReferenceLink) {
        node.setReferenceTarget((SReferenceLink) genuineLink, built);
      } else {
        node.addChild((SContainmentLink) genuineLink, built);
      }
    }
    return node;
  }
}

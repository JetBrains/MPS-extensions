package de.itemis.mps.editor.celllayout.layout;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.Sequence;
import de.itemis.mps.editor.celllayout.boxmodel.Size;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.itemis.mps.editor.celllayout.runtime.CellLayoutUtil;
import de.itemis.mps.editor.celllayout.boxmodel.LayoutBoxFrame;
import de.itemis.mps.editor.celllayout.boxmodel.EditorCellBoxModel;

public class Grid {
  private GridElement[] myElements;
  private int mySizeX;
  private int mySizeY;

  private int[] myColumnWidths;
  private int[] myRowAscents;
  private int[] myRowDescents;
  private int[] myRowPositions;
  private int[] myColumnPositions;

  public Grid(int sizeX, int sizeY) {
    mySizeX = sizeX;
    mySizeY = sizeY;
    myElements = new GridElement[sizeX * sizeY];

    int i = 0;
    for (int y = 0; y < sizeY; y++) {
      for (int x = 0; x < sizeX; x++) {
        myElements[i] = new GridElement(this, x, y);
        i++;
      }
    }

    myColumnWidths = new int[sizeX];
    myRowAscents = new int[sizeY];
    myRowDescents = new int[sizeY];
  }

  public GridElement getElement(int x, int y) {
    if (x >= mySizeX) {
      throw new IllegalArgumentException("x: " + x + " >= " + mySizeX);
    }
    if (y >= mySizeY) {
      throw new IllegalArgumentException("y: " + y + " >= " + mySizeY);
    }
    return myElements[y * getSizeX() + x];
  }

  public Iterable<GridElement> getElements() {
    return Sequence.fromArray(myElements);
  }

  public Iterable<GridElement> getValidElements() {
    return Sequence.fromIterable(getElements()).where((it) -> it.getLayoutable() != null);
  }

  public int getSizeX() {
    return mySizeX;
  }

  public int getSizeY() {
    return mySizeY;
  }

  public void extendColumnWidth(int column, int width) {
    int newValue = Math.min(Size.UNLIMITED, Math.max(myColumnWidths[column], width));
    if (newValue != myColumnWidths[column]) {
      myColumnWidths[column] = newValue;
      myColumnPositions = null;
    }
  }

  public void extendRowHeight(int row, int ascent, int descent) {
    if (ascent + descent < 0) {
      throw new IllegalArgumentException("height < 0: ascent = " + ascent + ", descent = " + descent);
    }
    int newAscent = Math.min(Size.UNLIMITED, Math.max(myRowAscents[row], ascent));
    int newDescent = Math.min(Size.UNLIMITED, Math.max(myRowDescents[row], descent));
    if (newAscent != myRowAscents[row] || newDescent != myRowDescents[row]) {
      myRowAscents[row] = newAscent;
      myRowDescents[row] = newDescent;
      myRowPositions = null;
    }
  }

  public void extendCells(_FunctionTypes._return_P1_E0<? extends Size, ? super ILayoutable> sizeGetter) {
    for (GridElement element : Sequence.fromIterable(getValidElements())) {
      element.extendSize(sizeGetter.invoke(element.getLayoutable()));
    }
  }

  public Size getSize() {
    return new Size(getWidth(), getHeight());
  }

  public int getHeight() {
    return getRowPosY(getSizeY());
  }

  public int getWidth() {
    return getColumnPosX(getSizeX());
  }

  public void scaleWidth(int newWidth, float[] weights) {
    if (getSizeX() == 0) {
      return;
    }
    if (newWidth == getWidth()) {
      return;
    }
    if (weights == null) {
      weights = new float[getSizeX()];
      for (int i = 0; i < weights.length; i++) {
        weights[i] = 1.0f;
      }
    }
    if (weights.length != getSizeX()) {
      throw new IllegalArgumentException("sizeX = " + getSizeX() + ", weights.length = " + weights.length);
    }
    normalize(weights);

    float targetChange = newWidth - getWidth();

    for (int i = 0; i < myColumnWidths.length; i++) {
      myColumnWidths[i] += Math.round(targetChange * weights[i]);
    }
    myColumnPositions = null;

    // compensate possible rounding error
    int roundingError = newWidth - getWidth();
    if (roundingError != 0) {
      int bestIndex = 0;
      int widthOfBest = myColumnWidths[0];
      for (int i = 0; i < getSizeX(); i++) {
        if (weights[i] != 0.0f) {
          if (roundingError < 0) {
            if (myColumnWidths[i] > widthOfBest) {
              bestIndex = i;
              widthOfBest = myColumnWidths[i];
            }
          } else {
            if (myColumnWidths[i] < widthOfBest) {
              bestIndex = i;
              widthOfBest = myColumnWidths[i];
            }
          }
        }
      }
      myColumnWidths[bestIndex] += roundingError;
    }

    myColumnPositions = null;
  }

  public void scaleHeight(int newHeight, float[] weights) {
    if (getSizeY() == 0) {
      return;
    }
    if (newHeight == getHeight()) {
      return;
    }
    if (weights == null) {
      weights = new float[getSizeY()];
      for (int i = 0; i < weights.length; i++) {
        weights[i] = 1.0f;
      }
    }
    if (weights.length != getSizeY()) {
      throw new IllegalArgumentException("sizeY = " + getSizeY() + ", weights.length = " + weights.length);
    }
    normalize(weights);

    float targetChange = newHeight - getHeight();

    for (int y = 0; y < getSizeY(); y++) {
      int height = myRowAscents[y] + myRowDescents[y];
      myRowAscents[y] += Math.round(targetChange * weights[y] * (((float) myRowAscents[y]) / height));
      myRowDescents[y] += Math.round(targetChange * weights[y] * (((float) myRowDescents[y]) / height));
    }

    myRowPositions = null;

    // possible rounding error
    int heightError = newHeight - getHeight();
    int ascentError = heightError / 2;
    int descentError = heightError - ascentError;
    myRowAscents[getSizeY() - 1] += ascentError;
    myRowDescents[getSizeY() - 1] += descentError;
    myRowPositions[getSizeY()] += heightError;

    for (int i = 0; i < myRowAscents.length; i++) {
      int rowHeight = myRowAscents[i] + myRowDescents[i];
      if (rowHeight < 0) {
        throw new RuntimeException("height of row " + i + " is " + rowHeight);
      }
    }
  }

  public void normalize(float[] weights) {
    // The sum will be 1.0
    double sum = 0;
    for (int i = 0; i < weights.length; i++) {
      sum += weights[i];
    }
    if (sum < 0.00001) {
      return;
    }
    for (int i = 0; i < weights.length; i++) {
      weights[i] = ((float) (((double) weights[i]) / sum));
    }
  }

  public void resetHeights() {
    for (int y = 0; y < getSizeY(); y++) {
      myRowAscents[y] = 0;
      myRowDescents[y] = 0;
    }
    myRowPositions = null;
  }

  public int getColumnWidth(int column) {
    return myColumnWidths[column];
  }

  public int getRowHeight(int row) {
    return myRowAscents[row] + myRowDescents[row];
  }

  public void setColumnWidth(int column, int width) {
    myColumnWidths[column] = width;
    myColumnPositions = null;
  }

  public void setRowHeight(int row, int ascent, int descent) {
    if (ascent + descent < 0) {
      throw new IllegalArgumentException("height < 0: ascent = " + ascent + ", descent = " + descent);
    }
    myRowAscents[row] = ascent;
    myRowDescents[row] = descent;
    myRowPositions = null;
  }

  public int getColumnPosX(int x) {
    if (x >= getSizeX() + 1) {
      throw new IndexOutOfBoundsException(x + " >= " + getSizeX() + 1);
    }
    if (myColumnPositions == null) {
      myColumnPositions = new int[getSizeX() + 1];
      int pos = 0;
      for (int i = 0; i < myColumnPositions.length - 1; i++) {
        myColumnPositions[i] = pos;
        pos += myColumnWidths[i];
        pos = Math.min(pos, Size.UNLIMITED);
      }
      myColumnPositions[myColumnPositions.length - 1] = pos;
    }
    return myColumnPositions[x];
  }

  public int getRowPosY(int y) {
    if (myRowPositions == null) {
      myRowPositions = new int[getSizeY() + 1];
      int pos = 0;
      for (int i = 0; i < myRowPositions.length - 1; i++) {
        myRowPositions[i] = pos;
        pos += myRowAscents[i] + myRowDescents[i];
        pos = Math.min(pos, Size.UNLIMITED);
      }
      myRowPositions[myRowPositions.length - 1] = pos;
    }
    return myRowPositions[y];
  }

  public int getAscent(int y) {
    return myRowAscents[y];
  }

  public int getDescent(int y) {
    return myRowDescents[y];
  }

  public void setAscent(int y, int ascent) {
    if (myRowDescents[y] + ascent < 0) {
      throw new IllegalArgumentException("height would be < 0: ascent = " + myRowAscents[y] + ", descent = " + myRowDescents[y] + ", new ascent = " + ascent);
    }
    myRowAscents[y] = ascent;
    myRowPositions = null;
  }

  public void setDescent(int y, int descent) {
    if (myRowAscents[y] + descent < 0) {
      throw new IllegalArgumentException("height would be < 0: ascent = " + myRowAscents[y] + ", descent = " + myRowDescents[y] + ", new descent = " + descent);
    }
    myRowDescents[y] = descent;
    myRowPositions = null;
  }

  public void applyLayout(int x, int y) {
    for (GridElement element : Sequence.fromIterable(getValidElements())) {
      ILayoutable layoutable = element.getLayoutable();
      int baseLine = y + element.getPosY() + getAscent(element.getRowIndex());
      int elementX = x + element.getPosX();
      int elementY = baseLine - layoutable.getAscent(getResultSize(element));
      Size size = getResultSize(element);

      // horizontal alignment
      int remainingSpace = element.getWidth() - size.getWidth();
      if (CellLayoutUtil.isAlignRight(layoutable)) {
        elementX += remainingSpace;
      } else if (CellLayoutUtil.isAlignHorizontalCenter(layoutable)) {
        elementX += remainingSpace / 2;
      }

      // overflow
      if (layoutable.isOverflowX() || layoutable.isOverflowY()) {
        if (layoutable.isOverflowX() && layoutable.isOverflowY()) {
          size = layoutable.getPreferredSize(Size.UNLIMITED_SIZE);
        } else if (layoutable.isOverflowX()) {
          size = layoutable.getPreferredSize(Size.limitedHeight(size.getHeight()));
        } else {
          size = layoutable.getPreferredSize(Size.limitedWidth(size.getWidth()));
        }
      }

      layoutable.setBounds(elementX, elementY, size.getWidth(), size.getHeight());
    }
  }

  public void growElements(int x, int y, boolean horizontal, boolean vertical) {
    for (GridElement element : Sequence.fromIterable(getValidElements())) {
      growElement(element, x, y, horizontal, vertical);
    }
  }

  public void growElement(GridElement element, int offsetX, int offsetY, boolean horizontal, boolean vertical) {
    ILayoutable layoutable = element.getLayoutable();
    LayoutBoxFrame additionalPadding = ((EditorCellBoxModel) layoutable.getBoxModel()).getAdditionalPadding();
    Size maxSize = layoutable.getMaxSize(element.getSize());

    additionalPadding.setFrameSize(0);

    if (horizontal && !(layoutable.isOverflowX())) {
      if (layoutable.isGrowX() && element.getWidth() <= maxSize.getWidth()) {
        layoutable.setWidth(element.getWidth());
      } else {
        // Use padding to grow the cell
        int padLeft = layoutable.getX() - (element.getPosX() + offsetX);
        int padRight = (element.getPosX() + element.getWidth() + offsetX) - LayoutableExtensions.getMaxX(layoutable);
        if (CellLayoutUtil.isAlignRight(layoutable)) {
          padLeft += padRight;
          padRight = 0;
        } else if (CellLayoutUtil.isAlignHorizontalCenter(layoutable)) {
          int total = padLeft + padRight;
          padLeft = total / 2;
          padRight = total - padLeft;
        }
        additionalPadding.setLeftSize(additionalPadding.getLeftSize() + padLeft);
        additionalPadding.setRightSize(additionalPadding.getRightSize() + padRight);
      }
    }
    if (vertical && !(layoutable.isOverflowY())) {
      if (layoutable.isGrowY() && element.getHeight() <= maxSize.getHeight()) {
        layoutable.setHeight(element.getHeight());
      } else {
        // Use padding to grow the cell
        int padTop = layoutable.getY() - (element.getPosY() + offsetY);
        int padBottom = (element.getPosY() + element.getHeight() + offsetY) - LayoutableExtensions.getMaxY(layoutable);
        additionalPadding.setTopSize(additionalPadding.getTopSize() + padTop);
        additionalPadding.setBottomSize(additionalPadding.getBottomSize() + padBottom);
      }
    }
  }

  private Size getResultSize(GridElement element) {
    Size size = element.getSize();
    size = size.min(element.getLayoutable().getPreferredSize(size));
    size = size.min(element.getLayoutable().getMaxSize(element.getSize()));
    return SizeExtensions.zeroIfOverflow(size, element.getLayoutable());
  }

  public boolean columnHasAnyGrowX(int x) {
    for (int y = 0; y < getSizeY(); y++) {
      ILayoutable layoutable = getElement(x, y).getLayoutable();
      if (layoutable != null && layoutable.isGrowX()) {
        return true;
      }
    }
    return false;
  }
}

package com.mbeddr.mpsutil.projectview.runtime.tree;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.util.Condition;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.ArrayDeque;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.ide.ui.tree.module.ProjectModuleTreeNode;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.library.ModulesMiner;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import jetbrains.mps.ide.ui.tree.smodel.SNodeTreeNode;
import jetbrains.mps.ide.ui.tree.smodel.SModelTreeNode;
import jetbrains.mps.ide.ui.tree.module.ProjectModulesPoolTreeNode;
import jetbrains.mps.ide.ui.tree.module.ProjectLanguageTreeNode;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.project.Project;

public final class ProjectTreeFindHelper {
  private CustomProjectTree myProjectTree;
  private int totalChecks = 0;

  public ProjectTreeFindHelper(CustomProjectTree projectTree) {
    myProjectTree = projectTree;
  }

  public CustomTreeNode findMostSuitableModuleTreeNode(@NotNull final SModule module) {
    return findTreeNode(myProjectTree.getRootNode(), SModule.class, Condition.TRUE_CONDITION, new Condition<SModule>() {
      public boolean met(SModule candidate) {
        return candidate == module;
      }
    });
  }
  public CustomTreeNode findMostSuitableModelTreeNode(@NotNull final SModel model) {
    return findTreeNode(myProjectTree.getRootNode(), SModel.class, Condition.TRUE_CONDITION, new Condition<SModel>() {
      public boolean met(SModel candidate) {
        return candidate == model;
      }
    });
  }
  public CustomTreeNode findMostSuitableSNodeTreeNode(@NotNull final SNode snode) {
    return findTreeNode(myProjectTree.getRootNode(), SNode.class, new Condition<MPSTreeNode>() {
      public boolean met(MPSTreeNode treeNode) {
        if (!(treeNode instanceof CustomTreeNode)) {
          return true;
        }

        Object obj = ((CustomTreeNode) treeNode).getObject();
        if (obj instanceof SModule) {
          return check_xf4enj_a0a0a3a0a0c0a0h(snode.getModel()) == obj || canHaveDescendantOfType(SModule.class, treeNode);
        }
        if (obj instanceof SModel) {
          return snode.getModel() == obj || canHaveDescendantOfType(SModel.class, treeNode);
        }
        if (obj instanceof SNode) {
          return ListSequence.fromList(SNodeOperations.getNodeAncestors(((SNode) snode), null, false)).contains(((SNode) obj));
        }

        return true;
      }
    }, new Condition<SNode>() {
      public boolean met(SNode candidate) {
        return candidate == snode;
      }
    });
  }

  protected MPSTreeNode findTreeNode(MPSTreeNode start, Condition<MPSTreeNode> descendCondition, Condition<MPSTreeNode> resultCondition) {
    // breadth-first to find top-most module (e.g. not the one under 'runtime' dependencies)
    ArrayDeque<MPSTreeNode> queue = new ArrayDeque(128);
    queue.add(start);
    while (!(queue.isEmpty())) {
      MPSTreeNode tn = queue.removeFirst();
      if (resultCondition.met(tn)) {
        return tn;
      }
      if (descendCondition.met(tn)) {
        if (!(tn.isInitialized())) {
          tn.init();
        }
        for (MPSTreeNode node : tn.getChildren()) {
          queue.addLast(node);
        }
      }
    }
    return null;
  }

  protected <T> CustomTreeNode findTreeNode(MPSTreeNode root, final Class<T> type, final Condition<MPSTreeNode> descendCondition, final Condition<T> resultCondition) {
    totalChecks = 0;
    return ((CustomTreeNode) findTreeNode(root, new Condition<MPSTreeNode>() {
      public boolean met(MPSTreeNode treeNode) {
        return descendCondition.met(treeNode) && canHaveDescendantOfType(type, treeNode);
      }
    }, new Condition<MPSTreeNode>() {
      public boolean met(MPSTreeNode treeNode) {
        if (!(treeNode instanceof CustomTreeNode)) {
          return false;
        }
        CustomTreeNode customTreeNode = ((CustomTreeNode) treeNode);
        Object object = customTreeNode.getObject();
        if (!(type.isInstance(object))) {
          return false;
        }
        return resultCondition.met(((T) object));
      }
    }, 0));
  }

  protected boolean canHaveDescendantOfType(final Class type, MPSTreeNode treeNode) {
    if (!(treeNode instanceof CustomTreeNode)) {
      return true;
    }
    Set<Class> possibleDescendantTypes = ((CustomTreeNode) treeNode).getElement().getPossibleDescendantTypes();
    for (Class possibleDescendantType : SetSequence.fromSet(possibleDescendantTypes)) {
      if (possibleDescendantType.isAssignableFrom(type) || type.isAssignableFrom(possibleDescendantType)) {
        return true;
      }
    }
    return false;
  }

  protected MPSTreeNode findTreeNode(MPSTreeNode root, Condition<MPSTreeNode> descendCondition, Condition<MPSTreeNode> resultCondition, int depth) {
    totalChecks++;
    if (totalChecks > 10000) {
      return null;
    }
    if (resultCondition.met(root)) {
      return root;
    }
    if (depth < 10 && descendCondition.met(root)) {
      if (!(root.isInitialized())) {
        CustomTreeNode.initIfNotAsync(root);
      }
      for (MPSTreeNode node : root) {
        MPSTreeNode result = findTreeNode(node, descendCondition, resultCondition, depth + 1);
        if (result != null) {
          return result;
        }
      }
    }
    return null;
  }
  public ProjectModuleTreeNode findModuleTreeNode(final IFile moduleFile) {
    Condition<MPSTreeNode> module4file = (MPSTreeNode treeNode) -> {
      if (!(treeNode instanceof ProjectModuleTreeNode)) {
        return false;
      }
      final SModule module = ((ProjectModuleTreeNode) treeNode).getModule();
      if (false == module instanceof AbstractModule) {
        return false;
      }
      final IFile descriptorFile = ((AbstractModule) module).getDescriptorFile();
      if (descriptorFile == null) {
        // for DD case, we need descriptorFile as well.
        return false;
      }
      if (descriptorFile.equals(moduleFile)) {
        return true;
      }
      final ModuleDescriptor md = ((AbstractModule) module).getModuleDescriptor();
      if (md == null || md.getDeploymentDescriptor() == null) {
        return false;
      }
      // next code had been stolen from ModuleFileTracker, #getSourceModuleDescriptor(AM)
      final IFile srcDescriptorFile = ModulesMiner.getSourceDescriptorFile(descriptorFile, md.getDeploymentDescriptor());
      return srcDescriptorFile != null && srcDescriptorFile.equals(moduleFile);
    };
    // for DD case, we need descriptorFile as well.
    // next code had been stolen from ModuleFileTracker, #getSourceModuleDescriptor(AM)
    // first, look at project modules
    MPSTreeNode rv = findTreeNode(getTree().getRootNode(), new ModuleInProjectCondition(), module4file);
    if (rv == null) {
      // if not among project, try pool of loaded then
      rv = findTreeNode(getTree().getRootNode(), new ModuleEverywhereCondition(), module4file);
    }
    return (ProjectModuleTreeNode) rv;
  }

  public MPSTreeNode findNextTreeNode(SNode node) {
    MPSTreeNode foundNode = findMostSuitableSNodeTreeNode(node);
    if (foundNode == null) {
      return null;
    }
    DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) foundNode.getParent();
    TreeNode result = parentNode.getChildAfter(foundNode);
    if (result == null) {
      result = parentNode.getChildBefore(foundNode);
    }
    if (result == null) {
      result = parentNode;
    }
    return (MPSTreeNode) result;
  }
  public MPSTreeNode findNextTreeNode(SModel modelDescriptor) {
    CustomTreeNode sModelNode = findMostSuitableModelTreeNode(modelDescriptor);
    if (sModelNode == null) {
      return null;
    }
    DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) sModelNode.getParent();
    TreeNode result = parentNode.getChildAfter(sModelNode);
    if (result == null) {
      result = parentNode.getChildBefore(sModelNode);
    }
    if (result == null) {
      result = parentNode;
    }
    return (MPSTreeNode) result;
  }
  private static class ModelEverywhereCondition implements Condition<MPSTreeNode> {

    protected SModel myModel;
    public ModelEverywhereCondition(SModel model) {
      myModel = model;
    }
    @Override
    public boolean met(MPSTreeNode node) {
      if (node instanceof SNodeTreeNode) {
        return false;
      }
      if (node instanceof SModelTreeNode) {
        SModelTreeNode modelNode = (SModelTreeNode) node;
        if (!(modelNode.hasModelsUnder())) {
          return false;
        }
        String outerName = modelNode.getModel().getName().getLongName();
        String innerName = myModel.getName().getLongName();
        return innerName.startsWith(outerName + '.');
      }
      if (!(node.isInitialized()) && !(node.hasInfiniteSubtree())) {
        CustomTreeNode.initIfNotAsync(node);
        return true;
      }
      return node.isInitialized();
    }
  }
  private static class NodeForModuleCondition implements Condition<MPSTreeNode> {

    private final SModule myModule;
    public NodeForModuleCondition(SModule module) {
      myModule = module;
    }
    @Override
    public boolean met(MPSTreeNode treeNode) {
      if (!(treeNode instanceof ProjectModuleTreeNode)) {
        return false;
      }
      return ((ProjectModuleTreeNode) treeNode).getModule() == myModule;
    }
  }
  private static class ModuleInProjectCondition extends ModuleEverywhereCondition {
    @Override
    public boolean met(MPSTreeNode object) {
      if (!(super.met(object))) {
        return false;
      }
      return !(object instanceof ProjectModulesPoolTreeNode);
    }
  }
  private static class ModuleEverywhereCondition implements Condition<MPSTreeNode> {
    @Override
    public boolean met(MPSTreeNode node) {
      // language tree nodes host generator tree nodes, hence shall allow to get into them
      if (node instanceof ProjectModuleTreeNode && !(node instanceof ProjectLanguageTreeNode)) {
        return false;
      }
      // just don't go under a model node
      return !(node instanceof SModelTreeNode);
    }
  }


  private static class NodeForModelCondition implements Condition<MPSTreeNode> {
    private final SModel myModel;
    public NodeForModelCondition(SModel model) {
      myModel = model;
    }
    @Override
    public boolean met(MPSTreeNode node) {
      if (!(node instanceof SModelTreeNode)) {
        return false;
      }
      SModelTreeNode modelNode = (SModelTreeNode) node;
      SModel modelDescriptor = modelNode.getModel();
      SModelReference modelReference = modelDescriptor.getReference();
      return modelReference.equals(myModel.getReference());
    }
  }
  protected Project getProject() {
    return getTree().getProject();
  }
  protected CustomProjectTree getTree() {
    return myProjectTree;
  }
  private static SModule check_xf4enj_a0a0a3a0a0c0a0h(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }
}

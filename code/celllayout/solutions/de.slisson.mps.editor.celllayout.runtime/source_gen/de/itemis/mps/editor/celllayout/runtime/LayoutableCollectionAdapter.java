package de.itemis.mps.editor.celllayout.runtime;

/*Generated by MPS */

import de.itemis.mps.editor.celllayout.layout.ILayoutableContainer;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.openapi.editor.style.StyleAttribute;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import java.util.Comparator;
import de.itemis.mps.editor.celllayout.boxmodel.Size;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import java.util.List;
import de.itemis.mps.editor.celllayout.layout.ILayoutable;
import org.jetbrains.annotations.NotNull;
import de.itemis.mps.editor.celllayout.layout.ILayouter;
import java.util.Map;
import java.util.TreeMap;
import jetbrains.mps.editor.runtime.style.DefaultBaseLine;
import de.itemis.mps.editor.celllayout.boxmodel.Bounds;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.cells.CellLayout;
import java.util.Objects;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import de.itemis.mps.editor.celllayout.layout.HorizontalLayout;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import de.itemis.mps.editor.celllayout.layout.GridLayout;
import de.itemis.mps.editor.celllayout.layout.VerticalLayout;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Indent;
import de.itemis.mps.editor.celllayout.layout.IndentLayout;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.editor.runtime.style.Padding;
import jetbrains.mps.editor.runtime.style.Measure;
import java.awt.Font;
import jetbrains.mps.nodeEditor.EditorSettings;
import java.awt.FontMetrics;
import java.awt.Toolkit;
import jetbrains.mps.openapi.editor.TextBuilder;

public class LayoutableCollectionAdapter extends AbstractLayoutableAdapter implements ILayoutableContainer {
  private static final Logger LOG = Logger.getLogger(LayoutableCollectionAdapter.class);
  private static final boolean CACHE_ENABLED = true;
  private static final StyleAttribute<Boolean> PUSH_X = StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_push-x");
  private static final StyleAttribute<Boolean> PUSH_Y = StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_push-y");
  private static final StyleAttribute<Boolean> GRID_LAYOUT_FLATTEN = StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten");
  private static final Comparator<Size> SIZE_COMPARATOR = new Comparator<Size>() {
    public int compare(Size p0, Size p1) {
      if (p0.getWidth() == p1.getWidth()) {
        if (p0.getHeight() == p1.getHeight()) {
          return 0;
        } else if (p0.getHeight() > p1.getHeight()) {
          return 1;
        } else {
          return -1;
        }
      } else if (p0.getWidth() > p1.getWidth()) {
        return 1;
      } else {
        return -1;
      }
    }
  };

  private EditorCell_Collection myCollectionCell;
  private List<ILayoutable> myChildren = null;
  @NotNull
  private ILayouter myLayouter;
  private SizeCache myPreferredInnerSizeCache = new SizeCache();
  private SizeCache myMinInnerSizeCache = new SizeCache();
  private SizeCache myMaxInnerSizeCache = new SizeCache();
  private Map<Size, Integer> myInnerAscentCache = new TreeMap<Size, Integer>();
  private int myCellGap = 0;
  private boolean myIsFlattenInGrid;
  private DefaultBaseLine myDefaultBaseLine = DefaultBaseLine.FIRST;

  private Bounds myLastLayoutBounds = null;

  public LayoutableCollectionAdapter(EditorCell_Collection cell, ILayouter layouter) {
    super(cell);
    myCollectionCell = cell;
    myLayouter = layouter;
  }

  public void clearCaches() {
    myPreferredInnerSizeCache.clear();
    myMinInnerSizeCache.clear();
    myMaxInnerSizeCache.clear();
    MapSequence.fromMap(myInnerAscentCache).clear();
    myLastLayoutBounds = null;
  }

  @Override
  public void setChanged(boolean changed) {
    if (changed) {
      clearCaches();
    }
    super.setChanged(changed);
  }

  @Override
  public EditorCell_Collection getEditorCell() {
    return myCollectionCell;
  }

  @Override
  public List<ILayoutable> getChildren() {
    List<ILayoutable> result = myChildren;
    if (result == null) {
      result = ListSequence.fromList(new ArrayList<ILayoutable>(myCollectionCell.getCellsCount()));
      for (EditorCell child : Sequence.fromIterable(myCollectionCell)) {
        IEditorCellBasedLayoutable childAdapter = LayoutableAdapters.getAdapter(child);
        childAdapter.setParent(this);
        ListSequence.fromList(result).addElement(childAdapter);
      }
      myChildren = result;
    }
    return result;
  }

  @Override
  public void relayout(@NotNull Size sizeConstraint) {
    Bounds layoutBounds = new Bounds(getInnerX(), getInnerY(), sizeConstraint.getWidth(), sizeConstraint.getHeight());

    boolean positionChanged = true;
    boolean sizeChanged = true;
    if (myLastLayoutBounds != null) {
      positionChanged = myLastLayoutBounds.getX() != layoutBounds.getX() || myLastLayoutBounds.getY() != layoutBounds.getY();
      sizeChanged = myLastLayoutBounds.getWidth() != layoutBounds.getWidth() || myLastLayoutBounds.getHeight() != layoutBounds.getHeight();
    }

    if (positionChanged || sizeChanged) {
      ILayouter layouter = getLayouter();
      if (layouter == null) {
        super.relayout(sizeConstraint.subtract(getTotalGapHorizontal(), getTotalGapVertical()));
      } else {
        if (sizeChanged) {
          LayoutWatchdog.countDown();
          layouter.layout(this, sizeConstraint.subtract(getTotalGapHorizontal(), getTotalGapVertical()));
        } else if (positionChanged) {
          layouter.moveChildren(this, layoutBounds.getX() - myLastLayoutBounds.getX(), layoutBounds.getY() - myLastLayoutBounds.getY());
        }
      }
    }

    myLastLayoutBounds = layoutBounds;
  }

  @Override
  public void cellAndDescendantsWereMoved() {
    super.cellAndDescendantsWereMoved();
    if (myLastLayoutBounds != null) {
      myLastLayoutBounds = new Bounds(getInnerX(), getInnerY(), myLastLayoutBounds.getWidth(), myLastLayoutBounds.getHeight());
    }
    for (AbstractLayoutableAdapter child : ListSequence.fromList(getChildren()).ofType(AbstractLayoutableAdapter.class)) {
      child.cellAndDescendantsWereMoved();
    }
  }

  @Override
  public ILayouter getLayouter() {
    return myLayouter;
  }

  public static ILayouter getLayouter(EditorCell_Collection cell) {
    if (overridesLayoutMethod(cell)) {
      return null;
    }

    CellLayout cellLayout = LayoutInterceptor.getOriginalLayout(cell);
    if (cellLayout instanceof ILayouter) {
      return ((ILayouter) cellLayout);
    }
    if (Objects.equals(cellLayout.getClass(), CellLayout_Horizontal.class)) {
      return new HorizontalLayout();
    }
    if (Objects.equals(cellLayout.getClass(), CellLayout_Vertical.class)) {
      if (((Boolean) ReflectionUtil.callMethod(CellLayout_Vertical.class, ((CellLayout_Vertical) cellLayout), "isGridLayout", new Class[]{}, new Object[]{}))) {
        return new GridLayout();
      } else {
        return new VerticalLayout();
      }
    }
    if (Objects.equals(cellLayout.getClass(), CellLayout_Indent.class)) {
      return new IndentLayout(CellLayoutUtil.getIndentSizeSetting());
    }
    if (Objects.equals(cellLayout.getClass(), TopDownCellLayoutAdapter.class)) {
      return ((TopDownCellLayoutAdapter) cellLayout).getLayouter();
    }
    if (LOG.isDebugLevel()) {
      LOG.debug("Unsupported layout: " + cellLayout.getClass().getName());
    }
    return null;
  }

  protected static boolean overridesLayoutMethod(EditorCell cell) {
    return MethodPolymorphismInfo.getInstance().overridesLayoutMethod(cell.getClass());
  }

  @Override
  public void setInnerBounds(int x, int y, int width, int height) {
    setBounds(x - getTotalGapLeft(), y - getTotalGapTop(), width + getTotalGapHorizontal(), height + getTotalGapVertical());
  }

  @Override
  public int getInnerX() {
    return myBoxModel.getContentBox().getX();
  }

  @Override
  public int getInnerY() {
    return myBoxModel.getContentBox().getY();
  }

  @Override
  public int getInnerWidth() {
    return myBoxModel.getContentBox().getWidth();
  }

  @Override
  public int getInnerHeight() {
    return myBoxModel.getContentBox().getHeight();
  }

  public int getTotalGapLeft() {
    return myBoxModel.getContentBox().getX() - myBoxModel.getMarginBox().getX();
  }

  public int getTotalGapRight() {
    return myBoxModel.getMarginBox().getRight() - myBoxModel.getContentBox().getRight();
  }

  public int getTotalGapTop() {
    return myBoxModel.getContentBox().getY() - myBoxModel.getMarginBox().getY();
  }

  public int getTotalGapBottom() {
    return myBoxModel.getMarginBox().getBottom() - myBoxModel.getContentBox().getBottom();
  }

  public int getTotalGapVertical() {
    return getTotalGapTop() + getTotalGapBottom();
  }

  public int getTotalGapHorizontal() {
    return getTotalGapLeft() + getTotalGapRight();
  }

  protected Size toInnerSize(Size sizeConstraint) {
    return sizeConstraint.subtract(getTotalGapHorizontal(), getTotalGapVertical());
  }

  protected Size toOuterSize(Size size) {
    return size.add(getTotalGapHorizontal(), getTotalGapVertical());
  }

  @Override
  public int getAscent(@NotNull Size sizeConstraint) {
    Size innerSizeConstraint = toInnerSize(sizeConstraint);
    Integer ascent = MapSequence.fromMap(myInnerAscentCache).get(innerSizeConstraint);
    if (ascent == null) {
      ascent = calcInnerAscent(innerSizeConstraint);
      MapSequence.fromMap(myInnerAscentCache).put(innerSizeConstraint, ascent);
    }
    return ascent + getTotalGapTop();
  }

  protected int calcInnerAscent(@NotNull Size size) {
    LayoutWatchdog.countDown();
    return getLayouter().getAscent(this, size);
  }

  @NotNull
  @Override
  public Size getPreferredSize(@NotNull Size sizeConstraint) {
    Size innerSizeConstraint = toInnerSize(sizeConstraint);
    Size prefInnerSize = null;
    if (CACHE_ENABLED) {
      prefInnerSize = myPreferredInnerSizeCache.get(innerSizeConstraint.deriveHeight(Size.UNLIMITED));
      if (prefInnerSize == null) {
        prefInnerSize = guessSizeFromCachedValues(innerSizeConstraint, myPreferredInnerSizeCache);
      }
    }
    if (prefInnerSize == null) {
      prefInnerSize = calcPreferredInnerSize(innerSizeConstraint);
      if (CACHE_ENABLED) {
        myPreferredInnerSizeCache.put(innerSizeConstraint.deriveHeight(Size.UNLIMITED), prefInnerSize);
      }
    }
    return toOuterSize(prefInnerSize);
  }

  protected Size calcPreferredInnerSize(@NotNull Size sizeConstraint) {
    LayoutWatchdog.countDown();
    return getLayouter().getPreferredInnerSize(this, sizeConstraint);
  }

  @NotNull
  @Override
  public Size getMinSize(@NotNull Size sizeConstraint) {
    Size innerSizeConstraint = toInnerSize(sizeConstraint);
    Size minInnerSize = null;
    if (CACHE_ENABLED) {
      minInnerSize = myMinInnerSizeCache.get(innerSizeConstraint.deriveHeight(Size.UNLIMITED));
      if (minInnerSize == null) {
        minInnerSize = guessSizeFromCachedValues(innerSizeConstraint, myMinInnerSizeCache);
      }
    }
    if (minInnerSize == null) {
      minInnerSize = calcMinSize(innerSizeConstraint);
      if (CACHE_ENABLED) {
        myMinInnerSizeCache.put(innerSizeConstraint.deriveHeight(Size.UNLIMITED), minInnerSize);
      }
    }
    return toOuterSize(minInnerSize);
  }

  protected Size calcMinSize(Size sizeConstraint) {
    LayoutWatchdog.countDown();
    return getLayouter().getMinInnerSize(this, sizeConstraint);
  }

  @NotNull
  @Override
  public Size getMaxSize(@NotNull Size sizeConstraint) {
    Size innerSizeConstraint = toInnerSize(sizeConstraint);
    Size maxInnerSize = null;
    if (CACHE_ENABLED) {
      maxInnerSize = myMaxInnerSizeCache.get(innerSizeConstraint.deriveHeight(Size.UNLIMITED));
      if (maxInnerSize == null) {
        maxInnerSize = guessSizeFromCachedValues(innerSizeConstraint, myMaxInnerSizeCache);
      }
    }
    if (maxInnerSize == null) {
      maxInnerSize = calcMaxSize(innerSizeConstraint);
      if (CACHE_ENABLED) {
        myMaxInnerSizeCache.put(innerSizeConstraint.deriveHeight(Size.UNLIMITED), maxInnerSize);
      }
    }
    return toOuterSize(maxInnerSize);
  }

  protected Size calcMaxSize(@NotNull Size sizeConstraint) {
    LayoutWatchdog.countDown();
    return getLayouter().getMaxInnerSize(this, sizeConstraint);
  }

  protected Size guessSizeFromCachedValues(final Size currentConstraint, SizeCache cache) {
    // If the size was already smaller for a more strict constraint, we can use that value.

    final Wrappers._T<Size> prevCacheConstraint = new Wrappers._T<Size>(null);
    final Wrappers._T<Size> prevCachedSize = new Wrappers._T<Size>(null);
    final Wrappers._T<Size> result = new Wrappers._T<Size>(null);

    cache.visitEntries((Size cachedConstraint, Size cachedSize) -> {
      if (prevCacheConstraint.value != null) {
        // We assume that all constraints between two constraints with the same result will produce the same result
        if (prevCacheConstraint.value.getWidth() <= currentConstraint.getWidth() && currentConstraint.getWidth() <= cachedConstraint.getWidth() && Objects.equals(prevCachedSize.value, cachedSize)) {
          result.value = cachedSize;
          return false;
        }
      }

      if (!(cachedConstraint.isWidthLimited()) && cachedSize.getWidth() <= currentConstraint.getWidth()) {
        result.value = cachedSize;
        return false;
      }

      prevCacheConstraint.value = cachedConstraint;
      prevCachedSize.value = cachedSize;

      return true;
    });

    return result.value;
  }

  @Override
  public void readSyncAll() {
    myChildren = null;
    super.readSyncAll();
    if (isChanged()) {
      myCellGap = calcCellGap();
      myIsFlattenInGrid = calcIsFlattenInGrid();
    }
    myDefaultBaseLine = myCollectionCell.getStyle().get(StyleAttributes.DEFAULT_BASE_LINE);
  }

  @Override
  protected void readSyncChildren() {
    for (AbstractLayoutableAdapter child : ListSequence.fromList(getChildren()).ofType(AbstractLayoutableAdapter.class)) {
      child.readSyncAll();
    }
  }

  @Override
  public void writeSyncAll() {
    super.writeSyncAll();
    for (AbstractLayoutableAdapter child : ListSequence.fromList(getChildren()).ofType(AbstractLayoutableAdapter.class)) {
      child.writeSyncAll();
    }
  }

  public int getCellGap() {
    return myCellGap;
  }

  protected int calcCellGap() {
    EditorCell_Collection editorCells = getEditorCell();

    // based on PunctuationUtil.getHorizontalGap
    Padding padding = editorCells.getStyle().get(StyleAttributes.HORIZONTAL_GAP);
    if (padding.getType() == Measure.PIXELS) {
      return (int) padding.getValue();
    } else {
      Font f = EditorSettings.getInstance().getDefaultEditorFont();
      FontMetrics m = Toolkit.getDefaultToolkit().getFontMetrics(f);
      return (int) (padding.getValue() * m.charWidth(' '));
    }
  }

  @Override
  public boolean calcHasBorder(boolean left) {
    if (super.hasBorder(left)) {
      return true;
    }
    if (ListSequence.fromList(getChildren()).count() > 0) {
      ILayoutable child = (left ? ListSequence.fromList(getChildren()).first() : ListSequence.fromList(getChildren()).last());
      if (check_z1h9za_a1a1a39(as_z1h9za_a0a1a1a49(child, AbstractLayoutableAdapter.class), left)) {
        return true;
      }
    }
    return false;
  }

  @Override
  protected boolean calcIsPushX() {
    return (myCell.getStyle().isSpecified(PUSH_X) ? myCell.getStyle().get(PUSH_X) : myCell.getStyle().get(PUSH_X) || ListSequence.fromList(getChildren()).any((it) -> it.isPushX()));
  }

  @Override
  protected boolean calcIsPushY() {
    return (myCell.getStyle().isSpecified(PUSH_Y) ? myCell.getStyle().get(PUSH_Y) : myCell.getStyle().get(PUSH_Y) || ListSequence.fromList(getChildren()).any((it) -> it.isPushY()));
  }

  @Override
  public boolean isFlattenInGrid() {
    return myIsFlattenInGrid;
  }

  protected boolean calcIsFlattenInGrid() {
    return myCollectionCell.getStyle().get(GRID_LAYOUT_FLATTEN);
  }

  @Override
  public ILayoutable getBaselineChild() {
    // See CellLayout_Indent.getAscent

    Iterable<EditorCell> children = myCollectionCell;
    for (EditorCell child : Sequence.fromIterable(children)) {
      IEditorCellBasedLayoutable childLayoutable = LayoutableAdapters.getAdapter(child);
      if (childLayoutable.isBaseLineCell()) {
        return childLayoutable;
      }
    }

    DefaultBaseLine bL = myDefaultBaseLine;

    switch (bL) {
      case FIRST:
        return LayoutableAdapters.getAdapter(Sequence.fromIterable(children).first());
      case LAST:
        return LayoutableAdapters.getAdapter(Sequence.fromIterable(children).last());
      case CENTER:
        // TODO not exactly the original definition of center
        return LayoutableAdapters.getAdapter(ListSequence.fromList(Sequence.fromIterable(children).toList()).getElement(Sequence.fromIterable(children).count() / 2));
    }

    return null;
  }

  @Override
  public TextBuilder toText() {
    return myLayouter.toText(this);
  }
  private static boolean check_z1h9za_a1a1a39(AbstractLayoutableAdapter checkedDotOperand, Boolean left) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.hasBorder(left);
    }
    return false;
  }
  private static <T> T as_z1h9za_a0a1a1a49(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

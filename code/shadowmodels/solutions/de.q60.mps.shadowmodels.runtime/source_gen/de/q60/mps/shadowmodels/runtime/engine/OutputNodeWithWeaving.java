package de.q60.mps.shadowmodels.runtime.engine;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.modelix.model.api.IConcept;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.INode;

public class OutputNodeWithWeaving implements IOutputNode {
  private IOutputNode node;
  private IWeaving weaving;
  private List<IOutputNodeReference> nodesToWeave;

  public OutputNodeWithWeaving(IOutputNode node, IWeaving weaving, Iterable<IOutputNodeReference> children) {
    this.node = node;
    this.weaving = weaving;
    this.nodesToWeave = Sequence.fromIterable(children).toList();
  }

  @Override
  public IOutputNodeReference getOutputNodeReference() {
    return new OutputNodeReferenceWithWeaving(node.getOutputNodeReference(), weaving);
  }
  @Override
  public IConcept getConcept() {
    return node.getConcept();
  }
  @Override
  public IContainment getContainment() {
    return node.getContainment();
  }
  @Override
  public Iterable<IOutputNodeReference> getChildren(String role) {
    int index = weaving.getIndex();
    Iterable<IOutputNodeReference> children = node.getChildren(role);
    if (Objects.equals(role, weaving.getTargetRole())) {
      if (0 <= index && index < Sequence.fromIterable(children).count()) {
        return Sequence.fromIterable(children).take(index).concat(ListSequence.fromList(nodesToWeave)).concat(Sequence.fromIterable(children).skip(index));
      } else {
        return Sequence.fromIterable(children).concat(ListSequence.fromList(nodesToWeave));
      }
    } else {
      return children;
    }
  }
  @Override
  public Iterable<IOutputNodeReference> getAllChildren() {
    return Sequence.fromIterable(node.getAllChildren()).concat(ListSequence.fromList(nodesToWeave));
  }
  @Override
  public void addNewChild(String role, int index, @Nullable IConcept concept) {
    throw new UnsupportedOperationException();
  }
  @Override
  public IOutputNodeReference getReferenceTarget(String role) {
    return node.getReferenceTarget(role);
  }
  @Override
  public void setReferenceTarget(String role, INode target) {
    node.setReferenceTarget(role, target);
  }
  @Override
  public String getPropertyValue(String role) {
    return node.getPropertyValue(role);
  }
  @Override
  public void setPropertyValue(String role, String value) {
    node.setPropertyValue(role, value);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    OutputNodeWithWeaving that = (OutputNodeWithWeaving) o;
    if ((node != null ? !(node.equals(that.node)) : that.node != null)) {
      return false;
    }
    if ((weaving != null ? !(weaving.equals(that.weaving)) : that.weaving != null)) {
      return false;
    }
    if ((nodesToWeave != null ? !(((Object) nodesToWeave).equals(that.nodesToWeave)) : that.nodesToWeave != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((node != null ? ((Object) node).hashCode() : 0));
    result = 31 * result + ((weaving != null ? ((Object) weaving).hashCode() : 0));
    result = 31 * result + ((nodesToWeave != null ? ((Object) nodesToWeave).hashCode() : 0));
    return result;
  }
}

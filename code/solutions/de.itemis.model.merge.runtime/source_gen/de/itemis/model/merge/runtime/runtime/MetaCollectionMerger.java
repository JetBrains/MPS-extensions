package de.itemis.model.merge.runtime.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Collection;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.google.common.collect.Lists;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Collections;
import java.util.Objects;

public class MetaCollectionMerger implements ConceptChildMerger {
  private final SContainmentLink myLink;

  private final CollectionElementMerger existsLeft;
  private final CollectionElementMerger newRight;
  private final CollectionElementMerger existsOnBothSides;
  private Identity id;


  public MetaCollectionMerger(CollectionElementMerger existsLeft, CollectionElementMerger newRight, CollectionElementMerger existsOnBothSides, SContainmentLink link, Identity id) {
    this.existsLeft = existsLeft;
    this.newRight = newRight;
    this.existsOnBothSides = existsOnBothSides;
    this.myLink = link;
    this.id = id;
  }


  /**
   * Perform a merge of the lists leftChildren and rightChildren by matching elements of both.
   * Unmatched elements from rightChildren, left to the first matched element, are prepended.
   * Unmatched elements from rightChildren, right to the last matched element, are added as suffix.
   * 
   * Example where left elements are dropped, right elements kept:
   *  L = [B, C, D, F], R = [A, B, C, F, G] ==> result = [A, B, C, F, G]
   * 
   * @param leftParent currently ignored
   * @param rightParent currently ignored
   * @param leftChildren list of children from the left side
   * @param rightChildren list of children from the right side
   * @param recursiveMergeOperation  merge operation which can be applied to two nodes, where node-specific merge-policy is retrieved
   * @return the list of merged elements
   */
  @Override
  public List<SNode> merge(SNode leftParent, SNode rightParent, final Collection<SNode> leftChildren, Collection<SNode> rightChildren, _FunctionTypes._return_P2_E0<? extends SNode, ? super SNode, ? super SNode> recursiveMergeOperation) {
    List<SNode> rightList = Lists.newLinkedList(rightChildren);
    final List<SNode> result = Lists.newArrayList();
    // Remember all right elements which form an unmatched prefix separately
    List<SNode> rightListPrefix = Lists.newLinkedList();

    // if we have not seen a match before, we must memorize the elements from the right list before equalRightElement separately to prioritize them in the merge
    boolean noMatchYet = true;
    for (final SNode leftElement : CollectionSequence.fromCollection(leftChildren)) {
      SNode equalRightElement = ListSequence.fromList(rightList).findFirst((it) -> isSame(it, leftElement));
      if (equalRightElement == null) {
        // no equal element on right side, apply existsLeft strategy
        this.existsLeft.merge(leftParent, rightParent, result, leftElement, null, recursiveMergeOperation);
        continue;
      }
      // right element is not null, apply the existsOnBothSides strategy
      this.existsOnBothSides.merge(leftParent, rightParent, result, leftElement, equalRightElement, recursiveMergeOperation);
      // if this is the first match we must prioritize towards the right children now
      if (noMatchYet) {
        // perform prefix memorization only once
        noMatchYet = false;
        int indexOfLeftMatchInRight = ListSequence.fromList(rightList).indexOf(equalRightElement);
        // there may be an element in rightChildren which has an equivalent element in leftChildren but later than the current iteration
        // to implement the bias we need to find this element and remember the earliest prefix in the right children list
        // this is the first element in R which has a match in L.
        SNode rightListFirstElemInLeft = ListSequence.fromList(rightList).findFirst((final SNode rcp) -> CollectionSequence.fromCollection(leftChildren).any((lc) -> isSame(rcp, lc)));
        int leftBorder = ListSequence.fromList(rightList).indexOf(rightListFirstElemInLeft);
        leftBorder = (leftBorder > -1 ? leftBorder : indexOfLeftMatchInRight);
        // The unmatched Prefix is the part of R to the left of 'leftBorder'
        ListSequence.fromList(rightListPrefix).addSequence(ListSequence.fromList(rightList).subListSequence(0, leftBorder));
        ListSequence.fromList(rightList).removeSequence(ListSequence.fromList(rightListPrefix));
      }
      ListSequence.fromList(rightList).removeElement(equalRightElement);
    }

    // Do a separate merge for the right-prefix
    List<SNode> resultPrefix = Lists.newArrayList();
    for (SNode rightElementsOnlyRight : ListSequence.fromList(rightListPrefix)) {
      this.newRight.merge(leftParent, rightParent, resultPrefix, null, rightElementsOnlyRight, recursiveMergeOperation);
    }
    // Also add the prefix to the front of the result
    ListSequence.fromList(resultPrefix).reversedList().visitAll((it) -> ListSequence.fromList(result).insertElement(0, it));

    // the remaining unmatched right elements got to the back of the result
    for (SNode rightElementsOnlyRight : ListSequence.fromList(rightList)) {
      this.newRight.merge(leftParent, rightParent, result, null, rightElementsOnlyRight, recursiveMergeOperation);
    }
    return result;
  }

  @Override
  public List<SNode> merge(SNode leftParent, SNode rightParent, _FunctionTypes._return_P2_E0<? extends SNode, ? super SNode, ? super SNode> auto) {
    return this.merge(leftParent, rightParent, Collections.<SNode>emptyList(), Collections.<SNode>emptyList(), auto);
  }

  private boolean isSame(SNode it, SNode leftElemenet) {
    return Objects.equals((this.id.get(it)), (this.id.get(leftElemenet)));
  }

  @Override
  public SContainmentLink link() {
    return this.myLink;
  }
}

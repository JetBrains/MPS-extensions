package de.itemis.mps.editor.diagram.runtime.model;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class AnnotationExtractor {

  public static List<EditorCell> extractAnnotations(EditorCell cell) {
    List<EditorCell> result = ListSequence.fromList(new ArrayList<EditorCell>());
    ListSequence.fromList(result).addElement(cell);
    if (cell instanceof EditorCell_Collection) {
      extractAnnotations((EditorCell_Collection) cell, cell, result);
    }
    return result;
  }

  protected static void extractAnnotations(EditorCell_Collection parentCell, EditorCell cell, List<EditorCell> result) {
    SNode snode = cell.getSNode();
    SNode parentSNode = parentCell.getSNode();
    if (parentSNode != snode && SNodeOperations.isInstanceOf(parentSNode, CONCEPTS.Attribute$g1)) {
      ListSequence.fromList(result).addElement(cell);
      parentCell.removeCell(cell);
    }
    if (cell instanceof EditorCell_Collection) {
      for (EditorCell child : Sequence.fromIterable(((EditorCell_Collection) cell))) {
        extractAnnotations(((EditorCell_Collection) cell), child, result);
      }
    }
  }


  private static final class CONCEPTS {
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
  }
}

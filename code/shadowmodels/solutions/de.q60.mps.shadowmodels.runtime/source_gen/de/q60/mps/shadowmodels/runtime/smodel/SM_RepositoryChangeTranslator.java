package de.q60.mps.shadowmodels.runtime.smodel;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNodeChangeListener;
import org.jetbrains.mps.openapi.module.SModuleListener;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import jetbrains.mps.smodel.event.SModelListener;
import java.util.List;
import de.q60.mps.incremental.runtime.DependencyKey;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.mps.openapi.module.SModule;
import org.modelix.model.mpsadapters.mps.SRepositoryAsNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.event.SPropertyChangeEvent;
import de.q60.mps.shadowmodels.runtime.engine.RoleDependency;
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter;
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent;
import org.jetbrains.mps.openapi.event.SNodeAddEvent;
import de.q60.mps.shadowmodels.runtime.engine.AllChildrenDependency;
import org.modelix.model.mpsadapters.mps.SModelAsNode;
import de.q60.mps.shadowmodels.runtime.engine.ContainmentDependency;
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelRenamedEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.event.SModelImportEvent;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import org.modelix.model.mpsadapters.mps.SModuleAsNode;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public abstract class SM_RepositoryChangeTranslator extends SM_GlobalModelListener implements SNodeChangeListener, SModuleListener, SRepositoryListener, SModelListener, org.jetbrains.mps.openapi.model.SModelListener {
  private static final String REPOSITORY_MODULES_NAME = LINKS.modules$jBPn.getName();
  private static final String MODEL_ROOTNODES_NAME = LINKS.rootNodes$jxXY.getName();
  private static final String MODEL_IMPORTS_NAME = LINKS.modelImports$8DOI.getName();
  private static final String MODULE_MODELS_NAME = LINKS.models$h3QT.getName();

  private List<DependencyKey> pendingChanges = ListSequence.fromList(new ArrayList<DependencyKey>());
  private final AtomicBoolean flushQueued = new AtomicBoolean(false);

  protected void flush() {
    if (ListSequence.fromList(pendingChanges).isEmpty()) {
      return;
    }
    List<DependencyKey> changes = pendingChanges;
    pendingChanges = ListSequence.fromList(new ArrayList<DependencyKey>());
    dependenciesChanged(changes);
  }

  protected void enqueueFlush() {
    if (!(flushQueued.getAndSet(true))) {
      ApplicationManager.getApplication().invokeLater(() -> {
        flushQueued.set(false);
        if (ListSequence.fromList(pendingChanges).isNotEmpty()) {
          SM_CommandHelper.runInCommand(() -> flush());
        }
      });
    }
  }

  protected abstract void dependenciesChanged(Iterable<DependencyKey> changes);

  protected void enqueueChange(DependencyKey change) {
    ListSequence.fromList(pendingChanges).addElement(change);
    enqueueFlush();
  }


  @Override
  public void start(SModule module) {
    if (!(SRepositoryAsNode.isVisible(module))) {
      return;
    }
    super.start(module);
  }

  @Override
  public void stop(SModule module) {
    if (!(SRepositoryAsNode.isVisible(module))) {
      return;
    }
    super.stop(module);
  }

  @Override
  protected void addListener(SModel model) {
    if (model instanceof SM_ShadowModel) {
      return;
    }
    model.addChangeListener(this);
    ((SModelInternal) model).addModelListener(this);
    model.addModelListener(this);
  }
  @Override
  protected void removeListener(SModel model) {
    if (model instanceof SM_ShadowModel) {
      return;
    }
    model.removeChangeListener(this);
    ((SModelInternal) model).removeModelListener(this);
    model.removeModelListener(this);
  }
  @Override
  protected void addListener(SModule module) {
    if (!(SRepositoryAsNode.isVisible(module))) {
      return;
    }
    module.addModuleListener(this);
  }
  @Override
  protected void removeListener(SModule module) {
    if (!(SRepositoryAsNode.isVisible(module))) {
      return;
    }
    module.removeModuleListener(this);
  }
  @Override
  protected void addListener(SRepository repository) {
    repository.addRepositoryListener(this);
  }

  @Override
  protected void removeListener(SRepository repository) {
    repository.removeRepositoryListener(this);
  }





  @Override
  public void propertyChanged(@NotNull SPropertyChangeEvent e) {
    enqueueChange(new RoleDependency(SNodeToNodeAdapter.wrap(e.getNode()).getReference(), e.getProperty().getName()));
    // TODO try to do batch processing for node level changes
    flush();
  }
  @Override
  public void referenceChanged(@NotNull SReferenceChangeEvent e) {
    enqueueChange(new RoleDependency(SNodeToNodeAdapter.wrap(e.getNode()).getReference(), e.getAssociationLink().getName()));
    flush();
  }
  @Override
  public void nodeAdded(@NotNull SNodeAddEvent e) {
    if (e.getParent() != null) {
      enqueueChange(new RoleDependency(SNodeToNodeAdapter.wrap(e.getParent()).getReference(), e.getAggregationLink().getName()));
      enqueueChange(new AllChildrenDependency(SNodeToNodeAdapter.wrap(e.getParent()).getReference()));
    } else {
      // root node
      enqueueChange(new RoleDependency(new SModelAsNode(e.getModel()).getReference(), MODEL_ROOTNODES_NAME));
      enqueueChange(new AllChildrenDependency(new SModelAsNode(e.getModel()).getReference()));
    }
    enqueueChange(new ContainmentDependency(SNodeToNodeAdapter.wrap(e.getChild()).getReference()));
    flush();
  }
  @Override
  public void nodeRemoved(@NotNull SNodeRemoveEvent e) {
    if (e.getParent() != null) {
      enqueueChange(new RoleDependency(SNodeToNodeAdapter.wrap(e.getParent()).getReference(), e.getAggregationLink().getName()));
      enqueueChange(new AllChildrenDependency(SNodeToNodeAdapter.wrap(e.getParent()).getReference()));
    } else {
      // root node
      enqueueChange(new RoleDependency(new SModelAsNode(e.getModel()).getReference(), MODEL_ROOTNODES_NAME));
      enqueueChange(new AllChildrenDependency(new SModelAsNode(e.getModel()).getReference()));
    }
    enqueueChange(new ContainmentDependency(SNodeToNodeAdapter.wrap(e.getChild()).getReference()));
    flush();
  }





  @Override
  public void beforeChildRemoved(SModelChildEvent event) {
  }
  @Override
  public void beforeModelDisposed(SModel model) {
  }
  @Override
  public void beforeModelRenamed(SModelRenamedEvent event) {
  }
  @Override
  public void beforeRootRemoved(SModelRootEvent event) {
  }
  @Override
  public void childAdded(SModelChildEvent event) {
  }
  @Override
  public void childRemoved(SModelChildEvent event) {
  }
  @Override
  public void devkitAdded(SModelDevKitEvent event) {
  }
  @Override
  public void devkitRemoved(SModelDevKitEvent event) {
  }
  @NotNull
  @Override
  public SModelListener.SModelListenerPriority getPriority() {
    return SModelListener.SModelListenerPriority.CLIENT;
  }
  @Override
  public void importAdded(SModelImportEvent event) {
    enqueueChange(new RoleDependency(new SModelAsNode(event.getModel()).getReference(), MODEL_IMPORTS_NAME));
    enqueueFlush();
  }
  @Override
  public void importRemoved(SModelImportEvent event) {
    enqueueChange(new RoleDependency(new SModelAsNode(event.getModel()).getReference(), MODEL_IMPORTS_NAME));
    enqueueFlush();
  }
  @Override
  public void languageAdded(SModelLanguageEvent event) {
  }
  @Override
  public void languageRemoved(SModelLanguageEvent event) {
  }
  @Override
  public void modelLoadingStateChanged(SModel model, ModelLoadingState state) {
  }
  @Override
  public void modelRenamed(SModelRenamedEvent event) {
  }
  @Override
  public void modelSaved(SModel model) {
  }
  @Override
  public void propertyChanged(SModelPropertyEvent event) {
  }
  @Override
  public void referenceAdded(SModelReferenceEvent event) {
  }
  @Override
  public void referenceRemoved(SModelReferenceEvent event) {
  }
  @Deprecated
  @Override
  public void rootAdded(SModelRootEvent event) {
  }
  @Deprecated
  @Override
  public void rootRemoved(SModelRootEvent event) {
  }





  @Override
  public void modelLoaded(SModel model, boolean partially) {
  }
  @Override
  public void modelReplaced(SModel model) {
    enqueueChange(new SM_ModelContentDependency(model.getReference()));
  }
  @Override
  public void modelUnloaded(SModel model) {
  }
  @Override
  public void modelAttached(SModel model, SRepository repository) {
  }
  @Override
  public void modelDetached(SModel model, SRepository repository) {
  }
  @Override
  public void conflictDetected(SModel model) {
  }
  @Override
  public void problemsDetected(SModel model, Iterable<SModel.Problem> problems) {
  }





  @Override
  public void modelAdded(SModule module, SModel model) {
    if (model instanceof SM_ShadowModel) {
      return;
    }
    enqueueChange(new RoleDependency(new SModuleAsNode(module).getReference(), MODULE_MODELS_NAME));
    enqueueChange(new AllChildrenDependency(new SModuleAsNode(module).getReference()));
    enqueueChange(new ContainmentDependency(new SModelAsNode(model).getReference()));
    enqueueFlush();
  }
  @Override
  public void beforeModelRemoved(SModule module, SModel model) {
    if (model instanceof SM_ShadowModel) {
      return;
    }
    enqueueChange(new RoleDependency(new SModuleAsNode(module).getReference(), MODULE_MODELS_NAME));
    enqueueChange(new AllChildrenDependency(new SModuleAsNode(module).getReference()));
    enqueueChange(new ContainmentDependency(new SModelAsNode(model).getReference()));
    enqueueFlush();
  }
  @Override
  public void modelRemoved(SModule module, SModelReference reference) {
  }
  @Override
  public void beforeModelRenamed(SModule module, SModel model, SModelReference reference) {
  }
  @Override
  public void modelRenamed(SModule module, SModel model, SModelReference reference) {
    enqueueChange(new RoleDependency(new SModelAsNode(model).getReference(), PROPS.name$MnvL.getName()));
    enqueueFlush();
  }
  @Override
  public void dependencyAdded(SModule module, SDependency dependency) {
  }
  @Override
  public void dependencyRemoved(SModule module, SDependency dependency) {
  }
  @Override
  public void languageAdded(SModule module, SLanguage language) {
  }
  @Override
  public void languageRemoved(SModule module, SLanguage language) {
  }
  @Override
  public void moduleChanged(SModule module) {
  }





  @Override
  public void moduleAdded(@NotNull SModule module) {
    if (module instanceof SM_ShadowModule) {
      return;
    }
    enqueueChange(new RoleDependency(new SRepositoryAsNode(module.getRepository()).getReference(), REPOSITORY_MODULES_NAME));
    enqueueChange(new AllChildrenDependency(new SRepositoryAsNode(module.getRepository()).getReference()));
    enqueueChange(new ContainmentDependency(new SModuleAsNode(module).getReference()));
    enqueueFlush();
  }

  @Override
  public void beforeModuleRemoved(@NotNull SModule module) {
    if (module instanceof SM_ShadowModule) {
      return;
    }
    enqueueChange(new RoleDependency(new SRepositoryAsNode(module.getRepository()).getReference(), REPOSITORY_MODULES_NAME));
    enqueueChange(new AllChildrenDependency(new SRepositoryAsNode(module.getRepository()).getReference()));
    enqueueChange(new ContainmentDependency(new SModuleAsNode(module).getReference()));
    enqueueFlush();
  }
  @Override
  public void moduleRemoved(@NotNull SModuleReference reference) {
  }
  @Override
  public void commandStarted(SRepository repository) {
  }
  @Override
  public void commandFinished(SRepository repository) {
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink modules$jBPn = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, 0x69652614fd1c517L, "modules");
    /*package*/ static final SContainmentLink rootNodes$jxXY = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x69652614fd1c514L, "rootNodes");
    /*package*/ static final SContainmentLink modelImports$8DOI = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x58dbe6e4d4f32eb8L, "modelImports");
    /*package*/ static final SContainmentLink models$h3QT = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, 0x69652614fd1c512L, "models");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}

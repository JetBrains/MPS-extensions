package de.slisson.mps.tables.runtime.selection;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.selection.AbstractMultipleSelection;
import de.slisson.mps.tables.runtime.cells.TableEditor;
import jetbrains.mps.openapi.editor.EditorComponent;
import de.slisson.mps.tables.runtime.simplegrid.GridPosition;
import java.util.Map;
import jetbrains.mps.openapi.editor.cells.CellInfo;
import jetbrains.mps.openapi.editor.selection.SelectionStoreException;
import jetbrains.mps.nodeEditor.selection.SelectionRestoreException;
import jetbrains.mps.nodeEditor.selection.SelectionInfoImpl;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import de.slisson.mps.tables.runtime.gridmodel.Grid;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellGridLeaf;
import jetbrains.mps.openapi.editor.selection.SelectionInfo;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.openapi.editor.EditorContext;

public class TableRangeSelection extends AbstractMultipleSelection {

  private static final String PROPERTY_START_COLUMN = "startColumn";
  private static final String PROPERTY_START_ROW = "startRow";
  private static final String PROPERTY_END_COLUMN = "endColumn";
  private static final String PROPERTY_END_ROW = "endRow";

  private TableEditor myTable;

  private int myStartColumn;
  private int myStartRow;
  private int myEndColumn;
  private int myEndRow;

  public TableRangeSelection(EditorComponent editorComponent, TableEditor table, GridPosition start, GridPosition end) {
    super(editorComponent);
    myTable = table;
    myStartColumn = start.getX();
    myStartRow = start.getY();
    myEndColumn = end.getX();
    myEndRow = end.getY();
    init();
  }

  public TableRangeSelection(EditorComponent editorComponent, Map<String, String> properties, CellInfo cellInfo) throws SelectionStoreException, SelectionRestoreException {
    super(editorComponent);
    if (cellInfo == null) {
      throw new SelectionStoreException("Required CellInfo parameter is null");
    }
    myTable = (TableEditor) cellInfo.findCell((jetbrains.mps.nodeEditor.EditorComponent) editorComponent);
    if (myTable == null) {
      throw new SelectionRestoreException();
    }
    myStartColumn = SelectionInfoImpl.Util.getIntProperty(properties, TableRangeSelection.PROPERTY_START_COLUMN);
    myStartRow = SelectionInfoImpl.Util.getIntProperty(properties, TableRangeSelection.PROPERTY_START_ROW);
    myEndColumn = SelectionInfoImpl.Util.getIntProperty(properties, TableRangeSelection.PROPERTY_END_COLUMN);
    myEndRow = SelectionInfoImpl.Util.getIntProperty(properties, TableRangeSelection.PROPERTY_END_ROW);
    init();
  }

  protected void init() {
    setSelectedCells(getSelectedGridCells());
  }

  public List<EditorCell> getSelectedGridCells() {
    List<EditorCell> selectedCells = ListSequence.fromList(new ArrayList<EditorCell>());
    Grid grid = myTable.getGrid();
    for (int x = Math.min(getStartColumn(), getEndColumn()); x <= Math.max(getStartColumn(), getEndColumn()); x++) {
      for (int y = Math.min(getStartRow(), getEndRow()); y <= Math.max(getStartRow(), getEndRow()); y++) {
        EditorCell cell = check_tr8opa_a0a0a0c0t(as_tr8opa_a0a0a0a0c0t(grid.getElement(x, y), EditorCellGridLeaf.class));
        if (cell != null) {
          ListSequence.fromList(selectedCells).addElement(cell);
        }
      }

    }
    return selectedCells;
  }

  @Override
  public SelectionInfo getSelectionInfo() throws SelectionStoreException {
    SelectionInfoImpl selectionInfo = new SelectionInfoImpl(this.getClass().getName(), PersistenceFacade.getInstance().createModuleReference("da21218f-a674-474d-8b4e-d59e33007003(de.slisson.mps.tables.runtime)"));
    selectionInfo.setCellInfo(myTable.getCellInfo());
    selectionInfo.getPropertiesMap().put(TableRangeSelection.PROPERTY_START_COLUMN, Integer.toString(myStartColumn));
    selectionInfo.getPropertiesMap().put(TableRangeSelection.PROPERTY_START_ROW, Integer.toString(myStartRow));
    selectionInfo.getPropertiesMap().put(TableRangeSelection.PROPERTY_END_COLUMN, Integer.toString(myEndColumn));
    selectionInfo.getPropertiesMap().put(TableRangeSelection.PROPERTY_END_ROW, Integer.toString(myEndRow));
    return selectionInfo;
  }

  public UndirectedTableRange toUndirectedRange() {
    boolean leftToRight = getStartRow() <= getEndRow();
    int startRow = (leftToRight ? getStartRow() : getEndRow());
    int endRow = (leftToRight ? getEndRow() : getStartRow());

    boolean topToBottom = getStartColumn() <= getEndColumn();
    int startCol = (topToBottom ? getStartColumn() : getEndColumn());
    int endCol = (topToBottom ? getEndColumn() : getStartColumn());

    return new UndirectedTableRange(getTable(), startRow, endRow, startCol, endCol);
  }

  @Override
  public boolean isSame(Selection other) {
    if (this == other) {
      return true;
    }
    if (other == null || this.getClass() != other.getClass()) {
      return false;
    }

    TableRangeSelection that = (TableRangeSelection) other;
    if (getEndColumn() != that.getEndColumn()) {
      return false;
    }
    if (getEndRow() != that.getEndRow()) {
      return false;
    }
    if (getStartColumn() != that.getStartColumn()) {
      return false;
    }
    if (getStartRow() != that.getStartRow()) {
      return false;
    }
    if ((myTable != null ? !(myTable.equals(that.myTable)) : that.myTable != null)) {
      return false;
    }

    return true;
  }

  public int getStartRow() {
    return myStartRow;
  }

  public int getStartColumn() {
    return myStartColumn;
  }

  public int getEndRow() {
    return myEndRow;
  }

  public int getEndColumn() {
    return myEndColumn;
  }

  public TableEditor getTable() {
    return myTable;
  }

  @Override
  public boolean canExecuteAction(CellActionType type) {
    CellAction action = getTable().getAction(type);
    if (action != null) {
      return action.canExecute(getTable().getContext());
    }
    return super.canExecuteAction(type);
  }

  @Override
  public void executeAction(CellActionType type) {
    TableEditor table = getTable();
    final CellAction action = table.getAction(type);
    if (action != null) {
      final EditorContext context = table.getContext();
      context.getRepository().getModelAccess().executeCommand(() -> {
        if (action.canExecute(context)) {
          action.execute(context);
        }
      });
    }
  }
  private static EditorCell check_tr8opa_a0a0a0c0t(EditorCellGridLeaf checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorCell();
    }
    return null;
  }
  private static <T> T as_tr8opa_a0a0a0a0c0t(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

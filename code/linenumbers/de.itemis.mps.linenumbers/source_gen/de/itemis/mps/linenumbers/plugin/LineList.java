package de.itemis.mps.linenumbers.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import java.util.Objects;
import java.util.Arrays;

public class LineList extends AbstractLineList implements ILineList {
  private ILineList[] subLists;
  private int size;
  private int firstLineNumber = 0;
  private ILineList subListForMinY;
  private ILineList subListForMaxY;

  public static ILineList create(Iterable<ILineList> subLists_) {
    List<ILineList> subLists = Sequence.fromIterable(subLists_).toList();
    if (ListSequence.fromList(subLists).isEmpty()) {
      return null;
    }
    if (ListSequence.fromList(subLists).count() == 1) {
      return ListSequence.fromList(subLists).first();
    }
    return new LineList(subLists);
  }

  public LineList(Iterable<ILineList> subLists) {
    this.subLists = Sequence.fromIterable(subLists).sort((it) -> it.getMinY(), true).alsoSort((it) -> it.getMaxY(), true).toGenericArray(ILineList.class);
    subListForMinY = Sequence.fromIterable(subLists).sort((it) -> it.getMinY(), true).first();
    subListForMaxY = Sequence.fromIterable(subLists).sort((it) -> it.getMaxY(), false).first();
    this.size = Sequence.fromIterable(Sequence.fromArray(this.subLists)).foldLeft(0, (Integer s, ILineList it) -> s + it.getSize());
    if (this.subLists.length == 0) {
      throw new IllegalArgumentException("At least one sub list required");
    }
  }

  @Override
  public void setExpandedSize(int size) {
    super.setExpandedSize(size);
    firstLineNumber = 0;
  }

  @Override
  public Iterable<Line> getLines() {
    return Sequence.fromIterable(Sequence.fromArray(subLists)).translate((it) -> it.getLines());
  }

  @Override
  public int getMaxY() {
    return subListForMaxY.getMaxY();
  }

  @Override
  public int getMinY() {
    return subListForMinY.getMinY();
  }

  @Override
  public int getSize() {
    return size;
  }

  @Nullable
  @Override
  public ILineList linesBelowY(final int y) {
    List<ILineList> filteredLines = Sequence.fromIterable(Sequence.fromArray(subLists)).select((it) -> it.linesBelowY(y)).where(new NotNullWhereFilter()).toList();
    if (ListSequence.fromList(filteredLines).isEmpty()) {
      return null;
    }
    LineList result = new LineList(filteredLines);
    if (Objects.equals(result, this)) {
      return this;
    }
    if (result.subLists.length == 0) {
      return null;
    }
    if (result.subLists.length == 1) {
      return result.subLists[0];
    }
    result.setExpandedSize(result.getSize() + (getExpandedSize() - getSize()));
    return result;
  }

  @Override
  public void assignLineNumber(int lineNumber) {
    if (lineNumber == firstLineNumber) {
      return;
    }
    firstLineNumber = lineNumber;
    for (ILineList subList : subLists) {
      subList.assignLineNumber(lineNumber);
      lineNumber += subList.getExpandedSize();
    }
  }

  @Override
  public Line getLast() {
    return subLists[subLists.length - 1].getLast();
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    LineList that = (LineList) o;
    if (size != that.size) {
      return false;
    }
    if (!(Arrays.equals(subLists, that.subLists))) {
      return false;
    }

    return true;
  }
  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + size;
    result = 31 * result + ((subLists != null ? Arrays.hashCode(subLists) : 0));
    return result;
  }
}

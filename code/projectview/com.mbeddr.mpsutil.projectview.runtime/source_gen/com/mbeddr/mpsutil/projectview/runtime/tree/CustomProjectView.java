package com.mbeddr.mpsutil.projectview.runtime.tree;

/*Generated by MPS */

import jetbrains.mps.ide.projectPane.BaseLogicalViewProjectPane;
import jetbrains.mps.ide.projectView.ProjectViewPaneOverride;
import jetbrains.mps.logging.Logger;
import com.mbeddr.mpsutil.projectview.runtime.ViewId;
import com.intellij.openapi.vfs.VirtualFileManagerListener;
import jetbrains.mps.classloading.DeployListener;
import jetbrains.mps.make.IMakeNotificationListener;
import jetbrains.mps.ide.platform.watching.ReloadListener;
import java.util.Set;
import com.intellij.util.messages.MessageBusConnection;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.openapi.fileEditor.FileEditorManagerListener;
import com.intellij.openapi.fileEditor.FileEditorManagerEvent;
import com.intellij.openapi.fileEditor.FileEditor;
import jetbrains.mps.ide.editor.MPSFileNodeEditor;
import jetbrains.mps.openapi.editor.EditorComponent;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import javax.swing.Icon;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.ide.icons.IdeIcons;
import com.mbeddr.mpsutil.projectview.runtime.IViewDescriptor;
import org.jetbrains.annotations.Nullable;
import com.mbeddr.mpsutil.projectview.runtime.ViewRegistry;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.workbench.MPSDataKeys;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import javax.swing.tree.TreeNode;
import java.util.ArrayList;
import javax.swing.tree.TreePath;
import jetbrains.mps.workbench.ActionPlace;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.project.Solution;
import jetbrains.mps.ide.platform.watching.ReloadManagerComponent;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.make.MakeServiceComponent;
import com.intellij.openapi.vfs.VirtualFileManager;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.RepoListenerRegistrar;
import org.jetbrains.mps.openapi.module.SModuleReference;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.util.Disposer;
import jetbrains.mps.make.MakeNotification;
import jetbrains.mps.module.ReloadableModule;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.ide.SelectInTarget;
import com.intellij.openapi.util.ActionCallback;
import com.intellij.openapi.vfs.VirtualFile;
import javax.swing.JComponent;
import com.intellij.ui.ScrollPaneFactory;
import com.intellij.openapi.actionSystem.ActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.ide.ui.tree.TreeHighlighterExtension;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.ide.ui.tree.MPSTree;
import org.jdom.Element;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.wm.ToolWindowManager;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.openapi.wm.ToolWindowId;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.mps.openapi.model.SNodeReference;
import com.intellij.util.ui.update.Update;
import jetbrains.mps.smodel.ModelReadRunnable;
import java.util.HashSet;
import com.intellij.openapi.ui.SimpleToolWindowPanel;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import org.jetbrains.mps.openapi.repository.CommandListener;
import com.mbeddr.mpsutil.projectview.runtime.ViewElement;

public class CustomProjectView extends BaseLogicalViewProjectPane implements ProjectViewPaneOverride {
  private static final Logger LOG = Logger.getLogger(CustomProjectView.class);

  private ViewId myViewId;
  private VirtualFileManagerListener myRefreshListener;
  private final MyRepositoryListener commandRepoListener = new MyRepositoryListener();
  private DeployListener myClassesListener;
  private IMakeNotificationListener myMakeNotificationListener;
  private ReloadListener myReloadListener;
  private WeightValues.AquiredValue myWeight;

  /**
   * Use this flag to signal if this view has already been disposed.
   * We simply guard against repeated calls of the dispose method with the flag.
   */
  private boolean isDisposed = false;

  private Set<ComponentCreationListener> myComponentCreationListeners;
  private static boolean ourShowGenStatus = true;
  private TreeState treeState = new TreeState();
  private MessageBusConnection myConnection;

  private SRepositoryListener myRepositoryListener = null;
  private MySimpleToolWindowPanel myComponent;
  private final MergingUpdateQueue myUpdateQueue = new MergingUpdateQueue("Project Pane Updates Queue", 500, true, null, null, null, true);

  private final FileEditorManagerListener myEditorListener = new FileEditorManagerListener() {
    @Override
    public void selectionChanged(FileEditorManagerEvent event) {
      FileEditor fileEditor = event.getNewEditor();
      if (fileEditor instanceof MPSFileNodeEditor) {
        final MPSFileNodeEditor editor = (MPSFileNodeEditor) fileEditor;
        if (getProjectView().isAutoscrollFromSource(getId())) {
          EditorComponent editorComponent = editor.getNodeEditor().getCurrentEditorComponent();
          if (editorComponent == null) {
            return;
          }
          final SNode sNode = editorComponent.getEditedNode();
          if (sNode != null) {
            selectNodeWithoutExpansion(sNode.getReference());
          }
        }
      }
    }
  };

  public CustomProjectView(@NotNull final Project ideaProject, @NotNull final ViewId viewId) {
    super(ideaProject);
    myViewId = viewId;
  }

  @NotNull
  public Icon getIcon() {
    final Wrappers._T<Icon> icon = new Wrappers._T<Icon>(null);
    getMPSProject().getRepository().getModelAccess().runReadAction(() -> icon.value = check_rm1e9y_a0a0a1a42(getMyViewDescriptor(), CustomProjectView.this));
    return (icon.value != null ? icon.value : IdeIcons.DEFAULT_ICON);
  }

  @NotNull
  public String getId() {
    return "CustomProjectView_" + myViewId.getId();
  }

  @Override
  public boolean isDefaultPane(@NotNull final Project project) {
    final IViewDescriptor viewDescriptor = getMyViewDescriptor();
    return (viewDescriptor != null ? viewDescriptor.isDefaultView(project) : false);
  }

  @NotNull
  public String getTitle() {
    String label = check_rm1e9y_a0a0eb(getMyViewDescriptor(), this);
    return ((label != null && label.length() > 0) ? label : "no title");
  }

  @Nullable
  private IViewDescriptor getMyViewDescriptor() {
    return ViewRegistry.getInstance().getDescriptor(myViewId);
  }

  public int getWeight() {
    if (myWeight == null) {
      int preferedValue = 10000;
      for (IViewDescriptor descriptor : Sequence.fromIterable(ViewRegistry.getInstance().getDescriptors(myViewId))) {
        preferedValue = Math.min(preferedValue, descriptor.getPriority());
      }
      myWeight = WeightValues.tryAquire(preferedValue);
    }
    return myWeight.getValue();
  }

  @Override
  public Object getData(final String dataId) {
    final IViewDescriptor descriptor = getMyViewDescriptor();
    if (descriptor != null && descriptor.isDataProvider()) {
      final Object data = descriptor.getData(dataId, this);
      if (data != null) {
        return data;
      }
    }

    if (CustomProjectViewDataKeys.CUSTOM_PROJECT_VIEW.is(dataId)) {
      return this;
    }

    final List<Object> selectedObjects = ListSequence.fromList(getSelectedTreeNodes(CustomTreeNode.class)).select(new _FunctionTypes._return_P1_E0<Object, CustomTreeNode>() {
      public Object invoke(CustomTreeNode it) {
        return it.getElement().getObject();
      }
    }).toList();
    final Object selectedObject = ListSequence.fromList(selectedObjects).first();

    if (MPSDataKeys.NODE.is(dataId)) {
      return as_rm1e9y_a0a0i0lb(selectedObject, SNode.class);
    }
    if (MPSDataKeys.NODES.is(dataId)) {
      return ListSequence.fromList(selectedObjects).ofType(SNode.class).toList();
    }
    if (MPSDataKeys.MODEL.is(dataId)) {
      return as_rm1e9y_a0a0k0lb(selectedObject, SModel.class);
    }
    if (MPSDataKeys.MODELS.is(dataId)) {
      return ListSequence.fromList(selectedObjects).ofType(SModel.class).toList();
    }
    if (MPSDataKeys.CONTEXT_MODEL.is(dataId)) {
      return getContextObject(SModel.class);
    }
    if (MPSDataKeys.MODULE.is(dataId)) {
      return as_rm1e9y_a0a0n0lb(selectedObject, SModule.class);
    }
    if (MPSDataKeys.MODULES.is(dataId)) {
      return ListSequence.fromList(selectedObjects).ofType(SModule.class).toList();
    }
    if (MPSDataKeys.CONTEXT_MODULE.is(dataId)) {
      return getContextObject(SModule.class);
    }
    if (MPSDataKeys.TREE_NODE.is(dataId)) {
      return ListSequence.fromList(getSelectedTreeNodes(TreeNode.class)).first();
    }
    if (MPSDataKeys.TREE_NODES.is(dataId)) {
      return ListSequence.fromList(getSelectedTreeNodes(TreeNode.class)).toList();
    }
    if (MPSDataKeys.TREE_SELECTION_SIZE.is(dataId)) {
      return getSelectionSize();
    }
    if (MPSDataKeys.PLACE.is(dataId)) {
      return getPlace();
    }

    return super.getData(dataId);
  }

  @NotNull
  public <T extends TreeNode> List<T> getSelectedTreeNodes(final Class<T> nodeClass) {
    return (List<T>) super.getSelectedTreeNodes(nodeClass);
  }

  @Override
  @NotNull
  public List<SNode> getSelectedSNodes() {
    final List<SNode> result = new ArrayList<SNode>();
    for (CustomTreeNode node : getSelectedTreeNodes(CustomTreeNode.class)) {
      final SNode snode = node.getSNode();
      if (snode == null) {
        continue;
      }
      result.add(snode);
    }
    return result;
  }

  @Override
  @NotNull
  public List<SModel> getSelectedModels() {
    final List<SModel> result = new ArrayList<SModel>();
    for (CustomTreeNode node : getSelectedTreeNodes(CustomTreeNode.class)) {
      final SModel model = node.getModel();
      if (model == null) {
        continue;
      }
      ListSequence.fromList(result).addElement(model);
    }
    return result;
  }

  @Override
  public SModel getSelectedModel() {
    return ListSequence.fromList(getSelectedModels()).first();
  }

  @Override
  public SModel getContextModel() {
    CustomTreeNode selectedTreeNode = getSelectedTreeNode(CustomTreeNode.class);
    while (selectedTreeNode != null) {
      if (selectedTreeNode.getModel() != null) {
        return selectedTreeNode.getModel();
      }
      selectedTreeNode = ((CustomTreeNode) selectedTreeNode.getParent());
    }
    return null;
  }

  protected <T> T getContextObject(final Class<T> type) {
    for (TreeNode currentNode = ListSequence.fromList(getSelectedTreeNodes(TreeNode.class)).first(); currentNode != null; currentNode = currentNode.getParent()) {
      final Object obj = check_rm1e9y_a0a0a0wb(check_rm1e9y_a0a0a0a84(as_rm1e9y_a0a0a0a0a94(currentNode, CustomTreeNode.class)));
      if (type.isInstance(obj)) {
        return ((T) obj);
      }
    }
    return null;
  }

  public int getSelectionSize() {
    final TreePath[] selection = getSelectionPaths();
    return (selection == null ? 0 : selection.length);
  }

  private ActionPlace getPlace() {
    final CustomTreeNode treeNode = getSelectedTreeNode(CustomTreeNode.class);
    Object selectedObject = check_rm1e9y_a0b0ac(check_rm1e9y_a0a1a25(treeNode));

    if (selectedObject instanceof SNode) {
      return ActionPlace.PROJECT_PANE_SNODE;
    } else
    if (selectedObject instanceof SModel) {
      return ActionPlace.PROJECT_PANE_SMODEL;
    } else
    if (selectedObject instanceof jetbrains.mps.project.Project) {
      return ActionPlace.PROJECT_PANE_PROJECT;
    } else
    if (selectedObject instanceof Generator) {
      return ActionPlace.PROJECT_PANE_GENERATOR;
    } else
    if (selectedObject instanceof Language) {
      return ActionPlace.PROJECT_PANE_LANGUAGE;
    } else if (selectedObject instanceof DevKit) {
      return ActionPlace.PROJECT_PANE_DEVKIT;
    } else if (selectedObject instanceof Solution) {
      return ActionPlace.PROJECT_PANE_SOLUTION;
    }
    return ActionPlace.PROJECT_PANE;
  }

  @Override
  public void dispose() {
    if (!(this.isDisposed)) {
      check_rm1e9y_a0a0a45(((CustomProjectTree) myTree));
      super.dispose();
      check_rm1e9y_a2a0a45(myWeight);
      this.isDisposed = true;
    }
  }

  @Override
  protected void removeListeners() {
    if (myReloadListener != null) {
      getProject().getComponent(ReloadManagerComponent.class).removeReloadListener(myReloadListener);
      myReloadListener = null;
    }
    final MPSProject mpsProject = getMPSProject();
    if (myClassesListener != null) {
      mpsProject.getComponent(ClassLoaderManager.class).removeListener(myClassesListener);
      myClassesListener = null;
    }

    if (myMakeNotificationListener != null) {
      mpsProject.getComponent(MakeServiceComponent.class).get().removeListener(myMakeNotificationListener);
      myMakeNotificationListener = null;
    }
    if (myRefreshListener != null) {
      VirtualFileManager.getInstance().removeVirtualFileManagerListener(myRefreshListener);
      myRefreshListener = null;
    }
    if (myRepositoryListener != null) {
      check_rm1e9y_a0a6a65(myConnection);
      myConnection = null;
      mpsProject.getComponent(MPSModuleRepository.class).removeRepositoryListener(myRepositoryListener);
      myRepositoryListener = null;
    }
    mpsProject.getModelAccess().removeCommandListener(commandRepoListener);
    new RepoListenerRegistrar(mpsProject.getRepository(), commandRepoListener).detach();
  }

  @Override
  protected void addListeners() {
    ReloadManagerComponent reloadManager = getProject().getComponent(ReloadManagerComponent.class);
    if (reloadManager != null) {
      myReloadListener = new ReloadListener() {
        @Override
        public void reloadStarted() {
        }
        @Override
        public void reloadFinished() {
          rebuild();
        }
      };
      reloadManager.addReloadListener(myReloadListener);
    }

    final MPSProject mpsProject = getMPSProject();
    IViewDescriptor myDescriptor = getMyViewDescriptor();
    if (myDescriptor != null) {
      if (myDescriptor.rebuildOnRepoChange()) {
        assert myConnection == null;
        // double initialization
        myConnection = getProject().getMessageBus().connect();
        myConnection.subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, myEditorListener);
        myRepositoryListener = new SRepositoryListener() {
          @Override
          public void moduleAdded(@NotNull SModule module) {
            rebuild();
          }
          @Override
          public void moduleRemoved(@NotNull SModuleReference module) {
            rebuild();
          }
        };
        mpsProject.getComponent(MPSModuleRepository.class).addRepositoryListener(myRepositoryListener);
      }
      if (myDescriptor.rebuildOnFileChange()) {
        myRefreshListener = new RefreshListener();
        Disposable disposer = Disposer.newDisposable();
        VirtualFileManager.getInstance().addVirtualFileManagerListener(myRefreshListener, disposer);
      }
      if (myDescriptor.rebuildOnMake()) {
        MakeServiceComponent makeServiceProvider = mpsProject.getComponent(MakeServiceComponent.class);
        if (makeServiceProvider != null && makeServiceProvider.get() != null) {
          myMakeNotificationListener = new IMakeNotificationListener.Stub() {
            @Override
            public void sessionClosed(MakeNotification notification) {
              // rebuild tree in case of 'cancel' too (need to get 'transient models' node rebuilt)
              rebuild();
            }
          };
          makeServiceProvider.get().addListener(myMakeNotificationListener);
        }
      }
      if (myDescriptor.rebuildOnClassLoad()) {
        myClassesListener = new DeployListener() {
          @Override
          public void onUnloaded(Set<ReloadableModule> set, @NotNull ProgressMonitor monitor) {
          }
          @Override
          public void onLoaded(Set<ReloadableModule> set, @NotNull ProgressMonitor monitor) {
            rebuild();
          }
        };
        mpsProject.getComponent(ClassLoaderManager.class).addListener(myClassesListener);
      }
    }
    new RepoListenerRegistrar(mpsProject.getRepository(), commandRepoListener).attach();
    mpsProject.getModelAccess().addCommandListener(commandRepoListener);
  }

  @Override
  public CustomProjectTree getTree() {
    return (CustomProjectTree) myTree;
  }

  protected MPSProject getMPSProject() {
    return ProjectHelper.fromIdeaProject(getProject());
  }

  @Override
  @NotNull
  public SelectInTarget createSelectInTarget() {
    return new CustomProjectViewSelectInTarget(this);
  }

  @NotNull
  @Override
  public ActionCallback updateFromRoot(boolean restoreExpandedPaths) {
    rebuild();
    return new ActionCallback();
  }

  @Override
  public void select(Object element, final VirtualFile file, final boolean requestFocus) {
  }

  @Override
  @NotNull
  public JComponent createComponent() {
    if (isComponentCreated()) {
      return myComponent;
    }
    CustomProjectTree tree = new CustomProjectTree(ProjectHelper.fromIdeaProject(myProject), myViewId);
    Disposer.register(this, tree);
    myTree = tree;
    myComponent = new MySimpleToolWindowPanel(true, true);
    myComponent.setContent(ScrollPaneFactory.createScrollPane(getTree()));

    String toolbarActionGroupId = check_rm1e9y_a0h0sc(getMyViewDescriptor(), this);
    if (toolbarActionGroupId != null) {
      ActionGroup toolbarActionGroup = ActionUtils.getGroup(toolbarActionGroupId);
      if (toolbarActionGroup != null) {
        ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.TOOLBAR, toolbarActionGroup, true);
        toolbar.setTargetComponent(getTree());
        myComponent.setToolbar(toolbar.getComponent());
      } else {
        if (LOG.isWarningLevel()) {
          LOG.warning(String.format("Couldn't find toolbar action group with id \"%s\"", toolbarActionGroupId));
        }
      }
    }

    addListeners();
    if (!(RuntimeFlags.isTestMode())) {
      rebuild();
    }
    TreeHighlighterExtension.attachHighlighters(tree, myProject);
    fireComponentCreated();
    restoreExpandedPathsOverride();
    return myComponent;
  }

  @Override
  protected boolean isComponentCreated() {
    return myComponent != null;
  }

  public void activate() {
    ThreadUtils.assertEDT();
    activatePane(null, true);
  }

  @Override
  public void rebuild() {
    saveExpandedPaths();
    myUpdateQueue.queue(new AbstractUpdate(UpdateID.REBUILD) {
      @Override
      public void run() {
        if (getTree() == null || getProject().isDisposed() || getTree().isDisposed()) {
          return;
        }
        CustomTreeNode.loadAllImmediately(() -> {
          getTree().rebuildNow();
          getTree().expandProjectNode();
          // synchronous restore of expansion state to avoid a collapsed tree being visible before the expansion happens
          loadExpandedPaths();
        });
      }
    });
  }

  @Override
  protected void saveExpandedPaths() {
    if (myTree != null && myTree.getModel().getRoot() != null) {
      TreeState newState = new TreeState();
      newState.setExpandedPathsRaw(((MPSTree) myTree).getExpandedPathsRaw());
      newState.setSelectedPathsRaw(((MPSTree) myTree).getSelectedPathsRaw());
      treeState = treeState.replaceIfNotEmpty(newState);
    }
  }

  protected void loadExpandedPaths() {
    if (myTree != null) {
      ((MPSTree) myTree).loadState(treeState.getExpandedPathsRaw(), treeState.getSelectedPathsRaw());
    }
  }

  @Override
  public void restoreExpandedPathsOverride() {
    // this gets called from the MPS's implementation of ProjectViewImpl
    // we must resort to this hack because the method in the superclass is declared private
    myUpdateQueue.queue(new AbstractUpdate(UpdateID.RESTORE_EXPAND) {
      @Override
      public void run() {
        loadExpandedPaths();
      }
    });
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    saveExpandedPaths();
    // keep the binary format in sync with what IDEA writes
    Element subPane = new Element("subPane");
    // we probably don't need this... we probably don't need this...
    if (getSubId() != null) {
      subPane.setAttribute("subId", getSubId());
    }
    writePaths(subPane, treeState.getExpandedPathsRaw(), "PATH");
    writePaths(subPane, treeState.getSelectedPathsRaw(), "SELECTED");
    element.addContent(subPane);
  }

  private void writePaths(Element parentElement, List<List<String>> pathsRaw, String elementName) {
    for (List<String> path : pathsRaw) {
      Element pathElement = new Element(elementName);
      writePath(path, pathElement);
      parentElement.addContent(pathElement);
    }
  }

  private void writePath(List<String> path, Element pathElement) {
    for (String treeNodeId : path) {
      Element elm = new Element("PATH_ELEMENT");
      writeNodeId(treeNodeId, elm);
      pathElement.addContent(elm);
    }
  }

  private void writeNodeId(String treeNodeId, Element elm) {
    Element option1 = new Element("option");
    option1.setAttribute("name", "myItemId");
    option1.setAttribute("value", treeNodeId);
    elm.addContent(option1);
    Element option2 = new Element("option");
    option2.setAttribute("name", "myItemType");
    option2.setAttribute("value", "");
    elm.addContent(option2);
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    // emulate the superclass's readExternal using the same binary format
    List<Element> subPanes = element.getChildren("subPane");
    for (Element subPane : subPanes) {
      TreeState newState = new TreeState();
      newState.setExpandedPathsRaw(readPaths(subPane, "PATH"));
      newState.setSelectedPathsRaw(readPaths(subPane, "SELECTED"));
      treeState = treeState.replaceIfNotEmpty(newState);
    }
    if (myTree != null) {
      ((MPSTree) myTree).loadState(treeState.getExpandedPathsRaw(), treeState.getSelectedPathsRaw());
    }
    restoreExpandedPathsOverride();
  }

  private List<List<String>> readPaths(Element parentElement, String name) {
    List<List<String>> result = new ArrayList<List<String>>();
    for (Element pathElement : parentElement.getChildren(name)) {
      List<String> path = readPath(pathElement);
      result.add(path);
    }
    return result;
  }

  @NotNull
  private List<String> readPath(Element pathElement) {
    List<String> path = new ArrayList<String>();
    for (Element elm : pathElement.getChildren("PATH_ELEMENT")) {
      String treeNodeId = readNodeId(elm);
      if (treeNodeId != null) {
        path.add(treeNodeId);
      }
    }
    return path;
  }

  @Nullable
  private String readNodeId(Element elm) {
    List<Element> options = elm.getChildren("option");
    String treeNodeId = null;
    for (Element option : options) {
      if ("myItemId".equals(option.getAttributeValue("name"))) {
        treeNodeId = option.getAttributeValue("value");
        break;
      }
    }
    return treeNodeId;
  }

  public void selectModule(@NotNull final SModule module, final boolean autofocus) {
    ThreadUtils.assertEDT();
    Runnable lookupAndSelect = new LookupAndSelect(module.getModuleReference());
    activatePane(new ScheduleUpdateRunnable(myUpdateQueue, createModelReadUpdate(UpdateID.SELECT, lookupAndSelect)), autofocus);
  }

  public void selectModel(@NotNull final SModel model, boolean autofocus) {
    ThreadUtils.assertEDT();
    Runnable lookupAndSelect = new LookupAndSelect(model.getReference());
    activatePane(new ScheduleUpdateRunnable(myUpdateQueue, createModelReadUpdate(UpdateID.SELECT, lookupAndSelect)), autofocus);
  }

  private void activatePane(@Nullable final Runnable postActivate, boolean autoFocusContents) {
    ToolWindowManager windowManager = ToolWindowManager.getInstance(getProject());
    ToolWindow projectViewToolWindow = windowManager.getToolWindow(ToolWindowId.PROJECT_VIEW);
    // In unit test mode projectViewToolWindow == null
    if (!(ApplicationManager.getApplication().isUnitTestMode())) {
      projectViewToolWindow.activate(new Runnable() {
        @Override
        public void run() {
          // I'm not quite sure next changeView is essential (what does toolWindow.activate() does then?),
          // but since there's no documentation what to expect, leave it the way it used to be in PaneActivator.
          getProjectView().changeView(getId());
          if (postActivate != null) {
            postActivate.run();
          }
        }
      }, autoFocusContents);
    }
  }

  public void selectNode(@NotNull final SNode node, boolean autofocus) {
    ThreadUtils.assertEDT();
    final Runnable lookupAndSelect = new LookupAndSelect(node.getReference());
    activatePane(new ScheduleUpdateRunnable(myUpdateQueue, createModelReadUpdate(UpdateID.SELECT, lookupAndSelect)), autofocus);
  }

  private void selectNodeWithoutExpansion(@NotNull SNodeReference nodeRef) {
    final Runnable lookupAndSelect = new LookupAndSelect(nodeRef);
    myUpdateQueue.queue(createModelReadUpdate(UpdateID.SELECT, new Runnable() {
      @Override
      public void run() {
        getTree().runWithoutExpansion(lookupAndSelect);
      }
    }));
  }

  /**
   * @return update code block with the given id, that runs supplied delegate with read access to project repository
   */
  private Update createModelReadUpdate(@NotNull UpdateID id, @NotNull Runnable delegate) {
    return new UpdateAdapter(id, new ModelReadRunnable(getMPSProject().getModelAccess(), delegate));
  }

  private void fireComponentCreated() {
    if (myComponentCreationListeners == null) {
      return;
    }
    for (ComponentCreationListener l : myComponentCreationListeners.toArray(new ComponentCreationListener[myComponentCreationListeners.size()])) {
      l.componentCreated(this);
    }
  }

  public void addComponentCreationListener(@NotNull ComponentCreationListener l) {
    if (myComponentCreationListeners == null) {
      myComponentCreationListeners = new HashSet<ComponentCreationListener>();
    }
    myComponentCreationListeners.add(l);
  }

  public void removeComponentCreationListener(@NotNull ComponentCreationListener l) {
    if (myComponentCreationListeners == null) {
      return;
    }
    myComponentCreationListeners.remove(l);
    if (myComponentCreationListeners.isEmpty()) {
      myComponentCreationListeners = null;
    }
  }

  public static void setShowGenStatus(boolean showGenStatusInTree) {
    ourShowGenStatus = showGenStatusInTree;
  }

  public static boolean isShowGenStatus() {
    return ourShowGenStatus;
  }

  @NotNull
  protected ProjectTreeFindHelper createFindHelper() {
    return new ProjectTreeFindHelper(getTree());
  }

  private class MySimpleToolWindowPanel extends SimpleToolWindowPanel {
    public MySimpleToolWindowPanel(boolean vertical, boolean borderless) {
      super(vertical, borderless);
    }
    public MySimpleToolWindowPanel(boolean vertical) {
      super(vertical);
    }

    @Override
    @Nullable
    public Object getData(@NonNls String dataId) {
      return CustomProjectView.this.getData(dataId);
    }

  }

  public interface ComponentCreationListener {
    void componentCreated(CustomProjectView projectPane);
  }

  private enum UpdateID {
    REBUILD(20),
    SELECT(30),
    RESTORE_EXPAND(40);

    private int myPriority;
    UpdateID(int priority) {
      myPriority = priority;
    }
    public int getPriority() {
      return myPriority;
    }
  }

  private static abstract class AbstractUpdate extends Update {
    /*package*/ AbstractUpdate(CustomProjectView.UpdateID id) {
      super(id, id.getPriority());
    }
  }

  private static class UpdateAdapter extends Update {
    private final Runnable myDelegate;
    /*package*/ UpdateAdapter(@NotNull CustomProjectView.UpdateID id, @NotNull Runnable delegate) {
      super(id, id.getPriority());
      myDelegate = delegate;
    }
    @Override
    public void run() {
      myDelegate.run();
    }
  }

  private static class ScheduleUpdateRunnable implements Runnable {
    private final MergingUpdateQueue myQueue;
    private final Update myUpdate;
    /*package*/ ScheduleUpdateRunnable(@NotNull MergingUpdateQueue queue, @NotNull Update update) {
      myQueue = queue;
      myUpdate = update;
    }
    @Override
    public void run() {
      myQueue.queue(myUpdate);
    }
  }

  private class LookupAndSelect implements Runnable {
    private SNodeReference myNode;
    private SModelReference myModel;
    private SModuleReference myModule;
    public LookupAndSelect(SModuleReference module) {
      myModule = module;
    }
    public LookupAndSelect(SModelReference model) {
      myModel = model;
    }
    public LookupAndSelect(SNodeReference node) {
      myNode = node;
    }
    @Override
    public void run() {
      MPSTreeNode toSelect = null;
      if (myModule != null) {
        SModule module = myModule.resolve(getMPSProject().getRepository());
        if (module == null) {
          // likely, by the time we got to this point (selection update), the reference is no longer valid, exit gracefully
          return;
        }
        toSelect = createFindHelper().findMostSuitableModuleTreeNode(module);
        if (toSelect == null) {
          if (LOG.isWarningLevel()) {
            LOG.warning(String.format("Couldn't select module \"%s\" : tree node not found.", myModule.getModuleName()));
          }
          return;
        }
      } else
      if (myModel != null) {
        SModel model = myModel.resolve(getMPSProject().getRepository());
        if (model == null) {
          return;
        }
        toSelect = createFindHelper().findMostSuitableModelTreeNode(model);
        if (toSelect == null) {
          if (LOG.isWarningLevel()) {
            LOG.warning(String.format("Couldn't select model \"%s\" : tree node not found.", myModel.getModelName()));
          }
          return;
        }
      } else
      if (myNode != null) {
        SNode node = myNode.resolve(getMPSProject().getRepository());
        if (node == null) {
          return;
        }
        toSelect = createFindHelper().findMostSuitableSNodeTreeNode(node);
        if (toSelect == null) {
          if (LOG.isWarningLevel()) {
            LOG.warning(String.format("Couldn't select node \"%s\" : tree node not found.", myNode.toString()));
          }
          return;
        }
      }
      if (toSelect != null) {
        getTree().selectNode(toSelect);
      }
    }
  }

  private class MyRepositoryListener extends SRepositoryContentAdapter implements CommandListener {
    private boolean myNeedRebuild = false;
    /*package*/ void rebuildTreeIfNeeded() {
      if (myNeedRebuild) {
        rebuild();
        myNeedRebuild = false;
      }
    }

    @Override
    public void repositoryChanged() {
      myNeedRebuild = true;
    }

    @Override
    public void modelRenamed(SModule module, SModel model, SModelReference oldRef) {
      myNeedRebuild = true;
    }

    @Override
    protected void startListening(SModel model) {
      if (!(model.isReadOnly())) {
        model.addModelListener(this);
      }
    }

    @Override
    protected void stopListening(SModel model) {
      model.removeModelListener(this);
    }

    @Override
    public void modelReplaced(SModel model) {
      myNeedRebuild = true;
    }

    @Override
    public void commandStarted() {
      myNeedRebuild = false;
    }

    @Override
    public void commandFinished() {
      rebuildTreeIfNeeded();
    }
  }

  private class RefreshListener implements VirtualFileManagerListener {
    @Override
    public void beforeRefreshStart(boolean asynchonous) {
    }

    @Override
    public void afterRefreshFinish(boolean asynchonous) {
      rebuild();
    }
  }
  private static Icon check_rm1e9y_a0a0a1a42(IViewDescriptor checkedDotOperand, CustomProjectView checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getIcon();
    }
    return null;
  }
  private static String check_rm1e9y_a0a0eb(IViewDescriptor checkedDotOperand, CustomProjectView checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLabel();
    }
    return null;
  }
  private static Object check_rm1e9y_a0a0a0wb(ViewElement<Object> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getObject();
    }
    return null;
  }
  private static ViewElement<Object> check_rm1e9y_a0a0a0a84(CustomTreeNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getElement();
    }
    return null;
  }
  private static Object check_rm1e9y_a0b0ac(ViewElement<Object> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getObject();
    }
    return null;
  }
  private static ViewElement<Object> check_rm1e9y_a0a1a25(CustomTreeNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getElement();
    }
    return null;
  }
  private static void check_rm1e9y_a0a0a45(CustomProjectTree checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.dispose();
    }

  }
  private static void check_rm1e9y_a2a0a45(WeightValues.AquiredValue checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.release();
    }

  }
  private static void check_rm1e9y_a0a6a65(MessageBusConnection checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.disconnect();
    }

  }
  private static String check_rm1e9y_a0h0sc(IViewDescriptor checkedDotOperand, CustomProjectView checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getToolbarActionGroupId();
    }
    return null;
  }
  private static <T> T as_rm1e9y_a0a0i0lb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_rm1e9y_a0a0k0lb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_rm1e9y_a0a0n0lb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_rm1e9y_a0a0a0a0a94(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

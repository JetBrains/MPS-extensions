package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import java.util.LinkedList;
import java.awt.geom.Rectangle2D;

public class PortLayouter {
  public static final double SPACE_BETWEEN_PORTS = 7.0;

  public static void layoutPortCells(List<PortDCell> ports, BoxDCell parentCell) {
    new PortLayouter(ports, parentCell).layoutPortCells(true);
  }

  public static void layoutPortCells(BoxDCell parentCell) {
    layoutPortCells(parentCell, true);
  }

  public static void layoutPortCells(BoxDCell parentCell, boolean keepFittedSize) {
    new PortLayouter(Sequence.fromIterable(parentCell.getPorts()).toList(), parentCell).layoutPortCells(keepFittedSize);
  }

  private List<PortDCell> ports;
  private BoxDCell parentCell;

  public static _FunctionTypes._return_P2_E0<? extends Integer, ? super PortDCell, ? super PortDCell> comparator = (PortDCell a, PortDCell b) -> {
    double deltaX = a.getPort().getRelativeXNN() - b.getPort().getRelativeXNN();
    double deltaY = a.getPort().getRelativeYNN() - b.getPort().getRelativeYNN();
    double delta = (Math.abs(deltaX) > Math.abs(deltaY) ? deltaX : deltaY);
    if (delta != 0.0) {
      return (delta > 0.0 ? 1 : -1);
    }
    return a.getPort().getOrdinal() - b.getPort().getOrdinal();
  };

  public PortLayouter(List<PortDCell> ports, BoxDCell parentCell) {
    this.ports = ListSequence.fromList(ports).sort((a, b) -> comparator.invoke(a, b), true).toList();
    this.parentCell = parentCell;

  }

  public void layoutPortCells(boolean keepFittedSize) {
    preprocess();
    doLayoutPorts(keepFittedSize);
    ensureBoxSize();
    configureOffset();
  }

  protected void doLayoutPorts(boolean keepFittedSize) {
    moveToPreferredPosition();

    Bounds originalParentBounds = CellExtensions.getBounds(parentCell);
    if (!(parentCell.containsSubdiagram())) {
      // temporarily fit the size
      parentCell.fitSize();
    }


    makeAbsolute();

    // use heuristics according to position of ports on boxes in order to speedup the ports layouting algorithm
    splitPortsAccordingToCardinalPositions();
    boolean portsPositionWasSet;
    portsPositionWasSet = setPortsPositionIfAllOverlap(east, CellExtensions.getBounds(parentCell).getHeight(), false);
    if (!(portsPositionWasSet)) {
      moveOverlapping(east);
    }
    portsPositionWasSet = setPortsPositionIfAllOverlap(west, CellExtensions.getBounds(parentCell).getHeight(), false);
    if (!(portsPositionWasSet)) {
      moveOverlapping(west);
    }
    portsPositionWasSet = setPortsPositionIfAllOverlap(north, CellExtensions.getBounds(parentCell).getWidth(), true);
    if (!(portsPositionWasSet)) {
      moveOverlapping(north);
    }
    portsPositionWasSet = setPortsPositionIfAllOverlap(south, CellExtensions.getBounds(parentCell).getWidth(), true);
    if (!(portsPositionWasSet)) {
      moveOverlapping(south);
    }
    moveOverlapping(other);

    if (!(parentCell.containsSubdiagram()) && !(keepFittedSize)) {
      // restore original bounds
      CellExtensions.setBounds(parentCell, originalParentBounds);
    }
  }

  /*package*/ List<PortDCell> north = ListSequence.fromList(new LinkedList<PortDCell>());
  /*package*/ List<PortDCell> south = ListSequence.fromList(new LinkedList<PortDCell>());
  /*package*/ List<PortDCell> east = ListSequence.fromList(new LinkedList<PortDCell>());
  /*package*/ List<PortDCell> west = ListSequence.fromList(new LinkedList<PortDCell>());
  /*package*/ List<PortDCell> other = ListSequence.fromList(new LinkedList<PortDCell>());

  private void splitPortsAccordingToCardinalPositions() {
    for (PortDCell port : ListSequence.fromList(ports)) {
      double relativeXNN = port.getPort().getRelativeXNN();
      double relativeYNN = port.getPort().getRelativeYNN();
      if (relativeXNN == 0 && relativeYNN != 0 && relativeYNN != 1) {
        ListSequence.fromList(east).addElement(port);
      } else if (relativeXNN == 1 && relativeYNN != 0 && relativeYNN != 1) {
        ListSequence.fromList(west).addElement(port);
      } else if (relativeYNN == 0 && relativeXNN != 0 && relativeXNN != 1) {
        ListSequence.fromList(north).addElement(port);
      } else if (relativeYNN == 1 && relativeXNN != 0 && relativeXNN != 1) {
        ListSequence.fromList(south).addElement(port);
      } else {
        ListSequence.fromList(other).addElement(port);
      }
    }
  }

  private boolean setPortsPositionIfAllOverlap(List<PortDCell> ports, double size, boolean horizontal) {
    if (ListSequence.fromList(ports).count() < 2) {
      return false;
    }
    if (horizontal) {
      // handle north and south edges
      final double relativeX = ListSequence.fromList(ports).first().getPort().getRelativeXNN();
      boolean b = ListSequence.fromList(ports).tailListSequence(1).any((it) -> relativeX != it.getPort().getRelativeXNN());
      if (b) {
        return false;
      }

      double spaceTakenByPorts = 0;
      for (int i = 0; i < ListSequence.fromList(ports).count(); i++) {
        spaceTakenByPorts += CellExtensions.getBounds(ListSequence.fromList(ports).getElement(i)).getWidth();
      }

      double spaceTakenByPortsIncludingWhiteSpace = (ListSequence.fromList(ports).count() - 1) * SPACE_BETWEEN_PORTS + spaceTakenByPorts;
      double padding = Math.abs(size - spaceTakenByPortsIncludingWhiteSpace) / 2 + CellExtensions.getBounds(ListSequence.fromList(ports).getElement(0)).getWidth() / 2;

      for (int i = 0; i < ListSequence.fromList(ports).count(); i++) {
        ListSequence.fromList(ports).getElement(i).setLayoutedX(padding);
        padding += SPACE_BETWEEN_PORTS + CellExtensions.getBounds(ListSequence.fromList(ports).getElement(i)).getWidth();
      }
    } else {
      // handle east and west edges
      final double relativeY = ListSequence.fromList(ports).first().getPort().getRelativeYNN();
      boolean b = ListSequence.fromList(ports).tailListSequence(1).any((it) -> relativeY != it.getPort().getRelativeYNN());
      if (b) {
        return false;
      }

      double spaceTakenByPorts = 0;
      for (int i = 0; i < ListSequence.fromList(ports).count(); i++) {
        spaceTakenByPorts += CellExtensions.getBounds(ListSequence.fromList(ports).getElement(i)).getHeight();
      }

      double spaceTakenByPortsIncludingWhiteSpace = (ListSequence.fromList(ports).count() - 1) * SPACE_BETWEEN_PORTS + spaceTakenByPorts;
      double padding = Math.abs(size - spaceTakenByPortsIncludingWhiteSpace) / 2 + CellExtensions.getBounds(ListSequence.fromList(ports).getElement(0)).getHeight() / 2;

      for (int i = 0; i < ListSequence.fromList(ports).count(); i++) {
        ListSequence.fromList(ports).getElement(i).setLayoutedY(padding);
        padding += SPACE_BETWEEN_PORTS + CellExtensions.getBounds(ListSequence.fromList(ports).getElement(i)).getHeight();
      }
    }
    return true;
  }

  protected boolean ensureBoxSize() {
    if (ListSequence.fromList(ports).count() == 0) {
      return false;
    }

    double minX = Double.MAX_VALUE;
    double maxX = Double.MIN_VALUE;
    double minY = Double.MAX_VALUE;
    double maxY = Double.MIN_VALUE;

    for (PortDCell port : ListSequence.fromList(ports)) {
      Bounds bounds = CellExtensions.getBounds(port);
      minX = Math.min(minX, bounds.getX());
      maxX = Math.max(maxX, bounds.getX());
      minY = Math.min(minY, bounds.getY());
      maxY = Math.max(maxY, bounds.getY());

      if (isNear(port.getPort().getTransformedRelativeX(), 1.0) || isNear(port.getPort().getTransformedRelativeX(), 0.0)) {
        maxY = Math.max(maxY, bounds.getMaxY());
      }
      if (isNear(port.getPort().getTransformedRelativeY(), 1.0) || isNear(port.getPort().getTransformedRelativeY(), 0.0)) {
        maxX = Math.max(maxX, bounds.getMaxX());
      }
    }

    double requiredWidth = maxX - minX;
    double requiredHeight = maxY - minY;
    Bounds parentBounds = CellExtensions.getBounds(parentCell);
    boolean changed = false;
    if (parentBounds.getWidth() < requiredWidth) {
      parentBounds.setWidth(requiredWidth);
      changed = true;
    }
    if (parentBounds.getHeight() < requiredHeight) {
      parentBounds.setHeight(requiredHeight);
      changed = true;
    }
    if (changed) {
      CellExtensions.setBounds(parentCell, parentBounds);
    }
    return changed;
  }

  protected void preprocess() {
  }

  protected void moveToPreferredPosition() {
    for (PortDCell port : ListSequence.fromList(ports)) {
      port.setLayoutedX(port.getPort().getTransformedRelativeX());
      port.setLayoutedY(port.getPort().getTransformedRelativeY());
    }
  }

  protected void moveOverlapping(List<PortDCell> ports) {
    boolean anyMoved;
    int timeout = 1000;
    do {
      anyMoved = false;
      for (int i = 0; i < ListSequence.fromList(ports).count(); i++) {
        for (int k = i + 1; k < ListSequence.fromList(ports).count(); k++) {
          boolean moved = moveIfOverlapping(ListSequence.fromList(ports).getElement(i), ListSequence.fromList(ports).getElement(k));
          if (moved) {
            anyMoved = true;
          }
        }
      }
    } while (anyMoved && --timeout > 0);
  }

  protected boolean moveIfOverlapping(PortDCell port1, PortDCell port2) {
    Rectangle2D rect1 = ExtensionMethods.toRectangle2D(CellExtensions.getBounds(port1));
    Rectangle2D rect2 = ExtensionMethods.toRectangle2D(CellExtensions.getBounds(port2));
    if (extend(rect1, SPACE_BETWEEN_PORTS / 2).intersects(extend(rect2, SPACE_BETWEEN_PORTS / 2))) {
      double amountX = rect1.getMaxX() - rect2.getMinX() + SPACE_BETWEEN_PORTS + 0.1;
      double amountY = rect1.getMaxY() - rect2.getMinY() + SPACE_BETWEEN_PORTS + 0.1;

      // which direction?
      boolean moveY = isNear(port1.getPort().getTransformedRelativeX(), 0.0) || isNear(port1.getPort().getTransformedRelativeX(), 1.0);

      // move
      if (moveY) {
        if (port1.getPort().getRelativeY() == null && port2.getPort().getRelativeY() != null) {
          port1.setLayoutedY(port1.getLayoutedY() - amountY);
        } else if (port2.getPort().getRelativeY() == null && port1.getPort().getRelativeY() != null) {
          port2.setLayoutedY(port2.getLayoutedY() + amountY);
        } else if (port1.getLayoutedY() - amountY / 2 - CellExtensions.getBounds(port1).getHeight() / 2 < 0 && port2.getLayoutedY() + amountY + CellExtensions.getBounds(port2).getHeight() / 2 <= CellExtensions.getBounds(parentCell).getHeight()) {
          port2.setLayoutedY(port2.getLayoutedY() + amountY);
        } else if (port1.getLayoutedY() - amountY - CellExtensions.getBounds(port1).getHeight() / 2 > 0 && port2.getLayoutedY() + amountY / 2 + CellExtensions.getBounds(port2).getHeight() / 2 > CellExtensions.getBounds(parentCell).getHeight()) {
          port1.setLayoutedY(port1.getLayoutedY() - amountY);
        } else {
          port1.setLayoutedY(port1.getLayoutedY() - amountY / 2);
          port2.setLayoutedY(port2.getLayoutedY() + amountY / 2);
        }
        // make sure the ports are not outside of the box
        if (port1.getLayoutedY() + CellExtensions.getBounds(port1).getHeight() > CellExtensions.getBounds(parentCell).getHeight()) {
          port1.setLayoutedY(CellExtensions.getBounds(parentCell).getHeight() - CellExtensions.getBounds(port1).getHeight());
        }
        if (port2.getLayoutedY() + CellExtensions.getBounds(port2).getHeight() > CellExtensions.getBounds(parentCell).getHeight()) {
          port2.setLayoutedY(CellExtensions.getBounds(parentCell).getHeight() - CellExtensions.getBounds(port2).getHeight());
        }
        if (port1.getLayoutedY() < 0.0) {
          port1.setLayoutedY(0.0);
        }
        if (port2.getLayoutedY() < 0.0) {
          port2.setLayoutedY(0.0);
        }
      } else {
        if (port1.getPort().getRelativeX() == null && port2.getPort().getRelativeX() != null) {
          port1.setLayoutedX(port1.getLayoutedX() - amountX);
        } else if (port2.getPort().getRelativeX() == null && port1.getPort().getRelativeX() != null) {
          port2.setLayoutedX(port2.getLayoutedX() + amountX);
        } else if (port1.getLayoutedX() - amountX / 2 - CellExtensions.getBounds(port1).getWidth() / 2 < 0 && port2.getLayoutedX() + amountX + CellExtensions.getBounds(port2).getWidth() / 2 <= CellExtensions.getBounds(parentCell).getWidth()) {
          port2.setLayoutedX(port2.getLayoutedX() + amountX);
        } else if (port1.getLayoutedX() - amountX - CellExtensions.getBounds(port1).getWidth() / 2 > 0 && port2.getLayoutedX() + amountX / 2 + CellExtensions.getBounds(port2).getWidth() / 2 > CellExtensions.getBounds(parentCell).getWidth()) {
          port1.setLayoutedX(port1.getLayoutedX() - amountX);
        } else {
          port1.setLayoutedX(port1.getLayoutedX() - amountX / 2);
          port2.setLayoutedX(port2.getLayoutedX() + amountX / 2);
        }
        // make sure the ports are not outside of the box
        if (port1.getLayoutedX() + CellExtensions.getBounds(port1).getWidth() > CellExtensions.getBounds(parentCell).getWidth()) {
          port1.setLayoutedX(CellExtensions.getBounds(parentCell).getWidth() - CellExtensions.getBounds(port1).getWidth());
        }
        if (port2.getLayoutedX() + CellExtensions.getBounds(port2).getWidth() > CellExtensions.getBounds(parentCell).getWidth()) {
          port2.setLayoutedX(CellExtensions.getBounds(parentCell).getWidth() - CellExtensions.getBounds(port2).getWidth());
        }
        if (port1.getLayoutedX() < 0.0) {
          port1.setLayoutedX(0.0);
        }
        if (port2.getLayoutedX() < 0.0) {
          port2.setLayoutedX(0.0);
        }
      }


      return true;
    }

    return false;
  }

  protected void makeAbsolute() {
    for (PortDCell port : ListSequence.fromList(ports)) {
      Bounds oldParentBounds = CellExtensions.getBounds(parentCell);
      if (!(parentCell.containsSubdiagram())) {
        parentCell.fitSize();
      }
      Bounds newParentBounds = CellExtensions.getBounds(parentCell);
      CellExtensions.setBounds(parentCell, oldParentBounds);
      port.setLayoutedX(newParentBounds.getWidth() * port.getLayoutedX());
      port.setLayoutedY(newParentBounds.getHeight() * port.getLayoutedY());
    }
  }


  protected void configureOffset() {
    for (PortDCell port : ListSequence.fromList(ports)) {
      double offsetX = -CellExtensions.getBounds(port).getWidth() / 2;
      double offsetY = -CellExtensions.getBounds(port).getHeight() / 2;
      double relativeX = port.getPort().getTransformedRelativeX();
      double relativeY = port.getPort().getTransformedRelativeY();
      if (isNear(relativeX, 0.0)) {
        offsetX = -CellExtensions.getBounds(port).getWidth();
      }
      if (isNear(relativeY, 0.0)) {
        offsetY = -CellExtensions.getBounds(port).getHeight();
      }
      if (isNear(relativeY, 1.0)) {
        offsetY = 0.0;
      }
      if (isNear(relativeX, 1.0)) {
        offsetX = 0.0;
      }
      port.setLayoutedX(port.getLayoutedX() + offsetX);
      port.setLayoutedY(port.getLayoutedY() + offsetY);
    }
  }

  public static Rectangle2D.Double extend(Rectangle2D rect, double amount) {
    return extend(rect, amount, amount);
  }

  public static Rectangle2D.Double extend(Rectangle2D rect, double amountX, double amountY) {
    return new Rectangle2D.Double(rect.getX() - amountX, rect.getY() - amountY, rect.getWidth() + amountX * 2, rect.getHeight() + amountY * 2);
  }

  public static boolean isNear(double v1, double v2) {
    return Math.abs(v1 - v2) < 0.001;
  }
}

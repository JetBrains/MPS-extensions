package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import de.itemis.mps.editor.celllayout.layout.AbstractGridLayout;
import de.itemis.mps.editor.celllayout.layout.ILayouter;
import de.itemis.mps.editor.celllayout.layout.ILayoutableContainer;
import de.itemis.mps.editor.celllayout.boxmodel.Size;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import de.itemis.mps.editor.celllayout.layout.ILayoutable;
import de.itemis.mps.editor.celllayout.layout.Grid;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import java.util.Map;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import de.itemis.mps.editor.celllayout.runtime.CellLayoutUtil;
import de.slisson.mps.tables.runtime.gridmodel.IGridElement;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellGridLeaf;
import de.itemis.mps.editor.celllayout.layout.LayoutableContainerExtensions;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import de.itemis.mps.editor.celllayout.layout.GridElement;
import java.util.HashMap;

public class TableLayout extends AbstractGridLayout implements ILayouter {

  public TableLayout() {
    super(true, true);
  }

  @Override
  public int getAscent(ILayoutableContainer container, Size sizeConstraint) {
    _FunctionTypes._return_P2_E0<? extends Size, ? super ILayoutable, ? super Size> sizeGetter = (ILayoutable layoutable, Size cellSizeConstraint) -> layoutable.getPreferredSize(cellSizeConstraint);
    Grid grid = loadGrid(container, sizeConstraint, sizeGetter);
    layoutGrid(grid, container, sizeConstraint, true);
    if (grid.getSizeY() == 0) {
      return 0;
    }
    List<Integer> ascents = Sequence.fromIterable(grid.getValidElements()).where((it) -> it.getPosY() == 0).select((it) -> check_e65flo_a0a0a0a0a0e0d(check_e65flo_a0a0a0a0a0a4a3(check_e65flo_a0a0a0a0a0a0e0d(as_e65flo_a0a0a0a0a0a0a0e0d(it.getLayoutable(), ILayoutableContainer.class))), it)).where((it) -> it > 0).sort((it) -> it, true).toList();
    if (ListSequence.fromList(ascents).isEmpty()) {
      return 0;
    } else {
      return ListSequence.fromList(ascents).getElement(ListSequence.fromList(ascents).count() / 2);
    }
  }

  @Override
  protected int getGapBetweenCells(@Nullable ILayoutable left, @Nullable ILayoutable right) {
    return 0;
  }

  @Override
  public void layout(ILayoutableContainer container, @NotNull Size sizeConstraint) {
    super.layout(container, sizeConstraint);
    layoutPartialTables(container);
  }

  protected void layoutPartialTables(ILayoutableContainer container) {
    Map<EditorCell, ILayoutable> layoutablesMap = collectLayoutables(container);

    TableEditor tableEditor = ((TableEditor) CellLayoutUtil.getEditorCell(container));

    de.slisson.mps.tables.runtime.gridmodel.Grid tableGrid = tableEditor.getGrid();
    Grid layoutGrid = createGrid(tableGrid.getSizeX(), tableGrid.getSizeY());

    for (int x = 0; x < layoutGrid.getSizeX(); x++) {
      for (int y = 0; y < layoutGrid.getSizeY(); y++) {
        IGridElement tableGridElement = tableGrid.getElement(x, y);
        if (!(tableGridElement instanceof EditorCellGridLeaf)) {
          continue;
        }
        EditorCell editorCell = ((EditorCellGridLeaf) tableGridElement).getEditorCell();
        if (editorCell == null) {
          continue;
        }

        for (EditorCell parent = editorCell.getParent(); parent != null && parent != tableEditor; parent = parent.getParent()) {
          LayoutableContainerExtensions.adjustToChildren(((ILayoutableContainer) MapSequence.fromMap(layoutablesMap).get(parent)));
        }

      }
    }
  }

  @Override
  protected Grid loadGrid(ILayoutableContainer container) {
    TableEditor tableEditor = ((TableEditor) CellLayoutUtil.getEditorCell(container));

    Map<EditorCell, ILayoutable> layoutablesMap = collectLayoutables(container);

    de.slisson.mps.tables.runtime.gridmodel.Grid tableGrid = tableEditor.getGrid();
    Grid layoutGrid = createGrid(tableGrid.getSizeX(), tableGrid.getSizeY());

    for (int x = 0; x < layoutGrid.getSizeX(); x++) {
      for (int y = 0; y < layoutGrid.getSizeY(); y++) {
        IGridElement tableGridElement = tableGrid.getElement(x, y);
        if (!(tableGridElement instanceof EditorCellGridLeaf)) {
          continue;
        }
        EditorCell editorCell = ((EditorCellGridLeaf) tableGridElement).getEditorCell();
        if (editorCell == null) {
          continue;
        }
        GridElement layoutGridElement = layoutGrid.getElement(x, y);
        layoutGridElement.setLayoutable(MapSequence.fromMap(layoutablesMap).get(editorCell));
        layoutGridElement.setColumnSpan(tableGridElement.getSpanX());
        layoutGridElement.setRowSpan(tableGridElement.getSpanY());
      }
    }

    return layoutGrid;
  }


  private Map<EditorCell, ILayoutable> collectLayoutables(ILayoutable layoutable) {
    Map<EditorCell, ILayoutable> result = MapSequence.fromMap(new HashMap<EditorCell, ILayoutable>());
    collectLayoutables(layoutable, result);
    return result;
  }

  private void collectLayoutables(ILayoutable layoutable, Map<EditorCell, ILayoutable> result) {
    EditorCell cell = CellLayoutUtil.getEditorCell(layoutable);
    if (cell != null) {
      MapSequence.fromMap(result).put(cell, layoutable);
    }
    if (layoutable instanceof ILayoutableContainer) {
      for (ILayoutable child : ListSequence.fromList(((ILayoutableContainer) layoutable).getChildren())) {
        collectLayoutables(child, result);
      }
    }
  }

  @Override
  public void moveChildren(ILayoutableContainer container, int deltaX, int deltaY) {
    super.moveChildren(container, deltaX, deltaY);
    layoutPartialTables(container);
  }

  @Override
  protected Iterable<ILayoutable> getChildrenToMove(ILayoutableContainer container) {
    return Sequence.fromIterable(loadGrid(container).getValidElements()).select((it) -> it.getLayoutable()).distinct();
  }
  private static int check_e65flo_a0a0a0a0a0e0d(ILayoutable checkedDotOperand, GridElement it) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAscent(it.getSize());
    }
    return 0;
  }
  private static ILayoutable check_e65flo_a0a0a0a0a0a4a3(List<ILayoutable> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return ListSequence.fromList(checkedDotOperand).first();
    }
    return null;
  }
  private static List<ILayoutable> check_e65flo_a0a0a0a0a0a0e0d(ILayoutableContainer checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getChildren();
    }
    return null;
  }
  private static <T> T as_e65flo_a0a0a0a0a0a0a0e0d(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

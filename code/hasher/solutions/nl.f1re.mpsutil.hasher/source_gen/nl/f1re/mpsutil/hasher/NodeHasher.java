package nl.f1re.mpsutil.hasher;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SConceptFeature;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.hash.Hasher;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import com.google.common.hash.Hashing;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SNodeUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.model.SReference;
import java.util.Objects;
import jetbrains.mps.smodel.adapter.structure.types.SPrimitiveTypes;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.concept.SAbstractConceptAdapter;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.structure.property.SPropertyAdapter;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.structure.ref.SReferenceLinkAdapter;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.link.SContainmentLinkAdapter;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SConceptFeatureId;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapterById;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import org.jetbrains.mps.openapi.model.SNodeId;
import java.nio.charset.StandardCharsets;
import java.util.Comparator;

/**
 * Hashes all passed nodes by their concept, property+value, (deep) containments+node, and references+target. 
 *  
 * Can ignore {{@link nl.f1re.mpsutil.hasher.NodeHasher#setIncludeNodeIds(boolean) node ids},
 * {@link nl.f1re.mpsutil.hasher.NodeHasher#setIncludeBaseConceptProperties(boolean) BaseConcept properties},
 * {@link nl.f1re.mpsutil.hasher.NodeHasher#setIncludeAnnotations(boolean) annotations/node attributes},
 * and {@link nl.f1re.mpsutil.hasher.NodeHasher#ignore(SConceptFeature) arbitrary features}.
 * By default, everything is included. 
 *  
 * If we consider node ids, we compare reference targets by node id;
 * otherwise by the target node's {@link jetbrains.mps.smodel.SNode#getPresentation() }.
 */
public class NodeHasher {
  private static final String UNSET_PROPERTY_VALUE = "false";
  private static final SProperty SHORT_DESCRIPTION = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x10d34f97574L, "shortDescription");

  private final List<SNode> nodes;
  private final Hasher hasher;

  private final Set<SProperty> ignoredProperties = SetSequence.fromSet(new LinkedHashSet<SProperty>());
  private final Set<SContainmentLink> ignoredContainments = SetSequence.fromSet(new LinkedHashSet<SContainmentLink>());
  private final Set<SReferenceLink> ignoredReferences = SetSequence.fromSet(new LinkedHashSet<SReferenceLink>());
  private boolean includeNodeIds = true;
  private boolean normalizeBooleanProperties = true;

  /**
   * Hashes all nodes. 
   * 
   * @param nodes Nodes to hash. The order of nodes, and (in)direct children of the same containment, matters.
   */
  public NodeHasher(List<SNode> nodes, int seed) {
    this.nodes = nodes;
    hasher = Hashing.murmur3_32(seed).newHasher();
  }

  /**
   * Convenience factory to hash nodes with default seed, including node ids and all features. 
   * 
   * @param nodes Nodes to hash. The order of nodes, and (in)direct children of the same containment, matters.
   */
  public static int hash(SNode... nodes) {
    return new NodeHasher(Sequence.fromIterable(Sequence.fromArray(nodes)).toList(), 0x21375341).hash();
  }

  /**
   * Whether we consider <tt>BaseConcept.shortDescription</tt> and <tt>BaseConcept.virtualPackage</tt> properties while hashing. 
   */
  public NodeHasher setIncludeBaseConceptProperties(boolean includeBaseConceptProperties) {
    if (includeBaseConceptProperties) {
      SetSequence.fromSet(ignoredProperties).removeElement(SHORT_DESCRIPTION);
      SetSequence.fromSet(ignoredProperties).removeElement(SNodeUtil.property_BaseConcept_virtualPackage);
    } else {
      SetSequence.fromSet(ignoredProperties).addElement(SHORT_DESCRIPTION);
      SetSequence.fromSet(ignoredProperties).addElement(SNodeUtil.property_BaseConcept_virtualPackage);
    }
    return this;
  }

  /**
   * Whether we consider <tt>BaseConcept.smodelAttribute</tt> containment while hashing. 
   */
  public NodeHasher setIncludeAnnotations(boolean includeAnnotations) {
    if (includeAnnotations) {
      SetSequence.fromSet(ignoredContainments).removeElement(SNodeUtil.link_BaseConcept_smodelAttribute);
    } else {
      SetSequence.fromSet(ignoredContainments).addElement(SNodeUtil.link_BaseConcept_smodelAttribute);
    }
    return this;
  }

  /**
   * Whether we consider node ids while hashing. 
   */
  public NodeHasher setIncludeNodeIds(boolean includeNodeIds) {
    this.includeNodeIds = includeNodeIds;
    return this;
  }

  /**
   * Whether we enforce boolean properties with value "false" to be present. 
   */
  public NodeHasher setNormalizeBooleanProperties(boolean normalizeBooleanProperties) {
    this.normalizeBooleanProperties = normalizeBooleanProperties;
    return this;
  }

  /**
   * Excludes given feature from hashing 
   */
  public NodeHasher ignore(SConceptFeature feature) {
    if (feature instanceof SProperty) {
      SetSequence.fromSet(ignoredProperties).addElement((SProperty) feature);
    } else
    if (feature instanceof SContainmentLink) {
      SetSequence.fromSet(ignoredContainments).addElement((SContainmentLink) feature);
    } else
    if (feature instanceof SReferenceLink) {
      SetSequence.fromSet(ignoredReferences).addElement((SReferenceLink) feature);
    }
    return this;
  }

  /**
   * Returns the calculated hash of all nodes and their descendants with all configured includes/ignores. 
   *  
   * @return The calculated hash. 
   */
  public int hash() {
    for (SNode node : ListSequence.fromList(nodes)) {
      hashNode(node, false);
    }
    return hasher.hash().asInt();
  }


  private void hashNode(SNode node, boolean includeContainment) {
    put(node.getConcept());

    if (includeNodeIds) {
      put(node.getNodeId());
    }

    if (includeContainment) {
      put(node.getContainmentLink());
    }

    for (SProperty prop : Sequence.fromIterable(collectConceptProperties(node)).subtract(SetSequence.fromSet(ignoredProperties)).sort(new PropertyComparator(), true)) {
      hashProperty(node, prop);
    }

    for (SReference ref : Sequence.fromIterable(((Iterable<SReference>) node.getReferences())).where((it) -> !(SetSequence.fromSet(ignoredReferences).contains(it.getLink()))).sort(new ReferenceComparator(), true)) {
      hashReference(ref);
    }

    for (SNode child : Sequence.fromIterable(((Iterable<SNode>) node.getChildren())).where((it) -> !(SetSequence.fromSet(ignoredContainments).contains(it.getContainmentLink()))).sort(new ContainmentComparator(), true)) {
      hashNode(child, true);
    }
  }

  private Iterable<SProperty> collectConceptProperties(SNode node) {
    return Sequence.fromIterable(((Iterable<SProperty>) node.getProperties())).concat(Sequence.fromIterable((this.normalizeBooleanProperties ? Sequence.fromIterable(((Iterable<SProperty>) node.getConcept().getProperties())).where((it) -> Objects.equals(it.getType(), SPrimitiveTypes.BOOLEAN)) : Collections.<SProperty>emptyList()))).distinct();
  }

  private void hashProperty(SNode node, SProperty property) {
    put(property);
    String value = node.getProperty(property);
    if (value == null) {
      value = UNSET_PROPERTY_VALUE;
    }
    put(value);
  }

  private void hashReference(SReference ref) {
    put(ref.getLink());
    if (includeNodeIds && ref.getTargetNodeId() != null) {
      put(ref.getTargetNodeId());
    } else
    if (ref.getTargetNode() != null) {
      put(ref.getTargetNode().getPresentation());
    } else {
      put(ref.describeTarget().toString());
    }
  }

  private void put(SAbstractConcept concept) {
    if (concept instanceof SConcept) {
      put((SConcept) concept);
    } else
    if (concept instanceof SAbstractConceptAdapter) {
      ConceptDescriptor descriptor = ((SAbstractConceptAdapter) concept).getConceptDescriptor();
      if (descriptor != null) {
        put(descriptor.getId());
        return;
      }
    }

    throw new IllegalStateException(String.format("Cannot hash concept %s: %s", concept.getClass(), concept));
  }

  private void put(SConcept concept) {
    if (concept instanceof SConceptAdapterById) {
      SConceptId id = ((SConceptAdapterById) concept).getId();
      put(id);
      return;
    }

    throw new IllegalStateException(String.format("Cannot hash concept %s: %s", concept.getClass(), concept));
  }

  private void put(SConceptId conceptId) {
    put(conceptId.getLanguageId());
    put(conceptId.getIdValue());
  }

  private void put(SProperty property) {
    if (property instanceof SPropertyAdapter) {
      SPropertyId id = ((SPropertyAdapter) property).getId();
      put(id);
      return;
    }

    throw new IllegalStateException(String.format("Cannot hash property %s: %s", property.getClass(), property));
  }

  private void put(SReferenceLink ref) {
    if (ref instanceof SReferenceLinkAdapter) {
      SReferenceLinkId id = ((SReferenceLinkAdapter) ref).getId();
      put(id);
      return;
    }

    throw new IllegalStateException(String.format("Cannot hash reference %s: %s", ref.getClass(), ref));
  }

  private void put(SContainmentLink containment) {
    if (containment == null) {
      return;
    }
    if (containment instanceof SContainmentLinkAdapter) {
      SContainmentLinkId id = ((SContainmentLinkAdapter) containment).getId();
      put(id);
      return;
    }

    throw new IllegalStateException(String.format("Cannot hash containment %s: %s", containment.getClass(), containment));
  }

  private void put(SConceptFeatureId featureId) {
    put(featureId.getConceptId());
    put(featureId.getIdValue());
  }

  private void put(SLanguage language) {
    if (language instanceof SLanguageAdapterById) {
      SLanguageId id = ((SLanguageAdapterById) language).getId();
      put(id);
      return;
    }

    throw new IllegalStateException(String.format("Cannot hash language %s: %s", language.getClass(), language));
  }

  private void put(SLanguageId languageId) {
    put(languageId.getHighBits());
    put(languageId.getLowBits());
  }

  private void put(SNodeId nodeId) {
    if (nodeId instanceof jetbrains.mps.smodel.SNodeId.Regular) {
      put(((jetbrains.mps.smodel.SNodeId.Regular) nodeId).getId());
    } else {
      put(nodeId.toString());
    }
  }

  private void put(CharSequence str) {
    hasher.putString(str, StandardCharsets.UTF_8);
  }
  private void put(long l) {
    hasher.putLong(l);
  }

  /**
   * We need to normalize the order of features (<i>not</i> feature values), 
   * as the order depends on insertion order but doesn't carry meaning. 
   */
  private static abstract class FeatureComparator<T extends SConceptFeatureId> {
    protected int compareFeature(T a, T b) {
      int idCompare = Long.compare(a.getIdValue(), b.getIdValue());
      if (idCompare != 0) {
        return idCompare;
      }
      SConceptId aConcept = a.getConceptId();
      SConceptId bConcept = b.getConceptId();
      int conceptCompare = Long.compare(aConcept.getIdValue(), bConcept.getIdValue());
      if (conceptCompare != 0) {
        return conceptCompare;
      }
      SLanguageId aLanguage = aConcept.getLanguageId();
      SLanguageId bLanguage = bConcept.getLanguageId();
      return aLanguage.getIdValue().compareTo(bLanguage.getIdValue());
    }

    protected String name(SConceptFeature a) {
      return a.getOwner().getLanguage().getQualifiedName() + a.getOwner().getName() + a.getName();
    }
  }

  private static class PropertyComparator extends FeatureComparator<SPropertyId> implements Comparator<SProperty> {
    @Override
    public int compare(SProperty a, SProperty b) {
      if (a instanceof SPropertyAdapter && b instanceof SPropertyAdapter) {
        return compareFeature(((SPropertyAdapter) a).getId(), ((SPropertyAdapter) b).getId());
      } else {
        return name(a).compareTo(name(b));
      }
    }
  }

  private static class ReferenceComparator extends FeatureComparator<SReferenceLinkId> implements Comparator<SReference> {
    @Override
    public int compare(SReference aRef, SReference bRef) {
      SReferenceLink a = aRef.getLink();
      SReferenceLink b = bRef.getLink();
      if (a instanceof SReferenceLinkAdapter && b instanceof SReferenceLinkAdapter) {
        return compareFeature(((SReferenceLinkAdapter) a).getId(), ((SReferenceLinkAdapter) b).getId());
      } else {
        return name(a).compareTo(name(b));
      }
    }
  }

  private static class ContainmentComparator extends FeatureComparator<SContainmentLinkId> implements Comparator<SNode> {
    @Override
    public int compare(SNode aChild, SNode bChild) {
      SContainmentLink a = aChild.getContainmentLink();
      SContainmentLink b = bChild.getContainmentLink();
      if (a instanceof SContainmentLinkAdapter && b instanceof SContainmentLinkAdapter) {
        return compareFeature(((SContainmentLinkAdapter) a).getId(), ((SContainmentLinkAdapter) b).getId());
      } else {
        return name(a).compareTo(name(b));
      }
    }
  }
}

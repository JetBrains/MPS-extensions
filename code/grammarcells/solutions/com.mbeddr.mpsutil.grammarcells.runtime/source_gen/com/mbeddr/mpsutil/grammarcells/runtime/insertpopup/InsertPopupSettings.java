package com.mbeddr.mpsutil.grammarcells.runtime.insertpopup;

/*Generated by MPS */

import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.ide.util.PropertiesComponent;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.net.URLDecoder;

public class InsertPopupSettings {
  private static final String RESOLVED_AMBIGUITIES_KEY = InsertPopupSettings.class.getName() + ".resolvedAmbiguities";
  private static final String POPUP_DISABLED_KEY = InsertPopupSettings.class.getName() + ".popupDisabled";
  private static final String ELEMENT_SEPARATOR = ",";
  private static final String ENTRY_SEPARATOR = ";";
  public static final InsertPopupSettings INSTANCE = new InsertPopupSettings();

  private Map<List<String>, Integer> resolvedAmbiguities = MapSequence.fromMap(new HashMap<List<String>, Integer>());

  private InsertPopupSettings() {
    load();
  }

  public void setPopupDisabled(boolean disabled) {
    PropertiesComponent.getInstance().setValue(POPUP_DISABLED_KEY, disabled, false);
  }

  public boolean isPopupDisabled() {
    return PropertiesComponent.getInstance().getBoolean(POPUP_DISABLED_KEY, true);
  }

  public void storeResolvedAmbiguity(List<String> options, int choice) {
    MapSequence.fromMap(resolvedAmbiguities).put(options, choice);
    store();
  }

  public void clearResolvedAmbiguities() {
    MapSequence.fromMap(resolvedAmbiguities).clear();
    store();
  }

  public int resolve(List<String> options) {
    return (MapSequence.fromMap(resolvedAmbiguities).containsKey(options) ? MapSequence.fromMap(resolvedAmbiguities).get(options) : -1);
  }

  public void store() {
    PropertiesComponent.getInstance().setValue(RESOLVED_AMBIGUITIES_KEY, IterableUtils.join(MapSequence.fromMap(resolvedAmbiguities).select((it) -> it.value() + ELEMENT_SEPARATOR + IterableUtils.join(ListSequence.fromList(it.key()), ELEMENT_SEPARATOR)), ENTRY_SEPARATOR));
  }

  public void load() {
    String serialized = PropertiesComponent.getInstance().getValue(RESOLVED_AMBIGUITIES_KEY);
    resolvedAmbiguities = MapSequence.fromMap(new HashMap<List<String>, Integer>());
    if ((serialized != null && serialized.length() > 0)) {
      for (String entry : Sequence.fromIterable(Sequence.fromArray(serialized.split(ENTRY_SEPARATOR))).where((it) -> (it != null && it.length() > 0))) {
        List<String> elements = Sequence.fromIterable(Sequence.fromArray(entry.split(ELEMENT_SEPARATOR))).where((it) -> (it != null && it.length() > 0)).select((it) -> {
          String string = it;
          return string;
        }).toList();
        MapSequence.fromMap(resolvedAmbiguities).put(ListSequence.fromList(elements).skip(1).toList(), Integer.parseInt(ListSequence.fromList(elements).first()));
      }
    }
  }

  private static String escape(String unescaped) {
    return URLEncoder.encode(unescaped, StandardCharsets.UTF_8);
  }

  private static String unescape(String escaped) {
    return URLDecoder.decode(escaped, StandardCharsets.UTF_8);
  }
}

package de.q60.mps.shadowmodels.transformation.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.typesystem.DataFlowUtil;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;

public class check_OperationImplementation_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_OperationImplementation_NonTypesystemRule() {
  }
  public void applyRule(final SNode n, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    if (SLinkOperations.getTarget(n, LINKS.body$xQ_Q) != null) {
      boolean checkReturns = false;
      if (SLinkOperations.getTarget(SLinkOperations.getTarget(n, LINKS.operationDecl$MEev), LINKS.returnType$p3Vo) != null && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SLinkOperations.getTarget(n, LINKS.operationDecl$MEev), LINKS.returnType$p3Vo), CONCEPTS.VoidType$BF))) {
        checkReturns = true;
      }
      DataFlowUtil.checkDataFlow(typeCheckingContext, SLinkOperations.getTarget(n, LINKS.body$xQ_Q), checkReturns);
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.OperationImplementation$F3;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink operationDecl$MEev = MetaAdapterFactory.getReferenceLink(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x557c3278312d9234L, 0x557c3278312d9235L, "operationDecl");
    /*package*/ static final SContainmentLink returnType$p3Vo = MetaAdapterFactory.getContainmentLink(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x557c3278311e707bL, 0x557c327831297938L, "returnType");
    /*package*/ static final SContainmentLink body$xQ_Q = MetaAdapterFactory.getContainmentLink(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x557c3278312d9234L, 0x557c327831320ff9L, "body");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept VoidType$BF = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc6bf96dL, "jetbrains.mps.baseLanguage.structure.VoidType");
    /*package*/ static final SConcept OperationImplementation$F3 = MetaAdapterFactory.getConcept(0x94b64715a2634c36L, 0xa1388da14705ffa7L, 0x557c3278312d9234L, "de.q60.mps.shadowmodels.transformation.structure.OperationImplementation");
  }
}

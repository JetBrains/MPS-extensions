package de.itemis.mps.nativelibs.plugin;

/*Generated by MPS */

import com.intellij.openapi.components.BaseComponent;
import jetbrains.mps.logging.Logger;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import com.intellij.util.lang.UrlClassLoader;
import java.util.HashMap;
import jetbrains.mps.classloading.DeployListener;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.module.ReloadableModule;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.NonNls;
import java.io.File;
import com.intellij.ide.plugins.IdeaPluginDescriptor;
import com.intellij.ide.plugins.PluginManagerCore;
import com.intellij.openapi.extensions.PluginId;
import java.lang.reflect.Method;
import java.util.List;
import java.net.URL;
import java.util.ArrayList;
import java.lang.reflect.InvocationTargetException;
import java.util.Collection;
import java.lang.reflect.Field;
import jetbrains.mps.classloading.ModuleClassLoader;
import jetbrains.mps.classloading.ModuleClassLoaderSupport;
import jetbrains.mps.reloading.IClassPathItem;
import jetbrains.mps.reloading.CompositeClassPathItem;
import java.util.Iterator;
import jetbrains.mps.reloading.JarFileClassPathItem;
import java.util.Objects;
import jetbrains.mps.util.MacrosFactory;

public class NativeLibraryLoader implements BaseComponent {
  private static final Logger LOG = Logger.getLogger(NativeLibraryLoader.class);
  private String PLUGIN_ID = "de.itemis.mps.nativelibs.loader";

  private String operatingSystem = detectOS();
  private Set<String> loadedLibraries = new HashSet<String>();
  private Map<String, UrlClassLoader> myClassLoaders = new HashMap<String, UrlClassLoader>();
  private Map<String, Set<String>> jarsToRemove = new HashMap<String, Set<String>>();
  private DeployListener classLoadingListener = new DeployListener() {
    @Override
    public void onLoaded(@NotNull Set<ReloadableModule> modules, @NotNull ProgressMonitor monitor) {
      for (ReloadableModule module : SetSequence.fromSet(modules)) {
        loadLibraries(module);
      }
    }

    @Override
    public void onUnloaded(@NotNull Set<ReloadableModule> unloadedModules, @NotNull ProgressMonitor monitor) {
    }
  };

  private final MPSCoreComponents myMpsCore;

  public NativeLibraryLoader() {
    myMpsCore = MPSCoreComponents.getInstance();
  }
  public void initComponent() {
    // FIXME replace CLM listener with ModuleDeploymentListener (introduced in 2022.3). Faciliates separation of deployment code activity.
    ClassLoaderManager clm = myMpsCore.getPlatform().findComponent(ClassLoaderManager.class);
    clm.addListener(classLoadingListener);
    final MPSModuleRepository repo = myMpsCore.getPlatform().findComponent(MPSModuleRepository.class);
    repo.getModelAccess().runReadAction(() -> {
      for (SModule existingModule : Sequence.fromIterable(repo.getModules())) {
        loadLibraries(existingModule);
      }
    });
  }

  public void disposeComponent() {
    // XXX due to IDEA-218341, we may face MPSCoreComponent disposed here. To address that, shall replace BaseComponent with
    // Disposable, but got no idea how to ensure initComponent in proper moment then
    ClassLoaderManager clm = myMpsCore.getPlatform().findComponent(ClassLoaderManager.class);
    if (clm != null) {
      clm.removeListener(classLoadingListener);
    }
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "Native Library Loader";
  }

  public File getPluginRoot() {
    IdeaPluginDescriptor plugin = PluginManagerCore.getPlugin(PluginId.getId(PLUGIN_ID));
    if (plugin == null) {
      throw new RuntimeException("Plugin not found: " + PLUGIN_ID);
    }
    return (plugin.getPluginPath() != null ? plugin.getPluginPath().toFile() : null);
  }

  public Set<String> getJarsToRemove(SModule module) {
    String moduleName = module.getModuleName();
    Set<String> result = jarsToRemove.get(moduleName);
    if (result == null) {
      result = new HashSet<String>();
      jarsToRemove.put(moduleName, result);
    }
    return result;
  }

  protected void loadLibraries(SModule module) {
    try {
      if (!(module instanceof ReloadableModule)) {
        return;
      }
      ReloadableModule reloadableModule = ((ReloadableModule) module);
      Class descriptor = null;
      try {
        if (reloadableModule.getClassLoader() != null) {
          descriptor = reloadableModule.getOwnClass(module.getModuleName() + ".plugin.NativeLibraries");
        }
      } catch (ClassNotFoundException ex) {
      }
      if (descriptor == null) {
        return;
      }
      Method getLibraryPaths = descriptor.getDeclaredMethod("getLibraryPaths", String.class);
      List<String> libraryPaths = (List<String>) getLibraryPaths.invoke(null, operatingSystem);


      UrlClassLoader classLoader = myClassLoaders.get(module.getModuleName());
      if (classLoader == null) {
        Method getJarPaths = descriptor.getDeclaredMethod("getJarPaths");
        List<String> jarPaths = (List<String>) getJarPaths.invoke(null);
        List<URL> classPath = new ArrayList<URL>(jarPaths.size());
        for (String path : jarPaths) {
          File absolute = new File(resolveLibraryPath(module, path));
          classPath.add(absolute.toURI().toURL());
          getJarsToRemove(module).add(absolute.getAbsolutePath());
        }
        // for loading LibraryLodingClass
        classPath.add(new File(new File(getPluginRoot(), "lib"), "de.itemis.mps.nativelibs.loader.jar").toURI().toURL());
        classLoader = UrlClassLoader.build().urls(classPath).get();
        myClassLoaders.put(module.getModuleName(), classLoader);
      }
      for (String j : getJarsToRemove(module)) {
        removeJarFromModuleClassLoader(module, j);
      }
      addDependencyClassLoader(module, classLoader);

      for (String path : libraryPaths) {
        loadLibrary(module, path, classLoader);
      }
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("Cannot load native libraries for module: " + module.getModuleName(), ex);
      }
    }

  }

  private void addDependencyClassLoader(SModule module, ClassLoader newDep) throws IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
    ClassLoader moduleCL = getModuleClassLoader(module);

    Method getDependencyClassLoaders = moduleCL.getClass().getDeclaredMethod("getDependencyClassLoaders");
    getDependencyClassLoaders.setAccessible(true);

    Collection<ClassLoader> deps = (Collection<ClassLoader>) getDependencyClassLoaders.invoke(moduleCL);
    deps.add(newDep);
  }

  public void removeJarFromModuleClassLoader(SModule module, String absolutePath) throws NoSuchFieldException, IllegalAccessException {
    ClassLoader moduleCL = getModuleClassLoader(module);

    Field supportField = ModuleClassLoader.class.getDeclaredField("mySupport");
    supportField.setAccessible(true);
    ModuleClassLoaderSupport support = (ModuleClassLoaderSupport) supportField.get(moduleCL);

    Field classPathItemField = ModuleClassLoaderSupport.class.getDeclaredField("myClassPathItem");
    classPathItemField.setAccessible(true);
    IClassPathItem classPathItem = (IClassPathItem) classPathItemField.get(support);

    removeJar(classPathItem, absolutePath);
  }

  public void removeJar(IClassPathItem cpi, String absolutePath) throws NoSuchFieldException, IllegalAccessException {
    if (cpi instanceof CompositeClassPathItem) {
      CompositeClassPathItem composite = ((CompositeClassPathItem) cpi);

      Field childrenField = CompositeClassPathItem.class.getDeclaredField("myChildren");
      childrenField.setAccessible(true);
      List<IClassPathItem> children = (List<IClassPathItem>) childrenField.get(composite);

      Iterator<IClassPathItem> iterator = children.iterator();
      while (iterator.hasNext()) {
        IClassPathItem item = iterator.next();
        if (item instanceof JarFileClassPathItem) {
          JarFileClassPathItem jarItem = ((JarFileClassPathItem) item);
          if (Objects.equals(jarItem.getPath().replace('\\', '/'), absolutePath.replace('\\', '/'))) {
            iterator.remove();
          }
        }
      }
    }
  }

  public ModuleClassLoader getModuleClassLoader(SModule module) {
    if (module instanceof ReloadableModule) {
      return (ModuleClassLoader) ((ReloadableModule) module).getClassLoader();
    }
    return null;
  }

  protected void loadLibrary(SModule module, String libraryPath, ClassLoader classLoader) {
    loadLibrary(resolveLibraryPath(module, libraryPath), classLoader);
  }

  public File getModuleFolder(SModule module) {
    // FIXME note, since 2023.3, MPS resolves ${module} macro of deployed module to location of its source descriptor,
    //      i.e. usually module-src.jar/module/, not module.jar/META-INF/ as it used to be.
    return new File(MacrosFactory.forModule(module).expandPath("${module}"));
  }

  protected String resolveLibraryPath(SModule module, String relativeLibraryPath) {
    File moduleFolder = new File(MacrosFactory.forModule(module).expandPath("${module}"));

    File absoluteLibraryPath = new File(moduleFolder, relativeLibraryPath);
    if (absoluteLibraryPath.exists()) {
      return absoluteLibraryPath.getAbsolutePath();
    }

    File libFolder = new File(moduleFolder, "lib");
    absoluteLibraryPath = new File(libFolder, relativeLibraryPath);
    if (absoluteLibraryPath.exists()) {
      return absoluteLibraryPath.getAbsolutePath();
    }

    File parentFolder = moduleFolder.getParentFile();
    while (parentFolder != null) {
      absoluteLibraryPath = new File(parentFolder, relativeLibraryPath);
      if (absoluteLibraryPath.exists()) {
        return absoluteLibraryPath.getAbsolutePath();
      }
      parentFolder = parentFolder.getParentFile();
    }

    throw new RuntimeException("Cannot find library: " + relativeLibraryPath + " in " + moduleFolder);
  }

  public void loadLibrary(String absolutePath, ClassLoader classLoader) {
    if (absolutePath == null) {
      return;
    }
    if (loadedLibraries.contains(absolutePath)) {
      return;
    }

    // A native library is assigned to the class loader of the calling class.
    // That's why we need to load the library from a class that was loaded by the same class loader.
    try {
      Class loaderClass = classLoader.loadClass(LibraryLoadingClass.class.getName());
      Method loadMethod = loaderClass.getDeclaredMethod("load", String.class);
      loadMethod.invoke(null, absolutePath);
      loadedLibraries.add(absolutePath);
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }
  }

  private static String detectOS() {
    String os = System.getProperty("os.name").toLowerCase();
    String arch = System.getProperty("os.arch").toLowerCase();
    if (os.contains("linux")) {
      if (arch.contains("64")) {
        return "LINUX64";
      } else
      if (arch.contains("86")) {
        return "LINUX32";
      }
    } else
    if (os.contains("win")) {
      if (arch.contains("64")) {
        return "WIN64";
      } else
      if (arch.contains("86")) {
        return "WIN32";
      }
    } else
    if (os.contains("mac")) {
      if (arch.contains("64")) {
        return "OSX64";
      } else
      if (arch.contains("86")) {
        return "OSX32";
      }
    }
    return null;
  }

}

package org.modelix.model.mpsadapters.mps;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SModule;
import org.modelix.model.api.INode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.project.Project;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.project.ProjectManager;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.area.IArea;
import org.modelix.model.api.IConcept;
import org.modelix.model.api.INodeReference;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class SRepositoryAsNode extends TreeElementAsNode<SRepository> {

  public static boolean isVisible(SModule module) {
    return true;
  }

  private static TreeElementAsNode.IChildAccessor<SRepository> modulesAccessor = new TreeElementAsNode.IChildAccessor<SRepository>() {
    public Iterable<INode> get(SRepository repository) {
      Iterable<SModule> modules = repository.getModules();
      return Sequence.fromIterable(modules).where((it) -> isVisible(it)).where((it) -> !(SModuleAsNode.isTempModule(it))).select((it) -> new SModuleAsNode(it));
    }
  };
  private static TreeElementAsNode.IChildAccessor<SRepository> tempModulesAccessor = new TreeElementAsNode.IChildAccessor<SRepository>() {
    public Iterable<INode> get(SRepository repository) {
      Iterable<SModule> modules = repository.getModules();
      return Sequence.fromIterable(modules).where((it) -> isVisible(it)).where((it) -> SModuleAsNode.isTempModule(it)).select((it) -> new SModuleAsNode(it));
    }
  };
  private static TreeElementAsNode.IChildAccessor<SRepository> projectsAccessor = new TreeElementAsNode.IChildAccessor<SRepository>() {
    public Iterable<INode> get(SRepository repository) {
      List<Project> projects = MPSCoreComponents.getInstance().getPlatform().findComponent(ProjectManager.class).getOpenedProjects();
      return ListSequence.fromList(projects).ofType(MPSProject.class).select((it) -> new ProjectAsNode(it));
    }
  };

  public SRepositoryAsNode(SRepository repository) {
    super(repository);
  }

  @NotNull
  @Override
  public IArea getArea() {
    return new MPSArea(getElement());
  }

  @Override
  public IConcept getConcept() {
    return SConceptAdapter.wrap(CONCEPTS.Repository$db);
  }

  @Override
  protected TreeElementAsNode.IChildAccessor getChildAccessor(String role) {
    if (role.equals(LINKS.modules$jBPn.getName())) {
      return modulesAccessor;
    }
    if (role.equals(LINKS.tempModules$Zqoa.getName())) {
      return tempModulesAccessor;
    }
    if (role.equals(LINKS.projects$NW07.getName())) {
      return projectsAccessor;
    }
    return super.getChildAccessor(role);
  }
  @Override
  protected TreeElementAsNode.IPropertyAccessor getPropertyAccessor(String role) {
    return super.getPropertyAccessor(role);
  }
  @Override
  protected TreeElementAsNode.IReferenceAccessor getReferenceAccessor(String role) {
    return super.getReferenceAccessor(role);
  }
  @Override
  public INode getParent() {
    return null;
  }
  @Override
  public String getRoleInParent() {
    return null;
  }
  @Override
  public String toString() {
    return "repository";
  }

  @NotNull
  @Override
  public INodeReference getReference() {
    return NodeReference.INSTANCE;
  }

  public static class NodeReference implements INodeReference {
    public static NodeReference INSTANCE = new NodeReference();
    private NodeReference() {
    }

    @Nullable
    @Override
    public INode resolveNode(@Nullable IArea area) {
      SRepository repo = null;
      if (area != null) {
        List<IArea> areas = area.collectAreas();
        repo = ListSequence.fromList(areas).ofType(MPSArea.class).select((it) -> it.getRepository()).where(new NotNullWhereFilter()).first();
      }
      if (repo == null) {
        repo = MPSCoreComponents.getInstance().getPlatform().findComponent(MPSModuleRepository.class);
      }
      return new SRepositoryAsNode(repo);
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Repository$db = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, "org.modelix.model.repositoryconcepts.structure.Repository");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink modules$jBPn = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, 0x69652614fd1c517L, "modules");
    /*package*/ static final SContainmentLink tempModules$Zqoa = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, 0x72291b7f31486ecaL, "tempModules");
    /*package*/ static final SContainmentLink projects$NW07 = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c516L, 0x620a8558361d3e0cL, "projects");
  }
}

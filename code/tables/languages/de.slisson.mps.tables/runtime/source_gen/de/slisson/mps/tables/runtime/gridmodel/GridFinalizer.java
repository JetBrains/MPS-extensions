package de.slisson.mps.tables.runtime.gridmodel;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import java.util.HashSet;
import de.slisson.mps.tables.runtime.cells.TableDebug;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.SubstituteInfo;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import com.intellij.ui.JBColor;
import de.slisson.mps.tables.runtime.simplegrid.SimpleGrid;
import de.slisson.mps.tables.runtime.simplegrid.GridPosition;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import de.slisson.mps.tables.runtime.simplegrid.ElementFactory;
import de.slisson.mps.tables.runtime.cells.RowEndCell;

public class GridFinalizer {

  private Grid myGrid;
  private EditorCellFactory myEditorCellFactory;
  private Set<EditorCell> myUsedHeaderCells = new HashSet<EditorCell>();

  public GridFinalizer(Grid grid, EditorCellFactory editorCellFactory) {
    myGrid = grid;
    myEditorCellFactory = editorCellFactory;
  }

  public void finalizeGrid(boolean hideLeftRowEndCells, boolean hideRightRowEndCells) {
    extendHeadersIntoEmptySpace();
    int columnHeaderSizeY = myGrid.getColumnHeadersSizeY();
    mergeHeadersIntoGrid();
    addRowEndCells(columnHeaderSizeY, !(hideLeftRowEndCells), !(hideRightRowEndCells));
    finalizeEditorCellLeafs();
    TableDebug.sout("finalized grid: " + myGrid);
  }

  public void finalizeEditorCellLeafs() {
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        IGridElement element = myGrid.getElement(x, y);
        if (element instanceof EditorCellGridLeaf) {
          EditorCell cell = ((EditorCellGridLeaf) element).getEditorCell();

          // insert after
          PriorizedValue<CellAction> insertAction = element.getInsertAction();
          if (insertAction != null && insertAction.getValue() != null) {
            if (cell.getAction(CellActionType.INSERT) == null || insertAction.getPriority() >= 0) {
              cell.setAction(CellActionType.INSERT, insertAction.getValue());
            }
          }

          // paste
          PriorizedValue<CellAction> pasteAction = element.getPasteAction();
          if (pasteAction != null && pasteAction.getValue() != null) {
            if (cell.getAction(CellActionType.PASTE) == null || pasteAction.getPriority() >= 0) {
              cell.setAction(CellActionType.PASTE, pasteAction.getValue());
            }
          }

          // insert before
          PriorizedValue<CellAction> insertBeforeAction = element.getInsertBeforeAction();
          if (insertBeforeAction != null && insertBeforeAction.getValue() != null) {
            if (cell.getAction(CellActionType.INSERT_BEFORE) == null || insertBeforeAction.getPriority() >= 0) {
              cell.setAction(CellActionType.INSERT_BEFORE, insertBeforeAction.getValue());
            }
          }

          // delete
          PriorizedValue<CellAction> deleteAction = element.getDeleteAction();
          if (deleteAction != null && deleteAction.getValue() != null) {
            if (cell.getAction(CellActionType.DELETE) == null || deleteAction.getPriority() >= 0) {
              cell.setAction(CellActionType.DELETE, deleteAction.getValue());
            }
          }


          // set substitute info
          SubstituteInfo substituteInfo = check_m036w7_a0u0b0a0a0j(element.getSubstituteInfo());
          if (substituteInfo != null && cell.getSubstituteInfo() == null) {
            cell.setSubstituteInfo(substituteInfo);
          }
          EditorCell firstLeaf = CellTraversalUtil.getFirstLeaf(cell);
          if (firstLeaf != null && firstLeaf.getSubstituteInfo() == null) {
            firstLeaf.setSubstituteInfo(substituteInfo);
          }
        }
      }
    }
  }

  private void replaceUnusedPositions() {
    for (int x = 0; x < myGrid.getSizeX(); x++) {
      for (int y = 0; y < myGrid.getSizeY(); y++) {
        UnusedPosition unused = as_m036w7_a0a0a0a0a11(myGrid.getElement(x, y), UnusedPosition.class);
        if (unused != null) {
          EditorCell cell = myEditorCellFactory.createConstant("", JBColor.LIGHT_GRAY, false, true);
          cell.setSelectable(false);
          EditorCellGridLeaf gridElement = new EditorCellGridLeaf(cell);
          gridElement.setSpanX(unused.getSpanX());
          gridElement.setSpanY(unused.getSpanY());
          myGrid.setElement(x, y, gridElement);
        }
      }
    }
  }

  private void mergeHeadersIntoGrid() {
    SimpleGrid<HeaderReference> columnHeaders = myGrid.getColumnHeaders();
    SimpleGrid<HeaderReference> rowHeaders = myGrid.getRowHeaders();
    myGrid.clearRowHeaders();
    myGrid.clearColumnHeaders();
    myGrid.insertRows(0, columnHeaders.getSizeY());
    myGrid.insertColumns(0, rowHeaders.getSizeX());
    mergeHeadersIntoGrid(columnHeaders, rowHeaders.getSizeX(), 0);
    mergeHeadersIntoGrid(rowHeaders, 0, columnHeaders.getSizeY());
  }

  private void mergeHeadersIntoGrid(SimpleGrid<HeaderReference> headers, int offsetX, int offsetY) {
    Set<GridPosition> processedPositions = SetSequence.fromSet(new HashSet<GridPosition>());
    for (int x = 0; x < headers.getSizeX(); x++) {
      for (int y = 0; y < headers.getSizeY(); y++) {
        if (SetSequence.fromSet(processedPositions).contains(new GridPosition(x, y))) {
          continue;
        }
        HeaderReference ref = headers.getElement(x, y);
        IGridElement ge = headerToGridElement(ref);
        setHeaderElementSpan(x, y, headers, ge);
        myGrid.setElement(offsetX + x, offsetY + y, ge);
        for (int x_ = 0; x_ < ge.getSpanX(); x_++) {
          for (int y_ = 0; y_ < ge.getSpanY(); y_++) {
            SetSequence.fromSet(processedPositions).addElement(new GridPosition(x + x_, y + y_));
          }
        }
      }
    }
  }

  private void setHeaderElementSpan(int x, int y, SimpleGrid<HeaderReference> headerGrid, IGridElement targetElement) {
    SpanningBounds bounds = GridUtils.getSpanningBounds(x, y, headerGrid);
    targetElement.setSpanX(bounds.getMaxX() - x + 1);
    targetElement.setSpanY(bounds.getMaxY() - y + 1);
  }

  private IGridElement headerToGridElement(HeaderReference headerRef) {
    if (headerRef == null) {
      return new UnusedPosition();
    }
    EditorCellGridLeaf element;
    EditorCellHeader header = (EditorCellHeader) myGrid.findHeader(headerRef);
    if (header != null) {
      EditorCell cell = header.getEditorCell();
      if (myUsedHeaderCells.contains(cell)) {
        String text = (header.getLabel() != null ? header.getLabel() : headerRef.getFallbackText());
        text = "+" + text;
        cell = myEditorCellFactory.createConstant(text);
        cell.getStyle().set(StyleAttributes.TEXT_COLOR, JBColor.LIGHT_GRAY);
      } else {
        myUsedHeaderCells.add(cell);
      }
      element = new EditorCellGridLeaf(cell);
      element.setOrAddStyle(header.getStyle());

      IRowCreateHandler rowInsertBeforeHandler = header.getRowInsertBeforeHandler();
      if (rowInsertBeforeHandler != null) {
        element.setLeftRowCreateHandler(rowInsertBeforeHandler);
      }

      IRowCreateHandler rowInsertHandler = header.getRowInsertHandler();
      if (rowInsertHandler != null) {
        element.setRightRowCreateHandler(rowInsertHandler);
      }

      IRowDeleteHandler rowDeleteHandler = header.getRowDeleteHandler();
      if (rowDeleteHandler != null) {
        element.setLeftRowDeleteHandler(rowDeleteHandler, 0);
        element.setRightRowDeleteHandler(rowDeleteHandler, 0);
      }

    } else {
      element = new EditorCellGridLeaf(myEditorCellFactory.createError("<header not found: " + headerRef + ">"));
    }
    return element;
  }

  public void addRowEndCells(int columnHeadersSizeY, boolean leftEnabled, boolean rightEnabled) {
    if (leftEnabled) {
      myGrid.insertColumn(0, new ElementFactory<IGridElement>() {
        public IGridElement createNewElement() {
          return new EditorCellGridLeaf(myEditorCellFactory.createRowEndCell(true));
        }
      });
    }
    if (rightEnabled) {
      myGrid.insertColumn(myGrid.getSizeX(), new ElementFactory<IGridElement>() {
        public IGridElement createNewElement() {
          return new EditorCellGridLeaf(myEditorCellFactory.createRowEndCell(false));
        }
      });
    }

    if (columnHeadersSizeY > 0) {
      if (leftEnabled) {
        for (int y = 0; y < columnHeadersSizeY; y++) {
          UnusedPosition leftCorner = new UnusedPosition();
          myGrid.setElement(0, y, leftCorner);
        }
      }
      if (rightEnabled) {
        for (int y = 0; y < columnHeadersSizeY; y++) {
          UnusedPosition rightCorner = new UnusedPosition();
          myGrid.setElement(myGrid.getSizeX() - 1, y, rightCorner);
        }
      }
    }

    for (int y = columnHeadersSizeY; y < myGrid.getSizeY(); y++) {
      if (leftEnabled) {
        RowEndCell left = (RowEndCell) ((EditorCellGridLeaf) myGrid.getElement(0, y)).getEditorCell();

        final IRowDeleteHandler leftDeleteHandler = myGrid.getLeftRowDeleteHandler(y);
        if (leftDeleteHandler != null) {
          left.setAction(CellActionType.BACKSPACE, new RowDeleteHandlerAdapter(leftDeleteHandler));
          left.setAction(CellActionType.DELETE, new RowDeleteHandlerAdapter(leftDeleteHandler));
        }

        final IRowCreateHandler leftCreateHandler = myGrid.getLeftRowCreateHandler(y);
        if (leftCreateHandler != null) {
          left.setAction(CellActionType.INSERT, new RowCreateHandlerAdapter(leftCreateHandler));
        }
        final IRowCreateHandler rightCreateHandler = myGrid.getRightRowCreateHandler(y);
        if (rightCreateHandler != null) {
          left.setAction(CellActionType.INSERT_BEFORE, new RowCreateHandlerAdapter(rightCreateHandler));
        } else {
          left.setAction(CellActionType.INSERT_BEFORE, left.getAction(CellActionType.INSERT));
        }
      }
      if (rightEnabled) {
        RowEndCell right = (RowEndCell) ((EditorCellGridLeaf) myGrid.getElement(myGrid.getSizeX() - 1, y)).getEditorCell();

        final IRowDeleteHandler rightDeleteHandler = myGrid.getRightRowDeleteHandler(y);
        if (rightDeleteHandler != null) {
          right.setAction(CellActionType.BACKSPACE, new RowDeleteHandlerAdapter(rightDeleteHandler));
          right.setAction(CellActionType.DELETE, new RowDeleteHandlerAdapter(rightDeleteHandler));
        }

        final IRowCreateHandler rightCreateHandler = myGrid.getRightRowCreateHandler(y);
        if (rightCreateHandler != null) {
          right.setAction(CellActionType.INSERT, new RowCreateHandlerAdapter(rightCreateHandler));
        }

        final IRowCreateHandler leftCreateHandler = myGrid.getLeftRowCreateHandler(y);
        if (leftCreateHandler != null) {
          right.setAction(CellActionType.INSERT_BEFORE, new RowCreateHandlerAdapter(leftCreateHandler));
        } else {
          right.setAction(CellActionType.INSERT_BEFORE, right.getAction(CellActionType.INSERT));
        }

      }
    }
  }

  public void extendHeadersIntoEmptySpace() {
    for (int x = 0; x < myGrid.getColumnHeadersSizeX(); x++) {
      for (int y = 0; y < myGrid.getColumnHeadersSizeY() - 1; y++) {
        if (myGrid.getColumnHeader(x, y + 1) == null) {
          myGrid.setColumnHeader(x, y + 1, myGrid.getColumnHeader(x, y));
        }
      }
    }
  }
  private static SubstituteInfo check_m036w7_a0u0b0a0a0j(PriorizedValue<SubstituteInfo> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getValue();
    }
    return null;
  }
  private static <T> T as_m036w7_a0a0a0a0a11(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

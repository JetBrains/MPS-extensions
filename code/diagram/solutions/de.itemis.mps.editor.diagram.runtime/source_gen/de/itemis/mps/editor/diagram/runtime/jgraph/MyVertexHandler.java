package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import com.mxgraph.swing.handler.mxVertexHandler;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.view.mxCellState;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.List;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import de.itemis.mps.editor.diagram.runtime.model.IConnectionType_Internal;
import java.awt.Graphics;
import java.awt.event.MouseEvent;
import com.mxgraph.util.mxRectangle;
import de.itemis.mps.editor.diagram.runtime.model.Bounds;
import com.mxgraph.view.mxGraphView;
import com.mxgraph.model.mxCell;

public class MyVertexHandler extends mxVertexHandler implements ISupportButtonHiding {

  private ContextButtonContainer myButtonContainer;
  private boolean mySnapToSiblingsEnabled = true;
  private AlignEnum align = AlignEnum.RIGHT;

  protected Map<Integer, Boolean> buttonVisibility = MapSequence.fromMap(new HashMap<Integer, Boolean>());

  public MyVertexHandler(mxGraphComponent graphComponent, mxCellState state, AlignEnum align, Map<Integer, Boolean> buttonVisibility) {
    super(graphComponent, state);
    this.align = align;
    this.buttonVisibility = buttonVisibility;

    updateButtons();
  }

  @Override
  public Map<Integer, Boolean> getButtonVisibilityMap() {
    return buttonVisibility;
  }

  public ContextButtonContainer getButtonContainer() {
    if (myButtonContainer == null) {
      myButtonContainer = new ContextButtonContainer(state.getView());
      updateButtons();
    }
    return myButtonContainer;
  }

  public double getScale() {
    return state.getView().getScale();
  }

  protected void updateButtons() {
    MyGraphComponent component = ((MyGraphComponent) this.getGraphComponent());
    RootDCell rootCell = ((RootDiagramECell) ReflectionUtil.readField(MyGraphComponent.class, component, "myDiagramCell")).getDCell(component.getGraph());
    _FunctionTypes._return_P3_E0<? extends List<ContextButton>, ? super EditorContext, ? super SNode, ? super mxCellState> buttonsCreator = rootCell.getVertexButtonsCreator();

    final List<ContextButton> buttons = ListSequence.fromList(new ArrayList<ContextButton>());
    if (buttonsCreator != null) {
      IMPSCellContainer container = (IMPSCellContainer) state.getCell();
      EditorCell editorCell = container.getBigCell();
      ListSequence.fromList(buttons).addSequence(ListSequence.fromList(buttonsCreator.invoke(editorCell.getEditorComponent().getEditorContext(), editorCell.getSNode(), state)));
    }

    final double size = ContextButton.DEFAULT_BUTTON_SIZE * getScale();

    if (state.getCell() instanceof BoxBaseDCell && buttonsCreator == null) {
      if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__fit-size-button"))) {
        ListSequence.fromList(buttons).addElement(new FitSizeButton(size, state));
      }
    }

    if (state.getCell() instanceof BoxDCell) {
      final BoxDCell boxCell = ((BoxDCell) state.getCell());
      final DiagramModel boxModel = boxCell.getBox().getModel();
      if (buttonsCreator == null) {
        if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__reorder-ports-button")) && !(boxCell.getBox().getPorts().isEmpty())) {
          ListSequence.fromList(buttons).addElement(new ReorderPortsButton(size, state));
        }
        if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__show-all-edges-button")) && boxModel.hasInvisibleEdges(boxCell.getBox())) {
          ListSequence.fromList(buttons).addElement(new ShowAllEdgesButton(size, state));
        }

        if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__hide-all-edges-button")) && boxModel.hasVisibleEdges(boxCell.getBox())) {
          ListSequence.fromList(buttons).addElement(new HideAllEdgesButton(size, state));
        }

        if (getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__open-node-buttons"))) {
          for (SNode target : ListSequence.fromList(boxCell.getBox().getNavigationTargets())) {
            ListSequence.fromList(buttons).addElement(new OpenNodeButton(size, state, target));
          }
        }
      }

      if (buttonsCreator == null && getButtonVisibility(StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.diagram.styles", "__create-edge-button"))) {
        final Wrappers._T<NewEdgeButton> newEdgeButton = new Wrappers._T<NewEdgeButton>(null);

        boxModel.getEditorContext().getRepository().getModelAccess().runReadAction(() -> {
          for (IConnectionType_Internal connectionType : ListSequence.fromList(boxModel.getConnectionTypes())) {
            if (connectionType.isValidStart(boxCell.getBox(), null)) {
              if (newEdgeButton.value == null) {
                newEdgeButton.value = new NewEdgeButton(size, state);
                ListSequence.fromList(buttons).addElement(newEdgeButton.value);
              }
              if (connectionType.showContextButton()) {
                newEdgeButton.value.addChildButton(new NewEdgeButton(size, state, connectionType));
              }
            }
          }
        });

      }
    }
    getButtonContainer().setButtons(buttons);
    // button position
    double x = state.getX();

    if (align == null) {
      align = AlignEnum.CENTER;
    }
    switch (this.align) {
      case LEFT:
        break;
      case RIGHT:
        x = x + state.getWidth() - getButtonContainer().getBounds().getWidth();
        break;
      case CENTER:
        x = x + (state.getWidth() - getButtonContainer().getBounds().getWidth()) / 2;
        break;
    }
    getButtonContainer().moveTo(x, state.getY() + state.getHeight() + ContextButtonContainer.BUTTON_SPACING * getScale());
  }

  @Override
  public void refresh(mxCellState state) {
    super.refresh(state);
    updateButtons();
    bounds.add(getButtonContainer().getBounds());
  }

  @Override
  public void paint(Graphics g) {
    super.paint(g);
    getButtonContainer().paint(g);
  }


  @Override
  public void mousePressed(MouseEvent event) {
    getButtonContainer().mousePressed(event);
    if (!(event.isConsumed())) {
      super.mousePressed(event);
    }
  }


  @Override
  public void mouseReleased(MouseEvent event) {
    getButtonContainer().mouseReleased(event);
    if (!(event.isConsumed())) {
      super.mouseReleased(event);
    }
  }

  @Override
  public void mouseMoved(MouseEvent event) {
    getButtonContainer().mouseMoved(event);
    super.mouseMoved(event);
  }

  @Override
  public void mouseDragged(MouseEvent event) {
    getButtonContainer().mouseDragged(event);
    if (!(event.isConsumed())) {
      mySnapToSiblingsEnabled = !(event.isShiftDown());
      super.mouseDragged(event);
    }
  }

  @Override
  protected mxRectangle union(mxRectangle bounds, double dx, double dy, int index) {
    mxRectangle newBounds = super.union(bounds, dx, dy, index);
    return (mySnapToSiblingsEnabled ? snapToSiblings(newBounds, dx, dy, index) : newBounds);
  }

  protected mxRectangle snapToSiblings(mxRectangle bounds, double dx, double dy, int index) {
    Bounds snapped = ExtensionMethods.toBounds(bounds);

    final mxGraphView view = graphComponent.getGraph().getView();
    final mxCell cell = (mxCell) state.getCell();
    List<mxCellState> siblingStates = ListSequence.fromList(JGraphUtil.getSiblings(cell)).where((it) -> it.getClass() == cell.getClass()).select((it) -> view.getState(it)).toList();

    boolean isTop = index < 3;
    boolean isBottom = index > 4;
    boolean isLeft = index == 0 || index == 3 || index == 5;
    boolean isRight = index == 2 || index == 4 || index == 7;

    if (isLeft) {
      Double nearest = null;
      for (mxCellState sibling : ListSequence.fromList(siblingStates)) {
        // snap only if the oppsite side is aligned
        if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(sibling.getRectangle().getMaxX(), snapped.getMaxX(), 1.0)) {
          nearest = nearest(nearest, sibling.getRectangle().getMinX(), snapped.getMinX());
        }
      }
      if (nearest != null) {
        double delta = nearest - snapped.getMinX();
        if (Math.abs(delta) < MyMovePreview.SNAP_DISTANCE_LIMIT) {
          snapped.setX(snapped.getX() + delta);
          snapped.setWidth(snapped.getWidth() - delta);
        }
      }
    }
    if (isRight) {
      Double nearest = null;
      for (mxCellState sibling : ListSequence.fromList(siblingStates)) {
        if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(sibling.getRectangle().getMinX(), snapped.getMinX(), 1.0)) {
          nearest = nearest(nearest, sibling.getRectangle().getMaxX(), snapped.getMaxX());
        }
      }
      if (nearest != null) {
        double delta = nearest - snapped.getMaxX();
        if (Math.abs(delta) < MyMovePreview.SNAP_DISTANCE_LIMIT) {
          snapped.setWidth(snapped.getWidth() + delta);
        }
      }
    }
    if (isTop) {
      Double nearest = null;
      for (mxCellState sibling : ListSequence.fromList(siblingStates)) {
        if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(sibling.getRectangle().getMaxY(), snapped.getMaxY(), 1.0)) {
          nearest = nearest(nearest, sibling.getRectangle().getMinY(), snapped.getMinY());
        }
      }
      if (nearest != null) {
        double delta = nearest - snapped.getMinY();
        if (Math.abs(delta) < MyMovePreview.SNAP_DISTANCE_LIMIT) {
          snapped.setY(snapped.getY() + delta);
          snapped.setHeight(snapped.getHeight() - delta);
        }
      }
    }
    if (isBottom) {
      Double nearest = null;
      for (mxCellState sibling : ListSequence.fromList(siblingStates)) {
        if (de.itemis.mps.editor.diagram.runtime.model.ExtensionMethods.isNear(sibling.getRectangle().getMinY(), snapped.getMinY(), 1.0)) {
          nearest = nearest(nearest, sibling.getRectangle().getMaxY(), snapped.getMaxY());
        }
      }
      if (nearest != null) {
        double delta = nearest - snapped.getMaxY();
        if (Math.abs(delta) < MyMovePreview.SNAP_DISTANCE_LIMIT) {
          snapped.setHeight(snapped.getHeight() + delta);
        }
      }
    }

    return ExtensionMethods.toMxRectangle(snapped);
  }

  private double nearest(Double previous, double newCandidate, double reference) {
    if (previous == null) {
      return newCandidate;
    } else {
      double newDistance = Math.abs(newCandidate - reference);
      double previousDistance = Math.abs(previous - reference);
      if (newDistance < previousDistance) {
        return newCandidate;
      } else {
        return previous;
      }
    }
  }

  @Override
  public String getToolTipText(MouseEvent event) {
    String toolTipText = getButtonContainer().getToolTipText(event.getX(), event.getY());
    if (toolTipText != null) {
      return toolTipText;
    }
    return super.getToolTipText(event);
  }
}

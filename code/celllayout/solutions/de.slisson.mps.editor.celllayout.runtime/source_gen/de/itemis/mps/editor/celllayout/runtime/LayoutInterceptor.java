package de.itemis.mps.editor.celllayout.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Indent;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import de.itemis.mps.editor.celllayout.boxmodel.EditorCellBoxModel;
import java.util.List;
import java.awt.Rectangle;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import java.util.ArrayList;
import jetbrains.mps.nodeEditor.cells.GeometryUtil;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.editor.runtime.TextBuilderImpl;
import java.util.Iterator;
import jetbrains.mps.nodeEditor.cells.EditorCell_Indent;
import jetbrains.mps.nodeEditor.cellLayout.PunctuationUtil;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.openapi.editor.style.StyleAttribute;
import java.awt.Color;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import de.itemis.mps.editor.celllayout.layout.ILayouter;

/**
 * Is set to all cells that have a supported layout
 */
public class LayoutInterceptor implements CellLayout, ICellLayoutWrapper {
  private static boolean DISABLED = false;

  public static jetbrains.mps.openapi.editor.cells.CellLayout getOriginalLayout(EditorCell_Collection cell) {
    jetbrains.mps.openapi.editor.cells.CellLayout cellLayout = cell.getCellLayout();
    return CellLayoutExtensions.unwrapAll(cellLayout);
  }

  private CellLayout myOriginalLayout;
  private boolean myIsLayouting = false;

  public LayoutInterceptor(CellLayout orginalLayout) {
    myOriginalLayout = orginalLayout;
  }

  public CellLayout getOriginalLayout() {
    return myOriginalLayout;
  }

  public CellLayout getWrappedLayout() {
    return myOriginalLayout;
  }

  @Override
  public void doLayout(EditorCell_Collection collection) {
    if (myIsLayouting) {
      return;
    }
    try {
      myIsLayouting = true;
      new LayoutEngine().layoutCell(collection);
    } finally {
      myIsLayouting = false;
    }
  }
  @Override
  public TextBuilder doLayoutText(Iterable<EditorCell> collection) {
    if (myOriginalLayout instanceof CellLayout_Indent) {
      return LayoutFixed.IndentLayoutFixes.doLayoutText(collection);
    }
    if (myOriginalLayout instanceof CellLayout_Horizontal) {
      return LayoutFixed.HorizontalLayoutFixes.doLayoutText(collection);
    }
    return myOriginalLayout.doLayoutText(collection);
  }
  @Override
  public int getAscent(EditorCell_Collection collection) {
    return EditorCellBoxModel.getInstance(collection).getBorderBox().getInnerBox().getAscent();
  }
  @Override
  public int getDescent(EditorCell_Collection collection) {
    return EditorCellBoxModel.getInstance(collection).getBorderBox().getInnerBox().getDescent();
  }
  @Override
  public List<Rectangle> getSelectionBounds(EditorCell_Collection collection) {
    if (myOriginalLayout instanceof CellLayout_Indent) {
      return LayoutFixed.IndentLayoutFixes.getSelectionBounds(collection);
    }
    return myOriginalLayout.getSelectionBounds(collection);
  }
  @Override
  public boolean canBeFolded() {
    return myOriginalLayout.canBeFolded();
  }
  @Nullable
  @Override
  public List<? extends EditorCell> getSelectionCells(EditorCell_Collection collection) {
    if (myOriginalLayout instanceof CellLayout_Indent) {
      return LayoutFixed.IndentLayoutFixes.getSelectionCells(collection);
    }
    return myOriginalLayout.getSelectionCells(collection);
  }

  @Override
  public void requestRelayout(EditorCell_Collection collection) {
  }
  @Override
  public void move(EditorCell_Collection collection, int deltaX, int deltaY) {
    EditorCellBoxModel.getInstance(collection).getMarginBox().move(deltaX, deltaY);
    for (EditorCell child : Sequence.fromIterable(collection)) {
      if (!(child instanceof EditorCell_Collection)) {
        EditorCellBoxModel.getInstance(child).getMarginBox().move(deltaX, deltaY);
      }
    }

    LayoutableAdapters.getAdapter(collection).setChanged(true);
  }

  public static void installRecursive(EditorComponent editorComponent) {
    if (DISABLED) {
      return;
    }
    installRecursive(editorComponent.getRootCell());
  }

  public static boolean installRecursive(EditorCell cell) {
    if (DISABLED) {
      return false;
    }
    boolean installedAnywhere = false;
    jetbrains.mps.nodeEditor.cells.EditorCell_Collection collectionCell = as_58rwot_a0a2a62(cell, jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class);
    if (collectionCell != null) {
      installedAnywhere |= install(collectionCell);
      for (EditorCell child : Sequence.fromIterable(collectionCell)) {
        installedAnywhere |= installRecursive(child);
      }
    }
    return installedAnywhere;
  }

  public static boolean installWhereRequired(EditorComponent editorComponent) {
    if (DISABLED) {
      return false;
    }
    return installWhereRequired(editorComponent.getRootCell());
  }

  public static boolean installWhereRequired(EditorCell cell) {
    if (DISABLED) {
      return false;
    }
    jetbrains.mps.nodeEditor.cells.EditorCell_Collection collectionCell = as_58rwot_a0a1a03(cell, jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class);
    if (collectionCell == null) {
      return false;
    }

    boolean installedAnywhere = false;
    for (jetbrains.mps.nodeEditor.cells.EditorCell_Collection c : SetSequence.fromSet(StylesRequiringInstall.collectRequiredCells(cell)).ofType(jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class)) {

      // Using the MPS layouter instead of our more feature rich algorithms is done for performance reasons.
      // Mixing both layout algorithms often causes overlapping cells and installing the interceptor into the whole subtree is a working workaround.
      // That's what we do here, if the layout algorithm is replaced anywhere, we replace it in the whole subtree.
      if (isInstalled(c)) {
        continue;
      }
      installedAnywhere |= installRecursive(c);
    }
    return installedAnywhere;
  }

  public static boolean install(EditorCell cell) {
    if (DISABLED) {
      return false;
    }
    jetbrains.mps.nodeEditor.cells.EditorCell_Collection collectionCell = as_58rwot_a0a1a23(cell, jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class);
    if (collectionCell == null) {
      return false;
    }
    if (!(LayoutableAdapters.isSupportedCollection(collectionCell))) {
      return false;
    }

    CellLayout layout = collectionCell.getCellLayout();
    if (!(layout instanceof ICellLayoutWrapper)) {
      CellLayout wrapped = new LayoutInterceptor(layout);
      if (layout instanceof CellLayout_Horizontal || layout instanceof CellLayout_Indent || check_58rwot_a0b0g0gb(check_58rwot_a0a1a6a23(as_58rwot_a0a0a1a6a23(layout, TopDownCellLayoutAdapter.class)))) {
        wrapped = new PunctuableLayout(wrapped);
      }
      ReflectionUtil.writeField(jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class, collectionCell, "myCellLayout", wrapped);
      collectionCell.requestRelayout();
      return true;
    }
    return false;
  }

  public static boolean isInstalled(EditorCell cell) {
    jetbrains.mps.nodeEditor.cells.EditorCell_Collection collectionCell = as_58rwot_a0a0a43(cell, jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class);
    if (collectionCell == null) {
      return false;
    }
    CellLayout layout = collectionCell.getCellLayout();
    return layout instanceof LayoutInterceptor;
  }

  public static void uninstall(EditorComponent editorComponent) {
    uninstall(editorComponent.getRootCell());
  }

  public static void uninstall(EditorCell cell) {
    jetbrains.mps.nodeEditor.cells.EditorCell_Collection collectionCell = as_58rwot_a0a0a83(cell, jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class);
    if (collectionCell == null) {
      return;
    }

    for (EditorCell child : Sequence.fromIterable(collectionCell)) {
      uninstall(child);
    }

    CellLayout layout = collectionCell.getCellLayout();
    if (layout instanceof ICellLayoutWrapper) {
      ReflectionUtil.writeField(jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class, collectionCell, "myCellLayout", ((CellLayout) CellLayoutExtensions.unwrapAll(layout)));
    }
  }

  @Override
  public String toString() {
    return ">" + myOriginalLayout.toString();
  }

  public static class LayoutFixed {
    public static class IndentLayoutFixes {
      public static List<? extends EditorCell> getSelectionCells(EditorCell_Collection editorCells) {
        return getIndentLeafs(editorCells);
      }
      public static List<Rectangle> getSelectionBounds(EditorCell_Collection editorCells) {
        List<Rectangle> result = new ArrayList<Rectangle>();
        List<EditorCell> indentLeafs = getIndentLeafs(editorCells);
        for (EditorCell leaf : indentLeafs) {
          result.add(GeometryUtil.getBounds(leaf));
        }
        return result;
      }
      private static List<EditorCell> getIndentLeafs(EditorCell_Collection current) {
        List<EditorCell> result = new ArrayList<EditorCell>();
        collectCells(current, result, null);
        return result;
      }
      private static void collectCells(EditorCell_Collection current, List<EditorCell> frontier, List<EditorCell_Collection> collections) {
        for (EditorCell child : current) {
          if (child instanceof EditorCell_Collection) {
            EditorCell_Collection collection = (EditorCell_Collection) child;
            if (isIndentCollection(collection)) {
              collectCells(collection, frontier, collections);
            } else {
              frontier.add(child);
            }
          } else {
            frontier.add(child);
          }
          if (collections != null) {
            collections.add(current);
          }
        }
      }
      private static boolean isIndentCollection(EditorCell_Collection collection) {
        return getOriginalLayout(collection) instanceof CellLayout_Indent && collection.getCellsCount() > 0;
      }
      public static TextBuilder doLayoutText(Iterable<EditorCell> editorCells) {
        Set<EditorCell> editorCellsSet = new HashSet<EditorCell>();
        for (EditorCell editorCell : editorCells) {
          editorCellsSet.add(editorCell);
        }
        TextBuilder result = new TextBuilderImpl();
        Iterator<EditorCell> iterator = editorCells.iterator();
        if (iterator.hasNext()) {
          boolean newLineAfter = false;
          EditorCell_Collection rootCell = iterator.next().getParent();
          for (EditorCell current : getIndentLeafs(rootCell)) {
            EditorCell childCell = current;
            while (childCell.getParent() != rootCell) {
              childCell = childCell.getParent();
            }
            if (!(editorCellsSet.contains(childCell))) {
              continue;
            }
            if (isOnNewLine(rootCell, current) || newLineAfter) {
              newLineAfter = false;
              result = result.appendToTheRight(new TextBuilderImpl("\n"), true);
              for (int i = 0; i < getIndent(rootCell, current, false); i++) {

                result = result.appendToTheRight(new TextBuilderImpl(EditorCell_Indent.getIndentText()), false);
              }
            }
            result = result.appendToTheRight(current.renderText(), PunctuationUtil.hasLeftGap(current));
            if (isNewLineAfter(rootCell, current)) {
              newLineAfter = true;
            }
          }
        }
        return result;
      }
      public static boolean isOnNewLine(EditorCell root, EditorCell cell) {
        for (EditorCell current = cell; current != root; current = current.getParent()) {
          if (current.getStyle().get(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE)) {
            return true;
          }
          if (current.getParent() == null || current.getParent().firstCell() != current) {
            return false;
          }
        }
        return false;
      }
      public static int getIndent(EditorCell root, EditorCell cell, boolean overflow) {
        int result = 0;
        if (overflow) {
          result += 2;
        }
        while (cell != root) {
          if (cell.getStyle().get(StyleAttributes.INDENT_LAYOUT_INDENT)) {
            result++;
          }
          cell = cell.getParent();
        }
        return result;
      }
      public static boolean isNewLineAfter(EditorCell root, EditorCell cell) {
        for (EditorCell current = cell; current != root; current = current.getParent()) {
          if (current.getStyle().get(StyleAttributes.INDENT_LAYOUT_NEW_LINE)) {
            return true;
          }
          EditorCell_Collection parent = current.getParent();
          if (parent != null && parent.getStyle().get(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE)) {
            return true;
          }
          if (parent == null || parent.lastCell() != current) {
            return false;
          }
        }
        return false;
      }

    }

    public static class HorizontalLayoutFixes {
      public static TextBuilder doLayoutText(Iterable<EditorCell> editorCells) {
        TextBuilder result = new TextBuilderImpl();
        for (EditorCell editorCell : editorCells) {
          result = result.appendToTheRight(editorCell.renderText(), PunctuationUtil.hasLeftGap(editorCell));
        }
        return result;
      }
    }

  }

  private static class StylesRequiringInstall {

    private static final Set<StyleAttribute> BORDER_ATTRIBUTES = SetSequence.fromSetAndArray(new HashSet<StyleAttribute>(), StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-color"), StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-left-color"), StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-right-color"), StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-top-color"), StyleAttributes.getInstance().<Color>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-bottom-color"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-size"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-left-size"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-right-size"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-top-size"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_border-bottom-size"));
    private static final Set<StyleAttribute> MARGIN_ATTRIBUTES = SetSequence.fromSetAndArray(new HashSet<StyleAttribute>(), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_margin-top"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_margin-bottom"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_margin-left"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_margin-right"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_margin"));
    private static final Set<StyleAttribute> GRID_ATTRIBUTES = SetSequence.fromSetAndArray(new HashSet<StyleAttribute>(), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-flatten"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-column-span"), StyleAttributes.getInstance().<Integer>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grid-layout-row-span"));
    private static final Set<StyleAttribute> GROW_ATTRIBUTES = SetSequence.fromSetAndArray(new HashSet<StyleAttribute>(), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grow-x"), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_grow-y"));
    private static final Set<StyleAttribute> PUSH_ATTRIBUTES = SetSequence.fromSetAndArray(new HashSet<StyleAttribute>(), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_push-x"), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_push-y"));
    private static final Set<StyleAttribute> OVERFLOW_ATTRIBUTES = SetSequence.fromSetAndArray(new HashSet<StyleAttribute>(), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_overflow-x"), StyleAttributes.getInstance().<Boolean>getAttribute("de.itemis.mps.editor.celllayout.styles", "_overflow-y"));

    private static final Set<StyleAttribute> REQUIRES_THIS_CELL = SetSequence.fromSet(new HashSet<StyleAttribute>());
    private static final Set<StyleAttribute> REQUIRES_PARENT_CELL = SetSequence.fromSet(new HashSet<StyleAttribute>());
    private static final Set<StyleAttribute> REQUIRES_ANCESTOR_CELLS = SetSequence.fromSet(new HashSet<StyleAttribute>());

    static {
      SetSequence.fromSet(REQUIRES_THIS_CELL).addSequence(SetSequence.fromSet(BORDER_ATTRIBUTES));
      SetSequence.fromSet(REQUIRES_THIS_CELL).addSequence(SetSequence.fromSet(MARGIN_ATTRIBUTES));
      SetSequence.fromSet(REQUIRES_PARENT_CELL).addSequence(SetSequence.fromSet(BORDER_ATTRIBUTES));
      SetSequence.fromSet(REQUIRES_PARENT_CELL).addSequence(SetSequence.fromSet(MARGIN_ATTRIBUTES));
      SetSequence.fromSet(REQUIRES_PARENT_CELL).addSequence(SetSequence.fromSet(GROW_ATTRIBUTES));
      SetSequence.fromSet(REQUIRES_ANCESTOR_CELLS).addSequence(SetSequence.fromSet(PUSH_ATTRIBUTES));
      SetSequence.fromSet(REQUIRES_ANCESTOR_CELLS).addSequence(SetSequence.fromSet(OVERFLOW_ATTRIBUTES));
    }

    public static Set<EditorCell> collectRequiredCells(EditorCell cell) {
      Set<EditorCell> acc = SetSequence.fromSet(new HashSet<EditorCell>());
      collectRequiredCells(cell, acc);
      return acc;
    }

    public static void collectRequiredCells(EditorCell cell, Set<EditorCell> acc) {
      for (StyleAttribute attribute : Sequence.fromIterable(cell.getStyle().getSpecifiedAttributes())) {
        if (SetSequence.fromSet(REQUIRES_THIS_CELL).contains(attribute)) {
          SetSequence.fromSet(acc).addElement(cell);
        }
        if (SetSequence.fromSet(REQUIRES_PARENT_CELL).contains(attribute)) {
          EditorCell_Collection parent = cell.getParent();
          if (parent != null) {
            SetSequence.fromSet(acc).addElement(parent);
          }
        }
        if (SetSequence.fromSet(REQUIRES_ANCESTOR_CELLS).contains(attribute)) {
          for (EditorCell ancestor = cell.getParent(); ancestor != null; ancestor = ancestor.getParent()) {
            SetSequence.fromSet(acc).addElement(ancestor);
          }
        }
        if (SetSequence.fromSet(GRID_ATTRIBUTES).contains(attribute)) {
          for (EditorCell ancestor = cell.getParent(); ancestor != null; ancestor = ancestor.getParent()) {
            SetSequence.fromSet(acc).addElement(ancestor);
            if (check_58rwot_a1a0a3a0a61sb(as_58rwot_a0a1a0a3a0a61sb(as_58rwot_a0a0a0b0a0d0a0q44(ancestor, jetbrains.mps.nodeEditor.cells.EditorCell_Collection.class).getCellLayout(), CellLayout_Vertical.class))) {
              break;
            }
          }
        }
      }

      if (cell instanceof jetbrains.mps.nodeEditor.cells.EditorCell_Collection) {
        for (EditorCell child : Sequence.fromIterable(((jetbrains.mps.nodeEditor.cells.EditorCell_Collection) cell))) {
          collectRequiredCells(child, acc);
        }
      }
    }

    private static boolean check_58rwot_a1a0a3a0a61sb(CellLayout_Vertical checkedDotOperand) {
      if (null != checkedDotOperand) {
        return ((Boolean) ReflectionUtil.callMethod(CellLayout_Vertical.class, checkedDotOperand, "isGridLayout", new Class[]{}, new Object[]{}));
      }
      return false;
    }
    private static <T> T as_58rwot_a0a1a0a3a0a61sb(Object o, Class<T> type) {
      return (type.isInstance(o) ? (T) o : null);
    }
    private static <T> T as_58rwot_a0a0a0b0a0d0a0q44(Object o, Class<T> type) {
      return (type.isInstance(o) ? (T) o : null);
    }
  }
  private static boolean check_58rwot_a0b0g0gb(ILayouter checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.usesPunctuation();
    }
    return false;
  }
  private static ILayouter check_58rwot_a0a1a6a23(TopDownCellLayoutAdapter checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getLayouter();
    }
    return null;
  }
  private static <T> T as_58rwot_a0a2a62(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_58rwot_a0a1a03(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_58rwot_a0a1a23(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_58rwot_a0a0a1a6a23(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_58rwot_a0a0a43(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_58rwot_a0a0a83(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

package de.q60.mps.shadowmodels.runtime.plugin;

/*Generated by MPS */

import javax.swing.Icon;
import java.util.Map;
import com.intellij.openapi.project.Project;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.project.ProjectHelper;
import de.q60.mps.util.invalidation.Invalidatable;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.ide.projectPane.ProjectPane;
import com.intellij.openapi.extensions.ExtensionPoint;
import com.intellij.ide.projectView.TreeStructureProvider;
import jetbrains.mps.ide.projectPane.logicalview.BaseModuleProjectViewNode;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.annotations.NotNull;
import com.intellij.ide.projectView.ViewSettings;
import jetbrains.mps.smodel.SObject;
import java.util.Objects;
import com.intellij.ide.projectView.PresentationData;
import jetbrains.mps.ide.projectPane.logicalview.TopHierarchyProjectViewNode;
import de.q60.mps.shadowmodels.runtime.smodel.SM_ShadowModule;
import java.util.Collection;
import com.intellij.ide.util.treeView.AbstractTreeNode;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.projectPane.logicalview.ProjectViewWeights;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class ProjectViewExtension {
  public static final Icon ROOT_ICON = new ShadowIcon("S", 16, 2.7f, 13.8f);
  public static final Icon MODULE_ICON = new ShadowIcon("M", 14, 2.0f, 13.0f);
  public static final Icon MODEL_ICON = new ShadowIcon("m", 14, 1.7f, 12.0f);

  private static Map<Project, ProjectViewExtension> ourInstances = MapSequence.fromMap(new HashMap<Project, ProjectViewExtension>());

  public static ProjectViewExtension getInstance(Project ideaProject) {
    ProjectViewExtension instance = MapSequence.fromMap(ourInstances).get(ideaProject);
    if (instance == null) {
      MPSProject mpsProject = ProjectHelper.fromIdeaProject(ideaProject);
      instance = new ProjectViewExtension(mpsProject);
      MapSequence.fromMap(ourInstances).put(ideaProject, instance);
    }
    return instance;
  }
  public static ProjectViewExtension getInstance(jetbrains.mps.project.Project mpsProject) {
    return getInstance(ProjectHelper.toIdeaProject(mpsProject));
  }

  private jetbrains.mps.project.Project project;
  private boolean disposed = false;

  private Invalidatable invalidatable = new Invalidatable("Project view extension", () -> ApplicationManager.getApplication().invokeLater(() -> ProjectPane.getInstance(project).updateFromRoot(true))) {
    @Override
    public String getText() {
      return "Project view extension (" + project.getName() + ")";
    }
  };

  public ProjectViewExtension(jetbrains.mps.project.Project project) {
    this.project = project;
  }

  public void addExtension() {
    Project ideaProject = getIdeaProject();
    ExtensionPoint<TreeStructureProvider> epoint = TreeStructureProvider.EP.getPoint(ideaProject);
    epoint.registerExtension(new ShadowRootTreeStructure1Provider(), ideaProject);
  }

  public void removeExtension() {
    Project ideaProject = getIdeaProject();
    ExtensionPoint<TreeStructureProvider> epoint = TreeStructureProvider.EP.getPoint(ideaProject);
    epoint.unregisterExtension(ShadowRootTreeStructure1Provider.class);
  }

  private Project getIdeaProject() {
    return ((MPSProject) project).getProject();
  }

  public void dispose() {
    disposed = true;
    MapSequence.fromMap(ourInstances).removeKey(ProjectHelper.toIdeaProject(project));
    invalidatable.dispose();
  }

  public static class ShadowModuleProjectViewNode extends BaseModuleProjectViewNode<SModule> {
    public ShadowModuleProjectViewNode(Project project, @NotNull SModule value, ViewSettings viewSettings) {
      super(project, value, viewSettings);
    }

    public SModule getModule() {
      return getValue();
    }

    @Override
    protected boolean containsSObject(SObject sObject) {
      return sObject.testIfHasSModule((mod) -> Objects.equals(mod, getModule()));
    }

    @Override
    protected boolean canRepresentSObject(SObject sObject) {
      return !(sObject.hasSNode()) && sObject.testIfHasSModule((mod) -> Objects.equals(mod, getModule()));
    }

    @Override
    protected void update(@NotNull PresentationData presentation) {
      presentation.setPresentableText(getModule().getModuleName());
      presentation.setIcon(MODULE_ICON);
      updateTooltip(presentation);
    }
  }

  public class ShadowRootProjectTreeNode extends TopHierarchyProjectViewNode<String> {
    public ShadowRootProjectTreeNode(Project project, @NotNull String value, ViewSettings viewSettings) {
      super(project, value, viewSettings);
    }

    @Override
    protected boolean containsSObject(SObject sObject) {
      return sObject.testIfHasSModule((mod) -> mod instanceof SM_ShadowModule);
    }

    @Override
    protected void fillChildren(final Collection<AbstractTreeNode<?>> collection) {
      SRepository repository = project.getRepository();
      Iterable<SModule> modules = repository.getModules();
      Sequence.fromIterable(modules).ofType(SM_ShadowModule.class).select((it) -> new ShadowModuleProjectViewNode(getIdeaProject(), it, getSettings())).visitAll((it) -> collection.add(it));
    }

    @Override
    public int getTypeSortWeight(boolean sortByType) {
      return ProjectViewWeights.MODULES_POOL_WEIGHT + 1;
    }

    @Override
    protected void updateInReadAction(PresentationData presentation) {
      presentation.setPresentableText(getValue());
      presentation.setIcon(ROOT_ICON);
    }
  }

  public class ShadowRootTreeStructure1Provider implements TreeStructureProvider {
    @NotNull
    @Override
    public Collection<AbstractTreeNode<?>> modify(@NotNull AbstractTreeNode<?> node, @NotNull final Collection<AbstractTreeNode<?>> children, final ViewSettings settings) {
      if (node.getParent() == null) {
        final SRepository repository = project.getRepository();
        final Wrappers._T<List<AbstractTreeNode<?>>> newChildren = new Wrappers._T<List<AbstractTreeNode<?>>>(null);
        repository.getModelAccess().runReadAction(() -> {
          Iterable<SModule> modules = repository.getModules();
          if (Sequence.fromIterable(modules).ofType(SM_ShadowModule.class).isNotEmpty()) {
            newChildren.value = ListSequence.fromListWithValues(new ArrayList<>(), children);
            ListSequence.fromList(newChildren.value).addElement(new ShadowRootProjectTreeNode(getIdeaProject(), "Shadow", settings));
          }
        });
        if (newChildren.value != null) {
          return newChildren.value;
        }
      }
      return children;
    }
  }

}

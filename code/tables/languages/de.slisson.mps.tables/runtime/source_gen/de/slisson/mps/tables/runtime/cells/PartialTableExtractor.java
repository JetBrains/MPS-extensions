package de.slisson.mps.tables.runtime.cells;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.util.WeakSet;
import de.slisson.mps.tables.runtime.gridmodel.Grid;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellGridLeaf;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellFactory;
import de.slisson.mps.tables.runtime.gridmodel.Header;
import de.slisson.mps.tables.runtime.gridmodel.EditorCellHeader;
import de.slisson.mps.tables.runtime.gridmodel.SNodeHeaderReference;
import jetbrains.mps.lang.structure.behavior.AttributeDesignTimeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.LinkedHashSet;
import de.slisson.mps.tables.runtime.gridmodel.IGridElement;
import java.util.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class PartialTableExtractor {

  private Set<PartialTableEditor> extracted = SetSequence.fromSet(new WeakSet<PartialTableEditor>());
  private static final String ORIGINAL_CHILDREN_KEY = PartialTableExtractor.class.getName() + ".originalChildren";

  private PartialTableExtractor() {
  }

  public Grid extract(EditorContext context, SNode snode, EditorCell cell, Grid contextGrid) {
    return extract(context, snode, cell, cell, contextGrid);
  }

  public Grid extract(EditorContext context, SNode snode, EditorCell rootCell, EditorCell currentCell, Grid contextGrid) {
    if (currentCell instanceof TableEditor) {
      return null;
    } else if (currentCell instanceof PartialTableEditor && !(SetSequence.fromSet(extracted).contains(((PartialTableEditor) currentCell))) && !(currentCell.getParent() instanceof PartialTableEditor)) {
      Grid result = new Grid();
      Grid annotatedGrid = ((PartialTableEditor) currentCell).getGrid().clone();
      result.setElement(0, 0, annotatedGrid);

      EditorCell_Collection parent = (EditorCell_Collection) currentCell.getParent();
      if (parent == null) {
        return null;
      }
      SetSequence.fromSet(extracted).addElement((PartialTableEditor) currentCell);

      result.setElement(1, 0, new EditorCellGridLeaf(rootCell));

      SNode annotation = SNodeOperations.as(((SNode) rootCell.getSNode()), CONCEPTS.Attribute$g1);
      if ((annotation != null)) {
        EditorCellFactory ecf = new EditorCellFactory(context, snode, contextGrid);
        SNode annotationConceptNode = SNodeOperations.cast(SNodeOperations.getConcept(annotation).getSourceNode().resolve(context.getRepository()), CONCEPTS.ConceptDeclaration$gH);
        Header annotationHeader = new EditorCellHeader(new SNodeHeaderReference(annotationConceptNode), ecf.createConstant("@" + AttributeDesignTimeOperations.getAttributeRole(annotationConceptNode)));
        result.setColumnHeader(1, 0, annotationHeader);
      }
      result.flattenOneLevel();
      return result;
    } else if (currentCell instanceof jetbrains.mps.openapi.editor.cells.EditorCell_Collection) {
      jetbrains.mps.openapi.editor.cells.EditorCell_Collection collection = (jetbrains.mps.openapi.editor.cells.EditorCell_Collection) currentCell;

      for (EditorCell child : Sequence.fromIterable(combineWithOriginalChildren(collection))) {
        Grid grid = extract(context, snode, rootCell, child, contextGrid);
        if (grid != null) {
          return grid;
        }
      }
    }

    return null;
  }

  public Iterable<EditorCell> combineWithOriginalChildren(jetbrains.mps.openapi.editor.cells.EditorCell_Collection parent) {
    Set<EditorCell> all = SetSequence.fromSet(new LinkedHashSet<EditorCell>());
    SetSequence.fromSet(all).addSequence(Sequence.fromIterable(((Iterable<EditorCell>) parent)));
    SetSequence.fromSet(all).addSequence(Sequence.fromIterable((Iterable<EditorCell>) parent.getUserObject(ORIGINAL_CHILDREN_KEY)));
    parent.putUserObject(ORIGINAL_CHILDREN_KEY, all);
    return all;
  }

  private static Grid getGridFromPartialTable(EditorCell editorCell, Grid parentGrid) {
    if (!(editorCell instanceof PartialTableEditor)) {
      return null;
    }
    PartialTableEditor partialTableEditor = ((PartialTableEditor) editorCell);
    Grid grid = partialTableEditor.getGrid().clone();
    return grid;
  }

  public static IGridElement getGridElementFromEditorCell(EditorCell cell, Grid parentGrid) {
    if (cell == null) {
      return null;
    }
    Grid grid = getGridFromPartialTable(cell, parentGrid);
    if (grid != null) {
      return grid;
    }
    PartialTableExtractor instance = getInstance();
    if (instance == null) {
      return new EditorCellGridLeaf(cell);
    }
    grid = instance.extract(cell.getContext(), cell.getSNode(), cell, parentGrid);
    if (grid != null) {
      return grid;
    }
    return new EditorCellGridLeaf(cell);
  }

  private static ThreadLocal<Deque<PartialTableExtractor>> instances = new ThreadLocal<Deque<PartialTableExtractor>>();

  public static PartialTableExtractor getInstance() {
    initStack();
    return DequeSequence.fromDequeNew(PartialTableExtractor.instances.get()).peekElement();
  }

  public static PartialTableExtractor pushNewInstance() {
    initStack();
    DequeSequence.fromDequeNew(PartialTableExtractor.instances.get()).pushElement(new PartialTableExtractor());
    return getInstance();
  }

  public static PartialTableExtractor popInstance() {
    initStack();
    return DequeSequence.fromDequeNew(PartialTableExtractor.instances.get()).popElement();
  }

  private static void initStack() {
    if (PartialTableExtractor.instances.get() == null) {
      PartialTableExtractor.instances.set(DequeSequence.fromDeque(new LinkedList<PartialTableExtractor>()));
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Attribute$g1 = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x47bf8397520e5939L, "jetbrains.mps.lang.core.structure.Attribute");
    /*package*/ static final SConcept ConceptDeclaration$gH = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
  }
}

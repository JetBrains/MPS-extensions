package de.itemis.mps.editor.diagram.runtime.jgraph;

/*Generated by MPS */

import java.util.List;
import com.mxgraph.util.mxPoint;
import java.awt.geom.Line2D;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import com.mxgraph.model.mxIGraphModel;
import com.mxgraph.model.mxGeometry;
import java.util.ArrayList;

public class EdgeLineMoveHandler {
  private static final int INDEX_OFFSET = 100000;
  private static final double DISTANCE_FROM_TERMINAL = 10.0;

  private MyEdgeHandler myEdgeHandler;

  public EdgeLineMoveHandler(MyEdgeHandler edgeHandler) {
    myEdgeHandler = edgeHandler;
  }

  public int indexLineToHandle(int lineIndex) {
    return lineIndex + INDEX_OFFSET;
  }

  public int indexHandleToLine(int handleIndex) {
    return handleIndex - INDEX_OFFSET;
  }

  public boolean isLineIndex(int handleIndex) {
    return handleIndex >= INDEX_OFFSET;
  }

  public int getIndexAt(int x, int y) {
    List<mxPoint> p = myEdgeHandler.getState().getAbsolutePoints();
    if (p != null && p.size() >= 2) {
      int closestIndex = 0;
      double closestDistance = Double.MAX_VALUE;
      for (int i = 0; i < p.size() - 1; i++) {
        mxPoint p1 = p.get(i);
        mxPoint p2 = p.get(i + 1);

        Line2D line = new Line2D.Double(VectorExtensions.toPoint2D(p1), VectorExtensions.toPoint2D(p2));
        double distance = JGraphUtil.distanceLinePoint(new Vector2D(x, y), line);
        if (distance < closestDistance) {
          closestIndex = i;
          closestDistance = distance;
        }
      }
      if (closestDistance <= myEdgeHandler.getGraphComponent().getTolerance()) {
        return indexLineToHandle(closestIndex);
      }
    }
    return -1;
  }

  public void move(Object edge, mxPoint startTerminal, mxPoint endTerminal, int lineIndex, double deltaX, double deltaY) {
    mxIGraphModel model = myEdgeHandler.getGraphComponent().getGraph().getModel();
    mxGeometry geometry = model.getGeometry(edge);
    if (geometry != null) {
      model.beginUpdate();
      try {
        geometry = (mxGeometry) geometry.clone();
        List<mxPoint> points = geometry.getPoints();
        if (points == null) {
          points = new ArrayList<mxPoint>();
        }
        movePoints(points, startTerminal, endTerminal, lineIndex, deltaX, deltaY);
        myEdgeHandler.postprocessPoints(startTerminal, endTerminal, points);
        geometry.setPoints(points);
        model.setGeometry(edge, geometry);
      } finally {
        model.endUpdate();
      }
    }
  }

  public mxPoint getPoint(int index, List<mxPoint> points, mxPoint startTerminal, mxPoint endTerminal) {
    if (index == -1) {
      return startTerminal;
    } else if (index == points.size()) {
      return endTerminal;
    } else {
      return points.get(index);
    }
  }

  public void movePoints(List<mxPoint> points, mxPoint startTerminal, mxPoint endTerminal, int lineIndex, double deltaX, double deltaY) {
    // We cannot move the terminal points. Therefore, we have to insert additional points to make the first/last
    // line segment moveable
    if (lineIndex == 0) {
      Vector2D newPoint = VectorExtensions.toVector2D(startTerminal);
      Vector2D nextPoint = VectorExtensions.toVector2D(((points.size() > 0 ? points.get(0) : endTerminal)));
      newPoint = newPoint.add(nextPoint.subtract(newPoint).normalize().scalarMultiply(DISTANCE_FROM_TERMINAL));
      points.add(0, VectorExtensions.toMxPoint(newPoint));
      points.add(0, VectorExtensions.toMxPoint(newPoint));
      lineIndex += 2;
    }
    if (lineIndex == points.size()) {
      Vector2D newPoint = VectorExtensions.toVector2D(endTerminal);
      Vector2D nextPoint = VectorExtensions.toVector2D(((points.size() > 0 ? points.get(points.size() - 1) : startTerminal)));
      newPoint = newPoint.add(nextPoint.subtract(newPoint).normalize().scalarMultiply(DISTANCE_FROM_TERMINAL));
      points.add(VectorExtensions.toMxPoint(newPoint));
      points.add(VectorExtensions.toMxPoint(newPoint));
    }

    // we are not allowed to change the points but only the list: create a copy of all points
    for (int i = 0; i < points.size(); i++) {
      points.set(i, (mxPoint) points.get(i).clone());
    }

    Vector2D p1 = VectorExtensions.toVector2D(points.get(lineIndex - 1));
    Vector2D p2 = VectorExtensions.toVector2D(points.get(lineIndex));

    // insert additional points if the lines are not orthogonal
    if (lineIndex + 1 < points.size()) {
      Vector2D p3 = VectorExtensions.toVector2D(points.get(lineIndex + 1));
      if (!(isSquareAngle(p3.subtract(p2), p2.subtract(p1)))) {
        points.add(lineIndex + 1, new mxPoint(points.get(lineIndex)));
      }
    }
    if (lineIndex - 2 >= 0) {
      Vector2D p0 = VectorExtensions.toVector2D(points.get(lineIndex - 2));
      if (!(isSquareAngle(p1.subtract(p0), p2.subtract(p1)))) {
        points.add(lineIndex - 1, new mxPoint(points.get(lineIndex - 1)));
        lineIndex++;
      }
    }

    Vector2D direction = VectorExtensions.rotate90(p2.subtract(p1)).normalize();
    Vector2D cursorVector = new Vector2D(deltaX, deltaY);
    double moveDistance = direction.dotProduct(cursorVector);
    Vector2D moveVector = direction.scalarMultiply(moveDistance);
    movePoint(points.get(lineIndex - 1), moveVector);
    movePoint(points.get(lineIndex), moveVector);

    // snap
    snapLine(points, startTerminal, endTerminal, lineIndex, lineIndex + 2);
    snapLine(points, startTerminal, endTerminal, lineIndex, lineIndex - 2);

    myEdgeHandler.postprocessPoints(startTerminal, endTerminal, points);
  }

  public void snapLine(List<mxPoint> points, mxPoint startTerminal, mxPoint endTerminal, int indexToSnap, int referenceIndex) {
    Vector2D p1 = VectorExtensions.toVector2D(points.get(indexToSnap - 1));
    Vector2D p2 = VectorExtensions.toVector2D(points.get(indexToSnap));
    if (referenceIndex <= points.size() && referenceIndex - 1 >= -1) {
      Vector2D p3 = VectorExtensions.toVector2D(getPoint(referenceIndex - 1, points, startTerminal, endTerminal));
      Vector2D p4 = VectorExtensions.toVector2D(getPoint(referenceIndex, points, startTerminal, endTerminal));
      Vector2D direction1 = VectorExtensions.normalizeSafe(p2.subtract(p1));
      Vector2D direction2 = VectorExtensions.normalizeSafe(p4.subtract(p3));
      boolean sameDirection = direction1.distance(direction2) < 0.01;

      if (sameDirection) {
        Line2D.Double line34 = new Line2D.Double(ExtensionMethods.toPoint2D(VectorExtensions.toPoint(p3)), ExtensionMethods.toPoint2D(VectorExtensions.toPoint(p4)));
        Vector2D snappedP1 = JGraphUtil.projectPointOnLine(p1, line34);
        Vector2D snappedP2 = JGraphUtil.projectPointOnLine(p2, line34);

        if (snappedP1.distance(p1) <= myEdgeHandler.getSnapDistance()) {
          points.set(indexToSnap - 1, VectorExtensions.toMxPoint(snappedP1));
          points.set(indexToSnap, VectorExtensions.toMxPoint(snappedP2));
        }
      }
    }
  }

  protected void movePoint(mxPoint p, double deltaX, double deltaY) {
    p.setX(p.getX() + deltaX);
    p.setY(p.getY() + deltaY);
  }

  protected void movePoint(mxPoint p, Vector2D delta) {
    p.setX(p.getX() + delta.getX());
    p.setY(p.getY() + delta.getY());
  }

  public static boolean isSquareAngle(Vector2D v1, Vector2D v2) {
    if (v1.getNorm() * v2.getNorm() == 0) {
      return true;
    }
    return isSquareAngle(Vector2D.angle(v1, v2));
  }

  public static boolean isSquareAngle(double angle) {
    double precision = 0.001;
    double deg90 = Math.PI / 2;
    angle = Math.abs(angle);
    angle = angle % deg90;
    return angle < precision || deg90 - angle < precision;
  }

}

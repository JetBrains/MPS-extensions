package org.modelix.model.mpsadapters.mps;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.modelix.model.api.INode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.model.SModel;
import org.modelix.model.api.NodeUtilKt;
import kotlin.Unit;

public class SNodeAPI {

  public static void clearChildren(SNode parent, SContainmentLink role) {
    while (parent.getChildren(role).iterator().hasNext()) {
      parent.removeChild(parent.getChildren(role).iterator().next());
    }
  }

  public static SNode replaceWithNewChild(SNode parent, SContainmentLink role, SAbstractConcept childConcept) {
    clearChildren(parent, role);
    return addNewChild(parent, role, 0, childConcept);
  }

  public static <T extends SNode> T replaceWithCopy(T sourceNode, SNode targetParent, SContainmentLink targetRole) {
    clearChildren(targetParent, targetRole);
    return copyTo(sourceNode, targetParent, targetRole, 0);
  }

  public static SNode addNewChild(SNode parent, SContainmentLink role, SAbstractConcept childConcept) {
    return addNewChild(parent, role, -1, childConcept);
  }

  public static SNode addNewChild(SNode parent, SContainmentLink role) {
    return addNewChild(parent, role, -1, role.getTargetConcept());
  }

  public static SNode addNewChild(SNode parent, SContainmentLink role, int index) {
    return addNewChild(parent, role, index, role.getTargetConcept());
  }

  public static SNode addNewChild(SNode parent, SContainmentLink role, int index, SAbstractConcept childConcept) {
    INode newChild = SNodeToNodeAdapter.wrap(parent).addNewChild(role.getName(), index, SConceptAdapter.wrap(childConcept));
    if (newChild == null) {
      throw new RuntimeException("addNewChild has to return the created child node");
    }
    return NodeToSNodeAdapter.wrap(newChild);
  }

  public static void moveChild(SNode newParent, SContainmentLink newRole, int newIndex, SNode child) {
    SNodeToNodeAdapter.wrap(newParent).moveChild(newRole.getName(), newIndex, SNodeToNodeAdapter.wrap(child));
  }

  public static <T extends SNode> T copyAsMPSNode(T sourceNode) {
    return (T) copyRootNode(sourceNode, SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(SNodeOperations.getConcept(sourceNode))));
  }

  public static <T extends SNode> T copyTo(T sourceNode, SNode targetParent, SContainmentLink targetRole, int targetIndex) {
    SAbstractConcept concept = SNodeOperations.getConcept(sourceNode);
    SNode copy = addNewChild(targetParent, targetRole, targetIndex, concept);
    return copyRootNode(sourceNode, ((T) copy));
  }

  protected static <T extends SNode> T copyRootNode(T sourceNode, T copy) {
    Map<SNode, SNode> copiedNodes = MapSequence.fromMap(new HashMap<SNode, SNode>());
    MapSequence.fromMap(copiedNodes).put(sourceNode, copy);
    copyProperties(sourceNode, copy);
    copyChildren(sourceNode, copy, copiedNodes);
    resolveReferences(copiedNodes);
    return copy;
  }

  private static SNode copyTo(SNode sourceNode, SNode targetParent, SContainmentLink targetRole, int targetIndex, Map<SNode, SNode> copiedNodes) {
    SConcept concept = sourceNode.getConcept();
    SNode copy = addNewChild(targetParent, targetRole, targetIndex, concept);
    MapSequence.fromMap(copiedNodes).put(sourceNode, copy);
    copyProperties(sourceNode, copy);
    copyChildren(sourceNode, copy, copiedNodes);
    return copy;
  }

  private static void copyProperties(SNode source, SNode target) {
    for (SProperty property : CollectionSequence.fromCollection(source.getConcept().getProperties())) {
      String value = source.getProperty(property);
      if (value != null) {
        target.setProperty(property, value);
      }
    }
  }

  private static void copyChildren(SNode source, SNode target, Map<SNode, SNode> copiedNodes) {
    for (SContainmentLink link : CollectionSequence.fromCollection(source.getConcept().getContainmentLinks())) {
      for (SNode child : Sequence.fromIterable(source.getChildren(link))) {
        copyTo(child, target, link, -1, copiedNodes);
      }
    }
  }

  private static void resolveReferences(Map<SNode, SNode> copiedNodes) {
    for (IMapping<SNode, SNode> entry : MapSequence.fromMap(copiedNodes)) {
      for (SReferenceLink link : CollectionSequence.fromCollection(entry.key().getConcept().getReferenceLinks())) {
        SReference ref = entry.key().getReference(link);
        if (ref == null) {
          continue;
        }
        SNode originalTarget = ref.getTargetNode();
        if (originalTarget == null) {
          continue;
        }
        SNode copiedTarget = MapSequence.fromMap(copiedNodes).get(originalTarget);
        entry.value().setReferenceTarget(link, (copiedTarget != null ? copiedTarget : originalTarget));
      }
    }
  }

  public static String uniqueString(SNode node) {
    node = NodeToSNodeAdapter.wrap(SNodeToNodeAdapter.wrap(node));
    if (node instanceof jetbrains.mps.smodel.SNode) {
      return node.getReference().toString();
    }
    throw new RuntimeException("Cannot calculate unique string for " + node);
  }

  public static SModel getOriginalModel(SNode node) {
    return check_jvh1te_a0a33(getOriginalNode(node));
  }

  public static SNode getOriginalNode(SNode node) {
    if (node == null) {
      return null;
    }
    return as_jvh1te_a0b0jb(NodeToSNodeAdapter.wrap(NodeUtilKt.deepUnwrapNode(SNodeToNodeAdapter.wrap(node))), jetbrains.mps.smodel.SNode.class);
  }

  public static SNode tryGetUnwrappedNode(SNode node) {
    SNode unwrapped = getOriginalNode(node);
    return (unwrapped != null ? unwrapped : node);
  }

  public static void runRead(SNode snode, final Runnable r) {
    SNodeToNodeAdapter.wrap(snode).getArea().executeRead(() -> {
      r.run();
      return Unit.INSTANCE;
    });
  }

  public static void runWrite(SNode snode, final Runnable r) {
    SNodeToNodeAdapter.wrap(snode).getArea().executeWrite(() -> {
      r.run();
      return Unit.INSTANCE;
    });
  }

  public static boolean isValid(SNode snode) {
    return (snode == null ? true : SNodeToNodeAdapter.wrap(snode).isValid());
  }
  private static SModel check_jvh1te_a0a33(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModel();
    }
    return null;
  }
  private static <T> T as_jvh1te_a0b0jb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

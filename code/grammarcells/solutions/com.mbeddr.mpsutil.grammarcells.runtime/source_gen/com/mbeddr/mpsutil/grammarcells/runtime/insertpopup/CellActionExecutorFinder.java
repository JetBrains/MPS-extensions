package com.mbeddr.mpsutil.grammarcells.runtime.insertpopup;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.editor.runtime.cells.PredefinedInsertAction;

public class CellActionExecutorFinder {
  @NotNull
  private final EditorCell myEditorCell;
  @NotNull
  private final CellActionType myActionType;
  @NotNull
  private final EditorComponent myEditorComponent;
  @NotNull
  private final EditorContext myEditorContext;
  private List<CellActionExecuter> myResult;
  public CellActionExecutorFinder(@NotNull EditorCell editorCell, @NotNull CellActionType actionType, @NotNull EditorComponent editorComponent) {
    myEditorCell = editorCell;
    myActionType = actionType;
    myEditorComponent = editorComponent;
    myEditorContext = editorComponent.getEditorContext();
  }
  public List<CellActionExecuter> findCellActionExecuter() {
    myEditorContext.getRepository().getModelAccess().runReadAction(() -> doFindCellActionExecuter());
    return ListSequence.fromList(myResult).where(new NotNullWhereFilter()).toList();
  }
  private void doFindCellActionExecuter() {
    for (EditorCell currentCell = myEditorCell; currentCell != null; currentCell = currentCell.getParent()) {
      CellActionExecuter cellActionExecuter = CellActionExecuter.getExecutableExecuter(currentCell, myActionType, myEditorContext);
      if (cellActionExecuter != null) {
        if (myActionType == CellActionType.INSERT) {
          // why not doing the same for insert_before?
          myResult = getOverridingRightBoundaryActionExecuter(cellActionExecuter, myEditorCell);
        } else {
          myResult = ListSequence.fromListAndArray(new ArrayList<CellActionExecuter>(), cellActionExecuter);
        }
        return;
      }
    }
    myResult = ListSequence.fromListAndArray(new ArrayList<CellActionExecuter>(), CellActionExecuter.getExecutableExecuterFromEditorComponent(myEditorCell, myActionType, myEditorComponent));
  }
  private List<CellActionExecuter> getOverridingRightBoundaryActionExecuter(CellActionExecuter actionExecuter, EditorCell editorCell) {
    List<CellActionExecuter> result = ListSequence.fromListAndArray(new ArrayList<CellActionExecuter>(), actionExecuter);
    SNode node = editorCell.getSNode();
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    for (EditorCell_Collection curCellCollection = editorCell.getParent(); curCellCollection != null && CellTraversalUtil.getLastLeaf(curCellCollection) == editorCell; curCellCollection = curCellCollection.getParent()) {
      if (!(node.equals(curCellCollection.getSNode()))) {
        CellActionExecuter overridingCellActionExecuter = CellActionExecuter.getExecutableExecuter(curCellCollection, myActionType, myEditorContext);
        if (overridingCellActionExecuter == null) {
          continue;
        }
        if (isPredefined(ListSequence.fromList(result).last()) || !(isPredefined(overridingCellActionExecuter))) {
          ListSequence.fromList(result).addElement(overridingCellActionExecuter);
        }
      }
    }
    return result;
  }
  private boolean isPredefined(CellActionExecuter overridingCellActionExecuter) {
    return overridingCellActionExecuter.getAction() instanceof PredefinedInsertAction;
  }
}

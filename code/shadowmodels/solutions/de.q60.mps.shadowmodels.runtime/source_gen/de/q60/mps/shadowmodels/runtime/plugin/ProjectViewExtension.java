package de.q60.mps.shadowmodels.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import javax.swing.Icon;
import java.util.Map;
import com.intellij.openapi.project.Project;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.ide.ui.tree.TextTreeNode;
import javax.swing.event.TreeModelListener;
import javax.swing.event.TreeModelEvent;
import javax.swing.tree.TreeModel;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import org.jetbrains.mps.openapi.module.SRepositoryListenerBase;
import java.util.concurrent.atomic.AtomicBoolean;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModule;
import de.q60.mps.shadowmodels.runtime.smodel.SM_ShadowModule;
import org.jetbrains.mps.openapi.module.SModuleReference;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.mps.openapi.module.SModuleListener;
import org.jetbrains.mps.openapi.module.SModuleListenerBase;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import de.q60.mps.util.invalidation.Invalidatable;
import jetbrains.mps.ide.projectPane.logicalview.ProjectTree;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import javax.swing.Timer;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import jetbrains.mps.ide.projectPane.ProjectPane;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import javax.swing.tree.DefaultTreeModel;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import javax.swing.tree.TreeNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.ui.tree.module.ProjectModuleTreeNode;
import jetbrains.mps.ide.ui.tree.smodel.SModelTreeNode;

public class ProjectViewExtension {
  private static final Logger LOG = Logger.getLogger(ProjectViewExtension.class);
  public static final Icon ROOT_ICON = new ShadowIcon("S", 16, 2.7f, 13.8f);
  public static final Icon MODULE_ICON = new ShadowIcon("M", 14, 2.0f, 13.0f);
  public static final Icon MODEL_ICON = new ShadowIcon("m", 14, 1.7f, 12.0f);

  private static Map<Project, ProjectViewExtension> ourInstances = MapSequence.fromMap(new HashMap<Project, ProjectViewExtension>());

  public static ProjectViewExtension getInstance(Project ideaProject) {
    ProjectViewExtension instance = MapSequence.fromMap(ourInstances).get(ideaProject);
    if (instance == null) {
      MPSProject mpsProject = ProjectHelper.fromIdeaProject(ideaProject);
      instance = new ProjectViewExtension(mpsProject);
      MapSequence.fromMap(ourInstances).put(ideaProject, instance);
    }
    return instance;
  }
  public static ProjectViewExtension getInstance(jetbrains.mps.project.Project mpsProject) {
    return getInstance(ProjectHelper.toIdeaProject(mpsProject));
  }

  private jetbrains.mps.project.Project project;
  private TextTreeNode shadowTreeNode;
  private TreeModelListener treeListener = new TreeModelListener() {
    private boolean handling;
    public void treeNodesChanged(TreeModelEvent p0) {
      handle();
    }
    public void treeNodesInserted(TreeModelEvent p0) {
      handle();
    }
    public void treeNodesRemoved(TreeModelEvent p0) {
      handle();
    }
    public void treeStructureChanged(TreeModelEvent p0) {
      handle();
    }
    public void handle() {
      if (handling) {
        return;
      }
      try {
        handling = true;
        attachShadowRootIfNotEmpty();
      } catch (Exception ex) {
        if (LOG.isErrorLevel()) {
          LOG.error("", ex);
        }
      } finally {
        handling = false;
      }
    }
  };
  private TreeModel treeModel;
  private boolean disposed = false;

  private SRepositoryListener repositoryListener = new SRepositoryListenerBase() {
    private AtomicBoolean modulesDirty = new AtomicBoolean(true);
    public void moduleAdded(@NotNull SModule m) {
      if (m instanceof SM_ShadowModule) {
        m.addModuleListener(moduleListener);
        queueUpdate();
      }
    }
    public void moduleRemoved(@NotNull SModuleReference m) {
      queueUpdate();
    }
    public void queueUpdate() {
      modulesDirty.set(true);
      ApplicationManager.getApplication().invokeLater(() -> {
        if (modulesDirty.getAndSet(false)) {
          updateModules();
        }
      });
    }
  };
  private SModuleListener moduleListener = new SModuleListenerBase() {
    @Override
    public void modelAdded(SModule module, SModel model) {
      super.modelAdded(module, model);
    }
    @Override
    public void modelRemoved(SModule module, SModelReference ref) {
      super.modelRemoved(module, ref);
    }
  };
  private Invalidatable invalidatable = new Invalidatable("Project view extension", () -> ApplicationManager.getApplication().invokeLater(() -> forceUpdate())) {
    @Override
    public String getText() {
      return "Project view extension (" + project.getName() + ")";
    }
  };

  public ProjectViewExtension(jetbrains.mps.project.Project project) {
    this.project = project;
  }

  public void init() {
    shadowTreeNode = new TextTreeNode("Shadow");
    shadowTreeNode.setIcon(ROOT_ICON);
    waitForProjectTree((ProjectTree tree) -> {
      if (disposed) {
        return;
      }
      treeModel = tree.getModel();
      treeModel.addTreeModelListener(treeListener);
      project.getRepository().addRepositoryListener(repositoryListener);
      updateModules();
    });
  }

  private void waitForProjectTree(final _FunctionTypes._void_P1_E0<? super ProjectTree> callback) {
    ProjectTree tree = getProjectTree();
    if (tree != null) {
      callback.invoke(tree);
    } else {
      final Wrappers._T<Timer> timer = new Wrappers._T<Timer>(null);
      timer.value = new Timer(1000, new ActionListener() {
        public void actionPerformed(ActionEvent e) {
          ProjectTree tree = getProjectTree();
          if (tree != null) {
            callback.invoke(tree);
            timer.value.stop();
          }
        }
      });
      timer.value.start();
    }
  }

  private ProjectTree getProjectTree() {
    if (project.isDisposed()) {
      return null;
    } else if ((project instanceof MPSProject) && ((MPSProject) project).getProject().isDisposed()) {
      // In certain cases, it can actually happen that the idea project is already disposed, 
      // but the MPS project is not yet. This situation can still lead to errors when trying to 
      // get the project pane. Let's guard against this case, as well. 
      return null;
    } else {
      ProjectPane pane = ProjectPane.getInstance(project);
      if (pane == null) {
        return null;
      } else {
        return pane.getTree();
      }
    }
  }

  public void dispose() {
    disposed = true;
    project.getRepository().removeRepositoryListener(repositoryListener);
    if (treeModel != null) {
      treeModel.removeTreeModelListener(treeListener);
      treeModel = null;
    }
    MapSequence.fromMap(ourInstances).removeKey(ProjectHelper.toIdeaProject(project));
    invalidatable.dispose();
  }

  public void attachShadowRoot() {
    ProjectPane projectPane = ProjectPane.getInstance(project);
    MPSTreeNode root = projectPane.getTree().getRootNode();
    if (root == null) {
      return;
    }

    DefaultTreeModel model = projectPane.getTree().getDFTreeModel();

    // wrong parent
    if (shadowTreeNode.getParent() != null && shadowTreeNode.getParent() != root) {
      model.removeNodeFromParent(shadowTreeNode);
    }

    // wrong position
    int preferedIndex = 2;
    if (shadowTreeNode.getParent() != null && shadowTreeNode.getParent().getIndex(shadowTreeNode) != Math.min(shadowTreeNode.getParent().getChildCount() - 1, preferedIndex)) {
      model.removeNodeFromParent(shadowTreeNode);
    }

    if (shadowTreeNode.getParent() == null) {
      model.insertNodeInto(shadowTreeNode, root, Math.min(root.getChildCount(), preferedIndex));
    }
  }

  public void attachShadowRootIfNotEmpty() {
    if (shadowTreeNode.getChildCount() == 0) {
      if (shadowTreeNode.getParent() != null && shadowTreeNode.getTree() != null) {
        shadowTreeNode.getTree().getDFTreeModel().removeNodeFromParent(shadowTreeNode);
      }
    } else {
      attachShadowRoot();
    }
  }

  public void forceUpdate() {
    while (shadowTreeNode.getChildCount() > 0) {
      ShadowModuleTreeNode moduleTreeNode = (ShadowModuleTreeNode) shadowTreeNode.getChildAt(0);
      getProjectTree().getDFTreeModel().removeNodeFromParent(moduleTreeNode);
      moduleTreeNode.dispose();
    }
    updateModules();
  }

  public void updateModules() {
    ProjectTree projectTree = getProjectTree();
    if (projectTree == null) {
      return;
    }
    final MPSTreeNode root = projectTree.getRootNode();
    if (root == null) {
      return;
    }
    final DefaultTreeModel treeModel = projectTree.getDFTreeModel();
    if (treeModel == null) {
      return;
    }

    final SRepository repository = project.getRepository();
    repository.getModelAccess().runReadAction(() -> {
      Iterable<SModule> modules = repository.getModules();
      final Map<SModule, ShadowModuleTreeNode> module2treeNode = MapSequence.fromMap(new HashMap<SModule, ShadowModuleTreeNode>());
      final Set<ShadowModuleTreeNode> treeNodesToRemove = SetSequence.fromSet(new HashSet<ShadowModuleTreeNode>());
      Sequence.fromIterable(getChildren(shadowTreeNode)).ofType(ShadowModuleTreeNode.class).visitAll((it) -> {
        SetSequence.fromSet(treeNodesToRemove).addElement(it);
        MapSequence.fromMap(module2treeNode).put(it.getModule(), it);
      });
      int insertAt = 0;
      for (SM_ShadowModule shadowModule : Sequence.fromIterable(modules).ofType(SM_ShadowModule.class).sort((it) -> it.getModuleName(), true)) {
        ShadowModuleTreeNode moduleTreeNode = MapSequence.fromMap(module2treeNode).get(shadowModule);
        if (moduleTreeNode == null) {
          treeModel.insertNodeInto(new ShadowModuleTreeNode(shadowModule), shadowTreeNode, insertAt);
          insertAt++;
        } else {
          insertAt = moduleTreeNode.getParent().getIndex(moduleTreeNode) + 1;
          MapSequence.fromMap(module2treeNode).removeKey(shadowModule);
          SetSequence.fromSet(treeNodesToRemove).removeElement(moduleTreeNode);
        }
      }
      SetSequence.fromSet(treeNodesToRemove).visitAll((it) -> {
        treeModel.removeNodeFromParent(it);
        it.dispose();
      });
      attachShadowRootIfNotEmpty();
    });
  }

  private static Iterable<TreeNode> getChildren(TreeNode parent) {
    List<TreeNode> result = ListSequence.fromList(new ArrayList<TreeNode>());
    for (int i = 0; i < parent.getChildCount(); i++) {
      ListSequence.fromList(result).addElement(parent.getChildAt(i));
    }
    return result;
  }

  public static class ShadowModuleTreeNode extends ProjectModuleTreeNode {
    private boolean myInitialized = false;
    private SModuleListenerBase moduleListener = new SModuleListenerBase() {
      @Override
      public void modelAdded(SModule module, SModel model) {
        update();
      }
      @Override
      public void modelRemoved(SModule module, SModelReference ref) {
        update();
      }
    };
    public ShadowModuleTreeNode(@NotNull SModule module) {
      super(module);
      setNodeIdentifier(module.getModuleId().toString());
      setIcon(MODULE_ICON);
      module.addModuleListener(moduleListener);
    }
    @Override
    public String getModuleText() {
      return getModule().getModuleName();
    }
    @Override
    public boolean isInitialized() {
      return myInitialized;
    }

    @Override
    protected void doInit() {
      populate();
      myInitialized = true;
    }

    protected void populate() {
      Iterable<SModel> models = getModule().getModels();
      for (SModel model : Sequence.fromIterable(models).sort((it) -> it.getName().getLongName(), true)) {
        SModelTreeNode tn = new SModelTreeNode(model);
        tn.setIcon(MODEL_ICON);
        tn.setBaseIcon(MODEL_ICON);
        add(tn);
      }
    }

    @Override
    protected void doUpdate() {
      super.doUpdate();
      myInitialized = false;
      removeAllChildren();
    }

    public void dispose() {
      getModule().removeModuleListener(moduleListener);
    }
  }

}
